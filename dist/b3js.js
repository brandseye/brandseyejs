var b3js =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/compute-iqr/lib/index.js":
/*!***********************************************!*\
  !*** ./node_modules/compute-iqr/lib/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n*\n*\tCOMPUTE: iqr\n*\n*\n*\tDESCRIPTION:\n*\t\t- Computes the interquartile range for an array of values.\n*\n*\n*\tNOTES:\n*\t\t[1]\n*\n*\n*\tTODO:\n*\t\t[1]\n*\n*\n*\tLICENSE:\n*\t\tMIT\n*\n*\tCopyright (c) 2014. Athan Reines.\n*\n*\n*\tAUTHOR:\n*\t\tAthan Reines. kgryte@gmail.com. 2014.\n*\n*/\n\n\n\n// MODULES //\n\nvar isObject = __webpack_require__( /*! validate.io-object */ \"./node_modules/validate.io-object/lib/index.js\" ),\n\tquantile = __webpack_require__( /*! compute-quantile */ \"./node_modules/compute-quantile/lib/index.js\" );\n\n\n// FUNCTIONS //\n\n/**\n* FUNCTION: ascending( a, b )\n*\tComparator function used to sort values in ascending order.\n*\n* @private\n* @param {Number} a\n* @param {Number} b\n* @returns {Number} difference between `a` and `b`\n*/\nfunction ascending( a, b ) {\n\treturn a - b;\n} // end FUNCTION ascending()\n\n\n// INTERQUARTILE RANGE //\n\n/**\n* FUNCTION: iqr( arr )\n*\tComputes the interquartile range for an array.\n*\n* @param {Array} arr - array of values\n* @returns {Number} interquartile range\n*/\nfunction iqr( arr, opts ) {\n\tif ( !Array.isArray( arr ) ) {\n\t\tthrow new TypeError( 'iqr()::invalid input argument. Must provide an array.' );\n\t}\n\tif ( arguments.length > 1 ) {\n\t\tif ( !isObject( opts ) ) {\n\t\t\tthrow new TypeError( 'iqr()::invalid input argument. Options should be an object.' );\n\t\t}\n\t} else {\n\t\topts = {\n\t\t\t'sorted': false\n\t\t};\n\t}\n\tif ( !opts.sorted ) {\n\t\tarr = arr.slice();\n\t\tarr.sort( ascending );\n\t\topts.sorted = true;\n\t}\n\treturn quantile( arr, 0.75, opts ) - quantile( arr, 0.25, opts );\n} // end FUNCTION iqr()\n\n\n// EXPORTS //\n\nmodule.exports = iqr;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY29tcHV0ZS1pcXIvbGliL2luZGV4LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYjNqcy8uL25vZGVfbW9kdWxlcy9jb21wdXRlLWlxci9saWIvaW5kZXguanM/MDBhOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbipcbipcdENPTVBVVEU6IGlxclxuKlxuKlxuKlx0REVTQ1JJUFRJT046XG4qXHRcdC0gQ29tcHV0ZXMgdGhlIGludGVycXVhcnRpbGUgcmFuZ2UgZm9yIGFuIGFycmF5IG9mIHZhbHVlcy5cbipcbipcbipcdE5PVEVTOlxuKlx0XHRbMV1cbipcbipcbipcdFRPRE86XG4qXHRcdFsxXVxuKlxuKlxuKlx0TElDRU5TRTpcbipcdFx0TUlUXG4qXG4qXHRDb3B5cmlnaHQgKGMpIDIwMTQuIEF0aGFuIFJlaW5lcy5cbipcbipcbipcdEFVVEhPUjpcbipcdFx0QXRoYW4gUmVpbmVzLiBrZ3J5dGVAZ21haWwuY29tLiAyMDE0LlxuKlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBpc09iamVjdCA9IHJlcXVpcmUoICd2YWxpZGF0ZS5pby1vYmplY3QnICksXG5cdHF1YW50aWxlID0gcmVxdWlyZSggJ2NvbXB1dGUtcXVhbnRpbGUnICk7XG5cblxuLy8gRlVOQ1RJT05TIC8vXG5cbi8qKlxuKiBGVU5DVElPTjogYXNjZW5kaW5nKCBhLCBiIClcbipcdENvbXBhcmF0b3IgZnVuY3Rpb24gdXNlZCB0byBzb3J0IHZhbHVlcyBpbiBhc2NlbmRpbmcgb3JkZXIuXG4qXG4qIEBwcml2YXRlXG4qIEBwYXJhbSB7TnVtYmVyfSBhXG4qIEBwYXJhbSB7TnVtYmVyfSBiXG4qIEByZXR1cm5zIHtOdW1iZXJ9IGRpZmZlcmVuY2UgYmV0d2VlbiBgYWAgYW5kIGBiYFxuKi9cbmZ1bmN0aW9uIGFzY2VuZGluZyggYSwgYiApIHtcblx0cmV0dXJuIGEgLSBiO1xufSAvLyBlbmQgRlVOQ1RJT04gYXNjZW5kaW5nKClcblxuXG4vLyBJTlRFUlFVQVJUSUxFIFJBTkdFIC8vXG5cbi8qKlxuKiBGVU5DVElPTjogaXFyKCBhcnIgKVxuKlx0Q29tcHV0ZXMgdGhlIGludGVycXVhcnRpbGUgcmFuZ2UgZm9yIGFuIGFycmF5LlxuKlxuKiBAcGFyYW0ge0FycmF5fSBhcnIgLSBhcnJheSBvZiB2YWx1ZXNcbiogQHJldHVybnMge051bWJlcn0gaW50ZXJxdWFydGlsZSByYW5nZVxuKi9cbmZ1bmN0aW9uIGlxciggYXJyLCBvcHRzICkge1xuXHRpZiAoICFBcnJheS5pc0FycmF5KCBhcnIgKSApIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCAnaXFyKCk6OmludmFsaWQgaW5wdXQgYXJndW1lbnQuIE11c3QgcHJvdmlkZSBhbiBhcnJheS4nICk7XG5cdH1cblx0aWYgKCBhcmd1bWVudHMubGVuZ3RoID4gMSApIHtcblx0XHRpZiAoICFpc09iamVjdCggb3B0cyApICkge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvciggJ2lxcigpOjppbnZhbGlkIGlucHV0IGFyZ3VtZW50LiBPcHRpb25zIHNob3VsZCBiZSBhbiBvYmplY3QuJyApO1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRvcHRzID0ge1xuXHRcdFx0J3NvcnRlZCc6IGZhbHNlXG5cdFx0fTtcblx0fVxuXHRpZiAoICFvcHRzLnNvcnRlZCApIHtcblx0XHRhcnIgPSBhcnIuc2xpY2UoKTtcblx0XHRhcnIuc29ydCggYXNjZW5kaW5nICk7XG5cdFx0b3B0cy5zb3J0ZWQgPSB0cnVlO1xuXHR9XG5cdHJldHVybiBxdWFudGlsZSggYXJyLCAwLjc1LCBvcHRzICkgLSBxdWFudGlsZSggYXJyLCAwLjI1LCBvcHRzICk7XG59IC8vIGVuZCBGVU5DVElPTiBpcXIoKVxuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBpcXI7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/compute-iqr/lib/index.js\n");

/***/ }),

/***/ "./node_modules/compute-quantile/lib/index.js":
/*!****************************************************!*\
  !*** ./node_modules/compute-quantile/lib/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n*\n*\tCOMPUTE: quantile\n*\n*\n*\tDESCRIPTION:\n*\t\t- Computes a quantile for a numeric array.\n*\n*\n*\tNOTES:\n*\t\t[1]\n*\n*\n*\tTODO:\n*\t\t[1]\n*\n*\n*\tLICENSE:\n*\t\tMIT\n*\n*\tCopyright (c) 2014. Athan Reines.\n*\n*\n*\tAUTHOR:\n*\t\tAthan Reines. kgryte@gmail.com. 2014.\n*\n*/\n\n\n\n// MODULES //\n\nvar isObject = __webpack_require__( /*! validate.io-object */ \"./node_modules/validate.io-object/lib/index.js\" );\n\n\n// FUNCTIONS //\n\n/**\n* FUNCTION: ascending( a, b )\n*\tComparator function used to sort values in ascending order.\n*\n* @private\n* @param {Number} a\n* @param {Number} b\n* @returns {Number} difference between `a` and `b`\n*/\nfunction ascending( a, b ) {\n\treturn a - b;\n} // end FUNCTION ascending()\n\n\n// QUANTILE //\n\n/**\n* FUNCTION: quantile( arr, prob[, opts] )\n*\tComputes a quantile for a numeric array.\n*\n* @private\n* @param {Array} arr - 1d array\n* @param {Number} prob - quantile prob [0,1]\n* @param {Object} [opts] - method options:\n\t`method`: method used to interpolate a quantile value\n\t`sorted`: boolean flag indicating if the input array is sorted\n* @returns {Number} quantile value\n*/\nfunction quantile( arr, p, opts ) {\n\tif ( !Array.isArray( arr ) ) {\n\t\tthrow new TypeError( 'quantile()::invalid input argument. First argument must be an array.' );\n\t}\n\tif ( typeof p !== 'number' || p !== p ) {\n\t\tthrow new TypeError( 'quantile()::invalid input argument. Quantile probability must be numeric.' );\n\t}\n\tif ( p < 0 || p > 1 ) {\n\t\tthrow new TypeError( 'quantile()::invalid input argument. Quantile probability must be on the interval [0,1].' );\n\t}\n\tif ( arguments.length > 2 ) {\n\t\tif ( !isObject( opts ) ) {\n\t\t\tthrow new TypeError( 'quantile()::invalid input argument. Options must be an object.' );\n\t\t}\n\t\tif ( opts.hasOwnProperty( 'sorted' ) && typeof opts.sorted !== 'boolean' ) {\n\t\t\tthrow new TypeError( 'quantile()::invalid input argument. Sorted flag must be a boolean.' );\n\t\t}\n\t\tif ( opts.hasOwnProperty( 'method' ) && typeof opts.method !== 'string' ) {\n\t\t\tthrow new TypeError( 'quantile()::invalid input argument. Method must be a string.' );\n\t\t}\n\t\t// TODO: validate that the requested method is supported. list.indexOf( method )\n\t} else {\n\t\topts = {};\n\t}\n\tvar len = arr.length,\n\t\tid;\n\n\tif ( !opts.sorted ) {\n\t\tarr = arr.slice();\n\t\tarr.sort( ascending );\n\t}\n\n\t// Cases...\n\n\t// [0] 0th percentile is the minimum value...\n\tif ( p === 0.0 ) {\n\t\treturn arr[ 0 ];\n\t}\n\t// [1] 100th percentile is the maximum value...\n\tif ( p === 1.0 ) {\n\t\treturn arr[ len-1 ];\n\t}\n\t// Calculate the vector index marking the quantile:\n\tid = ( len*p ) - 1;\n\n\t// [2] Is the index an integer?\n\tif ( id === Math.floor( id ) ) {\n\t\t// Value is the average between the value at id and id+1:\n\t\treturn ( arr[ id ] + arr[ id+1 ] ) / 2.0;\n\t}\n\t// [3] Round up to the next index:\n\tid = Math.ceil( id );\n\treturn arr[ id ];\n} // end FUNCTION quantile()\n\n\n// EXPORTS //\n\nmodule.exports = quantile;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY29tcHV0ZS1xdWFudGlsZS9saWIvaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9iM2pzLy4vbm9kZV9tb2R1bGVzL2NvbXB1dGUtcXVhbnRpbGUvbGliL2luZGV4LmpzP2FhZjciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4qXG4qXHRDT01QVVRFOiBxdWFudGlsZVxuKlxuKlxuKlx0REVTQ1JJUFRJT046XG4qXHRcdC0gQ29tcHV0ZXMgYSBxdWFudGlsZSBmb3IgYSBudW1lcmljIGFycmF5LlxuKlxuKlxuKlx0Tk9URVM6XG4qXHRcdFsxXVxuKlxuKlxuKlx0VE9ETzpcbipcdFx0WzFdXG4qXG4qXG4qXHRMSUNFTlNFOlxuKlx0XHRNSVRcbipcbipcdENvcHlyaWdodCAoYykgMjAxNC4gQXRoYW4gUmVpbmVzLlxuKlxuKlxuKlx0QVVUSE9SOlxuKlx0XHRBdGhhbiBSZWluZXMuIGtncnl0ZUBnbWFpbC5jb20uIDIwMTQuXG4qXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSggJ3ZhbGlkYXRlLmlvLW9iamVjdCcgKTtcblxuXG4vLyBGVU5DVElPTlMgLy9cblxuLyoqXG4qIEZVTkNUSU9OOiBhc2NlbmRpbmcoIGEsIGIgKVxuKlx0Q29tcGFyYXRvciBmdW5jdGlvbiB1c2VkIHRvIHNvcnQgdmFsdWVzIGluIGFzY2VuZGluZyBvcmRlci5cbipcbiogQHByaXZhdGVcbiogQHBhcmFtIHtOdW1iZXJ9IGFcbiogQHBhcmFtIHtOdW1iZXJ9IGJcbiogQHJldHVybnMge051bWJlcn0gZGlmZmVyZW5jZSBiZXR3ZWVuIGBhYCBhbmQgYGJgXG4qL1xuZnVuY3Rpb24gYXNjZW5kaW5nKCBhLCBiICkge1xuXHRyZXR1cm4gYSAtIGI7XG59IC8vIGVuZCBGVU5DVElPTiBhc2NlbmRpbmcoKVxuXG5cbi8vIFFVQU5USUxFIC8vXG5cbi8qKlxuKiBGVU5DVElPTjogcXVhbnRpbGUoIGFyciwgcHJvYlssIG9wdHNdIClcbipcdENvbXB1dGVzIGEgcXVhbnRpbGUgZm9yIGEgbnVtZXJpYyBhcnJheS5cbipcbiogQHByaXZhdGVcbiogQHBhcmFtIHtBcnJheX0gYXJyIC0gMWQgYXJyYXlcbiogQHBhcmFtIHtOdW1iZXJ9IHByb2IgLSBxdWFudGlsZSBwcm9iIFswLDFdXG4qIEBwYXJhbSB7T2JqZWN0fSBbb3B0c10gLSBtZXRob2Qgb3B0aW9uczpcblx0YG1ldGhvZGA6IG1ldGhvZCB1c2VkIHRvIGludGVycG9sYXRlIGEgcXVhbnRpbGUgdmFsdWVcblx0YHNvcnRlZGA6IGJvb2xlYW4gZmxhZyBpbmRpY2F0aW5nIGlmIHRoZSBpbnB1dCBhcnJheSBpcyBzb3J0ZWRcbiogQHJldHVybnMge051bWJlcn0gcXVhbnRpbGUgdmFsdWVcbiovXG5mdW5jdGlvbiBxdWFudGlsZSggYXJyLCBwLCBvcHRzICkge1xuXHRpZiAoICFBcnJheS5pc0FycmF5KCBhcnIgKSApIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCAncXVhbnRpbGUoKTo6aW52YWxpZCBpbnB1dCBhcmd1bWVudC4gRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhbiBhcnJheS4nICk7XG5cdH1cblx0aWYgKCB0eXBlb2YgcCAhPT0gJ251bWJlcicgfHwgcCAhPT0gcCApIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCAncXVhbnRpbGUoKTo6aW52YWxpZCBpbnB1dCBhcmd1bWVudC4gUXVhbnRpbGUgcHJvYmFiaWxpdHkgbXVzdCBiZSBudW1lcmljLicgKTtcblx0fVxuXHRpZiAoIHAgPCAwIHx8IHAgPiAxICkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoICdxdWFudGlsZSgpOjppbnZhbGlkIGlucHV0IGFyZ3VtZW50LiBRdWFudGlsZSBwcm9iYWJpbGl0eSBtdXN0IGJlIG9uIHRoZSBpbnRlcnZhbCBbMCwxXS4nICk7XG5cdH1cblx0aWYgKCBhcmd1bWVudHMubGVuZ3RoID4gMiApIHtcblx0XHRpZiAoICFpc09iamVjdCggb3B0cyApICkge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvciggJ3F1YW50aWxlKCk6OmludmFsaWQgaW5wdXQgYXJndW1lbnQuIE9wdGlvbnMgbXVzdCBiZSBhbiBvYmplY3QuJyApO1xuXHRcdH1cblx0XHRpZiAoIG9wdHMuaGFzT3duUHJvcGVydHkoICdzb3J0ZWQnICkgJiYgdHlwZW9mIG9wdHMuc29ydGVkICE9PSAnYm9vbGVhbicgKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCAncXVhbnRpbGUoKTo6aW52YWxpZCBpbnB1dCBhcmd1bWVudC4gU29ydGVkIGZsYWcgbXVzdCBiZSBhIGJvb2xlYW4uJyApO1xuXHRcdH1cblx0XHRpZiAoIG9wdHMuaGFzT3duUHJvcGVydHkoICdtZXRob2QnICkgJiYgdHlwZW9mIG9wdHMubWV0aG9kICE9PSAnc3RyaW5nJyApIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoICdxdWFudGlsZSgpOjppbnZhbGlkIGlucHV0IGFyZ3VtZW50LiBNZXRob2QgbXVzdCBiZSBhIHN0cmluZy4nICk7XG5cdFx0fVxuXHRcdC8vIFRPRE86IHZhbGlkYXRlIHRoYXQgdGhlIHJlcXVlc3RlZCBtZXRob2QgaXMgc3VwcG9ydGVkLiBsaXN0LmluZGV4T2YoIG1ldGhvZCApXG5cdH0gZWxzZSB7XG5cdFx0b3B0cyA9IHt9O1xuXHR9XG5cdHZhciBsZW4gPSBhcnIubGVuZ3RoLFxuXHRcdGlkO1xuXG5cdGlmICggIW9wdHMuc29ydGVkICkge1xuXHRcdGFyciA9IGFyci5zbGljZSgpO1xuXHRcdGFyci5zb3J0KCBhc2NlbmRpbmcgKTtcblx0fVxuXG5cdC8vIENhc2VzLi4uXG5cblx0Ly8gWzBdIDB0aCBwZXJjZW50aWxlIGlzIHRoZSBtaW5pbXVtIHZhbHVlLi4uXG5cdGlmICggcCA9PT0gMC4wICkge1xuXHRcdHJldHVybiBhcnJbIDAgXTtcblx0fVxuXHQvLyBbMV0gMTAwdGggcGVyY2VudGlsZSBpcyB0aGUgbWF4aW11bSB2YWx1ZS4uLlxuXHRpZiAoIHAgPT09IDEuMCApIHtcblx0XHRyZXR1cm4gYXJyWyBsZW4tMSBdO1xuXHR9XG5cdC8vIENhbGN1bGF0ZSB0aGUgdmVjdG9yIGluZGV4IG1hcmtpbmcgdGhlIHF1YW50aWxlOlxuXHRpZCA9ICggbGVuKnAgKSAtIDE7XG5cblx0Ly8gWzJdIElzIHRoZSBpbmRleCBhbiBpbnRlZ2VyP1xuXHRpZiAoIGlkID09PSBNYXRoLmZsb29yKCBpZCApICkge1xuXHRcdC8vIFZhbHVlIGlzIHRoZSBhdmVyYWdlIGJldHdlZW4gdGhlIHZhbHVlIGF0IGlkIGFuZCBpZCsxOlxuXHRcdHJldHVybiAoIGFyclsgaWQgXSArIGFyclsgaWQrMSBdICkgLyAyLjA7XG5cdH1cblx0Ly8gWzNdIFJvdW5kIHVwIHRvIHRoZSBuZXh0IGluZGV4OlxuXHRpZCA9IE1hdGguY2VpbCggaWQgKTtcblx0cmV0dXJuIGFyclsgaWQgXTtcbn0gLy8gZW5kIEZVTkNUSU9OIHF1YW50aWxlKClcblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gcXVhbnRpbGU7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/compute-quantile/lib/index.js\n");

/***/ }),

/***/ "./node_modules/validate.io-array/lib/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/validate.io-array/lib/index.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n* FUNCTION: isArray( value )\n*\tValidates if a value is an array.\n*\n* @param {*} value - value to be validated\n* @returns {Boolean} boolean indicating whether value is an array\n*/\nfunction isArray( value ) {\n\treturn Object.prototype.toString.call( value ) === '[object Array]';\n} // end FUNCTION isArray()\n\n// EXPORTS //\n\nmodule.exports = Array.isArray || isArray;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdmFsaWRhdGUuaW8tYXJyYXkvbGliL2luZGV4LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYjNqcy8uL25vZGVfbW9kdWxlcy92YWxpZGF0ZS5pby1hcnJheS9saWIvaW5kZXguanM/NjMzNyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKlxuKiBGVU5DVElPTjogaXNBcnJheSggdmFsdWUgKVxuKlx0VmFsaWRhdGVzIGlmIGEgdmFsdWUgaXMgYW4gYXJyYXkuXG4qXG4qIEBwYXJhbSB7Kn0gdmFsdWUgLSB2YWx1ZSB0byBiZSB2YWxpZGF0ZWRcbiogQHJldHVybnMge0Jvb2xlYW59IGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHZhbHVlIGlzIGFuIGFycmF5XG4qL1xuZnVuY3Rpb24gaXNBcnJheSggdmFsdWUgKSB7XG5cdHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoIHZhbHVlICkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59IC8vIGVuZCBGVU5DVElPTiBpc0FycmF5KClcblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgaXNBcnJheTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/validate.io-array/lib/index.js\n");

/***/ }),

/***/ "./node_modules/validate.io-object/lib/index.js":
/*!******************************************************!*\
  !*** ./node_modules/validate.io-object/lib/index.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n// MODULES //\n\nvar isArray = __webpack_require__( /*! validate.io-array */ \"./node_modules/validate.io-array/lib/index.js\" );\n\n\n// ISOBJECT //\n\n/**\n* FUNCTION: isObject( value )\n*\tValidates if a value is a object; e.g., {}.\n*\n* @param {*} value - value to be validated\n* @returns {Boolean} boolean indicating whether value is a object\n*/\nfunction isObject( value ) {\n\treturn ( typeof value === 'object' && value !== null && !isArray( value ) );\n} // end FUNCTION isObject()\n\n\n// EXPORTS //\n\nmodule.exports = isObject;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdmFsaWRhdGUuaW8tb2JqZWN0L2xpYi9pbmRleC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2IzanMvLi9ub2RlX21vZHVsZXMvdmFsaWRhdGUuaW8tb2JqZWN0L2xpYi9pbmRleC5qcz8yMjlmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLy8gTU9EVUxFUyAvL1xuXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoICd2YWxpZGF0ZS5pby1hcnJheScgKTtcblxuXG4vLyBJU09CSkVDVCAvL1xuXG4vKipcbiogRlVOQ1RJT046IGlzT2JqZWN0KCB2YWx1ZSApXG4qXHRWYWxpZGF0ZXMgaWYgYSB2YWx1ZSBpcyBhIG9iamVjdDsgZS5nLiwge30uXG4qXG4qIEBwYXJhbSB7Kn0gdmFsdWUgLSB2YWx1ZSB0byBiZSB2YWxpZGF0ZWRcbiogQHJldHVybnMge0Jvb2xlYW59IGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHZhbHVlIGlzIGEgb2JqZWN0XG4qL1xuZnVuY3Rpb24gaXNPYmplY3QoIHZhbHVlICkge1xuXHRyZXR1cm4gKCB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsICYmICFpc0FycmF5KCB2YWx1ZSApICk7XG59IC8vIGVuZCBGVU5DVElPTiBpc09iamVjdCgpXG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/validate.io-object/lib/index.js\n");

/***/ }),

/***/ "./src/Axes.js":
/*!*********************!*\
  !*** ./src/Axes.js ***!
  \*********************/
/*! exports provided: xaxis, yaxis, grid, yAxisLabel */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"xaxis\", function() { return xaxis; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"yaxis\", function() { return yaxis; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"grid\", function() { return grid; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"yAxisLabel\", function() { return yAxisLabel; });\n/* harmony import */ var _Colours__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Colours */ \"./src/Colours.js\");\n// Copyright (C) 2013-2014, 2018 BrandsEye (PTY) LTD\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this\n// software and associated documentation files (the \"Software\"), to deal in the Software\n// without restriction, including without limitation the rights to use, copy, modify,\n//     merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following\n// conditions:\n//\n//     The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n//     INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n// CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nconst AXIS_ANIMATION_DURATION = 1000;\nconst AXIS_DELAY = 250;\n\n\nfunction xaxis(selection, height, width, axisObject) {\n    selection.select(\".x-axis\").remove();\n    let axis = selection.append(\"g\")\n                        .attr(\"class\", \"x-axis\")\n                        .attr(\"transform\", \"translate(0,\" + height + \")\")\n                        .style(\"opacity\", 0)\n                        .call(axisObject);\n\n    axis.select(\".domain\").remove();\n\n    let max = 0;\n    const fontSize = 12;\n    axis.selectAll(\"text\")\n        .style(\"fill\", d3.hcl(_Colours__WEBPACK_IMPORTED_MODULE_0__[\"colours\"].eighteen.darkGrey).brighter())\n        .nodes()\n        .forEach(text => max = Math.max(max, text.getBBox().width));\n\n    if (max >= width - 10) {\n        const bad = max >= width * 2;\n        const angle = bad ? -90 : -30;\n        const fontSize = width <= 13 ? 8 : 12;\n        const x = bad ? -fontSize : 0;\n        const y = bad ? 5 : 2;\n\n        axis.selectAll(\"text\")\n            .style('text-anchor', 'end')\n            .style(\"font-size\", fontSize + \"px\")\n            .attr(\"transform\", () => \"translate(\" + x + \",\" + y + \") rotate(\" + angle + \" 0,0)\")\n    }\n\n    axis\n        .transition()\n        .duration(AXIS_ANIMATION_DURATION)\n        .delay(AXIS_DELAY)\n        .style(\"opacity\", 1);\n\n    const axisHeight = axis.node().getBBox().height;\n    axis.attr(\"transform\", \"translate(0,\" + (height - axisHeight) + \")\");\n    return axisHeight;\n}\n\nfunction yaxis(selection, axis) {\n    selection.select(\".y-axis\").remove();\n    let y = selection.append(\"g\")\n                     .attr(\"class\", \"y-axis\")\n                     .call(axis.tickSize(0).tickPadding(10))\n                     .style(\"opacity\", 0);\n\n    y.selectAll(\"text\")\n     .style(\"fill\", d3.hcl(_Colours__WEBPACK_IMPORTED_MODULE_0__[\"colours\"].eighteen.darkGrey).brighter());\n\n    y.selectAll(\".domain\")\n     .style(\"stroke\", _Colours__WEBPACK_IMPORTED_MODULE_0__[\"colours\"].eighteen.midGrey); // d3.hcl(colours.eighteen.darkGrey).brighter());\n\n    const width = y.node().getBBox().width;\n    y.attr(\"transform\", \"translate(\" + width + \",0)\");\n\n    y.transition()\n     .duration(AXIS_ANIMATION_DURATION)\n     .delay(AXIS_DELAY)\n     .style(\"opacity\", 1);\n\n    return width + 20;\n}\n\nfunction grid(selection, width, axis) {\n    selection.select(\".grid\").remove();\n\n    let grid = selection.append(\"g\")\n                        .attr(\"class\", \"grid\")\n                        .call(axis\n                            .tickSize(-width)\n                            .tickFormat(\"\")\n                        );\n\n    grid.selectAll(\"line\")\n        .style(\"stroke\", _Colours__WEBPACK_IMPORTED_MODULE_0__[\"colours\"].eighteen.lightGrey);\n    grid.selectAll(\".domain\").remove();\n\n    grid\n        .lower() // Always ensure that this is earlier in the dom. Things must be drawn on top of it.\n        .style(\"opacity\", 0)\n        .transition()\n        .delay(AXIS_DELAY)\n        .duration(AXIS_ANIMATION_DURATION)\n        .style(\"opacity\", 1);\n}\n\nfunction yAxisLabel(element, height, margins, label) {\n    element.selectAll(\".y-axis-label\").remove();\n\n    if (!label) return;\n    let text = label;\n    if (text.long) text = text.long;\n\n    let x = -(margins.top + height / 2);\n\n    let labelElement = element.append(\"g\")\n                              .attr(\"class\", \"y-axis-label\")\n                              .append(\"text\")\n                              .text(text)\n                              .attr(\"transform\", \"rotate(-90 0,0) translate(\" + x + \", 20)\")\n                              .style(\"fill\", d3.hcl(_Colours__WEBPACK_IMPORTED_MODULE_0__[\"colours\"].eighteen.darkGrey).brighter());\n\n    let width = labelElement.node().getBBox().width;\n    if (width >= height && label.short) {\n        labelElement.text(label.short);\n        width = labelElement.node().getBBox().width;\n    }\n\n    labelElement.attr(\"dx\", -width / 2)\n        .style(\"opacity\", 0)\n        .transition()\n        .delay(AXIS_DELAY)\n        .duration(AXIS_ANIMATION_DURATION)\n            .style(\"opacity\", 1)\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvQXhlcy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2IzanMvLi9zcmMvQXhlcy5qcz84ZTE3Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoQykgMjAxMy0yMDE0LCAyMDE4IEJyYW5kc0V5ZSAoUFRZKSBMVERcbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXNcbi8vIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZVxuLy8gd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LFxuLy8gICAgIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG9cbi8vIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nXG4vLyBjb25kaXRpb25zOlxuLy9cbi8vICAgICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbi8vIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gICAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1IgSU1QTElFRCxcbi8vICAgICBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQVxuLy8gUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxuLy8gSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GXG4vLyBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkVcbi8vIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5pbXBvcnQge2NvbG91cnN9IGZyb20gXCIuL0NvbG91cnNcIjtcblxuY29uc3QgQVhJU19BTklNQVRJT05fRFVSQVRJT04gPSAxMDAwO1xuY29uc3QgQVhJU19ERUxBWSA9IDI1MDtcblxuXG5leHBvcnQgZnVuY3Rpb24geGF4aXMoc2VsZWN0aW9uLCBoZWlnaHQsIHdpZHRoLCBheGlzT2JqZWN0KSB7XG4gICAgc2VsZWN0aW9uLnNlbGVjdChcIi54LWF4aXNcIikucmVtb3ZlKCk7XG4gICAgbGV0IGF4aXMgPSBzZWxlY3Rpb24uYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcIngtYXhpc1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoMCxcIiArIGhlaWdodCArIFwiKVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNhbGwoYXhpc09iamVjdCk7XG5cbiAgICBheGlzLnNlbGVjdChcIi5kb21haW5cIikucmVtb3ZlKCk7XG5cbiAgICBsZXQgbWF4ID0gMDtcbiAgICBjb25zdCBmb250U2l6ZSA9IDEyO1xuICAgIGF4aXMuc2VsZWN0QWxsKFwidGV4dFwiKVxuICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIGQzLmhjbChjb2xvdXJzLmVpZ2h0ZWVuLmRhcmtHcmV5KS5icmlnaHRlcigpKVxuICAgICAgICAubm9kZXMoKVxuICAgICAgICAuZm9yRWFjaCh0ZXh0ID0+IG1heCA9IE1hdGgubWF4KG1heCwgdGV4dC5nZXRCQm94KCkud2lkdGgpKTtcblxuICAgIGlmIChtYXggPj0gd2lkdGggLSAxMCkge1xuICAgICAgICBjb25zdCBiYWQgPSBtYXggPj0gd2lkdGggKiAyO1xuICAgICAgICBjb25zdCBhbmdsZSA9IGJhZCA/IC05MCA6IC0zMDtcbiAgICAgICAgY29uc3QgZm9udFNpemUgPSB3aWR0aCA8PSAxMyA/IDggOiAxMjtcbiAgICAgICAgY29uc3QgeCA9IGJhZCA/IC1mb250U2l6ZSA6IDA7XG4gICAgICAgIGNvbnN0IHkgPSBiYWQgPyA1IDogMjtcblxuICAgICAgICBheGlzLnNlbGVjdEFsbChcInRleHRcIilcbiAgICAgICAgICAgIC5zdHlsZSgndGV4dC1hbmNob3InLCAnZW5kJylcbiAgICAgICAgICAgIC5zdHlsZShcImZvbnQtc2l6ZVwiLCBmb250U2l6ZSArIFwicHhcIilcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsICgpID0+IFwidHJhbnNsYXRlKFwiICsgeCArIFwiLFwiICsgeSArIFwiKSByb3RhdGUoXCIgKyBhbmdsZSArIFwiIDAsMClcIilcbiAgICB9XG5cbiAgICBheGlzXG4gICAgICAgIC50cmFuc2l0aW9uKClcbiAgICAgICAgLmR1cmF0aW9uKEFYSVNfQU5JTUFUSU9OX0RVUkFUSU9OKVxuICAgICAgICAuZGVsYXkoQVhJU19ERUxBWSlcbiAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAxKTtcblxuICAgIGNvbnN0IGF4aXNIZWlnaHQgPSBheGlzLm5vZGUoKS5nZXRCQm94KCkuaGVpZ2h0O1xuICAgIGF4aXMuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZSgwLFwiICsgKGhlaWdodCAtIGF4aXNIZWlnaHQpICsgXCIpXCIpO1xuICAgIHJldHVybiBheGlzSGVpZ2h0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24geWF4aXMoc2VsZWN0aW9uLCBheGlzKSB7XG4gICAgc2VsZWN0aW9uLnNlbGVjdChcIi55LWF4aXNcIikucmVtb3ZlKCk7XG4gICAgbGV0IHkgPSBzZWxlY3Rpb24uYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcInktYXhpc1wiKVxuICAgICAgICAgICAgICAgICAgICAgLmNhbGwoYXhpcy50aWNrU2l6ZSgwKS50aWNrUGFkZGluZygxMCkpXG4gICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDApO1xuXG4gICAgeS5zZWxlY3RBbGwoXCJ0ZXh0XCIpXG4gICAgIC5zdHlsZShcImZpbGxcIiwgZDMuaGNsKGNvbG91cnMuZWlnaHRlZW4uZGFya0dyZXkpLmJyaWdodGVyKCkpO1xuXG4gICAgeS5zZWxlY3RBbGwoXCIuZG9tYWluXCIpXG4gICAgIC5zdHlsZShcInN0cm9rZVwiLCBjb2xvdXJzLmVpZ2h0ZWVuLm1pZEdyZXkpOyAvLyBkMy5oY2woY29sb3Vycy5laWdodGVlbi5kYXJrR3JleSkuYnJpZ2h0ZXIoKSk7XG5cbiAgICBjb25zdCB3aWR0aCA9IHkubm9kZSgpLmdldEJCb3goKS53aWR0aDtcbiAgICB5LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyB3aWR0aCArIFwiLDApXCIpO1xuXG4gICAgeS50cmFuc2l0aW9uKClcbiAgICAgLmR1cmF0aW9uKEFYSVNfQU5JTUFUSU9OX0RVUkFUSU9OKVxuICAgICAuZGVsYXkoQVhJU19ERUxBWSlcbiAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAxKTtcblxuICAgIHJldHVybiB3aWR0aCArIDIwO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ3JpZChzZWxlY3Rpb24sIHdpZHRoLCBheGlzKSB7XG4gICAgc2VsZWN0aW9uLnNlbGVjdChcIi5ncmlkXCIpLnJlbW92ZSgpO1xuXG4gICAgbGV0IGdyaWQgPSBzZWxlY3Rpb24uYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImdyaWRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jYWxsKGF4aXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGlja1NpemUoLXdpZHRoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aWNrRm9ybWF0KFwiXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgZ3JpZC5zZWxlY3RBbGwoXCJsaW5lXCIpXG4gICAgICAgIC5zdHlsZShcInN0cm9rZVwiLCBjb2xvdXJzLmVpZ2h0ZWVuLmxpZ2h0R3JleSk7XG4gICAgZ3JpZC5zZWxlY3RBbGwoXCIuZG9tYWluXCIpLnJlbW92ZSgpO1xuXG4gICAgZ3JpZFxuICAgICAgICAubG93ZXIoKSAvLyBBbHdheXMgZW5zdXJlIHRoYXQgdGhpcyBpcyBlYXJsaWVyIGluIHRoZSBkb20uIFRoaW5ncyBtdXN0IGJlIGRyYXduIG9uIHRvcCBvZiBpdC5cbiAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAwKVxuICAgICAgICAudHJhbnNpdGlvbigpXG4gICAgICAgIC5kZWxheShBWElTX0RFTEFZKVxuICAgICAgICAuZHVyYXRpb24oQVhJU19BTklNQVRJT05fRFVSQVRJT04pXG4gICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB5QXhpc0xhYmVsKGVsZW1lbnQsIGhlaWdodCwgbWFyZ2lucywgbGFiZWwpIHtcbiAgICBlbGVtZW50LnNlbGVjdEFsbChcIi55LWF4aXMtbGFiZWxcIikucmVtb3ZlKCk7XG5cbiAgICBpZiAoIWxhYmVsKSByZXR1cm47XG4gICAgbGV0IHRleHQgPSBsYWJlbDtcbiAgICBpZiAodGV4dC5sb25nKSB0ZXh0ID0gdGV4dC5sb25nO1xuXG4gICAgbGV0IHggPSAtKG1hcmdpbnMudG9wICsgaGVpZ2h0IC8gMik7XG5cbiAgICBsZXQgbGFiZWxFbGVtZW50ID0gZWxlbWVudC5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwieS1heGlzLWxhYmVsXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRleHQodGV4dClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwicm90YXRlKC05MCAwLDApIHRyYW5zbGF0ZShcIiArIHggKyBcIiwgMjApXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIGQzLmhjbChjb2xvdXJzLmVpZ2h0ZWVuLmRhcmtHcmV5KS5icmlnaHRlcigpKTtcblxuICAgIGxldCB3aWR0aCA9IGxhYmVsRWxlbWVudC5ub2RlKCkuZ2V0QkJveCgpLndpZHRoO1xuICAgIGlmICh3aWR0aCA+PSBoZWlnaHQgJiYgbGFiZWwuc2hvcnQpIHtcbiAgICAgICAgbGFiZWxFbGVtZW50LnRleHQobGFiZWwuc2hvcnQpO1xuICAgICAgICB3aWR0aCA9IGxhYmVsRWxlbWVudC5ub2RlKCkuZ2V0QkJveCgpLndpZHRoO1xuICAgIH1cblxuICAgIGxhYmVsRWxlbWVudC5hdHRyKFwiZHhcIiwgLXdpZHRoIC8gMilcbiAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAwKVxuICAgICAgICAudHJhbnNpdGlvbigpXG4gICAgICAgIC5kZWxheShBWElTX0RFTEFZKVxuICAgICAgICAuZHVyYXRpb24oQVhJU19BTklNQVRJT05fRFVSQVRJT04pXG4gICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDEpXG59Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/Axes.js\n");

/***/ }),

/***/ "./src/BarChart.js":
/*!*************************!*\
  !*** ./src/BarChart.js ***!
  \*************************/
/*! exports provided: BarChart */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BarChart\", function() { return BarChart; });\n/* harmony import */ var _Colours__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Colours */ \"./src/Colours.js\");\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers */ \"./src/helpers.js\");\n/* harmony import */ var _Chart__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Chart */ \"./src/Chart.js\");\n// Copyright (C) 2013-2014, 2018 BrandsEye (PTY) LTD\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this\n// software and associated documentation files (the \"Software\"), to deal in the Software\n// without restriction, including without limitation the rights to use, copy, modify,\n//     merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following\n// conditions:\n//\n//     The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n//     INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n// CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n\n\n\n\nclass BarChart extends _Chart__WEBPACK_IMPORTED_MODULE_2__[\"Chart\"] {\n\n    //------------------------------------------------------\n\n    data(data) {\n        if (!arguments.length) return this._data;\n        if (data && data[0].key === undefined) {\n            data = [\n                {\n                    key: \"series 1\",\n                    values: data\n                }\n            ];\n        }\n        this._data = data;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    element(element) {\n        if (!arguments.length) return this._element;\n        this._element = element;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    showLabels(show) {\n        if (!arguments.length) return this._show_labels;\n        this._show_labels = show;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    // todo dispatch\n    showLegend(show) {\n        if (!arguments.length) return this._show_legend;\n        this._show_legend = show;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    x(x) {\n        if (!arguments.length) return this._x;\n        this._x = x;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    y(y) {\n        if (!arguments.length) return this._y;\n        this._y = y;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    width(width) {\n        if (!arguments.length) return this._width;\n        this._width = width;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    height(height) {\n        if (!arguments.length) return this._height;\n        this._height = height;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    colours(colours) {\n        if (!arguments.length) return this._colours;\n        this._colours = colours;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    backgroundColour(colour) {\n        if (!arguments.length) return this._backgroundColour;\n        this._backgroundColour = colour || \"#FFF\"; // never set it to null.\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    tickFormat(format) {\n        if (!arguments.length) return this._tickFormat;\n        this._tickFormat = format;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    xAxisTickFormat(format) {\n        if (!arguments.length) return this._xAxisTickFormat;\n        this._xAxisTickFormat = format || (d => d.toString());\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    labelFormat(format) {\n        if (!arguments.length) return this._labelFormat;\n        this._labelFormat = format || (d => d.toString());\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    // todo missing\n    labelCompression(compression) {\n        if (!arguments.length) return this._compression;\n        this._compression = compression;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    //todo missing\n    dataAxisLabel(label) {\n        if (!arguments.length) return this._dataAxisLabel;\n        this._dataAxisLabel = label;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    tooltip(tooltip) {\n        if (!arguments.length) return this._tooltip;\n        this._tooltip = tooltip;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    forceY(force) {\n        if (!arguments.length) return this._forceY;\n        this._forceY = force;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n// todo missing\n    duration(duration) {\n        if (!arguments.length) return this._duration;\n        this._duration = duration;\n        return this;\n    }\n\n// todo missing\n    coarseness(coarseness) {\n        if (!arguments.length) return this._coarseness;\n        this._coarseness = coarseness;\n        return this;\n    }\n\n    // todo missing\n    padding(padding) {\n        if (!arguments.length) return this._padding;\n        this._padding = padding;\n        return this;\n    }\n\n    // todo missing\n    xAxisTooltips(tooltips) {\n        if (!arguments.length) return this._xAxisTooltips;\n        this._xAxisTooltips = tooltips;\n        return this;\n    }\n\n    xAxisOverride(override) {\n        if (!arguments.length) return this._xAxisOverride;\n        this._xAxisOverride = override;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    dispatch() {\n        return this._dispatch;\n    }\n\n    //------------------------------------------------------\n\n    render() {\n        if (!this._element) throw new Error(\"No element set for ColumnChart. See #element()\");\n        if (!this._data) {\n            console.warn(\"No data set for ColumnChart. See #data()\");\n            return;\n        }\n\n        const data = this.getTransformedData();\n        const keys = this.getKeys();\n\n        //------------------------------------------------\n        // Set up the SVG area\n\n        let topLevel = d3.select(this._element).select(\"svg\");\n        if (topLevel.empty()) topLevel = d3.select(this._element).append(\"svg\")\n\n        topLevel\n            .style(\"width\", this._width + \"px\")\n            .style(\"height\", this._height + \"px\");\n\n\n        // ---------------------------------\n        // Measure max data axis text length\n\n        const dataAxisBB = Object(_helpers__WEBPACK_IMPORTED_MODULE_1__[\"maxBounding\"])(topLevel, data.map(d => this._xAxisTickFormat(d.key)));\n\n        // ---------------------------------\n        // Layout the showLegend.\n        //\n        // We do this now because we need to know how much space the legend\n        // takes up in order to finish calculating the margins.\n\n        const legendHeight = this.renderLegend();\n\n        //----------------------------------\n        // Calculate margins.\n\n        const margin = {top: 20, right: 20, bottom: 40, left: 10};\n        margin.bottom += legendHeight ? legendHeight + 20 : 0;\n        margin.left += dataAxisBB.width + 10;\n        if (this._dataAxisLabel) margin.bottom += 10 + 12;\n\n        const width = this._width - margin.left - margin.right,\n              height = this._height - margin.top - margin.bottom;\n\n        //----------------------------------\n        // Calculate scales and so on.\n\n        const x = d3.scaleLinear()\n            .rangeRound([0, width])\n            .nice();\n\n        const y = d3.scaleBand()\n            .rangeRound([0, height])\n            .padding(this._data.length > 1 ? 0.08 : 0.1);\n\n        const yGroup = d3.scaleBand()\n            .padding(0);\n\n        this._xscale = x;\n        this._ygroupscale = yGroup;\n        this._yscale = y;\n\n        // Scale the range of the data in the domains\n        y.domain(data.map(d => d.key));\n        yGroup.rangeRound([0, y.bandwidth()]).domain(keys);\n        x.domain([0, d3.max(data, d => d3.max(d.data, d => d._y))]);\n\n        //------------------------------\n\n        let svg = topLevel.select('.main-group');\n\n        if (svg.empty()) {\n            svg = topLevel\n                .append(\"g\")\n                .attr(\"class\", \"main-group\")\n        }\n\n        svg.attr(\"transform\", \"translate(\" + margin.left + \",\" + margin.top + \")\");\n\n        //---------------------------------\n        // Get rid of current labels.\n        svg.select(\".chart-labels\")\n            .remove();\n\n        //---------------------------------\n        // append the rectangles for the bar chart\n        let groups = svg.select(\".bars\").selectAll('.group');\n\n        if (groups.empty()) {\n            groups = svg\n                .append(\"g\")\n                .attr(\"class\", \"bars\")\n                .selectAll(\".group\");\n        }\n\n        groups = groups.data(data);\n\n        groups.exit().remove();\n\n        // Adding new groups, and hence adding new bars to those groups.\n        groups.enter()\n            .append(\"g\")\n                .attr(\"class\", \"group\")\n                .attr(\"transform\", d => \"translate(0,\" + y(d.key) + \")\")\n                .attr(\"height\", height - y.bandwidth())\n                .attr(\"width\", \"100%\")\n            .merge(groups)\n            .interrupt(\"groups:move\")\n            .transition(\"groups:move\")\n                .attr(\"transform\", d => \"translate(0,\" + y(d.key) + \")\")\n                .attr(\"height\", y.bandwidth())\n            .each((s_d, s_i, nodes) => {\n                let group = d3.select(nodes[s_i]);\n\n                let bars = group.selectAll(\".bar\")\n                    .data(s_d.data);\n\n                bars.exit().remove();\n\n                bars.interrupt(\"bar:move\")     // Animate the bars to their new position.\n                    .transition(\"bar:move\")\n                        .attr(\"height\", yGroup.bandwidth())\n                        .attr(\"y\", d => yGroup(d._key))\n                        .attr(\"x\", 0);\n\n                bars.enter()\n                    .append(\"rect\")\n                        .attr(\"class\", (d, i) => \"bar series series-\" + i)\n                        .attr(\"y\", d => yGroup(d._key))\n                        .attr(\"x\", 0)\n                        .attr(\"height\", yGroup.bandwidth())\n                        .attr(\"width\", 0)\n                        .style(\"fill\", (d, i) => this.getSeriesColour(i))\n                        .style(\"cursor\", \"pointer\")\n                    .on(\"mouseover\", (d, i, nodes) => { // Darken the bar on mouse over\n                        d3.select(nodes[i])\n                            .interrupt(\"hover:colour\")\n                            .transition(\"hover:colour\")\n                            .duration(400)\n                            .style(\"fill\", d3.hcl(this.getSeriesColour(i)).darker())\n                        this._dispatch.call(\"tooltipShow\", this, {\n                            e: d3.event,\n                            point: d,\n                            series: s_d,\n                            seriesIndex: s_i,\n                            value: d._y\n                        })\n                    })\n                    .on(\"mouseout\", (d, i, nodes) => { // bar is regular colour on mouse out.\n                        d3.select(nodes[i])\n                            .interrupt(\"hover:colour\")\n                            .transition(\"hover:colour\")\n                            .duration(400)\n                            .style(\"fill\", this.getSeriesColour(i));\n                        this._dispatch.call(\"tooltipHide\", this);\n                    })\n                    .on(\"click auxclick\", (d, i, nodes) => {\n                        this._dispatch.call(\"elementClick\", this, {\n                            e: d3.event,\n                            point: d,\n                            series: d._series,\n                            seriesIndex: s_i,\n                            value: this._y(d)\n                        })\n                    })\n                    .merge(bars)\n                    .interrupt(\"bar:growth\")    // Animate bars growing.\n                    .transition(\"bar:growth\")\n                    .delay(() => {\n                        return this.calcBarGrowth(s_i, nodes.length);\n                    })\n                    .duration(this._duration)\n                        .style(\"fill\", (d, i) => this.getSeriesColour(i))\n                        .attr(\"width\", d => x(d._y));\n\n            });\n\n        // ---------------------------------\n        // Labels loaded after our first bar grows.\n        if (this._show_labels) {\n            svg.transition(\"bar:growth\")\n                .on(\"end\", (d, i, nodes) => {\n                    if (i < nodes.length - 1) return;\n                    this.renderLabels(svg, data, x, yGroup, y);\n                })\n        }\n\n        // ---------------------------------\n        // Draw the data axis data label.\n\n        if (this._dataAxisLabel) {\n            this.renderDataAxisLabel(width, margin);\n        }\n\n        // ---------------------------------\n        // Set the background colour\n\n        d3.select(this._element).select(\".background\").remove();\n        if (this._backgroundColour) {\n            d3.select(this._element).select(\"svg\")\n                .append(\"rect\")\n                    .attr(\"class\", \"background\")\n                    .attr(\"width\", \"100%\")\n                    .attr(\"height\", \"100%\")\n                    .style(\"fill\", this._backgroundColour)\n                .lower();\n        }\n\n        //---------------------------------\n        // add the Y gridlines\n        svg.call(this.grid, height, d3.axisBottom(x).ticks(5));\n\n        //---------------------------------\n        // axes\n        svg.call(this.labelAxis, d3.axisLeft(y).tickSize(0).tickPadding(5).tickFormat(this._xAxisTickFormat));\n        svg.call(this.dataAxis, height, d3.axisBottom(x).ticks(5).tickFormat(this._tickFormat));\n    }\n\n    //------------------------------------------------------\n\n    /*\n     * Returns an object with two functions, #show() and #hide(),\n     * to show and hide the labels.\n     */\n    labels() {\n        return {\n\n            show: () => {\n                if (this._element) {\n                    let selection = this._element,\n                        data = this.getTransformedData(),\n                        xscale = this._xscale,\n                        ygroup = this._ygroupscale,\n                        yscale = this._yscale;\n\n                    if (selection) selection = d3.select(this._element).select(\"svg\").select(\"g\");\n                    if (!selection.empty() && data && xscale && yscale && ygroup) {\n                        let labels = selection.select('.chart-labels');\n                        if (!labels.empty()) return;\n                        labels.remove()\n                        this.renderLabels(selection, data, xscale, ygroup, yscale, false);\n                    }\n                }\n\n            },\n\n            hide: () => {\n                if (this._element) {\n                    d3.select(this._element)\n                        .select('.chart-labels')\n                        .interrupt(\"labels\")\n                        .interrupt(\"labels:fade\")\n                        .transition(\"labels:fade\")\n                        .style(\"opacity\", 0)\n                        .on(\"end\", (d, i, nodes) => {\n                            d3.select(nodes[i]).remove();\n                        })\n                }\n            }\n        }\n    }\n\n    //------------------------------------------------------\n\n    renderLabels(selection, data, xscale, ygroup, yscale, animate) {\n        animate = animate === undefined ? true : animate;\n        selection.selectAll(\".chart-labels\").remove();\n\n        let labels = selection.append(\"g\")\n            .attr(\"class\", \"chart-labels\")\n            .selectAll(\".label-group\")\n            .data(data);\n\n        let fontSize = 12;    // Our initial font size.\n        const buffer = 5;     // Buffer space between words and the top of a bar.\n\n        labels.enter().each((series, s_i, s_nodes) => {\n            let group = d3.select(s_nodes[s_i])\n                .append(\"g\")\n                .attr(\"class\", \"label-group\")\n                .attr(\"transform\", d => \"translate(0,\" + yscale(d.key) + \")\")\n                .selectAll(\".chart-label\")\n                .data(series.data)\n                .enter()\n                .each((d, i, nodes) => {\n\n                    // Want to figure out if the label is too dark / light for the\n                    // bar.\n                    let invertedColor = d3.hcl(this.getSeriesColour(i));\n                    invertedColor.l += Math.min(invertedColor.l + 50, 100);\n                    let invert = d3.hcl(this.getSeriesColour(i)).l < 60;\n\n                    let xpos = xscale(d._y);\n\n                    let text = d3.select(nodes[i])\n                        .append(\"text\")\n                        .text(this._labelFormat(d._y))\n                            .attr(\"class\", \"chart-label\")\n                            .attr(\"x\", xpos + buffer)\n                            .attr(\"dx\", animate ? -15 : 0)\n                            .style(\"opacity\", 0)\n                            .style(\"pointer-events\", \"none\")\n                            .style(\"font-size\", fontSize + \"px\");\n\n\n                    const bb = text.node().getBBox();\n                    const oversize = xpos + bb.width + buffer > xscale.range()[1];\n\n                    text\n                        .attr(\"y\", ygroup(d._key) + fontSize / 2 + ygroup.bandwidth() / 2)\n                        .attr(\"x\", oversize ? xpos - buffer - bb.width : xpos + buffer)\n                        .style(\"fill\", oversize && invert ? invertedColor.toString() : _Colours__WEBPACK_IMPORTED_MODULE_0__[\"colours\"].eighteen.darkGrey);\n\n                    text\n                        .transition(\"labels\")\n                        .delay(() => animate ? this.calcBarGrowth(s_i, s_nodes.length) : 0) // Delay in lockstep with bar growth.\n                        .duration(this._duration)\n                        .attr(\"dx\", 0)\n                        .style(\"opacity\", 1)\n                })\n        });\n\n    }\n\n    //------------------------------------------------------\n\n    renderDataAxisLabel(width, margins) {\n        let svg = d3.select(this._element).select('svg');\n        svg.selectAll(\".data-labels\").remove();\n\n        if (!this._dataAxisLabel) return;\n        let text = this._dataAxisLabel;\n        if (text.long) text = text.long;\n\n        let x = (margins.left + width / 2);\n\n        let label = svg.append(\"g\")\n            .attr(\"class\", \"data-labels\")\n            .append(\"text\")\n            .text(text)\n            .attr(\"transform\", \"translate(\" + x + \",\" + (this._height - margins.bottom + 50) + \")\")\n            .style(\"fill\", _Colours__WEBPACK_IMPORTED_MODULE_0__[\"colours\"].eighteen.darkGrey);\n\n        let textWidth = label.node().getBBox().width;\n        if (textWidth >= width && this._dataAxisLabel.short) {\n            label.text(this._dataAxisLabel.short);\n            textWidth = label.node().getBBox().width;\n        }\n\n        label.attr(\"dx\", -textWidth / 2);\n    }\n\n    //------------------------------------------------------\n\n\n\n    grid(selection, height, axis) {\n        selection.select(\".grid\").remove();\n\n        let grid = selection.append(\"g\")\n            .attr(\"class\", \"grid\")\n            .call(axis\n                .tickSize(height)\n                .tickFormat(\"\")\n            );\n\n        grid.selectAll(\"line\")\n            .style(\"stroke\", _Colours__WEBPACK_IMPORTED_MODULE_0__[\"colours\"].eighteen.lightGrey);\n        grid.selectAll(\".domain\").remove();\n\n        grid\n            .lower() // Always ensure that this is earlier in the dom. Things must be drawn on top of it.\n            .style(\"opacity\", 0)\n            .transition()\n            .delay(500)\n            .duration(500)\n            .style(\"opacity\", 1);\n    }\n\n    //------------------------------------------------------\n\n    labelAxis(selection, axis_object) {\n        selection.select(\".label-axis\").remove();\n        let axis = selection.append(\"g\")\n            .attr(\"class\", \"label-axis\")\n            .style(\"opacity\", 0)\n            .call(axis_object);\n\n        axis.select(\".domain\").remove();\n\n        let max = 0;\n        const fontSize = 12;\n        axis.selectAll(\"text\")\n            .style(\"fill\", _Colours__WEBPACK_IMPORTED_MODULE_0__[\"colours\"].eighteen.darkGrey)\n            .nodes()\n            .forEach(text => max = Math.max(max, text.getBBox().width));\n\n        axis\n            .transition()\n            .duration(1000)\n            .style(\"opacity\", 1);\n    }\n\n    //------------------------------------------------------\n\n    dataAxis(selection, height, axis_object) {\n        selection.select(\".data-axis\").remove();\n        let axis = selection.append(\"g\")\n                .attr(\"class\", \"data-axis\")\n                .attr(\"transform\", \"translate(0,\" + height + \")\")\n            .call(axis_object.tickSize(0).tickPadding(10))\n                .style(\"opacity\", 0)\n            .transition()\n            .duration(1000)\n                .style(\"opacity\", 1);\n\n        axis.selectAll(\"text\")\n                .style(\"fill\", _Colours__WEBPACK_IMPORTED_MODULE_0__[\"colours\"].eighteen.darkGrey)\n    }\n\n    //------------------------------------------------------\n\n    calcBarGrowth(i, max) {\n        if (max < 10) return i * this._BAR_GROWTH / 2;\n        if (max < 35) return i * this._BAR_GROWTH / 4;\n        return 1;\n    }\n\n    getSeriesColour(i) {\n        if (i < 0 || !this._colours) return _Colours__WEBPACK_IMPORTED_MODULE_0__[\"colours\"].eighteen.midGrey;\n\n        i = i % this._colours.length;\n        return this._colours[i];\n    }\n\n    getSortedData() {\n        let data = this._data;\n        if (!data || !data.length) return [];\n\n        data = this._data.sort((lhs, rhs) => {\n            lhs = lhs.key.toLowerCase();\n            rhs = rhs.key.toLowerCase();\n\n            if (lhs === rhs) return 0;\n            if (lhs < rhs) return -1;\n            return 1;\n        });\n\n        return data;\n    }\n\n    getTransformedData() {\n        let data = this.getSortedData();\n        if (!data || !data.length) return [];\n\n        let results = [];\n\n        const getX = d => this._xAxisOverride ? this._xAxisOverride[this._x(d)] : this._x(d);\n\n        data.forEach((series, s_i) => {\n            series.values.forEach((d, d_i) => {\n                let field = results.find(bucket => bucket.key === getX(d));\n                if (!field) {\n                    field = {\n                        data: [],\n                        key: getX(d)\n                    };\n                    results.push(field);\n                }\n\n                field.data.push(Object.assign({\n                    _series: series,\n                    _s_i: s_i,\n                    _key: series.key,\n                    _y: this._y(d)\n                }, d));\n            })\n        });\n\n        return results;\n    }\n\n    getKeys() {\n        let data = this._data;\n        if (!data || !data.length) return [];\n\n        return [...new Set(data.map(d => d.key))]\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvQmFyQ2hhcnQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9iM2pzLy4vc3JjL0JhckNoYXJ0LmpzPzNjODUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChDKSAyMDEzLTIwMTQsIDIwMTggQnJhbmRzRXllIChQVFkpIExURFxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpc1xuLy8gc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlXG4vLyB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksXG4vLyAgICAgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0b1xuLy8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcbi8vIGNvbmRpdGlvbnM6XG4vL1xuLy8gICAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuLy8gY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyAgICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUiBJTVBMSUVELFxuLy8gICAgIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBXG4vLyBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUXG4vLyBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0Zcbi8vIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRVxuLy8gT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cblxuaW1wb3J0IHsgY29sb3VycyB9IGZyb20gJy4vQ29sb3Vycyc7XG5pbXBvcnQgeyBtYXhCb3VuZGluZyB9IGZyb20gXCIuL2hlbHBlcnNcIjtcbmltcG9ydCB7IENoYXJ0IH0gZnJvbSBcIi4vQ2hhcnRcIjtcblxuXG5leHBvcnQgY2xhc3MgQmFyQ2hhcnQgZXh0ZW5kcyBDaGFydCB7XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgZGF0YShkYXRhKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX2RhdGE7XG4gICAgICAgIGlmIChkYXRhICYmIGRhdGFbMF0ua2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRhdGEgPSBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBrZXk6IFwic2VyaWVzIDFcIixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzOiBkYXRhXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGVsZW1lbnQoZWxlbWVudCkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9lbGVtZW50O1xuICAgICAgICB0aGlzLl9lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHNob3dMYWJlbHMoc2hvdykge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9zaG93X2xhYmVscztcbiAgICAgICAgdGhpcy5fc2hvd19sYWJlbHMgPSBzaG93O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLy8gdG9kbyBkaXNwYXRjaFxuICAgIHNob3dMZWdlbmQoc2hvdykge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9zaG93X2xlZ2VuZDtcbiAgICAgICAgdGhpcy5fc2hvd19sZWdlbmQgPSBzaG93O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgeCh4KSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3g7XG4gICAgICAgIHRoaXMuX3ggPSB4O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgeSh5KSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3k7XG4gICAgICAgIHRoaXMuX3kgPSB5O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgd2lkdGgod2lkdGgpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fd2lkdGg7XG4gICAgICAgIHRoaXMuX3dpZHRoID0gd2lkdGg7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBoZWlnaHQoaGVpZ2h0KSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX2hlaWdodDtcbiAgICAgICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgY29sb3Vycyhjb2xvdXJzKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX2NvbG91cnM7XG4gICAgICAgIHRoaXMuX2NvbG91cnMgPSBjb2xvdXJzO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgYmFja2dyb3VuZENvbG91cihjb2xvdXIpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fYmFja2dyb3VuZENvbG91cjtcbiAgICAgICAgdGhpcy5fYmFja2dyb3VuZENvbG91ciA9IGNvbG91ciB8fCBcIiNGRkZcIjsgLy8gbmV2ZXIgc2V0IGl0IHRvIG51bGwuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB0aWNrRm9ybWF0KGZvcm1hdCkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl90aWNrRm9ybWF0O1xuICAgICAgICB0aGlzLl90aWNrRm9ybWF0ID0gZm9ybWF0O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgeEF4aXNUaWNrRm9ybWF0KGZvcm1hdCkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl94QXhpc1RpY2tGb3JtYXQ7XG4gICAgICAgIHRoaXMuX3hBeGlzVGlja0Zvcm1hdCA9IGZvcm1hdCB8fCAoZCA9PiBkLnRvU3RyaW5nKCkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgbGFiZWxGb3JtYXQoZm9ybWF0KSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX2xhYmVsRm9ybWF0O1xuICAgICAgICB0aGlzLl9sYWJlbEZvcm1hdCA9IGZvcm1hdCB8fCAoZCA9PiBkLnRvU3RyaW5nKCkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLy8gdG9kbyBtaXNzaW5nXG4gICAgbGFiZWxDb21wcmVzc2lvbihjb21wcmVzc2lvbikge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9jb21wcmVzc2lvbjtcbiAgICAgICAgdGhpcy5fY29tcHJlc3Npb24gPSBjb21wcmVzc2lvbjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8vdG9kbyBtaXNzaW5nXG4gICAgZGF0YUF4aXNMYWJlbChsYWJlbCkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9kYXRhQXhpc0xhYmVsO1xuICAgICAgICB0aGlzLl9kYXRhQXhpc0xhYmVsID0gbGFiZWw7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB0b29sdGlwKHRvb2x0aXApIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fdG9vbHRpcDtcbiAgICAgICAgdGhpcy5fdG9vbHRpcCA9IHRvb2x0aXA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBmb3JjZVkoZm9yY2UpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fZm9yY2VZO1xuICAgICAgICB0aGlzLl9mb3JjZVkgPSBmb3JjZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLy8gdG9kbyBtaXNzaW5nXG4gICAgZHVyYXRpb24oZHVyYXRpb24pIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fZHVyYXRpb247XG4gICAgICAgIHRoaXMuX2R1cmF0aW9uID0gZHVyYXRpb247XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuLy8gdG9kbyBtaXNzaW5nXG4gICAgY29hcnNlbmVzcyhjb2Fyc2VuZXNzKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX2NvYXJzZW5lc3M7XG4gICAgICAgIHRoaXMuX2NvYXJzZW5lc3MgPSBjb2Fyc2VuZXNzO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyB0b2RvIG1pc3NpbmdcbiAgICBwYWRkaW5nKHBhZGRpbmcpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fcGFkZGluZztcbiAgICAgICAgdGhpcy5fcGFkZGluZyA9IHBhZGRpbmc7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIHRvZG8gbWlzc2luZ1xuICAgIHhBeGlzVG9vbHRpcHModG9vbHRpcHMpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5feEF4aXNUb29sdGlwcztcbiAgICAgICAgdGhpcy5feEF4aXNUb29sdGlwcyA9IHRvb2x0aXBzO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB4QXhpc092ZXJyaWRlKG92ZXJyaWRlKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3hBeGlzT3ZlcnJpZGU7XG4gICAgICAgIHRoaXMuX3hBeGlzT3ZlcnJpZGUgPSBvdmVycmlkZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGRpc3BhdGNoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGlzcGF0Y2g7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9lbGVtZW50KSB0aHJvdyBuZXcgRXJyb3IoXCJObyBlbGVtZW50IHNldCBmb3IgQ29sdW1uQ2hhcnQuIFNlZSAjZWxlbWVudCgpXCIpO1xuICAgICAgICBpZiAoIXRoaXMuX2RhdGEpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIk5vIGRhdGEgc2V0IGZvciBDb2x1bW5DaGFydC4gU2VlICNkYXRhKClcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5nZXRUcmFuc2Zvcm1lZERhdGEoKTtcbiAgICAgICAgY29uc3Qga2V5cyA9IHRoaXMuZ2V0S2V5cygpO1xuXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIFNldCB1cCB0aGUgU1ZHIGFyZWFcblxuICAgICAgICBsZXQgdG9wTGV2ZWwgPSBkMy5zZWxlY3QodGhpcy5fZWxlbWVudCkuc2VsZWN0KFwic3ZnXCIpO1xuICAgICAgICBpZiAodG9wTGV2ZWwuZW1wdHkoKSkgdG9wTGV2ZWwgPSBkMy5zZWxlY3QodGhpcy5fZWxlbWVudCkuYXBwZW5kKFwic3ZnXCIpXG5cbiAgICAgICAgdG9wTGV2ZWxcbiAgICAgICAgICAgIC5zdHlsZShcIndpZHRoXCIsIHRoaXMuX3dpZHRoICsgXCJweFwiKVxuICAgICAgICAgICAgLnN0eWxlKFwiaGVpZ2h0XCIsIHRoaXMuX2hlaWdodCArIFwicHhcIik7XG5cblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gTWVhc3VyZSBtYXggZGF0YSBheGlzIHRleHQgbGVuZ3RoXG5cbiAgICAgICAgY29uc3QgZGF0YUF4aXNCQiA9IG1heEJvdW5kaW5nKHRvcExldmVsLCBkYXRhLm1hcChkID0+IHRoaXMuX3hBeGlzVGlja0Zvcm1hdChkLmtleSkpKTtcblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gTGF5b3V0IHRoZSBzaG93TGVnZW5kLlxuICAgICAgICAvL1xuICAgICAgICAvLyBXZSBkbyB0aGlzIG5vdyBiZWNhdXNlIHdlIG5lZWQgdG8ga25vdyBob3cgbXVjaCBzcGFjZSB0aGUgbGVnZW5kXG4gICAgICAgIC8vIHRha2VzIHVwIGluIG9yZGVyIHRvIGZpbmlzaCBjYWxjdWxhdGluZyB0aGUgbWFyZ2lucy5cblxuICAgICAgICBjb25zdCBsZWdlbmRIZWlnaHQgPSB0aGlzLnJlbmRlckxlZ2VuZCgpO1xuXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBDYWxjdWxhdGUgbWFyZ2lucy5cblxuICAgICAgICBjb25zdCBtYXJnaW4gPSB7dG9wOiAyMCwgcmlnaHQ6IDIwLCBib3R0b206IDQwLCBsZWZ0OiAxMH07XG4gICAgICAgIG1hcmdpbi5ib3R0b20gKz0gbGVnZW5kSGVpZ2h0ID8gbGVnZW5kSGVpZ2h0ICsgMjAgOiAwO1xuICAgICAgICBtYXJnaW4ubGVmdCArPSBkYXRhQXhpc0JCLndpZHRoICsgMTA7XG4gICAgICAgIGlmICh0aGlzLl9kYXRhQXhpc0xhYmVsKSBtYXJnaW4uYm90dG9tICs9IDEwICsgMTI7XG5cbiAgICAgICAgY29uc3Qgd2lkdGggPSB0aGlzLl93aWR0aCAtIG1hcmdpbi5sZWZ0IC0gbWFyZ2luLnJpZ2h0LFxuICAgICAgICAgICAgICBoZWlnaHQgPSB0aGlzLl9oZWlnaHQgLSBtYXJnaW4udG9wIC0gbWFyZ2luLmJvdHRvbTtcblxuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHNjYWxlcyBhbmQgc28gb24uXG5cbiAgICAgICAgY29uc3QgeCA9IGQzLnNjYWxlTGluZWFyKClcbiAgICAgICAgICAgIC5yYW5nZVJvdW5kKFswLCB3aWR0aF0pXG4gICAgICAgICAgICAubmljZSgpO1xuXG4gICAgICAgIGNvbnN0IHkgPSBkMy5zY2FsZUJhbmQoKVxuICAgICAgICAgICAgLnJhbmdlUm91bmQoWzAsIGhlaWdodF0pXG4gICAgICAgICAgICAucGFkZGluZyh0aGlzLl9kYXRhLmxlbmd0aCA+IDEgPyAwLjA4IDogMC4xKTtcblxuICAgICAgICBjb25zdCB5R3JvdXAgPSBkMy5zY2FsZUJhbmQoKVxuICAgICAgICAgICAgLnBhZGRpbmcoMCk7XG5cbiAgICAgICAgdGhpcy5feHNjYWxlID0geDtcbiAgICAgICAgdGhpcy5feWdyb3Vwc2NhbGUgPSB5R3JvdXA7XG4gICAgICAgIHRoaXMuX3lzY2FsZSA9IHk7XG5cbiAgICAgICAgLy8gU2NhbGUgdGhlIHJhbmdlIG9mIHRoZSBkYXRhIGluIHRoZSBkb21haW5zXG4gICAgICAgIHkuZG9tYWluKGRhdGEubWFwKGQgPT4gZC5rZXkpKTtcbiAgICAgICAgeUdyb3VwLnJhbmdlUm91bmQoWzAsIHkuYmFuZHdpZHRoKCldKS5kb21haW4oa2V5cyk7XG4gICAgICAgIHguZG9tYWluKFswLCBkMy5tYXgoZGF0YSwgZCA9PiBkMy5tYXgoZC5kYXRhLCBkID0+IGQuX3kpKV0pO1xuXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgbGV0IHN2ZyA9IHRvcExldmVsLnNlbGVjdCgnLm1haW4tZ3JvdXAnKTtcblxuICAgICAgICBpZiAoc3ZnLmVtcHR5KCkpIHtcbiAgICAgICAgICAgIHN2ZyA9IHRvcExldmVsXG4gICAgICAgICAgICAgICAgLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwibWFpbi1ncm91cFwiKVxuICAgICAgICB9XG5cbiAgICAgICAgc3ZnLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyBtYXJnaW4ubGVmdCArIFwiLFwiICsgbWFyZ2luLnRvcCArIFwiKVwiKTtcblxuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBHZXQgcmlkIG9mIGN1cnJlbnQgbGFiZWxzLlxuICAgICAgICBzdmcuc2VsZWN0KFwiLmNoYXJ0LWxhYmVsc1wiKVxuICAgICAgICAgICAgLnJlbW92ZSgpO1xuXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIGFwcGVuZCB0aGUgcmVjdGFuZ2xlcyBmb3IgdGhlIGJhciBjaGFydFxuICAgICAgICBsZXQgZ3JvdXBzID0gc3ZnLnNlbGVjdChcIi5iYXJzXCIpLnNlbGVjdEFsbCgnLmdyb3VwJyk7XG5cbiAgICAgICAgaWYgKGdyb3Vwcy5lbXB0eSgpKSB7XG4gICAgICAgICAgICBncm91cHMgPSBzdmdcbiAgICAgICAgICAgICAgICAuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJiYXJzXCIpXG4gICAgICAgICAgICAgICAgLnNlbGVjdEFsbChcIi5ncm91cFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdyb3VwcyA9IGdyb3Vwcy5kYXRhKGRhdGEpO1xuXG4gICAgICAgIGdyb3Vwcy5leGl0KCkucmVtb3ZlKCk7XG5cbiAgICAgICAgLy8gQWRkaW5nIG5ldyBncm91cHMsIGFuZCBoZW5jZSBhZGRpbmcgbmV3IGJhcnMgdG8gdGhvc2UgZ3JvdXBzLlxuICAgICAgICBncm91cHMuZW50ZXIoKVxuICAgICAgICAgICAgLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwiZ3JvdXBcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBkID0+IFwidHJhbnNsYXRlKDAsXCIgKyB5KGQua2V5KSArIFwiKVwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIGhlaWdodCAtIHkuYmFuZHdpZHRoKCkpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCBcIjEwMCVcIilcbiAgICAgICAgICAgIC5tZXJnZShncm91cHMpXG4gICAgICAgICAgICAuaW50ZXJydXB0KFwiZ3JvdXBzOm1vdmVcIilcbiAgICAgICAgICAgIC50cmFuc2l0aW9uKFwiZ3JvdXBzOm1vdmVcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBkID0+IFwidHJhbnNsYXRlKDAsXCIgKyB5KGQua2V5KSArIFwiKVwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIHkuYmFuZHdpZHRoKCkpXG4gICAgICAgICAgICAuZWFjaCgoc19kLCBzX2ksIG5vZGVzKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGdyb3VwID0gZDMuc2VsZWN0KG5vZGVzW3NfaV0pO1xuXG4gICAgICAgICAgICAgICAgbGV0IGJhcnMgPSBncm91cC5zZWxlY3RBbGwoXCIuYmFyXCIpXG4gICAgICAgICAgICAgICAgICAgIC5kYXRhKHNfZC5kYXRhKTtcblxuICAgICAgICAgICAgICAgIGJhcnMuZXhpdCgpLnJlbW92ZSgpO1xuXG4gICAgICAgICAgICAgICAgYmFycy5pbnRlcnJ1cHQoXCJiYXI6bW92ZVwiKSAgICAgLy8gQW5pbWF0ZSB0aGUgYmFycyB0byB0aGVpciBuZXcgcG9zaXRpb24uXG4gICAgICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKFwiYmFyOm1vdmVcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIHlHcm91cC5iYW5kd2lkdGgoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwieVwiLCBkID0+IHlHcm91cChkLl9rZXkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIDApO1xuXG4gICAgICAgICAgICAgICAgYmFycy5lbnRlcigpXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoXCJyZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIChkLCBpKSA9PiBcImJhciBzZXJpZXMgc2VyaWVzLVwiICsgaSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwieVwiLCBkID0+IHlHcm91cChkLl9rZXkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIDApXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcImhlaWdodFwiLCB5R3JvdXAuYmFuZHdpZHRoKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcIndpZHRoXCIsIDApXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIChkLCBpKSA9PiB0aGlzLmdldFNlcmllc0NvbG91cihpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcImN1cnNvclwiLCBcInBvaW50ZXJcIilcbiAgICAgICAgICAgICAgICAgICAgLm9uKFwibW91c2VvdmVyXCIsIChkLCBpLCBub2RlcykgPT4geyAvLyBEYXJrZW4gdGhlIGJhciBvbiBtb3VzZSBvdmVyXG4gICAgICAgICAgICAgICAgICAgICAgICBkMy5zZWxlY3Qobm9kZXNbaV0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmludGVycnVwdChcImhvdmVyOmNvbG91clwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKFwiaG92ZXI6Y29sb3VyXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKDQwMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIGQzLmhjbCh0aGlzLmdldFNlcmllc0NvbG91cihpKSkuZGFya2VyKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXNwYXRjaC5jYWxsKFwidG9vbHRpcFNob3dcIiwgdGhpcywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGU6IGQzLmV2ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50OiBkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllczogc19kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllc0luZGV4OiBzX2ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGQuX3lcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5vbihcIm1vdXNlb3V0XCIsIChkLCBpLCBub2RlcykgPT4geyAvLyBiYXIgaXMgcmVndWxhciBjb2xvdXIgb24gbW91c2Ugb3V0LlxuICAgICAgICAgICAgICAgICAgICAgICAgZDMuc2VsZWN0KG5vZGVzW2ldKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5pbnRlcnJ1cHQoXCJob3Zlcjpjb2xvdXJcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudHJhbnNpdGlvbihcImhvdmVyOmNvbG91clwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbig0MDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCB0aGlzLmdldFNlcmllc0NvbG91cihpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXNwYXRjaC5jYWxsKFwidG9vbHRpcEhpZGVcIiwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5vbihcImNsaWNrIGF1eGNsaWNrXCIsIChkLCBpLCBub2RlcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlzcGF0Y2guY2FsbChcImVsZW1lbnRDbGlja1wiLCB0aGlzLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZTogZDMuZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQ6IGQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzOiBkLl9zZXJpZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzSW5kZXg6IHNfaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy5feShkKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLm1lcmdlKGJhcnMpXG4gICAgICAgICAgICAgICAgICAgIC5pbnRlcnJ1cHQoXCJiYXI6Z3Jvd3RoXCIpICAgIC8vIEFuaW1hdGUgYmFycyBncm93aW5nLlxuICAgICAgICAgICAgICAgICAgICAudHJhbnNpdGlvbihcImJhcjpncm93dGhcIilcbiAgICAgICAgICAgICAgICAgICAgLmRlbGF5KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNhbGNCYXJHcm93dGgoc19pLCBub2Rlcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24odGhpcy5fZHVyYXRpb24pXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIChkLCBpKSA9PiB0aGlzLmdldFNlcmllc0NvbG91cihpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwid2lkdGhcIiwgZCA9PiB4KGQuX3kpKTtcblxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIExhYmVscyBsb2FkZWQgYWZ0ZXIgb3VyIGZpcnN0IGJhciBncm93cy5cbiAgICAgICAgaWYgKHRoaXMuX3Nob3dfbGFiZWxzKSB7XG4gICAgICAgICAgICBzdmcudHJhbnNpdGlvbihcImJhcjpncm93dGhcIilcbiAgICAgICAgICAgICAgICAub24oXCJlbmRcIiwgKGQsIGksIG5vZGVzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpIDwgbm9kZXMubGVuZ3RoIC0gMSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckxhYmVscyhzdmcsIGRhdGEsIHgsIHlHcm91cCwgeSk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBEcmF3IHRoZSBkYXRhIGF4aXMgZGF0YSBsYWJlbC5cblxuICAgICAgICBpZiAodGhpcy5fZGF0YUF4aXNMYWJlbCkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJEYXRhQXhpc0xhYmVsKHdpZHRoLCBtYXJnaW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIFNldCB0aGUgYmFja2dyb3VuZCBjb2xvdXJcblxuICAgICAgICBkMy5zZWxlY3QodGhpcy5fZWxlbWVudCkuc2VsZWN0KFwiLmJhY2tncm91bmRcIikucmVtb3ZlKCk7XG4gICAgICAgIGlmICh0aGlzLl9iYWNrZ3JvdW5kQ29sb3VyKSB7XG4gICAgICAgICAgICBkMy5zZWxlY3QodGhpcy5fZWxlbWVudCkuc2VsZWN0KFwic3ZnXCIpXG4gICAgICAgICAgICAgICAgLmFwcGVuZChcInJlY3RcIilcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImJhY2tncm91bmRcIilcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCBcIjEwMCVcIilcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgXCIxMDAlXCIpXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZShcImZpbGxcIiwgdGhpcy5fYmFja2dyb3VuZENvbG91cilcbiAgICAgICAgICAgICAgICAubG93ZXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIGFkZCB0aGUgWSBncmlkbGluZXNcbiAgICAgICAgc3ZnLmNhbGwodGhpcy5ncmlkLCBoZWlnaHQsIGQzLmF4aXNCb3R0b20oeCkudGlja3MoNSkpO1xuXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIGF4ZXNcbiAgICAgICAgc3ZnLmNhbGwodGhpcy5sYWJlbEF4aXMsIGQzLmF4aXNMZWZ0KHkpLnRpY2tTaXplKDApLnRpY2tQYWRkaW5nKDUpLnRpY2tGb3JtYXQodGhpcy5feEF4aXNUaWNrRm9ybWF0KSk7XG4gICAgICAgIHN2Zy5jYWxsKHRoaXMuZGF0YUF4aXMsIGhlaWdodCwgZDMuYXhpc0JvdHRvbSh4KS50aWNrcyg1KS50aWNrRm9ybWF0KHRoaXMuX3RpY2tGb3JtYXQpKTtcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLypcbiAgICAgKiBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIHR3byBmdW5jdGlvbnMsICNzaG93KCkgYW5kICNoaWRlKCksXG4gICAgICogdG8gc2hvdyBhbmQgaGlkZSB0aGUgbGFiZWxzLlxuICAgICAqL1xuICAgIGxhYmVscygpIHtcbiAgICAgICAgcmV0dXJuIHtcblxuICAgICAgICAgICAgc2hvdzogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9lbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzZWxlY3Rpb24gPSB0aGlzLl9lbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHRoaXMuZ2V0VHJhbnNmb3JtZWREYXRhKCksXG4gICAgICAgICAgICAgICAgICAgICAgICB4c2NhbGUgPSB0aGlzLl94c2NhbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB5Z3JvdXAgPSB0aGlzLl95Z3JvdXBzY2FsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHlzY2FsZSA9IHRoaXMuX3lzY2FsZTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uKSBzZWxlY3Rpb24gPSBkMy5zZWxlY3QodGhpcy5fZWxlbWVudCkuc2VsZWN0KFwic3ZnXCIpLnNlbGVjdChcImdcIik7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2VsZWN0aW9uLmVtcHR5KCkgJiYgZGF0YSAmJiB4c2NhbGUgJiYgeXNjYWxlICYmIHlncm91cCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGxhYmVscyA9IHNlbGVjdGlvbi5zZWxlY3QoJy5jaGFydC1sYWJlbHMnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbGFiZWxzLmVtcHR5KCkpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVscy5yZW1vdmUoKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJMYWJlbHMoc2VsZWN0aW9uLCBkYXRhLCB4c2NhbGUsIHlncm91cCwgeXNjYWxlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGhpZGU6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBkMy5zZWxlY3QodGhpcy5fZWxlbWVudClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZWxlY3QoJy5jaGFydC1sYWJlbHMnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmludGVycnVwdChcImxhYmVsc1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmludGVycnVwdChcImxhYmVsczpmYWRlXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAudHJhbnNpdGlvbihcImxhYmVsczpmYWRlXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDApXG4gICAgICAgICAgICAgICAgICAgICAgICAub24oXCJlbmRcIiwgKGQsIGksIG5vZGVzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZDMuc2VsZWN0KG5vZGVzW2ldKS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHJlbmRlckxhYmVscyhzZWxlY3Rpb24sIGRhdGEsIHhzY2FsZSwgeWdyb3VwLCB5c2NhbGUsIGFuaW1hdGUpIHtcbiAgICAgICAgYW5pbWF0ZSA9IGFuaW1hdGUgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBhbmltYXRlO1xuICAgICAgICBzZWxlY3Rpb24uc2VsZWN0QWxsKFwiLmNoYXJ0LWxhYmVsc1wiKS5yZW1vdmUoKTtcblxuICAgICAgICBsZXQgbGFiZWxzID0gc2VsZWN0aW9uLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJjaGFydC1sYWJlbHNcIilcbiAgICAgICAgICAgIC5zZWxlY3RBbGwoXCIubGFiZWwtZ3JvdXBcIilcbiAgICAgICAgICAgIC5kYXRhKGRhdGEpO1xuXG4gICAgICAgIGxldCBmb250U2l6ZSA9IDEyOyAgICAvLyBPdXIgaW5pdGlhbCBmb250IHNpemUuXG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IDU7ICAgICAvLyBCdWZmZXIgc3BhY2UgYmV0d2VlbiB3b3JkcyBhbmQgdGhlIHRvcCBvZiBhIGJhci5cblxuICAgICAgICBsYWJlbHMuZW50ZXIoKS5lYWNoKChzZXJpZXMsIHNfaSwgc19ub2RlcykgPT4ge1xuICAgICAgICAgICAgbGV0IGdyb3VwID0gZDMuc2VsZWN0KHNfbm9kZXNbc19pXSlcbiAgICAgICAgICAgICAgICAuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJsYWJlbC1ncm91cFwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIGQgPT4gXCJ0cmFuc2xhdGUoMCxcIiArIHlzY2FsZShkLmtleSkgKyBcIilcIilcbiAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKFwiLmNoYXJ0LWxhYmVsXCIpXG4gICAgICAgICAgICAgICAgLmRhdGEoc2VyaWVzLmRhdGEpXG4gICAgICAgICAgICAgICAgLmVudGVyKClcbiAgICAgICAgICAgICAgICAuZWFjaCgoZCwgaSwgbm9kZXMpID0+IHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBXYW50IHRvIGZpZ3VyZSBvdXQgaWYgdGhlIGxhYmVsIGlzIHRvbyBkYXJrIC8gbGlnaHQgZm9yIHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyBiYXIuXG4gICAgICAgICAgICAgICAgICAgIGxldCBpbnZlcnRlZENvbG9yID0gZDMuaGNsKHRoaXMuZ2V0U2VyaWVzQ29sb3VyKGkpKTtcbiAgICAgICAgICAgICAgICAgICAgaW52ZXJ0ZWRDb2xvci5sICs9IE1hdGgubWluKGludmVydGVkQ29sb3IubCArIDUwLCAxMDApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgaW52ZXJ0ID0gZDMuaGNsKHRoaXMuZ2V0U2VyaWVzQ29sb3VyKGkpKS5sIDwgNjA7XG5cbiAgICAgICAgICAgICAgICAgICAgbGV0IHhwb3MgPSB4c2NhbGUoZC5feSk7XG5cbiAgICAgICAgICAgICAgICAgICAgbGV0IHRleHQgPSBkMy5zZWxlY3Qobm9kZXNbaV0pXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRleHQodGhpcy5fbGFiZWxGb3JtYXQoZC5feSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImNoYXJ0LWxhYmVsXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIHhwb3MgKyBidWZmZXIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJkeFwiLCBhbmltYXRlID8gLTE1IDogMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwicG9pbnRlci1ldmVudHNcIiwgXCJub25lXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwiZm9udC1zaXplXCIsIGZvbnRTaXplICsgXCJweFwiKTtcblxuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJiID0gdGV4dC5ub2RlKCkuZ2V0QkJveCgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvdmVyc2l6ZSA9IHhwb3MgKyBiYi53aWR0aCArIGJ1ZmZlciA+IHhzY2FsZS5yYW5nZSgpWzFdO1xuXG4gICAgICAgICAgICAgICAgICAgIHRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwieVwiLCB5Z3JvdXAoZC5fa2V5KSArIGZvbnRTaXplIC8gMiArIHlncm91cC5iYW5kd2lkdGgoKSAvIDIpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcInhcIiwgb3ZlcnNpemUgPyB4cG9zIC0gYnVmZmVyIC0gYmIud2lkdGggOiB4cG9zICsgYnVmZmVyKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBvdmVyc2l6ZSAmJiBpbnZlcnQgPyBpbnZlcnRlZENvbG9yLnRvU3RyaW5nKCkgOiBjb2xvdXJzLmVpZ2h0ZWVuLmRhcmtHcmV5KTtcblxuICAgICAgICAgICAgICAgICAgICB0ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICAudHJhbnNpdGlvbihcImxhYmVsc1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmRlbGF5KCgpID0+IGFuaW1hdGUgPyB0aGlzLmNhbGNCYXJHcm93dGgoc19pLCBzX25vZGVzLmxlbmd0aCkgOiAwKSAvLyBEZWxheSBpbiBsb2Nrc3RlcCB3aXRoIGJhciBncm93dGguXG4gICAgICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24odGhpcy5fZHVyYXRpb24pXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcImR4XCIsIDApXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDEpXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgfSk7XG5cbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgcmVuZGVyRGF0YUF4aXNMYWJlbCh3aWR0aCwgbWFyZ2lucykge1xuICAgICAgICBsZXQgc3ZnID0gZDMuc2VsZWN0KHRoaXMuX2VsZW1lbnQpLnNlbGVjdCgnc3ZnJyk7XG4gICAgICAgIHN2Zy5zZWxlY3RBbGwoXCIuZGF0YS1sYWJlbHNcIikucmVtb3ZlKCk7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9kYXRhQXhpc0xhYmVsKSByZXR1cm47XG4gICAgICAgIGxldCB0ZXh0ID0gdGhpcy5fZGF0YUF4aXNMYWJlbDtcbiAgICAgICAgaWYgKHRleHQubG9uZykgdGV4dCA9IHRleHQubG9uZztcblxuICAgICAgICBsZXQgeCA9IChtYXJnaW5zLmxlZnQgKyB3aWR0aCAvIDIpO1xuXG4gICAgICAgIGxldCBsYWJlbCA9IHN2Zy5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwiZGF0YS1sYWJlbHNcIilcbiAgICAgICAgICAgIC5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgICAgICAgICAudGV4dCh0ZXh0KVxuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyB4ICsgXCIsXCIgKyAodGhpcy5faGVpZ2h0IC0gbWFyZ2lucy5ib3R0b20gKyA1MCkgKyBcIilcIilcbiAgICAgICAgICAgIC5zdHlsZShcImZpbGxcIiwgY29sb3Vycy5laWdodGVlbi5kYXJrR3JleSk7XG5cbiAgICAgICAgbGV0IHRleHRXaWR0aCA9IGxhYmVsLm5vZGUoKS5nZXRCQm94KCkud2lkdGg7XG4gICAgICAgIGlmICh0ZXh0V2lkdGggPj0gd2lkdGggJiYgdGhpcy5fZGF0YUF4aXNMYWJlbC5zaG9ydCkge1xuICAgICAgICAgICAgbGFiZWwudGV4dCh0aGlzLl9kYXRhQXhpc0xhYmVsLnNob3J0KTtcbiAgICAgICAgICAgIHRleHRXaWR0aCA9IGxhYmVsLm5vZGUoKS5nZXRCQm94KCkud2lkdGg7XG4gICAgICAgIH1cblxuICAgICAgICBsYWJlbC5hdHRyKFwiZHhcIiwgLXRleHRXaWR0aCAvIDIpO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuXG4gICAgZ3JpZChzZWxlY3Rpb24sIGhlaWdodCwgYXhpcykge1xuICAgICAgICBzZWxlY3Rpb24uc2VsZWN0KFwiLmdyaWRcIikucmVtb3ZlKCk7XG5cbiAgICAgICAgbGV0IGdyaWQgPSBzZWxlY3Rpb24uYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImdyaWRcIilcbiAgICAgICAgICAgIC5jYWxsKGF4aXNcbiAgICAgICAgICAgICAgICAudGlja1NpemUoaGVpZ2h0KVxuICAgICAgICAgICAgICAgIC50aWNrRm9ybWF0KFwiXCIpXG4gICAgICAgICAgICApO1xuXG4gICAgICAgIGdyaWQuc2VsZWN0QWxsKFwibGluZVwiKVxuICAgICAgICAgICAgLnN0eWxlKFwic3Ryb2tlXCIsIGNvbG91cnMuZWlnaHRlZW4ubGlnaHRHcmV5KTtcbiAgICAgICAgZ3JpZC5zZWxlY3RBbGwoXCIuZG9tYWluXCIpLnJlbW92ZSgpO1xuXG4gICAgICAgIGdyaWRcbiAgICAgICAgICAgIC5sb3dlcigpIC8vIEFsd2F5cyBlbnN1cmUgdGhhdCB0aGlzIGlzIGVhcmxpZXIgaW4gdGhlIGRvbS4gVGhpbmdzIG11c3QgYmUgZHJhd24gb24gdG9wIG9mIGl0LlxuICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAwKVxuICAgICAgICAgICAgLnRyYW5zaXRpb24oKVxuICAgICAgICAgICAgLmRlbGF5KDUwMClcbiAgICAgICAgICAgIC5kdXJhdGlvbig1MDApXG4gICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDEpO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBsYWJlbEF4aXMoc2VsZWN0aW9uLCBheGlzX29iamVjdCkge1xuICAgICAgICBzZWxlY3Rpb24uc2VsZWN0KFwiLmxhYmVsLWF4aXNcIikucmVtb3ZlKCk7XG4gICAgICAgIGxldCBheGlzID0gc2VsZWN0aW9uLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJsYWJlbC1heGlzXCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDApXG4gICAgICAgICAgICAuY2FsbChheGlzX29iamVjdCk7XG5cbiAgICAgICAgYXhpcy5zZWxlY3QoXCIuZG9tYWluXCIpLnJlbW92ZSgpO1xuXG4gICAgICAgIGxldCBtYXggPSAwO1xuICAgICAgICBjb25zdCBmb250U2l6ZSA9IDEyO1xuICAgICAgICBheGlzLnNlbGVjdEFsbChcInRleHRcIilcbiAgICAgICAgICAgIC5zdHlsZShcImZpbGxcIiwgY29sb3Vycy5laWdodGVlbi5kYXJrR3JleSlcbiAgICAgICAgICAgIC5ub2RlcygpXG4gICAgICAgICAgICAuZm9yRWFjaCh0ZXh0ID0+IG1heCA9IE1hdGgubWF4KG1heCwgdGV4dC5nZXRCQm94KCkud2lkdGgpKTtcblxuICAgICAgICBheGlzXG4gICAgICAgICAgICAudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAuZHVyYXRpb24oMTAwMClcbiAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMSk7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGRhdGFBeGlzKHNlbGVjdGlvbiwgaGVpZ2h0LCBheGlzX29iamVjdCkge1xuICAgICAgICBzZWxlY3Rpb24uc2VsZWN0KFwiLmRhdGEtYXhpc1wiKS5yZW1vdmUoKTtcbiAgICAgICAgbGV0IGF4aXMgPSBzZWxlY3Rpb24uYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJkYXRhLWF4aXNcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZSgwLFwiICsgaGVpZ2h0ICsgXCIpXCIpXG4gICAgICAgICAgICAuY2FsbChheGlzX29iamVjdC50aWNrU2l6ZSgwKS50aWNrUGFkZGluZygxMCkpXG4gICAgICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAwKVxuICAgICAgICAgICAgLnRyYW5zaXRpb24oKVxuICAgICAgICAgICAgLmR1cmF0aW9uKDEwMDApXG4gICAgICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAxKTtcblxuICAgICAgICBheGlzLnNlbGVjdEFsbChcInRleHRcIilcbiAgICAgICAgICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIGNvbG91cnMuZWlnaHRlZW4uZGFya0dyZXkpXG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGNhbGNCYXJHcm93dGgoaSwgbWF4KSB7XG4gICAgICAgIGlmIChtYXggPCAxMCkgcmV0dXJuIGkgKiB0aGlzLl9CQVJfR1JPV1RIIC8gMjtcbiAgICAgICAgaWYgKG1heCA8IDM1KSByZXR1cm4gaSAqIHRoaXMuX0JBUl9HUk9XVEggLyA0O1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICBnZXRTZXJpZXNDb2xvdXIoaSkge1xuICAgICAgICBpZiAoaSA8IDAgfHwgIXRoaXMuX2NvbG91cnMpIHJldHVybiBjb2xvdXJzLmVpZ2h0ZWVuLm1pZEdyZXk7XG5cbiAgICAgICAgaSA9IGkgJSB0aGlzLl9jb2xvdXJzLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbG91cnNbaV07XG4gICAgfVxuXG4gICAgZ2V0U29ydGVkRGF0YSgpIHtcbiAgICAgICAgbGV0IGRhdGEgPSB0aGlzLl9kYXRhO1xuICAgICAgICBpZiAoIWRhdGEgfHwgIWRhdGEubGVuZ3RoKSByZXR1cm4gW107XG5cbiAgICAgICAgZGF0YSA9IHRoaXMuX2RhdGEuc29ydCgobGhzLCByaHMpID0+IHtcbiAgICAgICAgICAgIGxocyA9IGxocy5rZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIHJocyA9IHJocy5rZXkudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICAgICAgaWYgKGxocyA9PT0gcmhzKSByZXR1cm4gMDtcbiAgICAgICAgICAgIGlmIChsaHMgPCByaHMpIHJldHVybiAtMTtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICBnZXRUcmFuc2Zvcm1lZERhdGEoKSB7XG4gICAgICAgIGxldCBkYXRhID0gdGhpcy5nZXRTb3J0ZWREYXRhKCk7XG4gICAgICAgIGlmICghZGF0YSB8fCAhZGF0YS5sZW5ndGgpIHJldHVybiBbXTtcblxuICAgICAgICBsZXQgcmVzdWx0cyA9IFtdO1xuXG4gICAgICAgIGNvbnN0IGdldFggPSBkID0+IHRoaXMuX3hBeGlzT3ZlcnJpZGUgPyB0aGlzLl94QXhpc092ZXJyaWRlW3RoaXMuX3goZCldIDogdGhpcy5feChkKTtcblxuICAgICAgICBkYXRhLmZvckVhY2goKHNlcmllcywgc19pKSA9PiB7XG4gICAgICAgICAgICBzZXJpZXMudmFsdWVzLmZvckVhY2goKGQsIGRfaSkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBmaWVsZCA9IHJlc3VsdHMuZmluZChidWNrZXQgPT4gYnVja2V0LmtleSA9PT0gZ2V0WChkKSk7XG4gICAgICAgICAgICAgICAgaWYgKCFmaWVsZCkge1xuICAgICAgICAgICAgICAgICAgICBmaWVsZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiBnZXRYKGQpXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChmaWVsZCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZmllbGQuZGF0YS5wdXNoKE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgICAgICAgICBfc2VyaWVzOiBzZXJpZXMsXG4gICAgICAgICAgICAgICAgICAgIF9zX2k6IHNfaSxcbiAgICAgICAgICAgICAgICAgICAgX2tleTogc2VyaWVzLmtleSxcbiAgICAgICAgICAgICAgICAgICAgX3k6IHRoaXMuX3koZClcbiAgICAgICAgICAgICAgICB9LCBkKSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG5cbiAgICBnZXRLZXlzKCkge1xuICAgICAgICBsZXQgZGF0YSA9IHRoaXMuX2RhdGE7XG4gICAgICAgIGlmICghZGF0YSB8fCAhZGF0YS5sZW5ndGgpIHJldHVybiBbXTtcblxuICAgICAgICByZXR1cm4gWy4uLm5ldyBTZXQoZGF0YS5tYXAoZCA9PiBkLmtleSkpXVxuICAgIH1cbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/BarChart.js\n");

/***/ }),

/***/ "./src/Bucket.js":
/*!***********************!*\
  !*** ./src/Bucket.js ***!
  \***********************/
/*! exports provided: DateBucket, DiscreteBucket, ContinuousBucket */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DateBucket\", function() { return DateBucket; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DiscreteBucket\", function() { return DiscreteBucket; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ContinuousBucket\", function() { return ContinuousBucket; });\n/* harmony import */ var _Statistics__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Statistics */ \"./src/Statistics.js\");\n// Copyright (C) 2013-2014, 2018 BrandsEye (PTY) LTD\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this\n// software and associated documentation files (the \"Software\"), to deal in the Software\n// without restriction, including without limitation the rights to use, copy, modify,\n//     merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following\n// conditions:\n//\n//     The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n//     INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n// CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n\nclass Bucket {\n    constructor(data) { this._data = data; }\n\n    /**\n     * Given a data point, this returns the bucket that the data point is a part of.\n     */\n    bucket(d) { return d; }\n\n    /**\n     * Given data that has had its buckets set up in each item's _key field,\n     * this consolidates the data in to a single collection of buckets.\n     */\n    consolidateBuckets(data) { return data; }\n\n}\n\n/**\n * The bucket of a Date object is just itself. We assume that\n * dates are their own buckets.\n */\nclass DateBucket extends Bucket {\n\n    // A noop: each date is its own bucket.\n    bucket(d) {\n        return d;\n    }\n\n    // A noop: our buckets are already consolidated.\n    consolidateBuckets(data) {\n        return data;\n    }\n}\n\nclass DiscreteBucket extends Bucket {\n\n    bucket(d) {\n        return d;\n    }\n\n    consolidateBuckets(data) {\n        data.forEach(bucket => {\n            const counts = {};\n            const examples = {};\n            // Count everything grouped by their keys\n            // (i.e. count individual series\n            bucket.data.forEach(d => {\n                counts[d._key] = (counts[d._key] || 0) + d._y;\n                examples[d._key] = d;\n            });\n            // Provide one summary per series, but preserve\n            // any extra data, such as colour and so on.\n            bucket.data = Object.keys(counts).map(key => {\n                const example = examples[key];\n                return Object.assign({}, example, {\n                    _y: counts[key]\n                })\n            })\n        });\n\n        return data;\n    }\n}\n\n\nclass ContinuousBucket extends Bucket {\n    // We calculate buckets based on the Freedman-Draconis\n    // inter-quartile range method.\n    constructor(data) {\n        super(data);\n        this._bucketWidth = Object(_Statistics__WEBPACK_IMPORTED_MODULE_0__[\"freedmanDiaconis\"])(data);\n    }\n\n    bucket(d) {\n        const b = Math.floor(d / this._bucketWidth);\n        return Math.ceil(b * this._bucketWidth + this._bucketWidth);\n    }\n\n    consolidateBuckets(data) {\n        data.forEach(bucket => {\n            const counts = {};\n            const examples = {};\n            // Count everything grouped by their keys\n            // (i.e. count individual series\n            bucket.data.forEach(d => {\n                counts[d._key] = (counts[d._key] || 0) + 1;\n                examples[d._key] = d;\n            });\n            // Provide one summary per series, but preserve\n            // any extra data, such as colour and so on.\n            bucket.data = Object.keys(counts).map(key => {\n                const example = examples[key];\n                return Object.assign({}, example, {\n                    _y: counts[key]\n                })\n            })\n        });\n\n        return data;\n    }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvQnVja2V0LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYjNqcy8uL3NyYy9CdWNrZXQuanM/ZTU5YSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKEMpIDIwMTMtMjAxNCwgMjAxOCBCcmFuZHNFeWUgKFBUWSkgTFREXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZiB0aGlzXG4vLyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmVcbi8vIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSxcbi8vICAgICBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvXG4vLyBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZ1xuLy8gY29uZGl0aW9uczpcbi8vXG4vLyAgICAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4vLyBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vICAgICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SIElNUExJRUQsXG4vLyAgICAgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEFcbi8vIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFRcbi8vIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRlxuLy8gQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFXG4vLyBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IHtmcmVlZG1hbkRpYWNvbmlzfSBmcm9tIFwiLi9TdGF0aXN0aWNzXCI7XG5cblxuY2xhc3MgQnVja2V0IHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhKSB7IHRoaXMuX2RhdGEgPSBkYXRhOyB9XG5cbiAgICAvKipcbiAgICAgKiBHaXZlbiBhIGRhdGEgcG9pbnQsIHRoaXMgcmV0dXJucyB0aGUgYnVja2V0IHRoYXQgdGhlIGRhdGEgcG9pbnQgaXMgYSBwYXJ0IG9mLlxuICAgICAqL1xuICAgIGJ1Y2tldChkKSB7IHJldHVybiBkOyB9XG5cbiAgICAvKipcbiAgICAgKiBHaXZlbiBkYXRhIHRoYXQgaGFzIGhhZCBpdHMgYnVja2V0cyBzZXQgdXAgaW4gZWFjaCBpdGVtJ3MgX2tleSBmaWVsZCxcbiAgICAgKiB0aGlzIGNvbnNvbGlkYXRlcyB0aGUgZGF0YSBpbiB0byBhIHNpbmdsZSBjb2xsZWN0aW9uIG9mIGJ1Y2tldHMuXG4gICAgICovXG4gICAgY29uc29saWRhdGVCdWNrZXRzKGRhdGEpIHsgcmV0dXJuIGRhdGE7IH1cblxufVxuXG4vKipcbiAqIFRoZSBidWNrZXQgb2YgYSBEYXRlIG9iamVjdCBpcyBqdXN0IGl0c2VsZi4gV2UgYXNzdW1lIHRoYXRcbiAqIGRhdGVzIGFyZSB0aGVpciBvd24gYnVja2V0cy5cbiAqL1xuZXhwb3J0IGNsYXNzIERhdGVCdWNrZXQgZXh0ZW5kcyBCdWNrZXQge1xuXG4gICAgLy8gQSBub29wOiBlYWNoIGRhdGUgaXMgaXRzIG93biBidWNrZXQuXG4gICAgYnVja2V0KGQpIHtcbiAgICAgICAgcmV0dXJuIGQ7XG4gICAgfVxuXG4gICAgLy8gQSBub29wOiBvdXIgYnVja2V0cyBhcmUgYWxyZWFkeSBjb25zb2xpZGF0ZWQuXG4gICAgY29uc29saWRhdGVCdWNrZXRzKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgRGlzY3JldGVCdWNrZXQgZXh0ZW5kcyBCdWNrZXQge1xuXG4gICAgYnVja2V0KGQpIHtcbiAgICAgICAgcmV0dXJuIGQ7XG4gICAgfVxuXG4gICAgY29uc29saWRhdGVCdWNrZXRzKGRhdGEpIHtcbiAgICAgICAgZGF0YS5mb3JFYWNoKGJ1Y2tldCA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb3VudHMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGV4YW1wbGVzID0ge307XG4gICAgICAgICAgICAvLyBDb3VudCBldmVyeXRoaW5nIGdyb3VwZWQgYnkgdGhlaXIga2V5c1xuICAgICAgICAgICAgLy8gKGkuZS4gY291bnQgaW5kaXZpZHVhbCBzZXJpZXNcbiAgICAgICAgICAgIGJ1Y2tldC5kYXRhLmZvckVhY2goZCA9PiB7XG4gICAgICAgICAgICAgICAgY291bnRzW2QuX2tleV0gPSAoY291bnRzW2QuX2tleV0gfHwgMCkgKyBkLl95O1xuICAgICAgICAgICAgICAgIGV4YW1wbGVzW2QuX2tleV0gPSBkO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBQcm92aWRlIG9uZSBzdW1tYXJ5IHBlciBzZXJpZXMsIGJ1dCBwcmVzZXJ2ZVxuICAgICAgICAgICAgLy8gYW55IGV4dHJhIGRhdGEsIHN1Y2ggYXMgY29sb3VyIGFuZCBzbyBvbi5cbiAgICAgICAgICAgIGJ1Y2tldC5kYXRhID0gT2JqZWN0LmtleXMoY291bnRzKS5tYXAoa2V5ID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBleGFtcGxlID0gZXhhbXBsZXNba2V5XTtcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgZXhhbXBsZSwge1xuICAgICAgICAgICAgICAgICAgICBfeTogY291bnRzW2tleV1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxufVxuXG5cbmV4cG9ydCBjbGFzcyBDb250aW51b3VzQnVja2V0IGV4dGVuZHMgQnVja2V0IHtcbiAgICAvLyBXZSBjYWxjdWxhdGUgYnVja2V0cyBiYXNlZCBvbiB0aGUgRnJlZWRtYW4tRHJhY29uaXNcbiAgICAvLyBpbnRlci1xdWFydGlsZSByYW5nZSBtZXRob2QuXG4gICAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgICAgICBzdXBlcihkYXRhKTtcbiAgICAgICAgdGhpcy5fYnVja2V0V2lkdGggPSBmcmVlZG1hbkRpYWNvbmlzKGRhdGEpO1xuICAgIH1cblxuICAgIGJ1Y2tldChkKSB7XG4gICAgICAgIGNvbnN0IGIgPSBNYXRoLmZsb29yKGQgLyB0aGlzLl9idWNrZXRXaWR0aCk7XG4gICAgICAgIHJldHVybiBNYXRoLmNlaWwoYiAqIHRoaXMuX2J1Y2tldFdpZHRoICsgdGhpcy5fYnVja2V0V2lkdGgpO1xuICAgIH1cblxuICAgIGNvbnNvbGlkYXRlQnVja2V0cyhkYXRhKSB7XG4gICAgICAgIGRhdGEuZm9yRWFjaChidWNrZXQgPT4ge1xuICAgICAgICAgICAgY29uc3QgY291bnRzID0ge307XG4gICAgICAgICAgICBjb25zdCBleGFtcGxlcyA9IHt9O1xuICAgICAgICAgICAgLy8gQ291bnQgZXZlcnl0aGluZyBncm91cGVkIGJ5IHRoZWlyIGtleXNcbiAgICAgICAgICAgIC8vIChpLmUuIGNvdW50IGluZGl2aWR1YWwgc2VyaWVzXG4gICAgICAgICAgICBidWNrZXQuZGF0YS5mb3JFYWNoKGQgPT4ge1xuICAgICAgICAgICAgICAgIGNvdW50c1tkLl9rZXldID0gKGNvdW50c1tkLl9rZXldIHx8IDApICsgMTtcbiAgICAgICAgICAgICAgICBleGFtcGxlc1tkLl9rZXldID0gZDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gUHJvdmlkZSBvbmUgc3VtbWFyeSBwZXIgc2VyaWVzLCBidXQgcHJlc2VydmVcbiAgICAgICAgICAgIC8vIGFueSBleHRyYSBkYXRhLCBzdWNoIGFzIGNvbG91ciBhbmQgc28gb24uXG4gICAgICAgICAgICBidWNrZXQuZGF0YSA9IE9iamVjdC5rZXlzKGNvdW50cykubWFwKGtleSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXhhbXBsZSA9IGV4YW1wbGVzW2tleV07XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGV4YW1wbGUsIHtcbiAgICAgICAgICAgICAgICAgICAgX3k6IGNvdW50c1trZXldXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbn0iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/Bucket.js\n");

/***/ }),

/***/ "./src/Chart.js":
/*!**********************!*\
  !*** ./src/Chart.js ***!
  \**********************/
/*! exports provided: Chart */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Chart\", function() { return Chart; });\n/* harmony import */ var _Colours__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Colours */ \"./src/Colours.js\");\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers */ \"./src/helpers.js\");\n// Copyright (C) 2013-2014, 2018 BrandsEye (PTY) LTD\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this\n// software and associated documentation files (the \"Software\"), to deal in the Software\n// without restriction, including without limitation the rights to use, copy, modify,\n//     merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following\n// conditions:\n//\n//     The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n//     INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n// CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n\n\n\nclass Chart {\n    constructor() {\n        this._x = (d) => d.x;\n        this._y = (d) => d.y;\n        this._height = 420;\n        this._width = 420;\n        this._BAR_GROWTH = 100;\n        this._duration = 300;\n        this._dispatch = d3.dispatch('elementClick', 'elementMiddleClick', 'elementRightClick',\n            'tooltipShow', 'tooltipHide');\n        this._xAxisTickFormat = this._tickFormat = this._labelFormat = d => d.toString();\n        this._colours = [ _Colours__WEBPACK_IMPORTED_MODULE_0__[\"colours\"].eighteen.midGrey, _Colours__WEBPACK_IMPORTED_MODULE_0__[\"colours\"].eighteen.lightGrey, _Colours__WEBPACK_IMPORTED_MODULE_0__[\"colours\"].eighteen.darkGrey ];\n        this._backgroundColour = \"#FFF\";\n        this._interbarProportion = null;\n    }\n\n    renderLegend(svg, data, min, width, height, getter) {\n        svg = svg || d3.select(this._element).select(\"svg\");\n        svg.selectAll(\".legend\").remove();\n        if (!this._show_legend) return 0;\n\n        min = min || 2;\n        data = data || this.getSortedData();\n        width = width || this._width;\n        height = height || this._height;\n        getter = getter || (d => d.key);\n\n        // Only if we have multiple series.\n        if (!data || data.length < min) return 0;\n\n        let maxWidth = Object(_helpers__WEBPACK_IMPORTED_MODULE_1__[\"maxBounding\"])(svg, data.map(getter)).width;\n\n        const legend = svg.append(\"g\")\n            .attr(\"class\", \"legend\");\n\n        let elements = legend.selectAll(\".legend-element\")\n            .data(data);\n\n        const position_start = 20;\n        let position = position_start;\n        let position_height = 0;\n\n        elements.enter()\n            .append(\"g\")\n            .attr(\"class\", (d, i) => \"legend-element series series-\" + i)\n            .style(\"cursor\", \"default\")\n            .each((d, i, nodes) => {\n                let element = d3.select(nodes[i]);\n\n                element.append(\"rect\")\n                    .attr(\"width\", 10)\n                    .attr(\"height\", 10)\n                    .attr(\"rx\", 2)\n                    .attr(\"ry\", 2)\n                    .attr(\"y\", -10)\n                    .style(\"fill\", () => this.getSeriesColour(i));\n\n                element.append(\"text\")\n                    .text(getter)\n                    .attr(\"dx\", 12)\n                    .style(\"font-family\", \"Open Sans, sans-serif\")\n                    .style(\"font-weight\", \"normal\")\n                    .style(\"font-size\", \"12px\")\n                    .style(\"fill\", _Colours__WEBPACK_IMPORTED_MODULE_0__[\"colours\"].eighteen.darkGrey);\n\n                element.append(\"title\")\n                    .text(getter);\n\n                element.attr(\"transform\", \"translate(\" + position + \",\" + position_height +\")\");\n                const positionDelta = maxWidth + 20; // element.node().getBBox().width + 10;\n                position += positionDelta;\n\n                if (position >= width) {\n                    position = position_start;\n                    position_height += 15;\n                    element.attr(\"transform\", \"translate(\" + position + \",\" + position_height + \")\");\n                    position += positionDelta;\n                }\n\n            })\n            .on(\"mouseover\", (d, i, nodes) => {\n                svg.selectAll(\".series:not(.series-\" + i + \")\")\n                    .interrupt(\"legend:highlight\")\n                    .transition(\"legend:highlight\")\n                    .style(\"opacity\", 0.3);\n            })\n            .on(\"mouseout\", (d, i, nodes) => {\n                svg.selectAll(\".series\")\n                    .interrupt(\"legend:highlight\")\n                    .transition(\"legend:highlight\")\n                    .style(\"opacity\", 1);\n            })\n            .style(\"opacity\", 0)\n            .transition()\n            .duration(1000)\n            .style(\"opacity\", 1);\n\n        const legendHeight = legend.node().getBBox().height;\n        legend.attr(\"transform\", \"translate(0,\" + (height - legendHeight) + \")\");\n        return legendHeight;\n    }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvQ2hhcnQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9iM2pzLy4vc3JjL0NoYXJ0LmpzPzYyYWUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChDKSAyMDEzLTIwMTQsIDIwMTggQnJhbmRzRXllIChQVFkpIExURFxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpc1xuLy8gc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlXG4vLyB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksXG4vLyAgICAgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0b1xuLy8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcbi8vIGNvbmRpdGlvbnM6XG4vL1xuLy8gICAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuLy8gY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyAgICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUiBJTVBMSUVELFxuLy8gICAgIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBXG4vLyBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUXG4vLyBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0Zcbi8vIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRVxuLy8gT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCB7Y29sb3Vyc30gZnJvbSAnLi9Db2xvdXJzJztcbmltcG9ydCB7IG1heEJvdW5kaW5nIH0gZnJvbSBcIi4vaGVscGVyc1wiO1xuXG5cblxuZXhwb3J0IGNsYXNzIENoYXJ0IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5feCA9IChkKSA9PiBkLng7XG4gICAgICAgIHRoaXMuX3kgPSAoZCkgPT4gZC55O1xuICAgICAgICB0aGlzLl9oZWlnaHQgPSA0MjA7XG4gICAgICAgIHRoaXMuX3dpZHRoID0gNDIwO1xuICAgICAgICB0aGlzLl9CQVJfR1JPV1RIID0gMTAwO1xuICAgICAgICB0aGlzLl9kdXJhdGlvbiA9IDMwMDtcbiAgICAgICAgdGhpcy5fZGlzcGF0Y2ggPSBkMy5kaXNwYXRjaCgnZWxlbWVudENsaWNrJywgJ2VsZW1lbnRNaWRkbGVDbGljaycsICdlbGVtZW50UmlnaHRDbGljaycsXG4gICAgICAgICAgICAndG9vbHRpcFNob3cnLCAndG9vbHRpcEhpZGUnKTtcbiAgICAgICAgdGhpcy5feEF4aXNUaWNrRm9ybWF0ID0gdGhpcy5fdGlja0Zvcm1hdCA9IHRoaXMuX2xhYmVsRm9ybWF0ID0gZCA9PiBkLnRvU3RyaW5nKCk7XG4gICAgICAgIHRoaXMuX2NvbG91cnMgPSBbIGNvbG91cnMuZWlnaHRlZW4ubWlkR3JleSwgY29sb3Vycy5laWdodGVlbi5saWdodEdyZXksIGNvbG91cnMuZWlnaHRlZW4uZGFya0dyZXkgXTtcbiAgICAgICAgdGhpcy5fYmFja2dyb3VuZENvbG91ciA9IFwiI0ZGRlwiO1xuICAgICAgICB0aGlzLl9pbnRlcmJhclByb3BvcnRpb24gPSBudWxsO1xuICAgIH1cblxuICAgIHJlbmRlckxlZ2VuZChzdmcsIGRhdGEsIG1pbiwgd2lkdGgsIGhlaWdodCwgZ2V0dGVyKSB7XG4gICAgICAgIHN2ZyA9IHN2ZyB8fCBkMy5zZWxlY3QodGhpcy5fZWxlbWVudCkuc2VsZWN0KFwic3ZnXCIpO1xuICAgICAgICBzdmcuc2VsZWN0QWxsKFwiLmxlZ2VuZFwiKS5yZW1vdmUoKTtcbiAgICAgICAgaWYgKCF0aGlzLl9zaG93X2xlZ2VuZCkgcmV0dXJuIDA7XG5cbiAgICAgICAgbWluID0gbWluIHx8IDI7XG4gICAgICAgIGRhdGEgPSBkYXRhIHx8IHRoaXMuZ2V0U29ydGVkRGF0YSgpO1xuICAgICAgICB3aWR0aCA9IHdpZHRoIHx8IHRoaXMuX3dpZHRoO1xuICAgICAgICBoZWlnaHQgPSBoZWlnaHQgfHwgdGhpcy5faGVpZ2h0O1xuICAgICAgICBnZXR0ZXIgPSBnZXR0ZXIgfHwgKGQgPT4gZC5rZXkpO1xuXG4gICAgICAgIC8vIE9ubHkgaWYgd2UgaGF2ZSBtdWx0aXBsZSBzZXJpZXMuXG4gICAgICAgIGlmICghZGF0YSB8fCBkYXRhLmxlbmd0aCA8IG1pbikgcmV0dXJuIDA7XG5cbiAgICAgICAgbGV0IG1heFdpZHRoID0gbWF4Qm91bmRpbmcoc3ZnLCBkYXRhLm1hcChnZXR0ZXIpKS53aWR0aDtcblxuICAgICAgICBjb25zdCBsZWdlbmQgPSBzdmcuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImxlZ2VuZFwiKTtcblxuICAgICAgICBsZXQgZWxlbWVudHMgPSBsZWdlbmQuc2VsZWN0QWxsKFwiLmxlZ2VuZC1lbGVtZW50XCIpXG4gICAgICAgICAgICAuZGF0YShkYXRhKTtcblxuICAgICAgICBjb25zdCBwb3NpdGlvbl9zdGFydCA9IDIwO1xuICAgICAgICBsZXQgcG9zaXRpb24gPSBwb3NpdGlvbl9zdGFydDtcbiAgICAgICAgbGV0IHBvc2l0aW9uX2hlaWdodCA9IDA7XG5cbiAgICAgICAgZWxlbWVudHMuZW50ZXIoKVxuICAgICAgICAgICAgLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgKGQsIGkpID0+IFwibGVnZW5kLWVsZW1lbnQgc2VyaWVzIHNlcmllcy1cIiArIGkpXG4gICAgICAgICAgICAuc3R5bGUoXCJjdXJzb3JcIiwgXCJkZWZhdWx0XCIpXG4gICAgICAgICAgICAuZWFjaCgoZCwgaSwgbm9kZXMpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgZWxlbWVudCA9IGQzLnNlbGVjdChub2Rlc1tpXSk7XG5cbiAgICAgICAgICAgICAgICBlbGVtZW50LmFwcGVuZChcInJlY3RcIilcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCAxMClcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgMTApXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFwicnhcIiwgMilcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJyeVwiLCAyKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcInlcIiwgLTEwKVxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJmaWxsXCIsICgpID0+IHRoaXMuZ2V0U2VyaWVzQ29sb3VyKGkpKTtcblxuICAgICAgICAgICAgICAgIGVsZW1lbnQuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgICAgICAgICAgICAgICAudGV4dChnZXR0ZXIpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiZHhcIiwgMTIpXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZShcImZvbnQtZmFtaWx5XCIsIFwiT3BlbiBTYW5zLCBzYW5zLXNlcmlmXCIpXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZShcImZvbnQtd2VpZ2h0XCIsIFwibm9ybWFsXCIpXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZShcImZvbnQtc2l6ZVwiLCBcIjEycHhcIilcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBjb2xvdXJzLmVpZ2h0ZWVuLmRhcmtHcmV5KTtcblxuICAgICAgICAgICAgICAgIGVsZW1lbnQuYXBwZW5kKFwidGl0bGVcIilcbiAgICAgICAgICAgICAgICAgICAgLnRleHQoZ2V0dGVyKTtcblxuICAgICAgICAgICAgICAgIGVsZW1lbnQuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIHBvc2l0aW9uICsgXCIsXCIgKyBwb3NpdGlvbl9oZWlnaHQgK1wiKVwiKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwb3NpdGlvbkRlbHRhID0gbWF4V2lkdGggKyAyMDsgLy8gZWxlbWVudC5ub2RlKCkuZ2V0QkJveCgpLndpZHRoICsgMTA7XG4gICAgICAgICAgICAgICAgcG9zaXRpb24gKz0gcG9zaXRpb25EZWx0YTtcblxuICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA+PSB3aWR0aCkge1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IHBvc2l0aW9uX3N0YXJ0O1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbl9oZWlnaHQgKz0gMTU7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIHBvc2l0aW9uICsgXCIsXCIgKyBwb3NpdGlvbl9oZWlnaHQgKyBcIilcIik7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uICs9IHBvc2l0aW9uRGVsdGE7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLm9uKFwibW91c2VvdmVyXCIsIChkLCBpLCBub2RlcykgPT4ge1xuICAgICAgICAgICAgICAgIHN2Zy5zZWxlY3RBbGwoXCIuc2VyaWVzOm5vdCguc2VyaWVzLVwiICsgaSArIFwiKVwiKVxuICAgICAgICAgICAgICAgICAgICAuaW50ZXJydXB0KFwibGVnZW5kOmhpZ2hsaWdodFwiKVxuICAgICAgICAgICAgICAgICAgICAudHJhbnNpdGlvbihcImxlZ2VuZDpoaWdobGlnaHRcIilcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAwLjMpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbihcIm1vdXNlb3V0XCIsIChkLCBpLCBub2RlcykgPT4ge1xuICAgICAgICAgICAgICAgIHN2Zy5zZWxlY3RBbGwoXCIuc2VyaWVzXCIpXG4gICAgICAgICAgICAgICAgICAgIC5pbnRlcnJ1cHQoXCJsZWdlbmQ6aGlnaGxpZ2h0XCIpXG4gICAgICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKFwibGVnZW5kOmhpZ2hsaWdodFwiKVxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDEpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMClcbiAgICAgICAgICAgIC50cmFuc2l0aW9uKClcbiAgICAgICAgICAgIC5kdXJhdGlvbigxMDAwKVxuICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAxKTtcblxuICAgICAgICBjb25zdCBsZWdlbmRIZWlnaHQgPSBsZWdlbmQubm9kZSgpLmdldEJCb3goKS5oZWlnaHQ7XG4gICAgICAgIGxlZ2VuZC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKDAsXCIgKyAoaGVpZ2h0IC0gbGVnZW5kSGVpZ2h0KSArIFwiKVwiKTtcbiAgICAgICAgcmV0dXJuIGxlZ2VuZEhlaWdodDtcbiAgICB9XG59Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/Chart.js\n");

/***/ }),

/***/ "./src/Colours.js":
/*!************************!*\
  !*** ./src/Colours.js ***!
  \************************/
/*! exports provided: colours */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"colours\", function() { return colours; });\n// Copyright (C) 2013-2014, 2018 BrandsEye (PTY) LTD\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this\n// software and associated documentation files (the \"Software\"), to deal in the Software\n// without restriction, including without limitation the rights to use, copy, modify,\n//     merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following\n// conditions:\n//\n//     The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n//     INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n// CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\nlet colours = {\n  // **brandseye.colours.scheme** is our basic colour scheme.\n    scheme: [\n        '#58B6FF',\n        '#5473BD',\n        '#DF71FC',\n        '#9856B0',\n        '#ff58a3',\n        '#D22D6F',\n        '#fc6a4b',\n        '#E53E39',\n        '#FFD658',\n        '#E8AF44',\n        '#43C278',\n        '#318F58'\n    ],\n    // And **brandseye.colours.allColours** defines a large number of colours.\n    allColours: [\n        '#f0f8ff', '#faebd7', '#00ffff', '#7fffd4', '#f0ffff', '#f5f5dc', '#ffe4c4', '#000000', '#ffebcd', '#0000ff', '#8a2be2',\n        '#a52a2a', '#deb887', '#5f9ea0', '#7fff00', '#d2691e', '#ff7f50', '#6495ed', '#fff8dc', '#dc143c', '#00ffff', '#00008b',\n        '#008b8b', '#b8860b', '#a9a9a9', '#006400', '#bdb76b', '#8b008b', '#556b2f', '#ff8c00', '#9932cc', '#8b0000', '#e9967a',\n        '#8fbc8f', '#483d8b', '#2f4f4f', '#00ced1', '#9400d3', '#ff1493', '#00bfff', '#696969', '#1e90ff', '#d19275', '#b22222',\n        '#fffaf0', '#228b22', '#ff00ff', '#dcdcdc', '#f8f8ff', '#ffd700', '#daa520', '#808080', '#008000', '#adff2f', '#f0fff0',\n        '#ff69b4', '#cd5c5c', '#4b0082', '#fffff0', '#f0e68c', '#e6e6fa', '#fff0f5', '#7cfc00', '#fffacd', '#add8e6', '#f08080',\n        '#e0ffff', '#fafad2', '#d3d3d3', '#90ee90', '#ffb6c1', '#ffa07a', '#20b2aa', '#87cefa', '#8470ff', '#778899', '#b0c4de',\n        '#ffffe0', '#00ff00', '#32cd32', '#faf0e6', '#ff00ff', '#800000', '#66cdaa', '#0000cd', '#ba55d3', '#9370d8', '#3cb371',\n        '#7b68ee', '#00fa9a', '#48d1cc', '#c71585', '#191970', '#f5fffa', '#ffe4e1', '#ffe4b5', '#ffdead', '#000080', '#fdf5e6',\n        '#808000', '#6b8e23', '#ffa500', '#ff4500', '#da70d6', '#eee8aa', '#98fb98', '#afeeee', '#d87093', '#ffefd5', '#ffdab9',\n        '#cd853f', '#ffc0cb', '#dda0dd', '#b0e0e6', '#800080', '#ff0000', '#bc8f8f', '#4169e1', '#8b4513', '#fa8072', '#f4a460',\n        '#2e8b57', '#fff5ee', '#a0522d', '#c0c0c0', '#87ceeb', '#6a5acd', '#708090', '#fffafa', '#00ff7f', '#4682b4', '#d2b48c',\n        '#008080', '#d8bfd8', '#ff6347', '#40e0d0', '#ee82ee', '#d02090', '#f5deb3', '#ffffff', '#f5f5f5', '#ffff00', '#9acd32'\n    ],\n\n    // These are the new brandseye colours for 2018, defined in reporting v.4.5.8\n    eighteen: {\n      good: \"#00c9a0\",       // Bright Green\n      series: [\n        \"#eba25d\",           // Muted orange\n        \"#9cd261\",           // Green\n        \"#958cb5\",           // Purple\n      ],\n      lightGrey: \"#e9e9e9\",  // gridlines, bars and columns, neutral sentiment\n      midGrey: \"#c0c0c0\",    // table borders, bars and columns if light grey is too lightGrey\n      darkGrey: \"#444444\",   // All text\n      sentiment: {\n        positive: \"#00b0b9\", // blue\n        neutral: \"#e9e9e9\",  // light grey\n        negative: \"#ee2737\", // Red\n        net: \"#1c1f2a\"       // Elite\n      }\n    }\n\n\n\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvQ29sb3Vycy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2IzanMvLi9zcmMvQ29sb3Vycy5qcz8yY2RhIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoQykgMjAxMy0yMDE0LCAyMDE4IEJyYW5kc0V5ZSAoUFRZKSBMVERcbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXNcbi8vIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZVxuLy8gd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LFxuLy8gICAgIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG9cbi8vIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nXG4vLyBjb25kaXRpb25zOlxuLy9cbi8vICAgICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbi8vIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gICAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1IgSU1QTElFRCxcbi8vICAgICBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQVxuLy8gUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxuLy8gSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GXG4vLyBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkVcbi8vIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5cbmV4cG9ydCBsZXQgY29sb3VycyA9IHtcbiAgLy8gKipicmFuZHNleWUuY29sb3Vycy5zY2hlbWUqKiBpcyBvdXIgYmFzaWMgY29sb3VyIHNjaGVtZS5cbiAgICBzY2hlbWU6IFtcbiAgICAgICAgJyM1OEI2RkYnLFxuICAgICAgICAnIzU0NzNCRCcsXG4gICAgICAgICcjREY3MUZDJyxcbiAgICAgICAgJyM5ODU2QjAnLFxuICAgICAgICAnI2ZmNThhMycsXG4gICAgICAgICcjRDIyRDZGJyxcbiAgICAgICAgJyNmYzZhNGInLFxuICAgICAgICAnI0U1M0UzOScsXG4gICAgICAgICcjRkZENjU4JyxcbiAgICAgICAgJyNFOEFGNDQnLFxuICAgICAgICAnIzQzQzI3OCcsXG4gICAgICAgICcjMzE4RjU4J1xuICAgIF0sXG4gICAgLy8gQW5kICoqYnJhbmRzZXllLmNvbG91cnMuYWxsQ29sb3VycyoqIGRlZmluZXMgYSBsYXJnZSBudW1iZXIgb2YgY29sb3Vycy5cbiAgICBhbGxDb2xvdXJzOiBbXG4gICAgICAgICcjZjBmOGZmJywgJyNmYWViZDcnLCAnIzAwZmZmZicsICcjN2ZmZmQ0JywgJyNmMGZmZmYnLCAnI2Y1ZjVkYycsICcjZmZlNGM0JywgJyMwMDAwMDAnLCAnI2ZmZWJjZCcsICcjMDAwMGZmJywgJyM4YTJiZTInLFxuICAgICAgICAnI2E1MmEyYScsICcjZGViODg3JywgJyM1ZjllYTAnLCAnIzdmZmYwMCcsICcjZDI2OTFlJywgJyNmZjdmNTAnLCAnIzY0OTVlZCcsICcjZmZmOGRjJywgJyNkYzE0M2MnLCAnIzAwZmZmZicsICcjMDAwMDhiJyxcbiAgICAgICAgJyMwMDhiOGInLCAnI2I4ODYwYicsICcjYTlhOWE5JywgJyMwMDY0MDAnLCAnI2JkYjc2YicsICcjOGIwMDhiJywgJyM1NTZiMmYnLCAnI2ZmOGMwMCcsICcjOTkzMmNjJywgJyM4YjAwMDAnLCAnI2U5OTY3YScsXG4gICAgICAgICcjOGZiYzhmJywgJyM0ODNkOGInLCAnIzJmNGY0ZicsICcjMDBjZWQxJywgJyM5NDAwZDMnLCAnI2ZmMTQ5MycsICcjMDBiZmZmJywgJyM2OTY5NjknLCAnIzFlOTBmZicsICcjZDE5Mjc1JywgJyNiMjIyMjInLFxuICAgICAgICAnI2ZmZmFmMCcsICcjMjI4YjIyJywgJyNmZjAwZmYnLCAnI2RjZGNkYycsICcjZjhmOGZmJywgJyNmZmQ3MDAnLCAnI2RhYTUyMCcsICcjODA4MDgwJywgJyMwMDgwMDAnLCAnI2FkZmYyZicsICcjZjBmZmYwJyxcbiAgICAgICAgJyNmZjY5YjQnLCAnI2NkNWM1YycsICcjNGIwMDgyJywgJyNmZmZmZjAnLCAnI2YwZTY4YycsICcjZTZlNmZhJywgJyNmZmYwZjUnLCAnIzdjZmMwMCcsICcjZmZmYWNkJywgJyNhZGQ4ZTYnLCAnI2YwODA4MCcsXG4gICAgICAgICcjZTBmZmZmJywgJyNmYWZhZDInLCAnI2QzZDNkMycsICcjOTBlZTkwJywgJyNmZmI2YzEnLCAnI2ZmYTA3YScsICcjMjBiMmFhJywgJyM4N2NlZmEnLCAnIzg0NzBmZicsICcjNzc4ODk5JywgJyNiMGM0ZGUnLFxuICAgICAgICAnI2ZmZmZlMCcsICcjMDBmZjAwJywgJyMzMmNkMzInLCAnI2ZhZjBlNicsICcjZmYwMGZmJywgJyM4MDAwMDAnLCAnIzY2Y2RhYScsICcjMDAwMGNkJywgJyNiYTU1ZDMnLCAnIzkzNzBkOCcsICcjM2NiMzcxJyxcbiAgICAgICAgJyM3YjY4ZWUnLCAnIzAwZmE5YScsICcjNDhkMWNjJywgJyNjNzE1ODUnLCAnIzE5MTk3MCcsICcjZjVmZmZhJywgJyNmZmU0ZTEnLCAnI2ZmZTRiNScsICcjZmZkZWFkJywgJyMwMDAwODAnLCAnI2ZkZjVlNicsXG4gICAgICAgICcjODA4MDAwJywgJyM2YjhlMjMnLCAnI2ZmYTUwMCcsICcjZmY0NTAwJywgJyNkYTcwZDYnLCAnI2VlZThhYScsICcjOThmYjk4JywgJyNhZmVlZWUnLCAnI2Q4NzA5MycsICcjZmZlZmQ1JywgJyNmZmRhYjknLFxuICAgICAgICAnI2NkODUzZicsICcjZmZjMGNiJywgJyNkZGEwZGQnLCAnI2IwZTBlNicsICcjODAwMDgwJywgJyNmZjAwMDAnLCAnI2JjOGY4ZicsICcjNDE2OWUxJywgJyM4YjQ1MTMnLCAnI2ZhODA3MicsICcjZjRhNDYwJyxcbiAgICAgICAgJyMyZThiNTcnLCAnI2ZmZjVlZScsICcjYTA1MjJkJywgJyNjMGMwYzAnLCAnIzg3Y2VlYicsICcjNmE1YWNkJywgJyM3MDgwOTAnLCAnI2ZmZmFmYScsICcjMDBmZjdmJywgJyM0NjgyYjQnLCAnI2QyYjQ4YycsXG4gICAgICAgICcjMDA4MDgwJywgJyNkOGJmZDgnLCAnI2ZmNjM0NycsICcjNDBlMGQwJywgJyNlZTgyZWUnLCAnI2QwMjA5MCcsICcjZjVkZWIzJywgJyNmZmZmZmYnLCAnI2Y1ZjVmNScsICcjZmZmZjAwJywgJyM5YWNkMzInXG4gICAgXSxcblxuICAgIC8vIFRoZXNlIGFyZSB0aGUgbmV3IGJyYW5kc2V5ZSBjb2xvdXJzIGZvciAyMDE4LCBkZWZpbmVkIGluIHJlcG9ydGluZyB2LjQuNS44XG4gICAgZWlnaHRlZW46IHtcbiAgICAgIGdvb2Q6IFwiIzAwYzlhMFwiLCAgICAgICAvLyBCcmlnaHQgR3JlZW5cbiAgICAgIHNlcmllczogW1xuICAgICAgICBcIiNlYmEyNWRcIiwgICAgICAgICAgIC8vIE11dGVkIG9yYW5nZVxuICAgICAgICBcIiM5Y2QyNjFcIiwgICAgICAgICAgIC8vIEdyZWVuXG4gICAgICAgIFwiIzk1OGNiNVwiLCAgICAgICAgICAgLy8gUHVycGxlXG4gICAgICBdLFxuICAgICAgbGlnaHRHcmV5OiBcIiNlOWU5ZTlcIiwgIC8vIGdyaWRsaW5lcywgYmFycyBhbmQgY29sdW1ucywgbmV1dHJhbCBzZW50aW1lbnRcbiAgICAgIG1pZEdyZXk6IFwiI2MwYzBjMFwiLCAgICAvLyB0YWJsZSBib3JkZXJzLCBiYXJzIGFuZCBjb2x1bW5zIGlmIGxpZ2h0IGdyZXkgaXMgdG9vIGxpZ2h0R3JleVxuICAgICAgZGFya0dyZXk6IFwiIzQ0NDQ0NFwiLCAgIC8vIEFsbCB0ZXh0XG4gICAgICBzZW50aW1lbnQ6IHtcbiAgICAgICAgcG9zaXRpdmU6IFwiIzAwYjBiOVwiLCAvLyBibHVlXG4gICAgICAgIG5ldXRyYWw6IFwiI2U5ZTllOVwiLCAgLy8gbGlnaHQgZ3JleVxuICAgICAgICBuZWdhdGl2ZTogXCIjZWUyNzM3XCIsIC8vIFJlZFxuICAgICAgICBuZXQ6IFwiIzFjMWYyYVwiICAgICAgIC8vIEVsaXRlXG4gICAgICB9XG4gICAgfVxuXG5cblxufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/Colours.js\n");

/***/ }),

/***/ "./src/ColumnChart.js":
/*!****************************!*\
  !*** ./src/ColumnChart.js ***!
  \****************************/
/*! exports provided: ColumnChart */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ColumnChart\", function() { return ColumnChart; });\n/* harmony import */ var _Colours__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Colours */ \"./src/Colours.js\");\n/* harmony import */ var _Chart__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Chart */ \"./src/Chart.js\");\n// Copyright (C) 2013-2014, 2018 BrandsEye (PTY) LTD\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this\n// software and associated documentation files (the \"Software\"), to deal in the Software\n// without restriction, including without limitation the rights to use, copy, modify,\n//     merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following\n// conditions:\n//\n//     The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n//     INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n// CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n\n\nclass ColumnChart extends _Chart__WEBPACK_IMPORTED_MODULE_1__[\"Chart\"] {\n\n    //------------------------------------------------------\n\n    data(data) {\n        if (!arguments.length) return this._data;\n        if (data && data[0].key === undefined) {\n            data = [\n                {\n                    key: \"series 1\",\n                    values: data\n                }\n            ];\n        }\n        this._data = data;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    element(element) {\n        if (!arguments.length) return this._element;\n        this._element = element;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    showLabels(show) {\n        if (!arguments.length) return this._show_labels;\n        this._show_labels = show;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    // todo dispatch\n    showLegend(show) {\n        if (!arguments.length) return this._show_legend;\n        this._show_legend = show;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    x(x) {\n        if (!arguments.length) return this._x;\n        this._x = x;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    y(y) {\n        if (!arguments.length) return this._y;\n        this._y = y;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    width(width) {\n        if (!arguments.length) return this._width;\n        this._width = width;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    height(height) {\n        if (!arguments.length) return this._height;\n        this._height = height;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    colours(colours) {\n        if (!arguments.length) return this._colours;\n        this._colours = colours;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    backgroundColour(colour) {\n        if (!arguments.length) return this._backgroundColour;\n        this._backgroundColour = colour || \"#FFF\"; // never set it to null.\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    tickFormat(format) {\n        if (!arguments.length) return this._tickFormat;\n        this._tickFormat = format;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    xAxisTickFormat(format) {\n        if (!arguments.length) return this._xAxisTickFormat;\n        this._xAxisTickFormat = format || (d => d.toString());\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    labelFormat(format) {\n        if (!arguments.length) return this._labelFormat;\n        this._labelFormat = format || (d => d.toString());\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    // todo missing\n    labelCompression(compression) {\n        if (!arguments.length) return this._compression;\n        this._compression = compression;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    //todo missing\n    dataAxisLabel(label) {\n        if (!arguments.length) return this._dataAxisLabel;\n        this._dataAxisLabel = label;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    tooltip(tooltip) {\n        if (!arguments.length) return this._tooltip;\n        this._tooltip = tooltip;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    forceY(force) {\n        if (!arguments.length) return this._forceY;\n        this._forceY = force;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n// todo missing\n    duration(duration) {\n        if (!arguments.length) return this._duration;\n        this._duration = duration;\n        return this;\n    }\n\n// todo missing\n    coarseness(coarseness) {\n        if (!arguments.length) return this._coarseness;\n        this._coarseness = coarseness;\n        return this;\n    }\n\n    // todo missing\n    padding(padding) {\n        if (!arguments.length) return this._padding;\n        this._padding = padding;\n        return this;\n    }\n\n    // todo missing\n    xAxisTooltips(tooltips) {\n        if (!arguments.length) return this._xAxisTooltips;\n        this._xAxisTooltips = tooltips;\n        return this;\n    }\n\n    xAxisOverride(override) {\n        if (!arguments.length) return this._xAxisOverride;\n        this._xAxisOverride = override;\n        return this;\n    }\n\n    interbarProportion(proportion) {\n        if (!arguments.length) return this._interbarProportion;\n        this._interbarProportion = proportion;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    dispatch() {\n        return this._dispatch;\n    }\n\n    //------------------------------------------------------\n\n    render() {\n        if (!this._element) throw new Error(\"No element set for ColumnChart. See #element()\");\n        if (!this._data) {\n            console.warn(\"No data set for ColumnChart. See #data()\");\n            return;\n        }\n\n        const data = this.getTransformedData();\n        const keys = this.getKeys();\n\n        //------------------------------------------------\n        // Set up the SVG area\n\n        let topLevel = d3.select(this._element).select(\"svg\");\n        if (topLevel.empty()) {\n            topLevel = d3.select(this._element).append(\"svg\");\n        }\n\n        topLevel\n            .style(\"width\", this._width + \"px\")\n            .style(\"height\", this._height + \"px\");\n\n\n        // ---------------------------------\n        // Layout the showLegend.\n        //\n        // We do this now because we need to know how much space the legend\n        // takes up in order to finish calculating the margins.\n\n        const legendHeight = this.renderLegend();\n\n        //----------------------------------\n        // Calculate margins.\n\n        const margin = {top: 20, right: 20, bottom: 40, left: 40};\n        margin.bottom += legendHeight ? legendHeight + 20 : 0;\n\n        if (this._dataAxisLabel) margin.left += 20 + 12;\n        if (data) {\n            let maxLabelLength = 0;\n            data.forEach(d => {\n                d.data.forEach(d => {\n                    let length = this._xAxisTickFormat(this._x(d)).length;\n                    if (length > maxLabelLength) maxLabelLength = length;\n                })\n            });\n            margin.bottom += maxLabelLength * 2 + 10;    // space for axes labels.\n        }\n\n        const width = this._width - margin.left - margin.right,\n            height = this._height - margin.top - margin.bottom;\n\n        //----------------------------------\n        // Calculate scales and so on.\n\n        const x = d3.scaleBand()\n            .rangeRound([0, width])\n            .padding(this._interbarProportion !== null ? this._interbarProportion : (this._data.length > 1 ? 0.08 : 0.1));\n\n        const xGroup = d3.scaleBand()\n            .padding(0);\n\n        const y = d3.scaleLinear()\n            .rangeRound([height, 0])\n            .nice();\n        this._xscale = x;\n        this._xgroupscale = xGroup;\n        this._yscale = y;\n\n        // Scale the range of the data in the domains\n        x.domain(data.map(d => d.key));\n        xGroup.rangeRound([0, x.bandwidth()]).domain(keys);\n        y.domain([0, d3.max(data, d => d3.max(d.data, d => d._y))]);\n\n        //------------------------------\n\n        let svg = topLevel.select('.main-group');\n\n        if (svg.empty()) {\n            svg = topLevel\n                .append(\"g\")\n                .attr(\"class\", \"main-group\");\n        }\n\n        svg.attr(\"transform\", \"translate(\" + margin.left + \",\" + margin.top + \")\");\n\n        //---------------------------------\n        // Get rid of current labels.\n        svg.select(\".chart-labels\")\n            .remove();\n\n        //---------------------------------\n        // append the rectangles for the bar chart\n        let groups = svg.select(\".bars\").selectAll('.group');\n\n        if (groups.empty()) {\n            groups = svg\n                .append(\"g\")\n                .attr(\"class\", \"bars\")\n                .selectAll(\".group\");\n        }\n\n        svg.select(\".bars\")\n            .attr(\"transform\", \"translate(0, \" + height + \"), scale(1, -1)\")\n\n        groups = groups.data(data);\n\n        groups.exit().remove();\n\n        // Adding new groups, and hence adding new bars to those groups.\n        groups.enter()\n            .append(\"g\")\n            .attr(\"class\", \"group\")\n            .attr(\"transform\", d => \"translate(\" + x(d.key) + \",0)\")\n            .attr(\"width\", x.bandwidth())\n            .attr(\"height\", \"100%\")\n            .merge(groups)\n            .interrupt(\"groups:move\")\n            .transition(\"groups:move\")\n            .attr(\"transform\", d => \"translate(\" + x(d.key) + \",0)\")\n            .attr(\"width\", x.bandwidth())\n            .each((s_d, s_i, nodes) => {\n                let group = d3.select(nodes[s_i])\n\n                let bars = group.selectAll(\".bar\")\n                    .data(s_d.data);\n\n                bars.exit().remove();\n\n                bars.interrupt(\"bar:move\")     // Animate the bars to their new position.\n                    .transition(\"bar:move\")\n                    .attr(\"width\", xGroup.bandwidth())\n                    .attr(\"x\", d => xGroup(d._key))\n                    .attr(\"y\", 0);\n\n                bars.enter()\n                    .append(\"rect\")\n                    .attr(\"class\", (d, i) => \"bar series series-\" + i)\n                    .attr(\"x\", d => xGroup(d._key))\n                    .attr(\"y\", 0)\n                    .attr(\"width\", xGroup.bandwidth())\n                    .attr(\"height\", 0)\n                    .style(\"fill\", (d, i) => this.getSeriesColour(i))\n                    .style(\"cursor\", \"pointer\")\n                    .on(\"mouseover\", (d, i, nodes) => { // Darken the bar on mouse over\n                        d3.select(nodes[i])\n                            .interrupt(\"hover:colour\")\n                            .transition(\"hover:colour\")\n                            .duration(400)\n                            .style(\"fill\", d3.hcl(this.getSeriesColour(i)).darker())\n                        this._dispatch.call(\"tooltipShow\", this, {\n                            e: d3.event,\n                            point: d,\n                            series: s_d,\n                            seriesIndex: s_i,\n                            value: d._y\n                        })\n                    })\n                    .on(\"mouseout\", (d, i, nodes) => { // bar is regular colour on mouse out.\n                        d3.select(nodes[i])\n                            .interrupt(\"hover:colour\")\n                            .transition(\"hover:colour\")\n                            .duration(400)\n                            .style(\"fill\", this.getSeriesColour(i));\n                        this._dispatch.call(\"tooltipHide\", this);\n                    })\n                    .on(\"click auxclick\", (d, i, nodes) => {\n                        this._dispatch.call(\"elementClick\", this, {\n                            e: d3.event,\n                            point: d,\n                            series: d._series,\n                            seriesIndex: s_i,\n                            value: this._y(d)\n                        })\n                    })\n                    .merge(bars)\n                    .interrupt(\"bar:growth\")    // Animate bars growing.\n                    .transition(\"bar:growth\")\n                    .delay((d) => {\n                        return this.calcBarGrowth(s_i, nodes.length);\n                    })\n                    .duration(this._duration)\n                    .style(\"fill\", (d, i) => this.getSeriesColour(i))\n                    .attr(\"height\", d => height - y(d._y));\n\n            })\n\n        // ---------------------------------\n        // Labels loaded after our first bar grows.\n        if (this._show_labels) {\n            svg.transition(\"bar:growth\")\n                .on(\"end\", (d, i, nodes) => {\n                    if (i < nodes.length - 1) return;\n                    this.renderLabels(svg, data, x, xGroup, y);\n                })\n        }\n\n        // ---------------------------------\n        // Draw the y axis data label.\n\n        if (this._dataAxisLabel) {\n            this.renderDataAxisLabel(height, margin);\n        }\n\n        // ---------------------------------\n        // Set the background colour\n\n        d3.select(this._element).select(\".background\").remove();\n        if (this._backgroundColour) {\n            d3.select(this._element).select(\"svg\")\n                .append(\"rect\")\n                .attr(\"class\", \"background\")\n                .attr(\"width\", \"100%\")\n                .attr(\"height\", \"100%\")\n                .style(\"fill\", this._backgroundColour)\n                .lower();\n        }\n\n        //---------------------------------\n        // add the Y gridlines\n        svg.call(this.grid, width, d3.axisLeft(y).ticks(5));\n\n        //---------------------------------\n        // axes\n        svg.call(this.xaxis, height, x.bandwidth(), d3.axisBottom(x).tickSize(0).tickPadding(5).tickFormat(this._xAxisTickFormat));\n        svg.call(this.yaxis, d3.axisLeft(y).ticks(5).tickFormat(this._tickFormat));\n    }\n\n    //------------------------------------------------------\n\n    /*\n     * Returns an object with two functions, #show() and #hide(),\n     * to show and hide the labels.\n     */\n    labels() {\n        return {\n\n            show: () => {\n                if (this._element) {\n                    let selection = this._element,\n                        data = this.getTransformedData(),\n                        xscale = this._xscale,\n                        xgroup = this._xgroupscale,\n                        yscale = this._yscale;\n\n                    if (selection) selection = d3.select(this._element).select(\"svg\").select(\"g\");\n                    if (!selection.empty() && data && xscale && yscale && xgroup) {\n                        let labels = selection.select('.chart-labels');\n                        if (!labels.empty()) return;\n                        labels.remove()\n                        this.renderLabels(selection, data, xscale, xgroup, yscale, false);\n                    }\n                }\n\n            },\n\n            hide: () => {\n                if (this._element) {\n                    d3.select(this._element)\n                        .select('.chart-labels')\n                        .interrupt(\"labels\")\n                        .interrupt(\"labels:fade\")\n                        .transition(\"labels:fade\")\n                        .style(\"opacity\", 0)\n                        .on(\"end\", (d, i, nodes) => {\n                            d3.select(nodes[i]).remove();\n                        })\n                }\n            }\n        }\n    }\n\n    //------------------------------------------------------\n\n    renderLabels(selection, data, xscale, xgroup, yscale, animate) {\n        animate = animate === undefined ? true : animate;\n        selection.selectAll(\".chart-labels\").remove();\n\n        let labels = selection.append(\"g\")\n            .attr(\"class\", \"chart-labels\")\n            // .selectAll(\".chart-label\")\n            .selectAll(\".label-group\")\n            .data(data)\n\n        let maxWidth = 0;     // For calculating the max width of text.\n        let fontSize = 12;    // Our initial font size.\n        const buffer = 5;     // Buffer space between words and the top of a bar.\n        const calcDy = (ypos) => ypos < 10 ? fontSize + buffer : -buffer;\n\n        // Want to figure out if the label is too dark / light for the\n        // bar.\n        const getInvertedColor = (i) => {\n            let invertedColor = d3.hcl(this.getSeriesColour(i));\n            invertedColor.l += Math.min(invertedColor.l + 50, 100);\n            return invertedColor;\n        };\n        const shouldInvert = (i) => d3.hcl(this.getSeriesColour(i)).l < 60;\n\n        labels.enter().each((series, s_i, s_nodes) => {\n            let group = d3.select(s_nodes[s_i])\n                .append(\"g\")\n                .attr(\"class\", \"label-group\")\n                .attr(\"transform\", d => \"translate(\" + xscale(d.key) + \",0)\")\n                .selectAll(\".chart-label\")\n                .data(series.data)\n                .enter()\n                .each((d, i, nodes) => {\n                    let ypos = yscale(d._y);\n                    let dy = calcDy(ypos);\n                    let text = d3.select(nodes[i])\n                        .append(\"text\")\n                        .text(this._labelFormat(d._y))\n                        .attr(\"class\", \"chart-label\")\n                        .attr(\"y\", ypos)\n                        .attr(\"dx\", animate ? -15 : 0)\n                        .attr(\"dy\", dy)\n                        .style(\"opacity\", 0)\n                        .style(\"pointer-events\", \"none\")\n                        // .style(\"font-family\", \"Open Sans, sans-serif\")\n                        // .style(\"font-weight\", \"normal\")\n                        // .style(\"font-size\", fontSize + \"px\")\n                        .style(\"fill\", dy > 0 && shouldInvert(i)? getInvertedColor(i).toString() : _Colours__WEBPACK_IMPORTED_MODULE_0__[\"colours\"].eighteen.darkGrey);\n\n                    // Set the x position, which is based on width.\n                    const width = text.node().getBBox().width;\n                    maxWidth = Math.max(width, maxWidth);\n                    text\n                        .attr(\"x\", xgroup(d._key) + xgroup.bandwidth() / 2 - width / 2);\n\n                    text\n                        .transition(\"labels\")\n                        .delay(() => animate ? this.calcBarGrowth(s_i, s_nodes.length) : 0) // Delay in lockstep with bar growth.\n                        .duration(this._duration)\n                        .attr(\"dx\", 0)\n                        .style(\"opacity\", 1)\n                })\n        })\n\n\n        // Figure out if we don't have enough space to show our labels.\n        // We then want to resize, if possible.\n        if (xgroup.bandwidth() < maxWidth * 1.05) {\n            let scale = maxWidth / xgroup.bandwidth() * 1.05;\n            fontSize = Math.floor(fontSize / scale);\n\n            if (fontSize < 8) {\n                // The labels are too small.\n                labels.enter().selectAll(\"text\").remove();\n            } else {\n                labels.enter()\n                    .merge(labels)\n                    .selectAll(\"text\")\n                    .style(\"font-size\", fontSize + \"px\")\n                    .each((d, i, nodes) => {\n                        const text = d3.select(nodes[i]);\n                        const width = text.node().getBBox().width;\n                        const dy = calcDy(yscale(d._y));\n\n                        text\n                            .attr(\"x\", xgroup(d._key) + xgroup.bandwidth() / 2 - width / 2)\n                            .style(\"fill\", dy > 0 && shouldInvert(i) ? getInvertedColor(i).toString() : _Colours__WEBPACK_IMPORTED_MODULE_0__[\"colours\"].eighteen.darkGrey)\n                            .attr(\"dy\", dy);\n                    })\n            }\n        }\n    }\n\n    //------------------------------------------------------\n\n    renderDataAxisLabel(height, margins) {\n        let svg = d3.select(this._element).select('svg');\n        svg.selectAll(\".data-labels\").remove();\n\n        if (!this._dataAxisLabel) return;\n        let text = this._dataAxisLabel;\n        if (text.long) text = text.long;\n\n        let x = -(margins.top + height / 2);\n\n        let label = svg.append(\"g\")\n            .attr(\"class\", \"data-labels\")\n            .append(\"text\")\n            .text(text)\n            .attr(\"transform\", \"rotate(-90 0,0) translate(\" + x + \", 20)\")\n            // .style(\"font-family\", \"Open Sans, sans-serif\")\n            // .style(\"font-size\", \"12px\")\n            // .style(\"font-style\", \"italic\")\n            .style(\"fill\", _Colours__WEBPACK_IMPORTED_MODULE_0__[\"colours\"].eighteen.darkGrey);\n\n        let width = label.node().getBBox().width;\n        if (width >= height && this._dataAxisLabel.short) {\n            label.text(this._dataAxisLabel.short);\n            width = label.node().getBBox().width;\n        }\n\n        label.attr(\"dx\", -width / 2);\n    }\n\n    //------------------------------------------------------\n\n    grid(selection, width, axis) {\n        selection.select(\".grid\").remove();\n\n        let grid = selection.append(\"g\")\n            .attr(\"class\", \"grid\")\n            .call(axis\n                .tickSize(-width)\n                .tickFormat(\"\")\n            );\n\n        grid.selectAll(\"line\")\n            .style(\"stroke\", _Colours__WEBPACK_IMPORTED_MODULE_0__[\"colours\"].eighteen.lightGrey);\n        grid.selectAll(\".domain\").remove();\n\n        grid\n            .lower() // Always ensure that this is earlier in the dom. Things must be drawn on top of it.\n            .style(\"opacity\", 0)\n            .transition()\n            .delay(500)\n            .duration(500)\n            .style(\"opacity\", 1);\n    }\n\n    //------------------------------------------------------\n\n    xaxis(selection, height, width, xaxis) {\n        selection.select(\".x-axis\").remove();\n        let axis = selection.append(\"g\")\n            .attr(\"class\", \"x-axis\")\n            .attr(\"transform\", \"translate(0,\" + height + \")\")\n            .style(\"opacity\", 0)\n            .call(xaxis);\n\n        axis.select(\".domain\").remove();\n\n        let max = 0;\n        const fontSize = 12;\n        axis.selectAll(\"text\")\n            // .style(\"font-family\", \"Open Sans, sans-serif\")\n            // .style(\"font-size\", fontSize + \"px\")\n            .style(\"fill\", _Colours__WEBPACK_IMPORTED_MODULE_0__[\"colours\"].eighteen.darkGrey)\n            .nodes()\n            .forEach(text => max = Math.max(max, text.getBBox().width));\n\n        if (max >= width - 10) {\n            const bad = max >= width * 2;\n            const angle = bad ? -90 : -30;\n            const fontSize = width <= 13 ? 8 : 12;\n            const x = bad ? -fontSize : 0;\n            const y = bad ? 5 : 2;\n\n            axis.selectAll(\"text\")\n                .style('text-anchor', 'end')\n                .style(\"font-size\", fontSize + \"px\")\n                .attr(\"transform\", () => \"translate(\" + x + \",\" + y + \") rotate(\" + angle + \" 0,0)\")\n        }\n\n        axis\n            .transition()\n            .duration(1000)\n            .style(\"opacity\", 1);\n    }\n\n    //------------------------------------------------------\n\n    yaxis(selection, axis) {\n        selection.select(\".y-axis\").remove();\n        let x = selection.append(\"g\")\n            .attr(\"class\", \"y-axis\")\n            .call(axis.tickSize(0).tickPadding(10))\n            .style(\"opacity\", 0)\n            .transition()\n            .duration(1000)\n            .style(\"opacity\", 1);\n\n        x.selectAll(\"text\")\n            // .style(\"font-family\", \"Open Sans, sans-serif\")\n            .style(\"fill\", _Colours__WEBPACK_IMPORTED_MODULE_0__[\"colours\"].eighteen.darkGrey)\n    }\n\n    //------------------------------------------------------\n\n    calcBarGrowth(i, max) {\n        if (max < 10) return i * this._BAR_GROWTH / 2;\n        if (max < 35) return i * this._BAR_GROWTH / 4;\n        return 1;\n    }\n\n    getSeriesColour(i) {\n        if (i < 0 || !this._colours) return _Colours__WEBPACK_IMPORTED_MODULE_0__[\"colours\"].eighteen.midGrey;\n\n        i = i % this._colours.length;\n        return this._colours[i];\n    }\n\n    getSortedData() {\n        let data = this._data;\n        if (!data || !data.length) return [];\n\n        data = this._data.sort((lhs, rhs) => {\n            lhs = lhs.key.toLowerCase();\n            rhs = rhs.key.toLowerCase();\n\n            if (lhs === rhs) return 0;\n            if (lhs < rhs) return -1;\n            return 1;\n        });\n\n        return data;\n    }\n\n    getTransformedData() {\n        let data = this.getSortedData();\n        if (!data || !data.length) return [];\n\n        let results = [];\n\n        const getX = d => this._xAxisOverride ? this._xAxisOverride[this._x(d)] : this._x(d);\n\n        data.forEach((series, s_i) => {\n            series.values.forEach((d, d_i) => {\n                let field = results.find(bucket => bucket.key === getX(d));\n                if (!field) {\n                    field = {\n                        data: [],\n                        key: getX(d)\n                    };\n                    results.push(field);\n                }\n\n                field.data.push(Object.assign({\n                    _series: series,\n                    _s_i: s_i,\n                    _key: series.key,\n                    _y: this._y(d)\n                }, d));\n            })\n        });\n\n        return results;\n    }\n\n    getKeys() {\n        let data = this._data;\n        if (!data || !data.length) return [];\n\n        return [...new Set(data.map(d => d.key))]\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvQ29sdW1uQ2hhcnQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9iM2pzLy4vc3JjL0NvbHVtbkNoYXJ0LmpzPzNlNDAiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChDKSAyMDEzLTIwMTQsIDIwMTggQnJhbmRzRXllIChQVFkpIExURFxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpc1xuLy8gc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlXG4vLyB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksXG4vLyAgICAgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0b1xuLy8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcbi8vIGNvbmRpdGlvbnM6XG4vL1xuLy8gICAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuLy8gY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyAgICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUiBJTVBMSUVELFxuLy8gICAgIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBXG4vLyBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUXG4vLyBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0Zcbi8vIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRVxuLy8gT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCB7Y29sb3Vyc30gZnJvbSAnLi9Db2xvdXJzJztcbmltcG9ydCB7Q2hhcnR9IGZyb20gJy4vQ2hhcnQnO1xuXG5cbmV4cG9ydCBjbGFzcyBDb2x1bW5DaGFydCBleHRlbmRzIENoYXJ0IHtcblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBkYXRhKGRhdGEpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fZGF0YTtcbiAgICAgICAgaWYgKGRhdGEgJiYgZGF0YVswXS5rZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZGF0YSA9IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGtleTogXCJzZXJpZXMgMVwiLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZXM6IGRhdGFcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgZWxlbWVudChlbGVtZW50KSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX2VsZW1lbnQ7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgc2hvd0xhYmVscyhzaG93KSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3Nob3dfbGFiZWxzO1xuICAgICAgICB0aGlzLl9zaG93X2xhYmVscyA9IHNob3c7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvLyB0b2RvIGRpc3BhdGNoXG4gICAgc2hvd0xlZ2VuZChzaG93KSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3Nob3dfbGVnZW5kO1xuICAgICAgICB0aGlzLl9zaG93X2xlZ2VuZCA9IHNob3c7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB4KHgpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5feDtcbiAgICAgICAgdGhpcy5feCA9IHg7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB5KHkpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5feTtcbiAgICAgICAgdGhpcy5feSA9IHk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB3aWR0aCh3aWR0aCkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl93aWR0aDtcbiAgICAgICAgdGhpcy5fd2lkdGggPSB3aWR0aDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGhlaWdodChoZWlnaHQpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5faGVpZ2h0O1xuICAgICAgICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBjb2xvdXJzKGNvbG91cnMpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fY29sb3VycztcbiAgICAgICAgdGhpcy5fY29sb3VycyA9IGNvbG91cnM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBiYWNrZ3JvdW5kQ29sb3VyKGNvbG91cikge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9iYWNrZ3JvdW5kQ29sb3VyO1xuICAgICAgICB0aGlzLl9iYWNrZ3JvdW5kQ29sb3VyID0gY29sb3VyIHx8IFwiI0ZGRlwiOyAvLyBuZXZlciBzZXQgaXQgdG8gbnVsbC5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHRpY2tGb3JtYXQoZm9ybWF0KSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3RpY2tGb3JtYXQ7XG4gICAgICAgIHRoaXMuX3RpY2tGb3JtYXQgPSBmb3JtYXQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB4QXhpc1RpY2tGb3JtYXQoZm9ybWF0KSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3hBeGlzVGlja0Zvcm1hdDtcbiAgICAgICAgdGhpcy5feEF4aXNUaWNrRm9ybWF0ID0gZm9ybWF0IHx8IChkID0+IGQudG9TdHJpbmcoKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBsYWJlbEZvcm1hdChmb3JtYXQpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fbGFiZWxGb3JtYXQ7XG4gICAgICAgIHRoaXMuX2xhYmVsRm9ybWF0ID0gZm9ybWF0IHx8IChkID0+IGQudG9TdHJpbmcoKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvLyB0b2RvIG1pc3NpbmdcbiAgICBsYWJlbENvbXByZXNzaW9uKGNvbXByZXNzaW9uKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX2NvbXByZXNzaW9uO1xuICAgICAgICB0aGlzLl9jb21wcmVzc2lvbiA9IGNvbXByZXNzaW9uO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLy90b2RvIG1pc3NpbmdcbiAgICBkYXRhQXhpc0xhYmVsKGxhYmVsKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX2RhdGFBeGlzTGFiZWw7XG4gICAgICAgIHRoaXMuX2RhdGFBeGlzTGFiZWwgPSBsYWJlbDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHRvb2x0aXAodG9vbHRpcCkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl90b29sdGlwO1xuICAgICAgICB0aGlzLl90b29sdGlwID0gdG9vbHRpcDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGZvcmNlWShmb3JjZSkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9mb3JjZVk7XG4gICAgICAgIHRoaXMuX2ZvcmNlWSA9IGZvcmNlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vLyB0b2RvIG1pc3NpbmdcbiAgICBkdXJhdGlvbihkdXJhdGlvbikge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9kdXJhdGlvbjtcbiAgICAgICAgdGhpcy5fZHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4vLyB0b2RvIG1pc3NpbmdcbiAgICBjb2Fyc2VuZXNzKGNvYXJzZW5lc3MpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fY29hcnNlbmVzcztcbiAgICAgICAgdGhpcy5fY29hcnNlbmVzcyA9IGNvYXJzZW5lc3M7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIHRvZG8gbWlzc2luZ1xuICAgIHBhZGRpbmcocGFkZGluZykge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9wYWRkaW5nO1xuICAgICAgICB0aGlzLl9wYWRkaW5nID0gcGFkZGluZztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gdG9kbyBtaXNzaW5nXG4gICAgeEF4aXNUb29sdGlwcyh0b29sdGlwcykge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl94QXhpc1Rvb2x0aXBzO1xuICAgICAgICB0aGlzLl94QXhpc1Rvb2x0aXBzID0gdG9vbHRpcHM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHhBeGlzT3ZlcnJpZGUob3ZlcnJpZGUpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5feEF4aXNPdmVycmlkZTtcbiAgICAgICAgdGhpcy5feEF4aXNPdmVycmlkZSA9IG92ZXJyaWRlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpbnRlcmJhclByb3BvcnRpb24ocHJvcG9ydGlvbikge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9pbnRlcmJhclByb3BvcnRpb247XG4gICAgICAgIHRoaXMuX2ludGVyYmFyUHJvcG9ydGlvbiA9IHByb3BvcnRpb247XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBkaXNwYXRjaCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc3BhdGNoO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGlmICghdGhpcy5fZWxlbWVudCkgdGhyb3cgbmV3IEVycm9yKFwiTm8gZWxlbWVudCBzZXQgZm9yIENvbHVtbkNoYXJ0LiBTZWUgI2VsZW1lbnQoKVwiKTtcbiAgICAgICAgaWYgKCF0aGlzLl9kYXRhKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJObyBkYXRhIHNldCBmb3IgQ29sdW1uQ2hhcnQuIFNlZSAjZGF0YSgpXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMuZ2V0VHJhbnNmb3JtZWREYXRhKCk7XG4gICAgICAgIGNvbnN0IGtleXMgPSB0aGlzLmdldEtleXMoKTtcblxuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBTZXQgdXAgdGhlIFNWRyBhcmVhXG5cbiAgICAgICAgbGV0IHRvcExldmVsID0gZDMuc2VsZWN0KHRoaXMuX2VsZW1lbnQpLnNlbGVjdChcInN2Z1wiKTtcbiAgICAgICAgaWYgKHRvcExldmVsLmVtcHR5KCkpIHtcbiAgICAgICAgICAgIHRvcExldmVsID0gZDMuc2VsZWN0KHRoaXMuX2VsZW1lbnQpLmFwcGVuZChcInN2Z1wiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRvcExldmVsXG4gICAgICAgICAgICAuc3R5bGUoXCJ3aWR0aFwiLCB0aGlzLl93aWR0aCArIFwicHhcIilcbiAgICAgICAgICAgIC5zdHlsZShcImhlaWdodFwiLCB0aGlzLl9oZWlnaHQgKyBcInB4XCIpO1xuXG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIExheW91dCB0aGUgc2hvd0xlZ2VuZC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gV2UgZG8gdGhpcyBub3cgYmVjYXVzZSB3ZSBuZWVkIHRvIGtub3cgaG93IG11Y2ggc3BhY2UgdGhlIGxlZ2VuZFxuICAgICAgICAvLyB0YWtlcyB1cCBpbiBvcmRlciB0byBmaW5pc2ggY2FsY3VsYXRpbmcgdGhlIG1hcmdpbnMuXG5cbiAgICAgICAgY29uc3QgbGVnZW5kSGVpZ2h0ID0gdGhpcy5yZW5kZXJMZWdlbmQoKTtcblxuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gQ2FsY3VsYXRlIG1hcmdpbnMuXG5cbiAgICAgICAgY29uc3QgbWFyZ2luID0ge3RvcDogMjAsIHJpZ2h0OiAyMCwgYm90dG9tOiA0MCwgbGVmdDogNDB9O1xuICAgICAgICBtYXJnaW4uYm90dG9tICs9IGxlZ2VuZEhlaWdodCA/IGxlZ2VuZEhlaWdodCArIDIwIDogMDtcblxuICAgICAgICBpZiAodGhpcy5fZGF0YUF4aXNMYWJlbCkgbWFyZ2luLmxlZnQgKz0gMjAgKyAxMjtcbiAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgIGxldCBtYXhMYWJlbExlbmd0aCA9IDA7XG4gICAgICAgICAgICBkYXRhLmZvckVhY2goZCA9PiB7XG4gICAgICAgICAgICAgICAgZC5kYXRhLmZvckVhY2goZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBsZW5ndGggPSB0aGlzLl94QXhpc1RpY2tGb3JtYXQodGhpcy5feChkKSkubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGVuZ3RoID4gbWF4TGFiZWxMZW5ndGgpIG1heExhYmVsTGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG1hcmdpbi5ib3R0b20gKz0gbWF4TGFiZWxMZW5ndGggKiAyICsgMTA7ICAgIC8vIHNwYWNlIGZvciBheGVzIGxhYmVscy5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHdpZHRoID0gdGhpcy5fd2lkdGggLSBtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodCxcbiAgICAgICAgICAgIGhlaWdodCA9IHRoaXMuX2hlaWdodCAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tO1xuXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBDYWxjdWxhdGUgc2NhbGVzIGFuZCBzbyBvbi5cblxuICAgICAgICBjb25zdCB4ID0gZDMuc2NhbGVCYW5kKClcbiAgICAgICAgICAgIC5yYW5nZVJvdW5kKFswLCB3aWR0aF0pXG4gICAgICAgICAgICAucGFkZGluZyh0aGlzLl9pbnRlcmJhclByb3BvcnRpb24gIT09IG51bGwgPyB0aGlzLl9pbnRlcmJhclByb3BvcnRpb24gOiAodGhpcy5fZGF0YS5sZW5ndGggPiAxID8gMC4wOCA6IDAuMSkpO1xuXG4gICAgICAgIGNvbnN0IHhHcm91cCA9IGQzLnNjYWxlQmFuZCgpXG4gICAgICAgICAgICAucGFkZGluZygwKTtcblxuICAgICAgICBjb25zdCB5ID0gZDMuc2NhbGVMaW5lYXIoKVxuICAgICAgICAgICAgLnJhbmdlUm91bmQoW2hlaWdodCwgMF0pXG4gICAgICAgICAgICAubmljZSgpO1xuICAgICAgICB0aGlzLl94c2NhbGUgPSB4O1xuICAgICAgICB0aGlzLl94Z3JvdXBzY2FsZSA9IHhHcm91cDtcbiAgICAgICAgdGhpcy5feXNjYWxlID0geTtcblxuICAgICAgICAvLyBTY2FsZSB0aGUgcmFuZ2Ugb2YgdGhlIGRhdGEgaW4gdGhlIGRvbWFpbnNcbiAgICAgICAgeC5kb21haW4oZGF0YS5tYXAoZCA9PiBkLmtleSkpO1xuICAgICAgICB4R3JvdXAucmFuZ2VSb3VuZChbMCwgeC5iYW5kd2lkdGgoKV0pLmRvbWFpbihrZXlzKTtcbiAgICAgICAgeS5kb21haW4oWzAsIGQzLm1heChkYXRhLCBkID0+IGQzLm1heChkLmRhdGEsIGQgPT4gZC5feSkpXSk7XG5cbiAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICBsZXQgc3ZnID0gdG9wTGV2ZWwuc2VsZWN0KCcubWFpbi1ncm91cCcpO1xuXG4gICAgICAgIGlmIChzdmcuZW1wdHkoKSkge1xuICAgICAgICAgICAgc3ZnID0gdG9wTGV2ZWxcbiAgICAgICAgICAgICAgICAuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJtYWluLWdyb3VwXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3ZnLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyBtYXJnaW4ubGVmdCArIFwiLFwiICsgbWFyZ2luLnRvcCArIFwiKVwiKTtcblxuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBHZXQgcmlkIG9mIGN1cnJlbnQgbGFiZWxzLlxuICAgICAgICBzdmcuc2VsZWN0KFwiLmNoYXJ0LWxhYmVsc1wiKVxuICAgICAgICAgICAgLnJlbW92ZSgpO1xuXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIGFwcGVuZCB0aGUgcmVjdGFuZ2xlcyBmb3IgdGhlIGJhciBjaGFydFxuICAgICAgICBsZXQgZ3JvdXBzID0gc3ZnLnNlbGVjdChcIi5iYXJzXCIpLnNlbGVjdEFsbCgnLmdyb3VwJyk7XG5cbiAgICAgICAgaWYgKGdyb3Vwcy5lbXB0eSgpKSB7XG4gICAgICAgICAgICBncm91cHMgPSBzdmdcbiAgICAgICAgICAgICAgICAuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJiYXJzXCIpXG4gICAgICAgICAgICAgICAgLnNlbGVjdEFsbChcIi5ncm91cFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN2Zy5zZWxlY3QoXCIuYmFyc1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoMCwgXCIgKyBoZWlnaHQgKyBcIiksIHNjYWxlKDEsIC0xKVwiKVxuXG4gICAgICAgIGdyb3VwcyA9IGdyb3Vwcy5kYXRhKGRhdGEpO1xuXG4gICAgICAgIGdyb3Vwcy5leGl0KCkucmVtb3ZlKCk7XG5cbiAgICAgICAgLy8gQWRkaW5nIG5ldyBncm91cHMsIGFuZCBoZW5jZSBhZGRpbmcgbmV3IGJhcnMgdG8gdGhvc2UgZ3JvdXBzLlxuICAgICAgICBncm91cHMuZW50ZXIoKVxuICAgICAgICAgICAgLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJncm91cFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgZCA9PiBcInRyYW5zbGF0ZShcIiArIHgoZC5rZXkpICsgXCIsMClcIilcbiAgICAgICAgICAgIC5hdHRyKFwid2lkdGhcIiwgeC5iYW5kd2lkdGgoKSlcbiAgICAgICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIFwiMTAwJVwiKVxuICAgICAgICAgICAgLm1lcmdlKGdyb3VwcylcbiAgICAgICAgICAgIC5pbnRlcnJ1cHQoXCJncm91cHM6bW92ZVwiKVxuICAgICAgICAgICAgLnRyYW5zaXRpb24oXCJncm91cHM6bW92ZVwiKVxuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgZCA9PiBcInRyYW5zbGF0ZShcIiArIHgoZC5rZXkpICsgXCIsMClcIilcbiAgICAgICAgICAgIC5hdHRyKFwid2lkdGhcIiwgeC5iYW5kd2lkdGgoKSlcbiAgICAgICAgICAgIC5lYWNoKChzX2QsIHNfaSwgbm9kZXMpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgZ3JvdXAgPSBkMy5zZWxlY3Qobm9kZXNbc19pXSlcblxuICAgICAgICAgICAgICAgIGxldCBiYXJzID0gZ3JvdXAuc2VsZWN0QWxsKFwiLmJhclwiKVxuICAgICAgICAgICAgICAgICAgICAuZGF0YShzX2QuZGF0YSk7XG5cbiAgICAgICAgICAgICAgICBiYXJzLmV4aXQoKS5yZW1vdmUoKTtcblxuICAgICAgICAgICAgICAgIGJhcnMuaW50ZXJydXB0KFwiYmFyOm1vdmVcIikgICAgIC8vIEFuaW1hdGUgdGhlIGJhcnMgdG8gdGhlaXIgbmV3IHBvc2l0aW9uLlxuICAgICAgICAgICAgICAgICAgICAudHJhbnNpdGlvbihcImJhcjptb3ZlXCIpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFwid2lkdGhcIiwgeEdyb3VwLmJhbmR3aWR0aCgpKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcInhcIiwgZCA9PiB4R3JvdXAoZC5fa2V5KSlcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ5XCIsIDApO1xuXG4gICAgICAgICAgICAgICAgYmFycy5lbnRlcigpXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoXCJyZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgKGQsIGkpID0+IFwiYmFyIHNlcmllcyBzZXJpZXMtXCIgKyBpKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcInhcIiwgZCA9PiB4R3JvdXAoZC5fa2V5KSlcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ5XCIsIDApXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFwid2lkdGhcIiwgeEdyb3VwLmJhbmR3aWR0aCgpKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcImhlaWdodFwiLCAwKVxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIChkLCBpKSA9PiB0aGlzLmdldFNlcmllc0NvbG91cihpKSlcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwiY3Vyc29yXCIsIFwicG9pbnRlclwiKVxuICAgICAgICAgICAgICAgICAgICAub24oXCJtb3VzZW92ZXJcIiwgKGQsIGksIG5vZGVzKSA9PiB7IC8vIERhcmtlbiB0aGUgYmFyIG9uIG1vdXNlIG92ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGQzLnNlbGVjdChub2Rlc1tpXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuaW50ZXJydXB0KFwiaG92ZXI6Y29sb3VyXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRyYW5zaXRpb24oXCJob3Zlcjpjb2xvdXJcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24oNDAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcImZpbGxcIiwgZDMuaGNsKHRoaXMuZ2V0U2VyaWVzQ29sb3VyKGkpKS5kYXJrZXIoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3BhdGNoLmNhbGwoXCJ0b29sdGlwU2hvd1wiLCB0aGlzLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZTogZDMuZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQ6IGQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzOiBzX2QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzSW5kZXg6IHNfaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZC5feVxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLm9uKFwibW91c2VvdXRcIiwgKGQsIGksIG5vZGVzKSA9PiB7IC8vIGJhciBpcyByZWd1bGFyIGNvbG91ciBvbiBtb3VzZSBvdXQuXG4gICAgICAgICAgICAgICAgICAgICAgICBkMy5zZWxlY3Qobm9kZXNbaV0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmludGVycnVwdChcImhvdmVyOmNvbG91clwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKFwiaG92ZXI6Y29sb3VyXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKDQwMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIHRoaXMuZ2V0U2VyaWVzQ29sb3VyKGkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3BhdGNoLmNhbGwoXCJ0b29sdGlwSGlkZVwiLCB0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLm9uKFwiY2xpY2sgYXV4Y2xpY2tcIiwgKGQsIGksIG5vZGVzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXNwYXRjaC5jYWxsKFwiZWxlbWVudENsaWNrXCIsIHRoaXMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlOiBkMy5ldmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludDogZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXM6IGQuX3NlcmllcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXNJbmRleDogc19pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLl95KGQpXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAubWVyZ2UoYmFycylcbiAgICAgICAgICAgICAgICAgICAgLmludGVycnVwdChcImJhcjpncm93dGhcIikgICAgLy8gQW5pbWF0ZSBiYXJzIGdyb3dpbmcuXG4gICAgICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKFwiYmFyOmdyb3d0aFwiKVxuICAgICAgICAgICAgICAgICAgICAuZGVsYXkoKGQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNhbGNCYXJHcm93dGgoc19pLCBub2Rlcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24odGhpcy5fZHVyYXRpb24pXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZShcImZpbGxcIiwgKGQsIGkpID0+IHRoaXMuZ2V0U2VyaWVzQ29sb3VyKGkpKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcImhlaWdodFwiLCBkID0+IGhlaWdodCAtIHkoZC5feSkpO1xuXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBMYWJlbHMgbG9hZGVkIGFmdGVyIG91ciBmaXJzdCBiYXIgZ3Jvd3MuXG4gICAgICAgIGlmICh0aGlzLl9zaG93X2xhYmVscykge1xuICAgICAgICAgICAgc3ZnLnRyYW5zaXRpb24oXCJiYXI6Z3Jvd3RoXCIpXG4gICAgICAgICAgICAgICAgLm9uKFwiZW5kXCIsIChkLCBpLCBub2RlcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA8IG5vZGVzLmxlbmd0aCAtIDEpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJMYWJlbHMoc3ZnLCBkYXRhLCB4LCB4R3JvdXAsIHkpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gRHJhdyB0aGUgeSBheGlzIGRhdGEgbGFiZWwuXG5cbiAgICAgICAgaWYgKHRoaXMuX2RhdGFBeGlzTGFiZWwpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyRGF0YUF4aXNMYWJlbChoZWlnaHQsIG1hcmdpbik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gU2V0IHRoZSBiYWNrZ3JvdW5kIGNvbG91clxuXG4gICAgICAgIGQzLnNlbGVjdCh0aGlzLl9lbGVtZW50KS5zZWxlY3QoXCIuYmFja2dyb3VuZFwiKS5yZW1vdmUoKTtcbiAgICAgICAgaWYgKHRoaXMuX2JhY2tncm91bmRDb2xvdXIpIHtcbiAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzLl9lbGVtZW50KS5zZWxlY3QoXCJzdmdcIilcbiAgICAgICAgICAgICAgICAuYXBwZW5kKFwicmVjdFwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJiYWNrZ3JvdW5kXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCBcIjEwMCVcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcImhlaWdodFwiLCBcIjEwMCVcIilcbiAgICAgICAgICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIHRoaXMuX2JhY2tncm91bmRDb2xvdXIpXG4gICAgICAgICAgICAgICAgLmxvd2VyKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBhZGQgdGhlIFkgZ3JpZGxpbmVzXG4gICAgICAgIHN2Zy5jYWxsKHRoaXMuZ3JpZCwgd2lkdGgsIGQzLmF4aXNMZWZ0KHkpLnRpY2tzKDUpKTtcblxuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBheGVzXG4gICAgICAgIHN2Zy5jYWxsKHRoaXMueGF4aXMsIGhlaWdodCwgeC5iYW5kd2lkdGgoKSwgZDMuYXhpc0JvdHRvbSh4KS50aWNrU2l6ZSgwKS50aWNrUGFkZGluZyg1KS50aWNrRm9ybWF0KHRoaXMuX3hBeGlzVGlja0Zvcm1hdCkpO1xuICAgICAgICBzdmcuY2FsbCh0aGlzLnlheGlzLCBkMy5heGlzTGVmdCh5KS50aWNrcyg1KS50aWNrRm9ybWF0KHRoaXMuX3RpY2tGb3JtYXQpKTtcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLypcbiAgICAgKiBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIHR3byBmdW5jdGlvbnMsICNzaG93KCkgYW5kICNoaWRlKCksXG4gICAgICogdG8gc2hvdyBhbmQgaGlkZSB0aGUgbGFiZWxzLlxuICAgICAqL1xuICAgIGxhYmVscygpIHtcbiAgICAgICAgcmV0dXJuIHtcblxuICAgICAgICAgICAgc2hvdzogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9lbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzZWxlY3Rpb24gPSB0aGlzLl9lbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHRoaXMuZ2V0VHJhbnNmb3JtZWREYXRhKCksXG4gICAgICAgICAgICAgICAgICAgICAgICB4c2NhbGUgPSB0aGlzLl94c2NhbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB4Z3JvdXAgPSB0aGlzLl94Z3JvdXBzY2FsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHlzY2FsZSA9IHRoaXMuX3lzY2FsZTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uKSBzZWxlY3Rpb24gPSBkMy5zZWxlY3QodGhpcy5fZWxlbWVudCkuc2VsZWN0KFwic3ZnXCIpLnNlbGVjdChcImdcIik7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2VsZWN0aW9uLmVtcHR5KCkgJiYgZGF0YSAmJiB4c2NhbGUgJiYgeXNjYWxlICYmIHhncm91cCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGxhYmVscyA9IHNlbGVjdGlvbi5zZWxlY3QoJy5jaGFydC1sYWJlbHMnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbGFiZWxzLmVtcHR5KCkpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVscy5yZW1vdmUoKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJMYWJlbHMoc2VsZWN0aW9uLCBkYXRhLCB4c2NhbGUsIHhncm91cCwgeXNjYWxlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGhpZGU6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBkMy5zZWxlY3QodGhpcy5fZWxlbWVudClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZWxlY3QoJy5jaGFydC1sYWJlbHMnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmludGVycnVwdChcImxhYmVsc1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmludGVycnVwdChcImxhYmVsczpmYWRlXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAudHJhbnNpdGlvbihcImxhYmVsczpmYWRlXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDApXG4gICAgICAgICAgICAgICAgICAgICAgICAub24oXCJlbmRcIiwgKGQsIGksIG5vZGVzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZDMuc2VsZWN0KG5vZGVzW2ldKS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHJlbmRlckxhYmVscyhzZWxlY3Rpb24sIGRhdGEsIHhzY2FsZSwgeGdyb3VwLCB5c2NhbGUsIGFuaW1hdGUpIHtcbiAgICAgICAgYW5pbWF0ZSA9IGFuaW1hdGUgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBhbmltYXRlO1xuICAgICAgICBzZWxlY3Rpb24uc2VsZWN0QWxsKFwiLmNoYXJ0LWxhYmVsc1wiKS5yZW1vdmUoKTtcblxuICAgICAgICBsZXQgbGFiZWxzID0gc2VsZWN0aW9uLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJjaGFydC1sYWJlbHNcIilcbiAgICAgICAgICAgIC8vIC5zZWxlY3RBbGwoXCIuY2hhcnQtbGFiZWxcIilcbiAgICAgICAgICAgIC5zZWxlY3RBbGwoXCIubGFiZWwtZ3JvdXBcIilcbiAgICAgICAgICAgIC5kYXRhKGRhdGEpXG5cbiAgICAgICAgbGV0IG1heFdpZHRoID0gMDsgICAgIC8vIEZvciBjYWxjdWxhdGluZyB0aGUgbWF4IHdpZHRoIG9mIHRleHQuXG4gICAgICAgIGxldCBmb250U2l6ZSA9IDEyOyAgICAvLyBPdXIgaW5pdGlhbCBmb250IHNpemUuXG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IDU7ICAgICAvLyBCdWZmZXIgc3BhY2UgYmV0d2VlbiB3b3JkcyBhbmQgdGhlIHRvcCBvZiBhIGJhci5cbiAgICAgICAgY29uc3QgY2FsY0R5ID0gKHlwb3MpID0+IHlwb3MgPCAxMCA/IGZvbnRTaXplICsgYnVmZmVyIDogLWJ1ZmZlcjtcblxuICAgICAgICAvLyBXYW50IHRvIGZpZ3VyZSBvdXQgaWYgdGhlIGxhYmVsIGlzIHRvbyBkYXJrIC8gbGlnaHQgZm9yIHRoZVxuICAgICAgICAvLyBiYXIuXG4gICAgICAgIGNvbnN0IGdldEludmVydGVkQ29sb3IgPSAoaSkgPT4ge1xuICAgICAgICAgICAgbGV0IGludmVydGVkQ29sb3IgPSBkMy5oY2wodGhpcy5nZXRTZXJpZXNDb2xvdXIoaSkpO1xuICAgICAgICAgICAgaW52ZXJ0ZWRDb2xvci5sICs9IE1hdGgubWluKGludmVydGVkQ29sb3IubCArIDUwLCAxMDApO1xuICAgICAgICAgICAgcmV0dXJuIGludmVydGVkQ29sb3I7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHNob3VsZEludmVydCA9IChpKSA9PiBkMy5oY2wodGhpcy5nZXRTZXJpZXNDb2xvdXIoaSkpLmwgPCA2MDtcblxuICAgICAgICBsYWJlbHMuZW50ZXIoKS5lYWNoKChzZXJpZXMsIHNfaSwgc19ub2RlcykgPT4ge1xuICAgICAgICAgICAgbGV0IGdyb3VwID0gZDMuc2VsZWN0KHNfbm9kZXNbc19pXSlcbiAgICAgICAgICAgICAgICAuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJsYWJlbC1ncm91cFwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIGQgPT4gXCJ0cmFuc2xhdGUoXCIgKyB4c2NhbGUoZC5rZXkpICsgXCIsMClcIilcbiAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKFwiLmNoYXJ0LWxhYmVsXCIpXG4gICAgICAgICAgICAgICAgLmRhdGEoc2VyaWVzLmRhdGEpXG4gICAgICAgICAgICAgICAgLmVudGVyKClcbiAgICAgICAgICAgICAgICAuZWFjaCgoZCwgaSwgbm9kZXMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHlwb3MgPSB5c2NhbGUoZC5feSk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkeSA9IGNhbGNEeSh5cG9zKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRleHQgPSBkMy5zZWxlY3Qobm9kZXNbaV0pXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRleHQodGhpcy5fbGFiZWxGb3JtYXQoZC5feSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwiY2hhcnQtbGFiZWxcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwieVwiLCB5cG9zKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJkeFwiLCBhbmltYXRlID8gLTE1IDogMClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiZHlcIiwgZHkpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDApXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJwb2ludGVyLWV2ZW50c1wiLCBcIm5vbmVcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIC5zdHlsZShcImZvbnQtZmFtaWx5XCIsIFwiT3BlbiBTYW5zLCBzYW5zLXNlcmlmXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAuc3R5bGUoXCJmb250LXdlaWdodFwiLCBcIm5vcm1hbFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gLnN0eWxlKFwiZm9udC1zaXplXCIsIGZvbnRTaXplICsgXCJweFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBkeSA+IDAgJiYgc2hvdWxkSW52ZXJ0KGkpPyBnZXRJbnZlcnRlZENvbG9yKGkpLnRvU3RyaW5nKCkgOiBjb2xvdXJzLmVpZ2h0ZWVuLmRhcmtHcmV5KTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBTZXQgdGhlIHggcG9zaXRpb24sIHdoaWNoIGlzIGJhc2VkIG9uIHdpZHRoLlxuICAgICAgICAgICAgICAgICAgICBjb25zdCB3aWR0aCA9IHRleHQubm9kZSgpLmdldEJCb3goKS53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgbWF4V2lkdGggPSBNYXRoLm1heCh3aWR0aCwgbWF4V2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICB0ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcInhcIiwgeGdyb3VwKGQuX2tleSkgKyB4Z3JvdXAuYmFuZHdpZHRoKCkgLyAyIC0gd2lkdGggLyAyKTtcblxuICAgICAgICAgICAgICAgICAgICB0ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICAudHJhbnNpdGlvbihcImxhYmVsc1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmRlbGF5KCgpID0+IGFuaW1hdGUgPyB0aGlzLmNhbGNCYXJHcm93dGgoc19pLCBzX25vZGVzLmxlbmd0aCkgOiAwKSAvLyBEZWxheSBpbiBsb2Nrc3RlcCB3aXRoIGJhciBncm93dGguXG4gICAgICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24odGhpcy5fZHVyYXRpb24pXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcImR4XCIsIDApXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDEpXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgfSlcblxuXG4gICAgICAgIC8vIEZpZ3VyZSBvdXQgaWYgd2UgZG9uJ3QgaGF2ZSBlbm91Z2ggc3BhY2UgdG8gc2hvdyBvdXIgbGFiZWxzLlxuICAgICAgICAvLyBXZSB0aGVuIHdhbnQgdG8gcmVzaXplLCBpZiBwb3NzaWJsZS5cbiAgICAgICAgaWYgKHhncm91cC5iYW5kd2lkdGgoKSA8IG1heFdpZHRoICogMS4wNSkge1xuICAgICAgICAgICAgbGV0IHNjYWxlID0gbWF4V2lkdGggLyB4Z3JvdXAuYmFuZHdpZHRoKCkgKiAxLjA1O1xuICAgICAgICAgICAgZm9udFNpemUgPSBNYXRoLmZsb29yKGZvbnRTaXplIC8gc2NhbGUpO1xuXG4gICAgICAgICAgICBpZiAoZm9udFNpemUgPCA4KSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGxhYmVscyBhcmUgdG9vIHNtYWxsLlxuICAgICAgICAgICAgICAgIGxhYmVscy5lbnRlcigpLnNlbGVjdEFsbChcInRleHRcIikucmVtb3ZlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxhYmVscy5lbnRlcigpXG4gICAgICAgICAgICAgICAgICAgIC5tZXJnZShsYWJlbHMpXG4gICAgICAgICAgICAgICAgICAgIC5zZWxlY3RBbGwoXCJ0ZXh0XCIpXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZShcImZvbnQtc2l6ZVwiLCBmb250U2l6ZSArIFwicHhcIilcbiAgICAgICAgICAgICAgICAgICAgLmVhY2goKGQsIGksIG5vZGVzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXh0ID0gZDMuc2VsZWN0KG5vZGVzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gdGV4dC5ub2RlKCkuZ2V0QkJveCgpLndpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZHkgPSBjYWxjRHkoeXNjYWxlKGQuX3kpKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwieFwiLCB4Z3JvdXAoZC5fa2V5KSArIHhncm91cC5iYW5kd2lkdGgoKSAvIDIgLSB3aWR0aCAvIDIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBkeSA+IDAgJiYgc2hvdWxkSW52ZXJ0KGkpID8gZ2V0SW52ZXJ0ZWRDb2xvcihpKS50b1N0cmluZygpIDogY29sb3Vycy5laWdodGVlbi5kYXJrR3JleSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcImR5XCIsIGR5KTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICByZW5kZXJEYXRhQXhpc0xhYmVsKGhlaWdodCwgbWFyZ2lucykge1xuICAgICAgICBsZXQgc3ZnID0gZDMuc2VsZWN0KHRoaXMuX2VsZW1lbnQpLnNlbGVjdCgnc3ZnJyk7XG4gICAgICAgIHN2Zy5zZWxlY3RBbGwoXCIuZGF0YS1sYWJlbHNcIikucmVtb3ZlKCk7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9kYXRhQXhpc0xhYmVsKSByZXR1cm47XG4gICAgICAgIGxldCB0ZXh0ID0gdGhpcy5fZGF0YUF4aXNMYWJlbDtcbiAgICAgICAgaWYgKHRleHQubG9uZykgdGV4dCA9IHRleHQubG9uZztcblxuICAgICAgICBsZXQgeCA9IC0obWFyZ2lucy50b3AgKyBoZWlnaHQgLyAyKTtcblxuICAgICAgICBsZXQgbGFiZWwgPSBzdmcuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImRhdGEtbGFiZWxzXCIpXG4gICAgICAgICAgICAuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgICAgICAgLnRleHQodGV4dClcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwicm90YXRlKC05MCAwLDApIHRyYW5zbGF0ZShcIiArIHggKyBcIiwgMjApXCIpXG4gICAgICAgICAgICAvLyAuc3R5bGUoXCJmb250LWZhbWlseVwiLCBcIk9wZW4gU2Fucywgc2Fucy1zZXJpZlwiKVxuICAgICAgICAgICAgLy8gLnN0eWxlKFwiZm9udC1zaXplXCIsIFwiMTJweFwiKVxuICAgICAgICAgICAgLy8gLnN0eWxlKFwiZm9udC1zdHlsZVwiLCBcIml0YWxpY1wiKVxuICAgICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBjb2xvdXJzLmVpZ2h0ZWVuLmRhcmtHcmV5KTtcblxuICAgICAgICBsZXQgd2lkdGggPSBsYWJlbC5ub2RlKCkuZ2V0QkJveCgpLndpZHRoO1xuICAgICAgICBpZiAod2lkdGggPj0gaGVpZ2h0ICYmIHRoaXMuX2RhdGFBeGlzTGFiZWwuc2hvcnQpIHtcbiAgICAgICAgICAgIGxhYmVsLnRleHQodGhpcy5fZGF0YUF4aXNMYWJlbC5zaG9ydCk7XG4gICAgICAgICAgICB3aWR0aCA9IGxhYmVsLm5vZGUoKS5nZXRCQm94KCkud2lkdGg7XG4gICAgICAgIH1cblxuICAgICAgICBsYWJlbC5hdHRyKFwiZHhcIiwgLXdpZHRoIC8gMik7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGdyaWQoc2VsZWN0aW9uLCB3aWR0aCwgYXhpcykge1xuICAgICAgICBzZWxlY3Rpb24uc2VsZWN0KFwiLmdyaWRcIikucmVtb3ZlKCk7XG5cbiAgICAgICAgbGV0IGdyaWQgPSBzZWxlY3Rpb24uYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImdyaWRcIilcbiAgICAgICAgICAgIC5jYWxsKGF4aXNcbiAgICAgICAgICAgICAgICAudGlja1NpemUoLXdpZHRoKVxuICAgICAgICAgICAgICAgIC50aWNrRm9ybWF0KFwiXCIpXG4gICAgICAgICAgICApO1xuXG4gICAgICAgIGdyaWQuc2VsZWN0QWxsKFwibGluZVwiKVxuICAgICAgICAgICAgLnN0eWxlKFwic3Ryb2tlXCIsIGNvbG91cnMuZWlnaHRlZW4ubGlnaHRHcmV5KTtcbiAgICAgICAgZ3JpZC5zZWxlY3RBbGwoXCIuZG9tYWluXCIpLnJlbW92ZSgpO1xuXG4gICAgICAgIGdyaWRcbiAgICAgICAgICAgIC5sb3dlcigpIC8vIEFsd2F5cyBlbnN1cmUgdGhhdCB0aGlzIGlzIGVhcmxpZXIgaW4gdGhlIGRvbS4gVGhpbmdzIG11c3QgYmUgZHJhd24gb24gdG9wIG9mIGl0LlxuICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAwKVxuICAgICAgICAgICAgLnRyYW5zaXRpb24oKVxuICAgICAgICAgICAgLmRlbGF5KDUwMClcbiAgICAgICAgICAgIC5kdXJhdGlvbig1MDApXG4gICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDEpO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB4YXhpcyhzZWxlY3Rpb24sIGhlaWdodCwgd2lkdGgsIHhheGlzKSB7XG4gICAgICAgIHNlbGVjdGlvbi5zZWxlY3QoXCIueC1heGlzXCIpLnJlbW92ZSgpO1xuICAgICAgICBsZXQgYXhpcyA9IHNlbGVjdGlvbi5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwieC1heGlzXCIpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZSgwLFwiICsgaGVpZ2h0ICsgXCIpXCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDApXG4gICAgICAgICAgICAuY2FsbCh4YXhpcyk7XG5cbiAgICAgICAgYXhpcy5zZWxlY3QoXCIuZG9tYWluXCIpLnJlbW92ZSgpO1xuXG4gICAgICAgIGxldCBtYXggPSAwO1xuICAgICAgICBjb25zdCBmb250U2l6ZSA9IDEyO1xuICAgICAgICBheGlzLnNlbGVjdEFsbChcInRleHRcIilcbiAgICAgICAgICAgIC8vIC5zdHlsZShcImZvbnQtZmFtaWx5XCIsIFwiT3BlbiBTYW5zLCBzYW5zLXNlcmlmXCIpXG4gICAgICAgICAgICAvLyAuc3R5bGUoXCJmb250LXNpemVcIiwgZm9udFNpemUgKyBcInB4XCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIGNvbG91cnMuZWlnaHRlZW4uZGFya0dyZXkpXG4gICAgICAgICAgICAubm9kZXMoKVxuICAgICAgICAgICAgLmZvckVhY2godGV4dCA9PiBtYXggPSBNYXRoLm1heChtYXgsIHRleHQuZ2V0QkJveCgpLndpZHRoKSk7XG5cbiAgICAgICAgaWYgKG1heCA+PSB3aWR0aCAtIDEwKSB7XG4gICAgICAgICAgICBjb25zdCBiYWQgPSBtYXggPj0gd2lkdGggKiAyO1xuICAgICAgICAgICAgY29uc3QgYW5nbGUgPSBiYWQgPyAtOTAgOiAtMzA7XG4gICAgICAgICAgICBjb25zdCBmb250U2l6ZSA9IHdpZHRoIDw9IDEzID8gOCA6IDEyO1xuICAgICAgICAgICAgY29uc3QgeCA9IGJhZCA/IC1mb250U2l6ZSA6IDA7XG4gICAgICAgICAgICBjb25zdCB5ID0gYmFkID8gNSA6IDI7XG5cbiAgICAgICAgICAgIGF4aXMuc2VsZWN0QWxsKFwidGV4dFwiKVxuICAgICAgICAgICAgICAgIC5zdHlsZSgndGV4dC1hbmNob3InLCAnZW5kJylcbiAgICAgICAgICAgICAgICAuc3R5bGUoXCJmb250LXNpemVcIiwgZm9udFNpemUgKyBcInB4XCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgKCkgPT4gXCJ0cmFuc2xhdGUoXCIgKyB4ICsgXCIsXCIgKyB5ICsgXCIpIHJvdGF0ZShcIiArIGFuZ2xlICsgXCIgMCwwKVwiKVxuICAgICAgICB9XG5cbiAgICAgICAgYXhpc1xuICAgICAgICAgICAgLnRyYW5zaXRpb24oKVxuICAgICAgICAgICAgLmR1cmF0aW9uKDEwMDApXG4gICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDEpO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB5YXhpcyhzZWxlY3Rpb24sIGF4aXMpIHtcbiAgICAgICAgc2VsZWN0aW9uLnNlbGVjdChcIi55LWF4aXNcIikucmVtb3ZlKCk7XG4gICAgICAgIGxldCB4ID0gc2VsZWN0aW9uLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJ5LWF4aXNcIilcbiAgICAgICAgICAgIC5jYWxsKGF4aXMudGlja1NpemUoMCkudGlja1BhZGRpbmcoMTApKVxuICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAwKVxuICAgICAgICAgICAgLnRyYW5zaXRpb24oKVxuICAgICAgICAgICAgLmR1cmF0aW9uKDEwMDApXG4gICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDEpO1xuXG4gICAgICAgIHguc2VsZWN0QWxsKFwidGV4dFwiKVxuICAgICAgICAgICAgLy8gLnN0eWxlKFwiZm9udC1mYW1pbHlcIiwgXCJPcGVuIFNhbnMsIHNhbnMtc2VyaWZcIilcbiAgICAgICAgICAgIC5zdHlsZShcImZpbGxcIiwgY29sb3Vycy5laWdodGVlbi5kYXJrR3JleSlcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgY2FsY0Jhckdyb3d0aChpLCBtYXgpIHtcbiAgICAgICAgaWYgKG1heCA8IDEwKSByZXR1cm4gaSAqIHRoaXMuX0JBUl9HUk9XVEggLyAyO1xuICAgICAgICBpZiAobWF4IDwgMzUpIHJldHVybiBpICogdGhpcy5fQkFSX0dST1dUSCAvIDQ7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIGdldFNlcmllc0NvbG91cihpKSB7XG4gICAgICAgIGlmIChpIDwgMCB8fCAhdGhpcy5fY29sb3VycykgcmV0dXJuIGNvbG91cnMuZWlnaHRlZW4ubWlkR3JleTtcblxuICAgICAgICBpID0gaSAlIHRoaXMuX2NvbG91cnMubGVuZ3RoO1xuICAgICAgICByZXR1cm4gdGhpcy5fY29sb3Vyc1tpXTtcbiAgICB9XG5cbiAgICBnZXRTb3J0ZWREYXRhKCkge1xuICAgICAgICBsZXQgZGF0YSA9IHRoaXMuX2RhdGE7XG4gICAgICAgIGlmICghZGF0YSB8fCAhZGF0YS5sZW5ndGgpIHJldHVybiBbXTtcblxuICAgICAgICBkYXRhID0gdGhpcy5fZGF0YS5zb3J0KChsaHMsIHJocykgPT4ge1xuICAgICAgICAgICAgbGhzID0gbGhzLmtleS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgcmhzID0gcmhzLmtleS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgICAgICBpZiAobGhzID09PSByaHMpIHJldHVybiAwO1xuICAgICAgICAgICAgaWYgKGxocyA8IHJocykgcmV0dXJuIC0xO1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIGdldFRyYW5zZm9ybWVkRGF0YSgpIHtcbiAgICAgICAgbGV0IGRhdGEgPSB0aGlzLmdldFNvcnRlZERhdGEoKTtcbiAgICAgICAgaWYgKCFkYXRhIHx8ICFkYXRhLmxlbmd0aCkgcmV0dXJuIFtdO1xuXG4gICAgICAgIGxldCByZXN1bHRzID0gW107XG5cbiAgICAgICAgY29uc3QgZ2V0WCA9IGQgPT4gdGhpcy5feEF4aXNPdmVycmlkZSA/IHRoaXMuX3hBeGlzT3ZlcnJpZGVbdGhpcy5feChkKV0gOiB0aGlzLl94KGQpO1xuXG4gICAgICAgIGRhdGEuZm9yRWFjaCgoc2VyaWVzLCBzX2kpID0+IHtcbiAgICAgICAgICAgIHNlcmllcy52YWx1ZXMuZm9yRWFjaCgoZCwgZF9pKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGZpZWxkID0gcmVzdWx0cy5maW5kKGJ1Y2tldCA9PiBidWNrZXQua2V5ID09PSBnZXRYKGQpKTtcbiAgICAgICAgICAgICAgICBpZiAoIWZpZWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6IGdldFgoZClcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGZpZWxkKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmaWVsZC5kYXRhLnB1c2goT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICAgICAgICAgIF9zZXJpZXM6IHNlcmllcyxcbiAgICAgICAgICAgICAgICAgICAgX3NfaTogc19pLFxuICAgICAgICAgICAgICAgICAgICBfa2V5OiBzZXJpZXMua2V5LFxuICAgICAgICAgICAgICAgICAgICBfeTogdGhpcy5feShkKVxuICAgICAgICAgICAgICAgIH0sIGQpKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cblxuICAgIGdldEtleXMoKSB7XG4gICAgICAgIGxldCBkYXRhID0gdGhpcy5fZGF0YTtcbiAgICAgICAgaWYgKCFkYXRhIHx8ICFkYXRhLmxlbmd0aCkgcmV0dXJuIFtdO1xuXG4gICAgICAgIHJldHVybiBbLi4ubmV3IFNldChkYXRhLm1hcChkID0+IGQua2V5KSldXG4gICAgfVxufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/ColumnChart.js\n");

/***/ }),

/***/ "./src/FantasticChart.js":
/*!*******************************!*\
  !*** ./src/FantasticChart.js ***!
  \*******************************/
/*! exports provided: chart */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"chart\", function() { return chart; });\n/* harmony import */ var _Colours__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Colours */ \"./src/Colours.js\");\n/* harmony import */ var _Scales__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Scales */ \"./src/Scales.js\");\n/* harmony import */ var _Axes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Axes */ \"./src/Axes.js\");\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./helpers */ \"./src/helpers.js\");\n/* harmony import */ var _Legend__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Legend */ \"./src/Legend.js\");\n// Copyright (C) 2013-2014, 2018 BrandsEye (PTY) LTD\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this\n// software and associated documentation files (the \"Software\"), to deal in the Software\n// without restriction, including without limitation the rights to use, copy, modify,\n//     merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following\n// conditions:\n//\n//     The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n//     INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n// CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n\n\n\n\n\nclass FantasticChart {\n\n    constructor(name) {\n        this._counter = this._counter || 0;\n        this._counter++;\n        this._name = name || (\"Chart \" + this._counter);\n        this.reset();\n    }\n\n    reset() {\n        this._geometries = [];\n        this._x_getter = d => d.x;\n        this._y_getter = d => d.y;\n        this._data = [];\n        this._element = null;\n        this._width = 900;\n        this._height = 512;\n        this._colour = () => _Colours__WEBPACK_IMPORTED_MODULE_0__[\"colours\"].eighteen.midGrey;\n        this._size = () => 1;\n        this._scale_x = Object(_Scales__WEBPACK_IMPORTED_MODULE_1__[\"scaleIdentity\"])();\n        this._scale_y = Object(_Scales__WEBPACK_IMPORTED_MODULE_1__[\"scaleIdentity\"])();\n        this._colour = () => 1;\n        this._facet_x = null;\n        this._colour_scale = d3.schemeAccent;\n        this._d3_colour_scale = d3.schemeAccent;\n        this._individual_colours = {};\n        this._x_formatter = d => \"\" + d;\n        this._y_formatter = d => d;\n        this._dispatch = d3.dispatch('elementClick', 'tooltipShow', 'tooltipHide');\n        this._show_labels = true;\n        this._show_legend = true;\n        this._y_axis_label = null;\n        this._label_formatter = null;\n\n        return this;\n    }\n\n    /*\n     * A DOM element that we want to render to.\n     * See, for instance, document.getElementById(id), to get\n     * such a dom element.\n     */\n    element(el) {\n        if (arguments.length === 0) return this._element;\n        this._element = el;\n        return this;\n    }\n\n    width(width) {\n        if (arguments.length === 0) return this._width;\n        if (typeof width !== \"number\" && width > 0) throw new Error(\"width must be a positive number\");\n        this._width = width;\n        return this;\n    }\n\n    height(height) {\n        if (arguments.length === 0) return this._height;\n        if (typeof height !== \"number\" && height > 0) throw new Error(\"height must be a positive number\");\n        this._height = height;\n        return this;\n    }\n\n    x(getter) {\n        if (arguments.length === 0) return this._x_getter;\n        if (typeof getter !== 'function') throw new Error(\"x getter must be a function\");\n        this._x_getter = getter;\n        return this;\n    }\n\n    y(getter) {\n        if (arguments.length === 0) return this._y_getter;\n        if (typeof getter !== 'function') throw new Error(\"y getter must be a function\");\n        this._y_getter = getter;\n        return this;\n    }\n\n    scaleX(scale) {\n        if (arguments.length === 0) return this._scale_x;\n        this._scale_x = scale;\n        return this;\n    }\n\n    scaleY(scale) {\n        if (arguments.length === 0) return this._scale_y;\n        this._scale_y = scale;\n        return this;\n    }\n\n    /*\n     * Add geometry to render. Multiple geometries can be added.\n     */\n    geometry(geom) {\n        if (arguments.length === 0) return this._geometries.slice(0);\n        this._geometries.push(geom);\n        return this;\n    }\n\n    size() {\n        console.log(\"=> size: not implemented\")\n    }\n\n    formatX(formatter) {\n        if (arguments.length === 0) return this._x_formatter;\n        if (typeof formatter !== 'function') throw new Error(\"formatter must be a function\");\n        this._x_formatter = formatter;\n        return this;\n    }\n\n    formatY(formatter) {\n        if (arguments.length === 0) return this._y_formatter;\n        if (typeof formatter !== 'function') throw new Error(\"formatter must be a function\");\n        this._y_formatter = formatter;\n        return this;\n    }\n\n    formatLabel(formatter) {\n        if (arguments.length === 0) return this._label_formatter;\n        if (typeof formatter !== 'function') throw new Error(\"formatter must be a function\");\n        this._label_formatter = formatter;\n        return this;\n    }\n\n    yAxisLabel(label) {\n        if (arguments.length === 0) return this._y_axis_label;\n        this._y_axis_label = label;\n        return this;\n    }\n\n    /**\n     * Defines how to separate data visually using colours. It\n     * does not define what colour to use.\n     * @param colour\n     * @returns {*}\n     */\n    colour(colour) {\n        if (arguments.length === 0) return this._colour;\n        if (typeof colour !== 'function') throw new Error(\"colour must be a function\");\n        this._colour = colour;\n        return this;\n    }\n\n    /**\n     * Defines colours to use.\n     * @param colours\n     */\n    colourScale(colours) {\n        if (arguments.length === 0) return this._colour_scale;\n        if (typeof colours !== 'object' || !colours.length) throw new Error(\"colour must be an Array\");\n        this._colour_scale = colours;\n        return this;\n    }\n\n    /**\n     * Provide a map of x-value fields and the colours that they should be mapped to. This overrides\n     * the colour scale. The colour scale will be used for values not defined by this map.\n     * @param colourMap\n     * @returns {*}\n     */\n    individualColours(colourMap) {\n        if (arguments.length === 0) return this._individual_colours;\n        this._individual_colours = colourMap;\n        return this;\n    }\n\n    facetX(selector) {\n        if (arguments.length === 0) return this._facet_x;\n        if (selector != null && typeof selector !== 'function') throw new Error(\"The facet selector must be a function\");\n        this._facet_x = selector;\n        return this;\n    }\n\n    /**\n     * Whether to show labels or not. This is retained mode: it will not show the labels\n     * immediately. Please call #render() again to show the labels.\n     */\n    showLabels(show) {\n        if (arguments.length === 0) return this._show_labels;\n        this._show_labels = !!show;\n        return this;\n    }\n\n    showLegend(show) {\n        if (arguments.length === 0) return this._show_legend;\n        this._show_legend = !!show;\n        return this;\n    }\n\n    /**\n     * Renders or hides labels as they are requested.\n     */\n    immediatelyRenderLabels(show) {\n        if (this._geometries) {\n            this._geometries.forEach(geom => geom.immediatelyRenderLabels(!!show))\n        }\n    }\n\n    /**\n     * The event handle for the charts. Supports the following events:\n     *\n     * - elementClick\n     * - tooltipShow\n     * - tooltipHide\n     *\n     * @returns {*|Dispatch}\n     */\n    dispatch() {\n        return this._dispatch;\n    }\n\n    data(data) {\n        if (arguments.length === 0) return this._data.slice();\n        this._data = data;\n        return this;\n    }\n\n    /**\n     * The chart's name, as defined in the constructor\n     * @returns {String}\n     */\n    name() {\n        return this._name;\n    }\n\n    render() {\n        console.info(\"-------- RENDERING \" + this.name() + \" ---------\");\n\n        //-----------------------------------------------\n        // Create initial svg element\n        let svg = d3.select(this._element).select(\"svg\");\n        if (svg.empty()) svg = d3.select(this._element).append(\"svg\");\n\n        //-----------------------------------------------\n        // Setup initial data\n\n        const bs = Object(_Legend__WEBPACK_IMPORTED_MODULE_4__[\"buckets\"])(this._data, this._colour, this._size);\n        const colourScale = this._d3_colour_scale = d3.scaleOrdinal(this.colourScale())\n                                                      .domain(Array.from(bs.colours));\n\n        //-----------------------------------------------\n        // Calculate the space that various elements will want to take up\n\n        const geometries = this.sortGeometries();\n        geometries.forEach(geom => this.setupGeom(geom));\n        const axisWidth = geometries.length ? Object(_helpers__WEBPACK_IMPORTED_MODULE_3__[\"maxBounding\"])(svg, geometries[0].yValues().map(geometries[0].formatY())).width + 20 : 0;\n\n        //-----------------------------------------------\n        // Draw the legend\n        const legendHeight = Object(_Legend__WEBPACK_IMPORTED_MODULE_4__[\"renderLegend\"])(svg, bs, colourScale, this._width, this._height);\n\n        //-----------------------------------------------\n        // Calculate margins without knowing the final height.\n        // We can only calculate the final height once we can accurately\n        // determine how to lay out the x-axis.\n\n        const outerPadding = 20;\n\n        const margin = {\n            top: outerPadding,\n            right: outerPadding,\n            bottom: outerPadding + legendHeight,\n            left: outerPadding + axisWidth\n        };\n        if (this._y_axis_label) margin.left += 20;\n        const width  = this._width - margin.left - margin.right;\n        const leftOuterPadding = outerPadding + (this._y_axis_label ? 20 : 0);\n        const bottomOuterPadding = outerPadding + legendHeight;\n\n        //-----------------------------------------------\n        // Determine initial facet / small multiple information\n\n        const facets = getFacets(this._data, this._facet_x);\n        const singleFacet = facets.length === 1;\n\n        const facetBand = d3.scaleBand()\n                            .rangeRound([0, width])\n                            .padding(singleFacet ? 0 : 0.1) // take up full space if the only facet.\n                            .domain(facets);\n\n        //-----------------------------------------------\n        // Determine x-axis height\n        // We do this by rendering the various x-axes offscreen.\n\n        geometries.forEach(geom => geom.width(facetBand.bandwidth()));\n        const axisSizeArea = svg.append(\"g\")\n            .attr(\"transform\", \"translate(-1000, -1000)\");\n\n        let axisHeight = 0;\n        facets.forEach(facet => {\n            const xScale = geometries[0]\n                .width(facetBand.bandwidth())\n                .facet(singleFacet ? null : (d => this._facet_x(d) === facet))\n                .getD3XScale();\n\n            let height = Object(_Axes__WEBPACK_IMPORTED_MODULE_2__[\"xaxis\"])(axisSizeArea, this._height,\n                xScale.bandwidth ? xScale.bandwidth() : facetBand.bandwidth() / xScale.domain().length,\n                d3.axisBottom(xScale).tickSize(0).tickPadding(5).tickFormat(geometries[0].formatX()));\n\n            axisHeight = Math.max(height, axisHeight);\n        });\n\n        axisSizeArea.remove();\n\n        //-----------------------------------------------\n        // Update margins and calculate height\n\n        margin.bottom += axisHeight;\n        const height = this._height - margin.top - margin.bottom;\n\n        //-----------------------------------------------\n        // Setup the svg\n\n        svg\n            .style(\"width\", this._width + \"px\")\n            .style(\"height\", this._height + \"px\");\n\n        //-----------------------------------------------\n        // An area for us to render the geometries in to.\n\n        let drawingArea = svg.select('.drawing-area');\n\n        if (drawingArea.empty()) {\n            drawingArea = svg\n                .append(\"g\")\n                .attr(\"class\", \"drawing-area\")\n        }\n\n        drawingArea.attr(\"transform\", \"translate(\" + margin.left + \",\" + margin.top + \")\");\n\n\n        //-----------------------------------------------\n        // Set up small multiples / facets\n\n        let facetAreas = drawingArea.selectAll('.facet').data(facets);\n        facetAreas.exit().remove();\n\n        //-----------------------------------------------\n        // Setup axes.\n\n        let xAxisArea = svg.select(\".x-axis-area\");\n\n        xAxisArea.remove();\n        xAxisArea = svg\n            .append(\"g\")\n            .attr(\"class\", \"x-axis-area\");\n\n        xAxisArea.attr(\"transform\", \"translate(\" + margin.left + \",\" + -bottomOuterPadding +\")\");\n\n\n        let yAxisArea = svg.select(\".y-axis-area\");\n\n        yAxisArea.remove();\n        yAxisArea = svg\n            .append(\"g\")\n            .attr(\"class\", \"y-axis-area\")\n            .attr(\"transform\", \"translate(\" + leftOuterPadding +\",\" + margin.top + \")\");\n\n\n        const yscale = geometries.length ? geometries[0].height(height).getD3YScale() : null;\n        if (geometries.length) {\n            // Draw the yaxis.\n            Object(_Axes__WEBPACK_IMPORTED_MODULE_2__[\"yaxis\"])(yAxisArea, d3.axisLeft(yscale).ticks(5).tickFormat(geometries[0].formatY())); //;.tickFormat(this._tickFormat));\n\n            // Draw a little x-axis for every facet.\n            facets.forEach(facet => {\n                const xScale = geometries[0]\n                    .width(facetBand.bandwidth())\n                    .height(height)\n                    .facet(singleFacet ? null : (d => this._facet_x(d) === facet))\n                    .getD3XScale();\n\n                const area = xAxisArea\n                    .append(\"g\")\n                    .attr(\"transform\", \"translate(\" + (facetBand(facet)) + \",0)\")// + (this._height - axisHeight) +\")\")\n                    .attr(\"width\", facetBand.bandwidth());\n\n\n                Object(_Axes__WEBPACK_IMPORTED_MODULE_2__[\"xaxis\"])(area, this._height,\n                    xScale.bandwidth ? xScale.bandwidth() : facetBand.bandwidth() / xScale.domain().length,\n                    d3.axisBottom(xScale).tickSize(0).tickPadding(5).tickFormat(geometries[0].formatX()))\n            });\n\n        }\n\n        //-----------------------------------------------\n        // Setup labels\n\n        Object(_Axes__WEBPACK_IMPORTED_MODULE_2__[\"yAxisLabel\"])(svg, height, margin, this._y_axis_label);\n\n\n        //-----------------------------------------------\n        // Draw individual geometries.\n\n        facetAreas\n            .enter()\n            .append(\"g\")\n            .attr(\"class\", \"facet\")\n            .merge(facetAreas)\n            .attr(\"width\", facetBand.bandwidth())\n            .attr(\"transform\", facetId => {\n                if (singleFacet) return \"translate(0,0)\";\n                return \"translate(\" + facetBand(facetId) + \",0)\";\n            })\n            .each((facet, facet_i, facetNodes) => {\n                console.log(\"------------ facet \", facet || \"single-facet\");\n                const area = d3.select(facetNodes[facet_i]);\n\n                Object(_Axes__WEBPACK_IMPORTED_MODULE_2__[\"grid\"])(area, facetBand.bandwidth(), d3.axisLeft(yscale).ticks(5));\n\n                let geoms = area.selectAll(\".geometry\").data(geometries);\n\n                geoms.exit().remove();\n\n                geoms.enter()\n                     .append(\"g\")\n                     .attr(\"class\", \"geometry\")\n                     .merge(geoms)\n                     .each((geom, i, nodes) => {\n                         const geom_width  = facetBand.bandwidth(),\n                               geom_height = height;\n\n                         const geom_top  = 0,\n                               geom_left = 0;\n\n                         let node = d3.select(nodes[i]);\n                         node\n                             .attr(\"transform\", \"translate(\" + geom_left + \",\" + geom_top + \")\")\n                             .each((d, i, nodes) => {\n                                 console.log(\"Setting height for\", geom.name(), \"to\", height - axisHeight);\n                                 geom.element(d3.select(nodes[i]))\n                                     .facet(singleFacet ? null : (d => this._facet_x(d) === facet))\n                                     .height(geom_height)\n                                     .width(geom_width)\n                                     .render();\n                             })\n                     });\n\n                // Ensure this is rendered on top of other things.\n                area.select(\".x-axis\").raise();\n            })\n\n    }\n\n\n    /*\n     * Ensures that each geom has the settings that it needs.\n     */\n    setupGeom(geom) {\n        geom.setupX(this._x_getter)\n            .setupY(this._y_getter)\n            .setupColour(this._colour)\n            .setupSize(this._size)\n            .setupScaleX(this._scale_x)\n            .setupScaleY(this._scale_y)\n            .setupFormatX(this._x_formatter)\n            .setupFormatY(this._y_formatter)\n            .setupFormatLabel(this._label_formatter)\n            .setupColourScale(this._colour_scale)\n            .setupIndividualColours(this._individual_colours)\n            .setupShowLabels(this._show_labels)\n            .d3ColourScale(this._d3_colour_scale);\n        geom._dispatch.on(\"elementClick\", (e) => {\n            this._dispatch.call(\"elementClick\", this, e);\n        });\n        geom._dispatch.on(\"tooltipHide\", () => {\n            this._dispatch.call(\"tooltipHide\", this);\n        });\n        geom._dispatch.on(\"tooltipShow\", (e) => {\n            this._dispatch.call(\"tooltipShow\", this, e);\n        });\n        geom.data(this._data);\n    }\n\n\n    /**\n     * We want to ensure that geometries have a particular order to them.\n     * This is important for rendering: lines should be rendered on top of\n     * large histogram rectangles, for instance, otherwise they will be hidden.\n     */\n    sortGeometries() {\n        if (!this._geometries || !this._geometries.length) return [];\n\n        let geometries = this._geometries.slice(0);\n        geometries.sort((lhs, rhs) => {\n            return lhs.priority() - rhs.priority();\n        });\n\n        return geometries;\n    }\n\n}\n\n\n/*\n * Returns the unique facet choices from the data, given a facet selector.\n */\nfunction getFacets(data, selector) {\n    if (!selector || !data || !data.length) return [1];\n\n    const keys = new Set(data.map(selector));\n    return [...keys];\n}\n\n\n/**\n * Create a new chart object.\n * @param name An optional name for the chart.\n * @returns {FantasticChart}\n */\nfunction chart(name) {\n    return new FantasticChart(name);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvRmFudGFzdGljQ2hhcnQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9iM2pzLy4vc3JjL0ZhbnRhc3RpY0NoYXJ0LmpzPzAzMTkiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChDKSAyMDEzLTIwMTQsIDIwMTggQnJhbmRzRXllIChQVFkpIExURFxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpc1xuLy8gc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlXG4vLyB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksXG4vLyAgICAgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0b1xuLy8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcbi8vIGNvbmRpdGlvbnM6XG4vL1xuLy8gICAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuLy8gY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyAgICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUiBJTVBMSUVELFxuLy8gICAgIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBXG4vLyBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUXG4vLyBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0Zcbi8vIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRVxuLy8gT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCB7IGNvbG91cnMgfSBmcm9tICcuL0NvbG91cnMnO1xuaW1wb3J0IHtjaG9vc2VTY2FsZSwgc2NhbGVJZGVudGl0eX0gZnJvbSBcIi4vU2NhbGVzXCI7XG5pbXBvcnQgeyB4YXhpcywgeWF4aXMsIGdyaWQsIHlBeGlzTGFiZWwgfSBmcm9tIFwiLi9BeGVzXCI7XG5pbXBvcnQge21heEJvdW5kaW5nfSBmcm9tIFwiLi9oZWxwZXJzXCI7XG5pbXBvcnQgeyByZW5kZXJMZWdlbmQsIGJ1Y2tldHMgfSBmcm9tIFwiLi9MZWdlbmRcIjtcblxuXG5jbGFzcyBGYW50YXN0aWNDaGFydCB7XG5cbiAgICBjb25zdHJ1Y3RvcihuYW1lKSB7XG4gICAgICAgIHRoaXMuX2NvdW50ZXIgPSB0aGlzLl9jb3VudGVyIHx8IDA7XG4gICAgICAgIHRoaXMuX2NvdW50ZXIrKztcbiAgICAgICAgdGhpcy5fbmFtZSA9IG5hbWUgfHwgKFwiQ2hhcnQgXCIgKyB0aGlzLl9jb3VudGVyKTtcbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgIH1cblxuICAgIHJlc2V0KCkge1xuICAgICAgICB0aGlzLl9nZW9tZXRyaWVzID0gW107XG4gICAgICAgIHRoaXMuX3hfZ2V0dGVyID0gZCA9PiBkLng7XG4gICAgICAgIHRoaXMuX3lfZ2V0dGVyID0gZCA9PiBkLnk7XG4gICAgICAgIHRoaXMuX2RhdGEgPSBbXTtcbiAgICAgICAgdGhpcy5fZWxlbWVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3dpZHRoID0gOTAwO1xuICAgICAgICB0aGlzLl9oZWlnaHQgPSA1MTI7XG4gICAgICAgIHRoaXMuX2NvbG91ciA9ICgpID0+IGNvbG91cnMuZWlnaHRlZW4ubWlkR3JleTtcbiAgICAgICAgdGhpcy5fc2l6ZSA9ICgpID0+IDE7XG4gICAgICAgIHRoaXMuX3NjYWxlX3ggPSBzY2FsZUlkZW50aXR5KCk7XG4gICAgICAgIHRoaXMuX3NjYWxlX3kgPSBzY2FsZUlkZW50aXR5KCk7XG4gICAgICAgIHRoaXMuX2NvbG91ciA9ICgpID0+IDE7XG4gICAgICAgIHRoaXMuX2ZhY2V0X3ggPSBudWxsO1xuICAgICAgICB0aGlzLl9jb2xvdXJfc2NhbGUgPSBkMy5zY2hlbWVBY2NlbnQ7XG4gICAgICAgIHRoaXMuX2QzX2NvbG91cl9zY2FsZSA9IGQzLnNjaGVtZUFjY2VudDtcbiAgICAgICAgdGhpcy5faW5kaXZpZHVhbF9jb2xvdXJzID0ge307XG4gICAgICAgIHRoaXMuX3hfZm9ybWF0dGVyID0gZCA9PiBcIlwiICsgZDtcbiAgICAgICAgdGhpcy5feV9mb3JtYXR0ZXIgPSBkID0+IGQ7XG4gICAgICAgIHRoaXMuX2Rpc3BhdGNoID0gZDMuZGlzcGF0Y2goJ2VsZW1lbnRDbGljaycsICd0b29sdGlwU2hvdycsICd0b29sdGlwSGlkZScpO1xuICAgICAgICB0aGlzLl9zaG93X2xhYmVscyA9IHRydWU7XG4gICAgICAgIHRoaXMuX3Nob3dfbGVnZW5kID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5feV9heGlzX2xhYmVsID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbGFiZWxfZm9ybWF0dGVyID0gbnVsbDtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIEEgRE9NIGVsZW1lbnQgdGhhdCB3ZSB3YW50IHRvIHJlbmRlciB0by5cbiAgICAgKiBTZWUsIGZvciBpbnN0YW5jZSwgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpLCB0byBnZXRcbiAgICAgKiBzdWNoIGEgZG9tIGVsZW1lbnQuXG4gICAgICovXG4gICAgZWxlbWVudChlbCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX2VsZW1lbnQ7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQgPSBlbDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgd2lkdGgod2lkdGgpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl93aWR0aDtcbiAgICAgICAgaWYgKHR5cGVvZiB3aWR0aCAhPT0gXCJudW1iZXJcIiAmJiB3aWR0aCA+IDApIHRocm93IG5ldyBFcnJvcihcIndpZHRoIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXJcIik7XG4gICAgICAgIHRoaXMuX3dpZHRoID0gd2lkdGg7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGhlaWdodChoZWlnaHQpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl9oZWlnaHQ7XG4gICAgICAgIGlmICh0eXBlb2YgaGVpZ2h0ICE9PSBcIm51bWJlclwiICYmIGhlaWdodCA+IDApIHRocm93IG5ldyBFcnJvcihcImhlaWdodCBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyXCIpO1xuICAgICAgICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHgoZ2V0dGVyKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5feF9nZXR0ZXI7XG4gICAgICAgIGlmICh0eXBlb2YgZ2V0dGVyICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgRXJyb3IoXCJ4IGdldHRlciBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG4gICAgICAgIHRoaXMuX3hfZ2V0dGVyID0gZ2V0dGVyO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB5KGdldHRlcikge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX3lfZ2V0dGVyO1xuICAgICAgICBpZiAodHlwZW9mIGdldHRlciAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IEVycm9yKFwieSBnZXR0ZXIgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICB0aGlzLl95X2dldHRlciA9IGdldHRlcjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgc2NhbGVYKHNjYWxlKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5fc2NhbGVfeDtcbiAgICAgICAgdGhpcy5fc2NhbGVfeCA9IHNjYWxlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzY2FsZVkoc2NhbGUpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl9zY2FsZV95O1xuICAgICAgICB0aGlzLl9zY2FsZV95ID0gc2NhbGU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qXG4gICAgICogQWRkIGdlb21ldHJ5IHRvIHJlbmRlci4gTXVsdGlwbGUgZ2VvbWV0cmllcyBjYW4gYmUgYWRkZWQuXG4gICAgICovXG4gICAgZ2VvbWV0cnkoZ2VvbSkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX2dlb21ldHJpZXMuc2xpY2UoMCk7XG4gICAgICAgIHRoaXMuX2dlb21ldHJpZXMucHVzaChnZW9tKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgc2l6ZSgpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCI9PiBzaXplOiBub3QgaW1wbGVtZW50ZWRcIilcbiAgICB9XG5cbiAgICBmb3JtYXRYKGZvcm1hdHRlcikge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX3hfZm9ybWF0dGVyO1xuICAgICAgICBpZiAodHlwZW9mIGZvcm1hdHRlciAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IEVycm9yKFwiZm9ybWF0dGVyIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgdGhpcy5feF9mb3JtYXR0ZXIgPSBmb3JtYXR0ZXI7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZvcm1hdFkoZm9ybWF0dGVyKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5feV9mb3JtYXR0ZXI7XG4gICAgICAgIGlmICh0eXBlb2YgZm9ybWF0dGVyICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgRXJyb3IoXCJmb3JtYXR0ZXIgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICB0aGlzLl95X2Zvcm1hdHRlciA9IGZvcm1hdHRlcjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZm9ybWF0TGFiZWwoZm9ybWF0dGVyKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5fbGFiZWxfZm9ybWF0dGVyO1xuICAgICAgICBpZiAodHlwZW9mIGZvcm1hdHRlciAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IEVycm9yKFwiZm9ybWF0dGVyIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgdGhpcy5fbGFiZWxfZm9ybWF0dGVyID0gZm9ybWF0dGVyO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB5QXhpc0xhYmVsKGxhYmVsKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5feV9heGlzX2xhYmVsO1xuICAgICAgICB0aGlzLl95X2F4aXNfbGFiZWwgPSBsYWJlbDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVmaW5lcyBob3cgdG8gc2VwYXJhdGUgZGF0YSB2aXN1YWxseSB1c2luZyBjb2xvdXJzLiBJdFxuICAgICAqIGRvZXMgbm90IGRlZmluZSB3aGF0IGNvbG91ciB0byB1c2UuXG4gICAgICogQHBhcmFtIGNvbG91clxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGNvbG91cihjb2xvdXIpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl9jb2xvdXI7XG4gICAgICAgIGlmICh0eXBlb2YgY29sb3VyICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgRXJyb3IoXCJjb2xvdXIgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICB0aGlzLl9jb2xvdXIgPSBjb2xvdXI7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlZmluZXMgY29sb3VycyB0byB1c2UuXG4gICAgICogQHBhcmFtIGNvbG91cnNcbiAgICAgKi9cbiAgICBjb2xvdXJTY2FsZShjb2xvdXJzKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5fY29sb3VyX3NjYWxlO1xuICAgICAgICBpZiAodHlwZW9mIGNvbG91cnMgIT09ICdvYmplY3QnIHx8ICFjb2xvdXJzLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKFwiY29sb3VyIG11c3QgYmUgYW4gQXJyYXlcIik7XG4gICAgICAgIHRoaXMuX2NvbG91cl9zY2FsZSA9IGNvbG91cnM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByb3ZpZGUgYSBtYXAgb2YgeC12YWx1ZSBmaWVsZHMgYW5kIHRoZSBjb2xvdXJzIHRoYXQgdGhleSBzaG91bGQgYmUgbWFwcGVkIHRvLiBUaGlzIG92ZXJyaWRlc1xuICAgICAqIHRoZSBjb2xvdXIgc2NhbGUuIFRoZSBjb2xvdXIgc2NhbGUgd2lsbCBiZSB1c2VkIGZvciB2YWx1ZXMgbm90IGRlZmluZWQgYnkgdGhpcyBtYXAuXG4gICAgICogQHBhcmFtIGNvbG91ck1hcFxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGluZGl2aWR1YWxDb2xvdXJzKGNvbG91ck1hcCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX2luZGl2aWR1YWxfY29sb3VycztcbiAgICAgICAgdGhpcy5faW5kaXZpZHVhbF9jb2xvdXJzID0gY29sb3VyTWFwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmYWNldFgoc2VsZWN0b3IpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl9mYWNldF94O1xuICAgICAgICBpZiAoc2VsZWN0b3IgIT0gbnVsbCAmJiB0eXBlb2Ygc2VsZWN0b3IgIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBFcnJvcihcIlRoZSBmYWNldCBzZWxlY3RvciBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG4gICAgICAgIHRoaXMuX2ZhY2V0X3ggPSBzZWxlY3RvcjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0byBzaG93IGxhYmVscyBvciBub3QuIFRoaXMgaXMgcmV0YWluZWQgbW9kZTogaXQgd2lsbCBub3Qgc2hvdyB0aGUgbGFiZWxzXG4gICAgICogaW1tZWRpYXRlbHkuIFBsZWFzZSBjYWxsICNyZW5kZXIoKSBhZ2FpbiB0byBzaG93IHRoZSBsYWJlbHMuXG4gICAgICovXG4gICAgc2hvd0xhYmVscyhzaG93KSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5fc2hvd19sYWJlbHM7XG4gICAgICAgIHRoaXMuX3Nob3dfbGFiZWxzID0gISFzaG93O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzaG93TGVnZW5kKHNob3cpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl9zaG93X2xlZ2VuZDtcbiAgICAgICAgdGhpcy5fc2hvd19sZWdlbmQgPSAhIXNob3c7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgb3IgaGlkZXMgbGFiZWxzIGFzIHRoZXkgYXJlIHJlcXVlc3RlZC5cbiAgICAgKi9cbiAgICBpbW1lZGlhdGVseVJlbmRlckxhYmVscyhzaG93KSB7XG4gICAgICAgIGlmICh0aGlzLl9nZW9tZXRyaWVzKSB7XG4gICAgICAgICAgICB0aGlzLl9nZW9tZXRyaWVzLmZvckVhY2goZ2VvbSA9PiBnZW9tLmltbWVkaWF0ZWx5UmVuZGVyTGFiZWxzKCEhc2hvdykpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZXZlbnQgaGFuZGxlIGZvciB0aGUgY2hhcnRzLiBTdXBwb3J0cyB0aGUgZm9sbG93aW5nIGV2ZW50czpcbiAgICAgKlxuICAgICAqIC0gZWxlbWVudENsaWNrXG4gICAgICogLSB0b29sdGlwU2hvd1xuICAgICAqIC0gdG9vbHRpcEhpZGVcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHsqfERpc3BhdGNofVxuICAgICAqL1xuICAgIGRpc3BhdGNoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGlzcGF0Y2g7XG4gICAgfVxuXG4gICAgZGF0YShkYXRhKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5fZGF0YS5zbGljZSgpO1xuICAgICAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGNoYXJ0J3MgbmFtZSwgYXMgZGVmaW5lZCBpbiB0aGUgY29uc3RydWN0b3JcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIG5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc29sZS5pbmZvKFwiLS0tLS0tLS0gUkVOREVSSU5HIFwiICsgdGhpcy5uYW1lKCkgKyBcIiAtLS0tLS0tLS1cIik7XG5cbiAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBDcmVhdGUgaW5pdGlhbCBzdmcgZWxlbWVudFxuICAgICAgICBsZXQgc3ZnID0gZDMuc2VsZWN0KHRoaXMuX2VsZW1lbnQpLnNlbGVjdChcInN2Z1wiKTtcbiAgICAgICAgaWYgKHN2Zy5lbXB0eSgpKSBzdmcgPSBkMy5zZWxlY3QodGhpcy5fZWxlbWVudCkuYXBwZW5kKFwic3ZnXCIpO1xuXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gU2V0dXAgaW5pdGlhbCBkYXRhXG5cbiAgICAgICAgY29uc3QgYnMgPSBidWNrZXRzKHRoaXMuX2RhdGEsIHRoaXMuX2NvbG91ciwgdGhpcy5fc2l6ZSk7XG4gICAgICAgIGNvbnN0IGNvbG91clNjYWxlID0gdGhpcy5fZDNfY29sb3VyX3NjYWxlID0gZDMuc2NhbGVPcmRpbmFsKHRoaXMuY29sb3VyU2NhbGUoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5kb21haW4oQXJyYXkuZnJvbShicy5jb2xvdXJzKSk7XG5cbiAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIHNwYWNlIHRoYXQgdmFyaW91cyBlbGVtZW50cyB3aWxsIHdhbnQgdG8gdGFrZSB1cFxuXG4gICAgICAgIGNvbnN0IGdlb21ldHJpZXMgPSB0aGlzLnNvcnRHZW9tZXRyaWVzKCk7XG4gICAgICAgIGdlb21ldHJpZXMuZm9yRWFjaChnZW9tID0+IHRoaXMuc2V0dXBHZW9tKGdlb20pKTtcbiAgICAgICAgY29uc3QgYXhpc1dpZHRoID0gZ2VvbWV0cmllcy5sZW5ndGggPyBtYXhCb3VuZGluZyhzdmcsIGdlb21ldHJpZXNbMF0ueVZhbHVlcygpLm1hcChnZW9tZXRyaWVzWzBdLmZvcm1hdFkoKSkpLndpZHRoICsgMjAgOiAwO1xuXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gRHJhdyB0aGUgbGVnZW5kXG4gICAgICAgIGNvbnN0IGxlZ2VuZEhlaWdodCA9IHJlbmRlckxlZ2VuZChzdmcsIGJzLCBjb2xvdXJTY2FsZSwgdGhpcy5fd2lkdGgsIHRoaXMuX2hlaWdodCk7XG5cbiAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBDYWxjdWxhdGUgbWFyZ2lucyB3aXRob3V0IGtub3dpbmcgdGhlIGZpbmFsIGhlaWdodC5cbiAgICAgICAgLy8gV2UgY2FuIG9ubHkgY2FsY3VsYXRlIHRoZSBmaW5hbCBoZWlnaHQgb25jZSB3ZSBjYW4gYWNjdXJhdGVseVxuICAgICAgICAvLyBkZXRlcm1pbmUgaG93IHRvIGxheSBvdXQgdGhlIHgtYXhpcy5cblxuICAgICAgICBjb25zdCBvdXRlclBhZGRpbmcgPSAyMDtcblxuICAgICAgICBjb25zdCBtYXJnaW4gPSB7XG4gICAgICAgICAgICB0b3A6IG91dGVyUGFkZGluZyxcbiAgICAgICAgICAgIHJpZ2h0OiBvdXRlclBhZGRpbmcsXG4gICAgICAgICAgICBib3R0b206IG91dGVyUGFkZGluZyArIGxlZ2VuZEhlaWdodCxcbiAgICAgICAgICAgIGxlZnQ6IG91dGVyUGFkZGluZyArIGF4aXNXaWR0aFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5feV9heGlzX2xhYmVsKSBtYXJnaW4ubGVmdCArPSAyMDtcbiAgICAgICAgY29uc3Qgd2lkdGggID0gdGhpcy5fd2lkdGggLSBtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodDtcbiAgICAgICAgY29uc3QgbGVmdE91dGVyUGFkZGluZyA9IG91dGVyUGFkZGluZyArICh0aGlzLl95X2F4aXNfbGFiZWwgPyAyMCA6IDApO1xuICAgICAgICBjb25zdCBib3R0b21PdXRlclBhZGRpbmcgPSBvdXRlclBhZGRpbmcgKyBsZWdlbmRIZWlnaHQ7XG5cbiAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBEZXRlcm1pbmUgaW5pdGlhbCBmYWNldCAvIHNtYWxsIG11bHRpcGxlIGluZm9ybWF0aW9uXG5cbiAgICAgICAgY29uc3QgZmFjZXRzID0gZ2V0RmFjZXRzKHRoaXMuX2RhdGEsIHRoaXMuX2ZhY2V0X3gpO1xuICAgICAgICBjb25zdCBzaW5nbGVGYWNldCA9IGZhY2V0cy5sZW5ndGggPT09IDE7XG5cbiAgICAgICAgY29uc3QgZmFjZXRCYW5kID0gZDMuc2NhbGVCYW5kKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmFuZ2VSb3VuZChbMCwgd2lkdGhdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5wYWRkaW5nKHNpbmdsZUZhY2V0ID8gMCA6IDAuMSkgLy8gdGFrZSB1cCBmdWxsIHNwYWNlIGlmIHRoZSBvbmx5IGZhY2V0LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5kb21haW4oZmFjZXRzKTtcblxuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIERldGVybWluZSB4LWF4aXMgaGVpZ2h0XG4gICAgICAgIC8vIFdlIGRvIHRoaXMgYnkgcmVuZGVyaW5nIHRoZSB2YXJpb3VzIHgtYXhlcyBvZmZzY3JlZW4uXG5cbiAgICAgICAgZ2VvbWV0cmllcy5mb3JFYWNoKGdlb20gPT4gZ2VvbS53aWR0aChmYWNldEJhbmQuYmFuZHdpZHRoKCkpKTtcbiAgICAgICAgY29uc3QgYXhpc1NpemVBcmVhID0gc3ZnLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKC0xMDAwLCAtMTAwMClcIik7XG5cbiAgICAgICAgbGV0IGF4aXNIZWlnaHQgPSAwO1xuICAgICAgICBmYWNldHMuZm9yRWFjaChmYWNldCA9PiB7XG4gICAgICAgICAgICBjb25zdCB4U2NhbGUgPSBnZW9tZXRyaWVzWzBdXG4gICAgICAgICAgICAgICAgLndpZHRoKGZhY2V0QmFuZC5iYW5kd2lkdGgoKSlcbiAgICAgICAgICAgICAgICAuZmFjZXQoc2luZ2xlRmFjZXQgPyBudWxsIDogKGQgPT4gdGhpcy5fZmFjZXRfeChkKSA9PT0gZmFjZXQpKVxuICAgICAgICAgICAgICAgIC5nZXREM1hTY2FsZSgpO1xuXG4gICAgICAgICAgICBsZXQgaGVpZ2h0ID0geGF4aXMoYXhpc1NpemVBcmVhLCB0aGlzLl9oZWlnaHQsXG4gICAgICAgICAgICAgICAgeFNjYWxlLmJhbmR3aWR0aCA/IHhTY2FsZS5iYW5kd2lkdGgoKSA6IGZhY2V0QmFuZC5iYW5kd2lkdGgoKSAvIHhTY2FsZS5kb21haW4oKS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgZDMuYXhpc0JvdHRvbSh4U2NhbGUpLnRpY2tTaXplKDApLnRpY2tQYWRkaW5nKDUpLnRpY2tGb3JtYXQoZ2VvbWV0cmllc1swXS5mb3JtYXRYKCkpKTtcblxuICAgICAgICAgICAgYXhpc0hlaWdodCA9IE1hdGgubWF4KGhlaWdodCwgYXhpc0hlaWdodCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGF4aXNTaXplQXJlYS5yZW1vdmUoKTtcblxuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIFVwZGF0ZSBtYXJnaW5zIGFuZCBjYWxjdWxhdGUgaGVpZ2h0XG5cbiAgICAgICAgbWFyZ2luLmJvdHRvbSArPSBheGlzSGVpZ2h0O1xuICAgICAgICBjb25zdCBoZWlnaHQgPSB0aGlzLl9oZWlnaHQgLSBtYXJnaW4udG9wIC0gbWFyZ2luLmJvdHRvbTtcblxuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIFNldHVwIHRoZSBzdmdcblxuICAgICAgICBzdmdcbiAgICAgICAgICAgIC5zdHlsZShcIndpZHRoXCIsIHRoaXMuX3dpZHRoICsgXCJweFwiKVxuICAgICAgICAgICAgLnN0eWxlKFwiaGVpZ2h0XCIsIHRoaXMuX2hlaWdodCArIFwicHhcIik7XG5cbiAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBBbiBhcmVhIGZvciB1cyB0byByZW5kZXIgdGhlIGdlb21ldHJpZXMgaW4gdG8uXG5cbiAgICAgICAgbGV0IGRyYXdpbmdBcmVhID0gc3ZnLnNlbGVjdCgnLmRyYXdpbmctYXJlYScpO1xuXG4gICAgICAgIGlmIChkcmF3aW5nQXJlYS5lbXB0eSgpKSB7XG4gICAgICAgICAgICBkcmF3aW5nQXJlYSA9IHN2Z1xuICAgICAgICAgICAgICAgIC5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImRyYXdpbmctYXJlYVwiKVxuICAgICAgICB9XG5cbiAgICAgICAgZHJhd2luZ0FyZWEuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIG1hcmdpbi5sZWZ0ICsgXCIsXCIgKyBtYXJnaW4udG9wICsgXCIpXCIpO1xuXG5cbiAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBTZXQgdXAgc21hbGwgbXVsdGlwbGVzIC8gZmFjZXRzXG5cbiAgICAgICAgbGV0IGZhY2V0QXJlYXMgPSBkcmF3aW5nQXJlYS5zZWxlY3RBbGwoJy5mYWNldCcpLmRhdGEoZmFjZXRzKTtcbiAgICAgICAgZmFjZXRBcmVhcy5leGl0KCkucmVtb3ZlKCk7XG5cbiAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBTZXR1cCBheGVzLlxuXG4gICAgICAgIGxldCB4QXhpc0FyZWEgPSBzdmcuc2VsZWN0KFwiLngtYXhpcy1hcmVhXCIpO1xuXG4gICAgICAgIHhBeGlzQXJlYS5yZW1vdmUoKTtcbiAgICAgICAgeEF4aXNBcmVhID0gc3ZnXG4gICAgICAgICAgICAuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcIngtYXhpcy1hcmVhXCIpO1xuXG4gICAgICAgIHhBeGlzQXJlYS5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgbWFyZ2luLmxlZnQgKyBcIixcIiArIC1ib3R0b21PdXRlclBhZGRpbmcgK1wiKVwiKTtcblxuXG4gICAgICAgIGxldCB5QXhpc0FyZWEgPSBzdmcuc2VsZWN0KFwiLnktYXhpcy1hcmVhXCIpO1xuXG4gICAgICAgIHlBeGlzQXJlYS5yZW1vdmUoKTtcbiAgICAgICAgeUF4aXNBcmVhID0gc3ZnXG4gICAgICAgICAgICAuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcInktYXhpcy1hcmVhXCIpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIGxlZnRPdXRlclBhZGRpbmcgK1wiLFwiICsgbWFyZ2luLnRvcCArIFwiKVwiKTtcblxuXG4gICAgICAgIGNvbnN0IHlzY2FsZSA9IGdlb21ldHJpZXMubGVuZ3RoID8gZ2VvbWV0cmllc1swXS5oZWlnaHQoaGVpZ2h0KS5nZXREM1lTY2FsZSgpIDogbnVsbDtcbiAgICAgICAgaWYgKGdlb21ldHJpZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBEcmF3IHRoZSB5YXhpcy5cbiAgICAgICAgICAgIHlheGlzKHlBeGlzQXJlYSwgZDMuYXhpc0xlZnQoeXNjYWxlKS50aWNrcyg1KS50aWNrRm9ybWF0KGdlb21ldHJpZXNbMF0uZm9ybWF0WSgpKSk7IC8vOy50aWNrRm9ybWF0KHRoaXMuX3RpY2tGb3JtYXQpKTtcblxuICAgICAgICAgICAgLy8gRHJhdyBhIGxpdHRsZSB4LWF4aXMgZm9yIGV2ZXJ5IGZhY2V0LlxuICAgICAgICAgICAgZmFjZXRzLmZvckVhY2goZmFjZXQgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHhTY2FsZSA9IGdlb21ldHJpZXNbMF1cbiAgICAgICAgICAgICAgICAgICAgLndpZHRoKGZhY2V0QmFuZC5iYW5kd2lkdGgoKSlcbiAgICAgICAgICAgICAgICAgICAgLmhlaWdodChoZWlnaHQpXG4gICAgICAgICAgICAgICAgICAgIC5mYWNldChzaW5nbGVGYWNldCA/IG51bGwgOiAoZCA9PiB0aGlzLl9mYWNldF94KGQpID09PSBmYWNldCkpXG4gICAgICAgICAgICAgICAgICAgIC5nZXREM1hTY2FsZSgpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgYXJlYSA9IHhBeGlzQXJlYVxuICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIChmYWNldEJhbmQoZmFjZXQpKSArIFwiLDApXCIpLy8gKyAodGhpcy5faGVpZ2h0IC0gYXhpc0hlaWdodCkgK1wiKVwiKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcIndpZHRoXCIsIGZhY2V0QmFuZC5iYW5kd2lkdGgoKSk7XG5cblxuICAgICAgICAgICAgICAgIHhheGlzKGFyZWEsIHRoaXMuX2hlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgeFNjYWxlLmJhbmR3aWR0aCA/IHhTY2FsZS5iYW5kd2lkdGgoKSA6IGZhY2V0QmFuZC5iYW5kd2lkdGgoKSAvIHhTY2FsZS5kb21haW4oKS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgIGQzLmF4aXNCb3R0b20oeFNjYWxlKS50aWNrU2l6ZSgwKS50aWNrUGFkZGluZyg1KS50aWNrRm9ybWF0KGdlb21ldHJpZXNbMF0uZm9ybWF0WCgpKSlcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH1cblxuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIFNldHVwIGxhYmVsc1xuXG4gICAgICAgIHlBeGlzTGFiZWwoc3ZnLCBoZWlnaHQsIG1hcmdpbiwgdGhpcy5feV9heGlzX2xhYmVsKTtcblxuXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gRHJhdyBpbmRpdmlkdWFsIGdlb21ldHJpZXMuXG5cbiAgICAgICAgZmFjZXRBcmVhc1xuICAgICAgICAgICAgLmVudGVyKClcbiAgICAgICAgICAgIC5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwiZmFjZXRcIilcbiAgICAgICAgICAgIC5tZXJnZShmYWNldEFyZWFzKVxuICAgICAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCBmYWNldEJhbmQuYmFuZHdpZHRoKCkpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBmYWNldElkID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoc2luZ2xlRmFjZXQpIHJldHVybiBcInRyYW5zbGF0ZSgwLDApXCI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwidHJhbnNsYXRlKFwiICsgZmFjZXRCYW5kKGZhY2V0SWQpICsgXCIsMClcIjtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuZWFjaCgoZmFjZXQsIGZhY2V0X2ksIGZhY2V0Tm9kZXMpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIi0tLS0tLS0tLS0tLSBmYWNldCBcIiwgZmFjZXQgfHwgXCJzaW5nbGUtZmFjZXRcIik7XG4gICAgICAgICAgICAgICAgY29uc3QgYXJlYSA9IGQzLnNlbGVjdChmYWNldE5vZGVzW2ZhY2V0X2ldKTtcblxuICAgICAgICAgICAgICAgIGdyaWQoYXJlYSwgZmFjZXRCYW5kLmJhbmR3aWR0aCgpLCBkMy5heGlzTGVmdCh5c2NhbGUpLnRpY2tzKDUpKTtcblxuICAgICAgICAgICAgICAgIGxldCBnZW9tcyA9IGFyZWEuc2VsZWN0QWxsKFwiLmdlb21ldHJ5XCIpLmRhdGEoZ2VvbWV0cmllcyk7XG5cbiAgICAgICAgICAgICAgICBnZW9tcy5leGl0KCkucmVtb3ZlKCk7XG5cbiAgICAgICAgICAgICAgICBnZW9tcy5lbnRlcigpXG4gICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImdlb21ldHJ5XCIpXG4gICAgICAgICAgICAgICAgICAgICAubWVyZ2UoZ2VvbXMpXG4gICAgICAgICAgICAgICAgICAgICAuZWFjaCgoZ2VvbSwgaSwgbm9kZXMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBnZW9tX3dpZHRoICA9IGZhY2V0QmFuZC5iYW5kd2lkdGgoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW9tX2hlaWdodCA9IGhlaWdodDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGdlb21fdG9wICA9IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VvbV9sZWZ0ID0gMDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBub2RlID0gZDMuc2VsZWN0KG5vZGVzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICBub2RlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgZ2VvbV9sZWZ0ICsgXCIsXCIgKyBnZW9tX3RvcCArIFwiKVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZWFjaCgoZCwgaSwgbm9kZXMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiU2V0dGluZyBoZWlnaHQgZm9yXCIsIGdlb20ubmFtZSgpLCBcInRvXCIsIGhlaWdodCAtIGF4aXNIZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VvbS5lbGVtZW50KGQzLnNlbGVjdChub2Rlc1tpXSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZhY2V0KHNpbmdsZUZhY2V0ID8gbnVsbCA6IChkID0+IHRoaXMuX2ZhY2V0X3goZCkgPT09IGZhY2V0KSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuaGVpZ2h0KGdlb21faGVpZ2h0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC53aWR0aChnZW9tX3dpZHRoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZW5kZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gRW5zdXJlIHRoaXMgaXMgcmVuZGVyZWQgb24gdG9wIG9mIG90aGVyIHRoaW5ncy5cbiAgICAgICAgICAgICAgICBhcmVhLnNlbGVjdChcIi54LWF4aXNcIikucmFpc2UoKTtcbiAgICAgICAgICAgIH0pXG5cbiAgICB9XG5cblxuICAgIC8qXG4gICAgICogRW5zdXJlcyB0aGF0IGVhY2ggZ2VvbSBoYXMgdGhlIHNldHRpbmdzIHRoYXQgaXQgbmVlZHMuXG4gICAgICovXG4gICAgc2V0dXBHZW9tKGdlb20pIHtcbiAgICAgICAgZ2VvbS5zZXR1cFgodGhpcy5feF9nZXR0ZXIpXG4gICAgICAgICAgICAuc2V0dXBZKHRoaXMuX3lfZ2V0dGVyKVxuICAgICAgICAgICAgLnNldHVwQ29sb3VyKHRoaXMuX2NvbG91cilcbiAgICAgICAgICAgIC5zZXR1cFNpemUodGhpcy5fc2l6ZSlcbiAgICAgICAgICAgIC5zZXR1cFNjYWxlWCh0aGlzLl9zY2FsZV94KVxuICAgICAgICAgICAgLnNldHVwU2NhbGVZKHRoaXMuX3NjYWxlX3kpXG4gICAgICAgICAgICAuc2V0dXBGb3JtYXRYKHRoaXMuX3hfZm9ybWF0dGVyKVxuICAgICAgICAgICAgLnNldHVwRm9ybWF0WSh0aGlzLl95X2Zvcm1hdHRlcilcbiAgICAgICAgICAgIC5zZXR1cEZvcm1hdExhYmVsKHRoaXMuX2xhYmVsX2Zvcm1hdHRlcilcbiAgICAgICAgICAgIC5zZXR1cENvbG91clNjYWxlKHRoaXMuX2NvbG91cl9zY2FsZSlcbiAgICAgICAgICAgIC5zZXR1cEluZGl2aWR1YWxDb2xvdXJzKHRoaXMuX2luZGl2aWR1YWxfY29sb3VycylcbiAgICAgICAgICAgIC5zZXR1cFNob3dMYWJlbHModGhpcy5fc2hvd19sYWJlbHMpXG4gICAgICAgICAgICAuZDNDb2xvdXJTY2FsZSh0aGlzLl9kM19jb2xvdXJfc2NhbGUpO1xuICAgICAgICBnZW9tLl9kaXNwYXRjaC5vbihcImVsZW1lbnRDbGlja1wiLCAoZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fZGlzcGF0Y2guY2FsbChcImVsZW1lbnRDbGlja1wiLCB0aGlzLCBlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGdlb20uX2Rpc3BhdGNoLm9uKFwidG9vbHRpcEhpZGVcIiwgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fZGlzcGF0Y2guY2FsbChcInRvb2x0aXBIaWRlXCIsIHRoaXMpO1xuICAgICAgICB9KTtcbiAgICAgICAgZ2VvbS5fZGlzcGF0Y2gub24oXCJ0b29sdGlwU2hvd1wiLCAoZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fZGlzcGF0Y2guY2FsbChcInRvb2x0aXBTaG93XCIsIHRoaXMsIGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgZ2VvbS5kYXRhKHRoaXMuX2RhdGEpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogV2Ugd2FudCB0byBlbnN1cmUgdGhhdCBnZW9tZXRyaWVzIGhhdmUgYSBwYXJ0aWN1bGFyIG9yZGVyIHRvIHRoZW0uXG4gICAgICogVGhpcyBpcyBpbXBvcnRhbnQgZm9yIHJlbmRlcmluZzogbGluZXMgc2hvdWxkIGJlIHJlbmRlcmVkIG9uIHRvcCBvZlxuICAgICAqIGxhcmdlIGhpc3RvZ3JhbSByZWN0YW5nbGVzLCBmb3IgaW5zdGFuY2UsIG90aGVyd2lzZSB0aGV5IHdpbGwgYmUgaGlkZGVuLlxuICAgICAqL1xuICAgIHNvcnRHZW9tZXRyaWVzKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2dlb21ldHJpZXMgfHwgIXRoaXMuX2dlb21ldHJpZXMubGVuZ3RoKSByZXR1cm4gW107XG5cbiAgICAgICAgbGV0IGdlb21ldHJpZXMgPSB0aGlzLl9nZW9tZXRyaWVzLnNsaWNlKDApO1xuICAgICAgICBnZW9tZXRyaWVzLnNvcnQoKGxocywgcmhzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbGhzLnByaW9yaXR5KCkgLSByaHMucHJpb3JpdHkoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGdlb21ldHJpZXM7XG4gICAgfVxuXG59XG5cblxuLypcbiAqIFJldHVybnMgdGhlIHVuaXF1ZSBmYWNldCBjaG9pY2VzIGZyb20gdGhlIGRhdGEsIGdpdmVuIGEgZmFjZXQgc2VsZWN0b3IuXG4gKi9cbmZ1bmN0aW9uIGdldEZhY2V0cyhkYXRhLCBzZWxlY3Rvcikge1xuICAgIGlmICghc2VsZWN0b3IgfHwgIWRhdGEgfHwgIWRhdGEubGVuZ3RoKSByZXR1cm4gWzFdO1xuXG4gICAgY29uc3Qga2V5cyA9IG5ldyBTZXQoZGF0YS5tYXAoc2VsZWN0b3IpKTtcbiAgICByZXR1cm4gWy4uLmtleXNdO1xufVxuXG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGNoYXJ0IG9iamVjdC5cbiAqIEBwYXJhbSBuYW1lIEFuIG9wdGlvbmFsIG5hbWUgZm9yIHRoZSBjaGFydC5cbiAqIEByZXR1cm5zIHtGYW50YXN0aWNDaGFydH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNoYXJ0KG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IEZhbnRhc3RpY0NoYXJ0KG5hbWUpO1xufSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/FantasticChart.js\n");

/***/ }),

/***/ "./src/Geometry.js":
/*!*************************!*\
  !*** ./src/Geometry.js ***!
  \*************************/
/*! exports provided: Geometry, getKey, fromKey */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Geometry\", function() { return Geometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getKey\", function() { return getKey; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromKey\", function() { return fromKey; });\n// Copyright (C) 2013-2014, 2018 BrandsEye (PTY) LTD\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this\n// software and associated documentation files (the \"Software\"), to deal in the Software\n// without restriction, including without limitation the rights to use, copy, modify,\n//     merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following\n// conditions:\n//\n//     The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n//     INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n// CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\nclass Geometry {\n\n    constructor(name, priority) {\n        this._name = name || \"[UNNAMED GEOMETRY]\";\n        this._chart_x_getter = null;\n        this._chart_y_getter = null;\n        this._x_getter = null;\n        this._y_getter = null;\n        this._colour = null;\n        this._size = null;\n        this._scale_x = null;\n        this._scale_y = null;\n        this._facet_selector = null;\n        this._chart_colour_scale = null;\n        this._colour_scale = null;\n        this._individual_colours = null;\n        this._chart_individual_colours = null;\n        this._x_formatter = null;\n        this._y_formatter = null;\n        this._chart_x_formatter = null;\n        this._chart_y_formatter = null;\n        this._label_formatter = null;\n        this._chart_label_formatter = null;\n        this._priority = priority || 1;\n        this._dispatch = d3.dispatch('elementClick', 'elementMiddleClick', 'elementRightClick',\n            'tooltipShow', 'tooltipHide');\n        this._show_labels = null;\n        this._chart_show_labels = null;\n        this._d3_colour_scale = null;\n    }\n\n    name() {\n        return this._name;\n    }\n\n    /**\n     * Provides a sort order priority for metrics. Metrics with a higher priority\n     * are drawn on top of lower priority metrics.\n     */\n    priority() {\n        return this._priority;\n    }\n\n    element(el) {\n        if (arguments.length === 0) return this._element;\n        this._element = el;\n        return this;\n    }\n\n    x(getter) {\n        if (arguments.length === 0) return this._x_getter || this._chart_x_getter;\n        if (typeof getter !== 'function') throw new Error(\"x getter must be a function\");\n        this._x_getter = getter;\n        return this;\n    }\n\n    y(getter) {\n        if (arguments.length === 0) return this._y_getter || this._chart_y_getter;\n        if (typeof getter !== 'function') throw new Error(\"y getter must be a function\");\n        this._y_getter = getter;\n        return this;\n    }\n\n    setupX(getter) {\n        if (arguments.length === 0) return this._chart_x_getter;\n        if (typeof getter !== 'function') throw new Error(\"x getter must be a function\");\n        this._chart_x_getter = getter;\n        return this;\n    }\n\n    setupY(getter) {\n        if (arguments.length === 0) return this._chart_y_getter;\n        if (typeof getter !== 'function') throw new Error(\"y getter must be a function\");\n        this._chart_y_getter = getter;\n        return this;\n    }\n\n    colour(colour) {\n        if (arguments.length === 0) return this._colour || this._chart_colour;\n        this._colour = colour;\n        return this;\n    }\n\n    setupColour(colour) {\n        if (arguments.length === 0) return this._chart_colour;\n        this._chart_colour = colour;\n        return this;\n    }\n\n    colourScale(colours) {\n        if (arguments.length === 0) return this._chart_colour_scale || this._colour_scale;\n        if (typeof colours !== 'object' || !colours.length) throw new Error(\"colour must be an Array\");\n        this._colour_scale = colours;\n        return this;\n    }\n\n    setupColourScale(colours) {\n        if (arguments.length === 0) return this._chart_colour_scale;\n        if (typeof colours !== 'object' || !colours.length) throw new Error(\"colour must be an Array\");\n        this._chart_colour_scale = colours;\n        return this;\n    }\n\n    individualColours(colourMap) {\n        if (arguments.length === 0) return this._chart_individual_colours || this._individual_colours;\n        this._individual_colours = colourMap;\n        return this;\n    }\n\n    setupIndividualColours(colourMap) {\n        if (arguments.length === 0) return this._chart_individual_colours;\n        this._chart_individual_colours = colourMap;\n        return this;\n    }\n\n    d3ColourScale(scale) {\n        if (arguments.length === 0) return this._d3_colour_scale;\n        this._d3_colour_scale = scale;\n        return this;\n    }\n\n    getD3Colour(d) {\n        return this.individualColours()[d._x] || this.d3ColourScale()(d._colour);\n    }\n\n    size(size) {\n        if (arguments.length === 0) return this._size || this._chart_size;\n        this._size = size;\n        return this;\n    }\n\n    setupSize(size) {\n        if (arguments.length === 0) return this._chart_size;\n        this._chart_size = size;\n        return this;\n    }\n\n    scaleX(scale) {\n        if (arguments.length === 0) return this._scale_x || this._chart_scale_x;\n        this._scale_x = scale;\n        return this;\n    }\n\n    setupScaleX(scale) {\n        if (arguments.length === 0) return this._chart_scale_x;\n        this._chart_scale_x = scale;\n        return this;\n    }\n\n    scaleY(scale) {\n        if (arguments.length === 0) return this._scale_y || this._chart_scale_y;\n        this._scale_y = scale;\n        return this;\n    }\n\n    setupScaleY(scale) {\n        if (arguments.length === 0) return this._chart_scale_y;\n        this._chart_scale_y = scale;\n        return this;\n    }\n\n    formatX(formatter) {\n        if (arguments.length === 0) return this._x_formatter || this._chart_x_formatter;\n        if (typeof formatter !== 'function') throw new Error(\"formatter must be a function\");\n        this._x_formatter = formatter;\n        return this;\n    }\n\n    setupFormatX(formatter) {\n        if (arguments.length === 0) return this._chart_x_formatter;\n        if (typeof formatter !== 'function') throw new Error(\"formatter must be a function\");\n        this._chart_x_formatter = formatter;\n        return this;\n    }\n\n    formatY(formatter) {\n        if (arguments.length === 0) return this._y_formatter || this._chart_y_formatter;\n        if (typeof formatter !== 'function') throw new Error(\"formatter must be a function\");\n        this._y_formatter = formatter;\n        return this;\n    }\n\n    setupFormatY(formatter) {\n        if (arguments.length === 0) return this._chart_y_formatter;\n        if (typeof formatter !== 'function') throw new Error(\"formatter must be a function\");\n        this._chart_y_formatter = formatter;\n        return this;\n    }\n\n    formatLabel(formatter) {\n        if (arguments.length === 0) return this._label_formatter || this._chart_label_formatter || this.formatY();\n        if (typeof formatter !== 'function') throw new Error(\"formatter must be a function\");\n        this._label_formatter = formatter;\n        return this;\n    }\n\n    setupFormatLabel(formatter) {\n        if (arguments.length === 0) return this._chart_label_formatter;\n        this._chart_label_formatter = formatter;\n        return this;\n    }\n\n\n    width(width) {\n        if (arguments.length === 0) return this._width;\n        this._width = width;\n        return this;\n    }\n\n    height(height) {\n        if (arguments.length === 0) return this._height;\n        this._height = height;\n        return this;\n    }\n\n    showLabels(show) {\n        if (arguments.length === 0) return this._chart_show_labels || this._show_labels;\n        this._show_labels = !!show;\n        return this;\n    }\n\n    setupShowLabels(show) {\n        if (arguments.length === 0) return this._chart_show_labels;\n        this._chart_show_labels = !!show;\n        return this;\n    }\n\n    immediatelyRenderLabels(show) {\n        console.warn(\"#immediatelyRenderLabels not implemented for\", this.name());\n    }\n\n    data(data) {\n        if (arguments.length === 0) return this._data;\n        this._data = data;\n        return this;\n    }\n\n    facet(selector) {\n        if (arguments.length === 0) return this._facet_selector;\n        if (selector != null && typeof selector !== 'function' && selector !== null) throw new Error(\"Facet selector must be a function\");\n        this._facet_selector = selector;\n        return this;\n    }\n\n\n    /*\n     * This takes our array of data, and determines what elements\n     * are to be mapped to what aesthetic values, such as colour or size.\n     * Data is grouped by these fields.\n     */\n    prepareData(data, faceted) {\n        faceted = !!faceted && this.facet();\n        data = data || this._data;\n        if (!data || !data.length) return [];\n\n        const x = this.x(),\n              y = this.y(),\n              scaleX = this.scaleX(),\n              scaleY = this.scaleY();\n\n        let mapped = {};\n\n        data.forEach(d => {\n            if (faceted && !this.facet()(d)) return;\n            const object = Object.assign({\n                _x: scaleX.transform(x(d)),\n                _y: scaleY.transform(y(d)),\n                _colour: this.colour()(d),\n                _size: this.size()(d)\n            }, d);\n\n            const key = getKey(object);\n            object._key = key;\n\n            let series = mapped[key] || getKeyParameters(object);\n            series.data.push(object);\n            mapped[key] = series;\n        });\n\n        return Object.values(mapped);\n    }\n\n    getD3XScale() {\n        throw new Error(\"getD3XScale not implemented for \" + this.name());\n    }\n\n    getD3YScale() {\n        throw new Error(\"getD3YScale not implemented for \" + this.name());\n    }\n\n    /**\n     * Get all the Y values for this geometry, ignoring faceting.\n     */\n    yValues() {\n        return this.data()\n            .map(d => this.y()(d))\n            .map(d => this.scaleY().transform(d));\n    }\n\n    /**\n     * Get all the Y values for this geometry, ignoring faceting.\n     */\n    xValues() {\n        return this.data()\n                   .map(d => this.x()(d))\n                   .map(d => this.scaleX().transform(d));\n    }\n\n\n    /**\n     * Implement your render code here.\n     */\n    render() {\n        throw new Error(\"RENDER NOT IMPLEMENTED FOR \" + this.name());\n    }\n\n\n    /**\n     * Returns the unique values that the colour function\n     * returns.\n     * @param data\n     * @returns {*}\n     */\n    getColourDomain(data) {\n        if (!data || !data.length) return [];\n\n        const colours = new Set();\n\n        // todo calculate buckets\n        data.forEach(series => {\n            series.data.forEach(d => {\n                colours.add(this.colour()(d))\n            });\n        });\n\n        return [...colours]\n    }\n\n}\n\nfunction getKey(d) {\n    // TODO we probably need to encode this better so we can split on the :\n    return \"\" + d._size + \":\" + d._colour;\n}\n\nfunction fromKey(key) {\n    const split = key.split(\":\");\n    return {\n        _size: split[0],\n        _colour: split[1],\n        _key: key\n    }\n}\n\nfunction getKeyParameters(d) {\n    return {\n        _key: getKey(d),\n        _size: d._size,\n        _colour: d._colour,\n        data: []\n    }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvR2VvbWV0cnkuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9iM2pzLy4vc3JjL0dlb21ldHJ5LmpzPzExM2IiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChDKSAyMDEzLTIwMTQsIDIwMTggQnJhbmRzRXllIChQVFkpIExURFxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpc1xuLy8gc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlXG4vLyB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksXG4vLyAgICAgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0b1xuLy8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcbi8vIGNvbmRpdGlvbnM6XG4vL1xuLy8gICAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuLy8gY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyAgICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUiBJTVBMSUVELFxuLy8gICAgIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBXG4vLyBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUXG4vLyBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0Zcbi8vIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRVxuLy8gT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cblxuZXhwb3J0IGNsYXNzIEdlb21ldHJ5IHtcblxuICAgIGNvbnN0cnVjdG9yKG5hbWUsIHByaW9yaXR5KSB7XG4gICAgICAgIHRoaXMuX25hbWUgPSBuYW1lIHx8IFwiW1VOTkFNRUQgR0VPTUVUUlldXCI7XG4gICAgICAgIHRoaXMuX2NoYXJ0X3hfZ2V0dGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5fY2hhcnRfeV9nZXR0ZXIgPSBudWxsO1xuICAgICAgICB0aGlzLl94X2dldHRlciA9IG51bGw7XG4gICAgICAgIHRoaXMuX3lfZ2V0dGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5fY29sb3VyID0gbnVsbDtcbiAgICAgICAgdGhpcy5fc2l6ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3NjYWxlX3ggPSBudWxsO1xuICAgICAgICB0aGlzLl9zY2FsZV95ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZmFjZXRfc2VsZWN0b3IgPSBudWxsO1xuICAgICAgICB0aGlzLl9jaGFydF9jb2xvdXJfc2NhbGUgPSBudWxsO1xuICAgICAgICB0aGlzLl9jb2xvdXJfc2NhbGUgPSBudWxsO1xuICAgICAgICB0aGlzLl9pbmRpdmlkdWFsX2NvbG91cnMgPSBudWxsO1xuICAgICAgICB0aGlzLl9jaGFydF9pbmRpdmlkdWFsX2NvbG91cnMgPSBudWxsO1xuICAgICAgICB0aGlzLl94X2Zvcm1hdHRlciA9IG51bGw7XG4gICAgICAgIHRoaXMuX3lfZm9ybWF0dGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5fY2hhcnRfeF9mb3JtYXR0ZXIgPSBudWxsO1xuICAgICAgICB0aGlzLl9jaGFydF95X2Zvcm1hdHRlciA9IG51bGw7XG4gICAgICAgIHRoaXMuX2xhYmVsX2Zvcm1hdHRlciA9IG51bGw7XG4gICAgICAgIHRoaXMuX2NoYXJ0X2xhYmVsX2Zvcm1hdHRlciA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByaW9yaXR5ID0gcHJpb3JpdHkgfHwgMTtcbiAgICAgICAgdGhpcy5fZGlzcGF0Y2ggPSBkMy5kaXNwYXRjaCgnZWxlbWVudENsaWNrJywgJ2VsZW1lbnRNaWRkbGVDbGljaycsICdlbGVtZW50UmlnaHRDbGljaycsXG4gICAgICAgICAgICAndG9vbHRpcFNob3cnLCAndG9vbHRpcEhpZGUnKTtcbiAgICAgICAgdGhpcy5fc2hvd19sYWJlbHMgPSBudWxsO1xuICAgICAgICB0aGlzLl9jaGFydF9zaG93X2xhYmVscyA9IG51bGw7XG4gICAgICAgIHRoaXMuX2QzX2NvbG91cl9zY2FsZSA9IG51bGw7XG4gICAgfVxuXG4gICAgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJvdmlkZXMgYSBzb3J0IG9yZGVyIHByaW9yaXR5IGZvciBtZXRyaWNzLiBNZXRyaWNzIHdpdGggYSBoaWdoZXIgcHJpb3JpdHlcbiAgICAgKiBhcmUgZHJhd24gb24gdG9wIG9mIGxvd2VyIHByaW9yaXR5IG1ldHJpY3MuXG4gICAgICovXG4gICAgcHJpb3JpdHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcmlvcml0eTtcbiAgICB9XG5cbiAgICBlbGVtZW50KGVsKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5fZWxlbWVudDtcbiAgICAgICAgdGhpcy5fZWxlbWVudCA9IGVsO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB4KGdldHRlcikge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX3hfZ2V0dGVyIHx8IHRoaXMuX2NoYXJ0X3hfZ2V0dGVyO1xuICAgICAgICBpZiAodHlwZW9mIGdldHRlciAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IEVycm9yKFwieCBnZXR0ZXIgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICB0aGlzLl94X2dldHRlciA9IGdldHRlcjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgeShnZXR0ZXIpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl95X2dldHRlciB8fCB0aGlzLl9jaGFydF95X2dldHRlcjtcbiAgICAgICAgaWYgKHR5cGVvZiBnZXR0ZXIgIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBFcnJvcihcInkgZ2V0dGVyIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgdGhpcy5feV9nZXR0ZXIgPSBnZXR0ZXI7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHNldHVwWChnZXR0ZXIpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl9jaGFydF94X2dldHRlcjtcbiAgICAgICAgaWYgKHR5cGVvZiBnZXR0ZXIgIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBFcnJvcihcInggZ2V0dGVyIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgdGhpcy5fY2hhcnRfeF9nZXR0ZXIgPSBnZXR0ZXI7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHNldHVwWShnZXR0ZXIpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl9jaGFydF95X2dldHRlcjtcbiAgICAgICAgaWYgKHR5cGVvZiBnZXR0ZXIgIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBFcnJvcihcInkgZ2V0dGVyIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgdGhpcy5fY2hhcnRfeV9nZXR0ZXIgPSBnZXR0ZXI7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGNvbG91cihjb2xvdXIpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl9jb2xvdXIgfHwgdGhpcy5fY2hhcnRfY29sb3VyO1xuICAgICAgICB0aGlzLl9jb2xvdXIgPSBjb2xvdXI7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHNldHVwQ29sb3VyKGNvbG91cikge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX2NoYXJ0X2NvbG91cjtcbiAgICAgICAgdGhpcy5fY2hhcnRfY29sb3VyID0gY29sb3VyO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBjb2xvdXJTY2FsZShjb2xvdXJzKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5fY2hhcnRfY29sb3VyX3NjYWxlIHx8IHRoaXMuX2NvbG91cl9zY2FsZTtcbiAgICAgICAgaWYgKHR5cGVvZiBjb2xvdXJzICE9PSAnb2JqZWN0JyB8fCAhY29sb3Vycy5sZW5ndGgpIHRocm93IG5ldyBFcnJvcihcImNvbG91ciBtdXN0IGJlIGFuIEFycmF5XCIpO1xuICAgICAgICB0aGlzLl9jb2xvdXJfc2NhbGUgPSBjb2xvdXJzO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzZXR1cENvbG91clNjYWxlKGNvbG91cnMpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl9jaGFydF9jb2xvdXJfc2NhbGU7XG4gICAgICAgIGlmICh0eXBlb2YgY29sb3VycyAhPT0gJ29iamVjdCcgfHwgIWNvbG91cnMubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoXCJjb2xvdXIgbXVzdCBiZSBhbiBBcnJheVwiKTtcbiAgICAgICAgdGhpcy5fY2hhcnRfY29sb3VyX3NjYWxlID0gY29sb3VycztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaW5kaXZpZHVhbENvbG91cnMoY29sb3VyTWFwKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5fY2hhcnRfaW5kaXZpZHVhbF9jb2xvdXJzIHx8IHRoaXMuX2luZGl2aWR1YWxfY29sb3VycztcbiAgICAgICAgdGhpcy5faW5kaXZpZHVhbF9jb2xvdXJzID0gY29sb3VyTWFwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzZXR1cEluZGl2aWR1YWxDb2xvdXJzKGNvbG91ck1hcCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX2NoYXJ0X2luZGl2aWR1YWxfY29sb3VycztcbiAgICAgICAgdGhpcy5fY2hhcnRfaW5kaXZpZHVhbF9jb2xvdXJzID0gY29sb3VyTWFwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBkM0NvbG91clNjYWxlKHNjYWxlKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5fZDNfY29sb3VyX3NjYWxlO1xuICAgICAgICB0aGlzLl9kM19jb2xvdXJfc2NhbGUgPSBzY2FsZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZ2V0RDNDb2xvdXIoZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmRpdmlkdWFsQ29sb3VycygpW2QuX3hdIHx8IHRoaXMuZDNDb2xvdXJTY2FsZSgpKGQuX2NvbG91cik7XG4gICAgfVxuXG4gICAgc2l6ZShzaXplKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5fc2l6ZSB8fCB0aGlzLl9jaGFydF9zaXplO1xuICAgICAgICB0aGlzLl9zaXplID0gc2l6ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgc2V0dXBTaXplKHNpemUpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl9jaGFydF9zaXplO1xuICAgICAgICB0aGlzLl9jaGFydF9zaXplID0gc2l6ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgc2NhbGVYKHNjYWxlKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5fc2NhbGVfeCB8fCB0aGlzLl9jaGFydF9zY2FsZV94O1xuICAgICAgICB0aGlzLl9zY2FsZV94ID0gc2NhbGU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHNldHVwU2NhbGVYKHNjYWxlKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5fY2hhcnRfc2NhbGVfeDtcbiAgICAgICAgdGhpcy5fY2hhcnRfc2NhbGVfeCA9IHNjYWxlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzY2FsZVkoc2NhbGUpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl9zY2FsZV95IHx8IHRoaXMuX2NoYXJ0X3NjYWxlX3k7XG4gICAgICAgIHRoaXMuX3NjYWxlX3kgPSBzY2FsZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgc2V0dXBTY2FsZVkoc2NhbGUpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl9jaGFydF9zY2FsZV95O1xuICAgICAgICB0aGlzLl9jaGFydF9zY2FsZV95ID0gc2NhbGU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZvcm1hdFgoZm9ybWF0dGVyKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5feF9mb3JtYXR0ZXIgfHwgdGhpcy5fY2hhcnRfeF9mb3JtYXR0ZXI7XG4gICAgICAgIGlmICh0eXBlb2YgZm9ybWF0dGVyICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgRXJyb3IoXCJmb3JtYXR0ZXIgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICB0aGlzLl94X2Zvcm1hdHRlciA9IGZvcm1hdHRlcjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgc2V0dXBGb3JtYXRYKGZvcm1hdHRlcikge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX2NoYXJ0X3hfZm9ybWF0dGVyO1xuICAgICAgICBpZiAodHlwZW9mIGZvcm1hdHRlciAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IEVycm9yKFwiZm9ybWF0dGVyIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgdGhpcy5fY2hhcnRfeF9mb3JtYXR0ZXIgPSBmb3JtYXR0ZXI7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZvcm1hdFkoZm9ybWF0dGVyKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5feV9mb3JtYXR0ZXIgfHwgdGhpcy5fY2hhcnRfeV9mb3JtYXR0ZXI7XG4gICAgICAgIGlmICh0eXBlb2YgZm9ybWF0dGVyICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgRXJyb3IoXCJmb3JtYXR0ZXIgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICB0aGlzLl95X2Zvcm1hdHRlciA9IGZvcm1hdHRlcjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgc2V0dXBGb3JtYXRZKGZvcm1hdHRlcikge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX2NoYXJ0X3lfZm9ybWF0dGVyO1xuICAgICAgICBpZiAodHlwZW9mIGZvcm1hdHRlciAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IEVycm9yKFwiZm9ybWF0dGVyIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgdGhpcy5fY2hhcnRfeV9mb3JtYXR0ZXIgPSBmb3JtYXR0ZXI7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZvcm1hdExhYmVsKGZvcm1hdHRlcikge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX2xhYmVsX2Zvcm1hdHRlciB8fCB0aGlzLl9jaGFydF9sYWJlbF9mb3JtYXR0ZXIgfHwgdGhpcy5mb3JtYXRZKCk7XG4gICAgICAgIGlmICh0eXBlb2YgZm9ybWF0dGVyICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgRXJyb3IoXCJmb3JtYXR0ZXIgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICB0aGlzLl9sYWJlbF9mb3JtYXR0ZXIgPSBmb3JtYXR0ZXI7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHNldHVwRm9ybWF0TGFiZWwoZm9ybWF0dGVyKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5fY2hhcnRfbGFiZWxfZm9ybWF0dGVyO1xuICAgICAgICB0aGlzLl9jaGFydF9sYWJlbF9mb3JtYXR0ZXIgPSBmb3JtYXR0ZXI7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuXG4gICAgd2lkdGgod2lkdGgpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl93aWR0aDtcbiAgICAgICAgdGhpcy5fd2lkdGggPSB3aWR0aDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaGVpZ2h0KGhlaWdodCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX2hlaWdodDtcbiAgICAgICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzaG93TGFiZWxzKHNob3cpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl9jaGFydF9zaG93X2xhYmVscyB8fCB0aGlzLl9zaG93X2xhYmVscztcbiAgICAgICAgdGhpcy5fc2hvd19sYWJlbHMgPSAhIXNob3c7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHNldHVwU2hvd0xhYmVscyhzaG93KSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5fY2hhcnRfc2hvd19sYWJlbHM7XG4gICAgICAgIHRoaXMuX2NoYXJ0X3Nob3dfbGFiZWxzID0gISFzaG93O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpbW1lZGlhdGVseVJlbmRlckxhYmVscyhzaG93KSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIiNpbW1lZGlhdGVseVJlbmRlckxhYmVscyBub3QgaW1wbGVtZW50ZWQgZm9yXCIsIHRoaXMubmFtZSgpKTtcbiAgICB9XG5cbiAgICBkYXRhKGRhdGEpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl9kYXRhO1xuICAgICAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZmFjZXQoc2VsZWN0b3IpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl9mYWNldF9zZWxlY3RvcjtcbiAgICAgICAgaWYgKHNlbGVjdG9yICE9IG51bGwgJiYgdHlwZW9mIHNlbGVjdG9yICE9PSAnZnVuY3Rpb24nICYmIHNlbGVjdG9yICE9PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IoXCJGYWNldCBzZWxlY3RvciBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG4gICAgICAgIHRoaXMuX2ZhY2V0X3NlbGVjdG9yID0gc2VsZWN0b3I7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuXG4gICAgLypcbiAgICAgKiBUaGlzIHRha2VzIG91ciBhcnJheSBvZiBkYXRhLCBhbmQgZGV0ZXJtaW5lcyB3aGF0IGVsZW1lbnRzXG4gICAgICogYXJlIHRvIGJlIG1hcHBlZCB0byB3aGF0IGFlc3RoZXRpYyB2YWx1ZXMsIHN1Y2ggYXMgY29sb3VyIG9yIHNpemUuXG4gICAgICogRGF0YSBpcyBncm91cGVkIGJ5IHRoZXNlIGZpZWxkcy5cbiAgICAgKi9cbiAgICBwcmVwYXJlRGF0YShkYXRhLCBmYWNldGVkKSB7XG4gICAgICAgIGZhY2V0ZWQgPSAhIWZhY2V0ZWQgJiYgdGhpcy5mYWNldCgpO1xuICAgICAgICBkYXRhID0gZGF0YSB8fCB0aGlzLl9kYXRhO1xuICAgICAgICBpZiAoIWRhdGEgfHwgIWRhdGEubGVuZ3RoKSByZXR1cm4gW107XG5cbiAgICAgICAgY29uc3QgeCA9IHRoaXMueCgpLFxuICAgICAgICAgICAgICB5ID0gdGhpcy55KCksXG4gICAgICAgICAgICAgIHNjYWxlWCA9IHRoaXMuc2NhbGVYKCksXG4gICAgICAgICAgICAgIHNjYWxlWSA9IHRoaXMuc2NhbGVZKCk7XG5cbiAgICAgICAgbGV0IG1hcHBlZCA9IHt9O1xuXG4gICAgICAgIGRhdGEuZm9yRWFjaChkID0+IHtcbiAgICAgICAgICAgIGlmIChmYWNldGVkICYmICF0aGlzLmZhY2V0KCkoZCkpIHJldHVybjtcbiAgICAgICAgICAgIGNvbnN0IG9iamVjdCA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgICAgIF94OiBzY2FsZVgudHJhbnNmb3JtKHgoZCkpLFxuICAgICAgICAgICAgICAgIF95OiBzY2FsZVkudHJhbnNmb3JtKHkoZCkpLFxuICAgICAgICAgICAgICAgIF9jb2xvdXI6IHRoaXMuY29sb3VyKCkoZCksXG4gICAgICAgICAgICAgICAgX3NpemU6IHRoaXMuc2l6ZSgpKGQpXG4gICAgICAgICAgICB9LCBkKTtcblxuICAgICAgICAgICAgY29uc3Qga2V5ID0gZ2V0S2V5KG9iamVjdCk7XG4gICAgICAgICAgICBvYmplY3QuX2tleSA9IGtleTtcblxuICAgICAgICAgICAgbGV0IHNlcmllcyA9IG1hcHBlZFtrZXldIHx8IGdldEtleVBhcmFtZXRlcnMob2JqZWN0KTtcbiAgICAgICAgICAgIHNlcmllcy5kYXRhLnB1c2gob2JqZWN0KTtcbiAgICAgICAgICAgIG1hcHBlZFtrZXldID0gc2VyaWVzO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyhtYXBwZWQpO1xuICAgIH1cblxuICAgIGdldEQzWFNjYWxlKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJnZXREM1hTY2FsZSBub3QgaW1wbGVtZW50ZWQgZm9yIFwiICsgdGhpcy5uYW1lKCkpO1xuICAgIH1cblxuICAgIGdldEQzWVNjYWxlKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJnZXREM1lTY2FsZSBub3QgaW1wbGVtZW50ZWQgZm9yIFwiICsgdGhpcy5uYW1lKCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBhbGwgdGhlIFkgdmFsdWVzIGZvciB0aGlzIGdlb21ldHJ5LCBpZ25vcmluZyBmYWNldGluZy5cbiAgICAgKi9cbiAgICB5VmFsdWVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhKClcbiAgICAgICAgICAgIC5tYXAoZCA9PiB0aGlzLnkoKShkKSlcbiAgICAgICAgICAgIC5tYXAoZCA9PiB0aGlzLnNjYWxlWSgpLnRyYW5zZm9ybShkKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGFsbCB0aGUgWSB2YWx1ZXMgZm9yIHRoaXMgZ2VvbWV0cnksIGlnbm9yaW5nIGZhY2V0aW5nLlxuICAgICAqL1xuICAgIHhWYWx1ZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEoKVxuICAgICAgICAgICAgICAgICAgIC5tYXAoZCA9PiB0aGlzLngoKShkKSlcbiAgICAgICAgICAgICAgICAgICAubWFwKGQgPT4gdGhpcy5zY2FsZVgoKS50cmFuc2Zvcm0oZCkpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogSW1wbGVtZW50IHlvdXIgcmVuZGVyIGNvZGUgaGVyZS5cbiAgICAgKi9cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJFTkRFUiBOT1QgSU1QTEVNRU5URUQgRk9SIFwiICsgdGhpcy5uYW1lKCkpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdW5pcXVlIHZhbHVlcyB0aGF0IHRoZSBjb2xvdXIgZnVuY3Rpb25cbiAgICAgKiByZXR1cm5zLlxuICAgICAqIEBwYXJhbSBkYXRhXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZ2V0Q29sb3VyRG9tYWluKGRhdGEpIHtcbiAgICAgICAgaWYgKCFkYXRhIHx8ICFkYXRhLmxlbmd0aCkgcmV0dXJuIFtdO1xuXG4gICAgICAgIGNvbnN0IGNvbG91cnMgPSBuZXcgU2V0KCk7XG5cbiAgICAgICAgLy8gdG9kbyBjYWxjdWxhdGUgYnVja2V0c1xuICAgICAgICBkYXRhLmZvckVhY2goc2VyaWVzID0+IHtcbiAgICAgICAgICAgIHNlcmllcy5kYXRhLmZvckVhY2goZCA9PiB7XG4gICAgICAgICAgICAgICAgY29sb3Vycy5hZGQodGhpcy5jb2xvdXIoKShkKSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gWy4uLmNvbG91cnNdXG4gICAgfVxuXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRLZXkoZCkge1xuICAgIC8vIFRPRE8gd2UgcHJvYmFibHkgbmVlZCB0byBlbmNvZGUgdGhpcyBiZXR0ZXIgc28gd2UgY2FuIHNwbGl0IG9uIHRoZSA6XG4gICAgcmV0dXJuIFwiXCIgKyBkLl9zaXplICsgXCI6XCIgKyBkLl9jb2xvdXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tS2V5KGtleSkge1xuICAgIGNvbnN0IHNwbGl0ID0ga2V5LnNwbGl0KFwiOlwiKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBfc2l6ZTogc3BsaXRbMF0sXG4gICAgICAgIF9jb2xvdXI6IHNwbGl0WzFdLFxuICAgICAgICBfa2V5OiBrZXlcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdldEtleVBhcmFtZXRlcnMoZCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIF9rZXk6IGdldEtleShkKSxcbiAgICAgICAgX3NpemU6IGQuX3NpemUsXG4gICAgICAgIF9jb2xvdXI6IGQuX2NvbG91cixcbiAgICAgICAgZGF0YTogW11cbiAgICB9XG59Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/Geometry.js\n");

/***/ }),

/***/ "./src/Histogram.js":
/*!**************************!*\
  !*** ./src/Histogram.js ***!
  \**************************/
/*! exports provided: histogram, columnChart */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"histogram\", function() { return histogram; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"columnChart\", function() { return columnChart; });\n/* harmony import */ var _Geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Geometry */ \"./src/Geometry.js\");\n/* harmony import */ var _Colours__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Colours */ \"./src/Colours.js\");\n/* harmony import */ var _Legend__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Legend */ \"./src/Legend.js\");\n// Copyright (C) 2013-2014, 2018 BrandsEye (PTY) LTD\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this\n// software and associated documentation files (the \"Software\"), to deal in the Software\n// without restriction, including without limitation the rights to use, copy, modify,\n//     merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following\n// conditions:\n//\n//     The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n//     INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n// CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n\n\n\nclass Histogram extends _Geometry__WEBPACK_IMPORTED_MODULE_0__[\"Geometry\"] {\n\n    constructor(name, padding) {\n        super(name || \"HISTOGRAM\");\n        this._BAR_GROWTH = 100;\n        this._padding = padding || 0;\n    }\n\n    /**\n     * Set the padding between bar groups. 0 padding is a standard histogram.\n     */\n    padding(padding) {\n        if (arguments.length === 0) return this._padding;\n        this._padding = padding;\n        return this;\n    }\n\n    render() {\n        console.log(\"\\tRendering HISTOGRAM\");\n\n        const element = this._element;\n        const data = this.prepareData(null, true);\n        const allData = this.prepareData(null, false);\n        const width = this._width,\n              height = this._height;\n\n        element.classed(\"histogram\", true);\n\n        console.log(\"histgoram with\", width, \"height\", height);\n        console.log(\"\\tdata\", data);\n        const x = this.getD3XScale(data, width);\n        const y = this.getD3YScale(allData, height);\n        const xGroup = this.getD3XGroupScale(data, x);\n        const colours = this.d3ColourScale();\n\n        let groups = element.select(\".bars\").selectAll('.group');\n\n        //----------------------------------------------\n        // Get rid of current labels\n\n        element.select(\".chart-labels\")\n           .remove();\n\n        //----------------------------------------------\n\n        if (groups.empty()) {\n            groups = element\n                .append(\"g\")\n                .attr(\"class\", \"bars\")\n                .selectAll(\".group\");\n        }\n\n        // Ensure that we're always using the correct height.\n        element.select(\".bars\")\n           .attr(\"transform\", \"translate(0, \" + height + \"), scale(1, -1)\");\n\n        groups = groups.data(data);\n\n        groups.exit().remove();\n\n        groups.enter()\n              .append(\"g\")\n                  .attr(\"class\", \"group\")\n                  .attr(\"transform\", d => \"translate(\" + x(d._key) + \",0)\")\n                  .attr(\"width\", x.bandwidth())\n                  .attr(\"height\", \"100%\")\n              .merge(groups)\n              .interrupt(\"groups:move\")\n              .transition(\"groups:move\")\n                  .attr(\"transform\", d => \"translate(\" + x(d._key) + \",0)\")\n                  .attr(\"width\", x.bandwidth())\n              .each((s_d, s_i, nodes) => {\n                  let group = d3.select(nodes[s_i]);\n\n                  let bars = group.selectAll(\".bar\")\n                                  .data(s_d.data);\n\n                  bars.exit().remove();\n\n                  bars.interrupt(\"bar:move\")     // Animate the bars to their new position.\n                      .transition(\"bar:move\")\n                      .attr(\"width\", xGroup.bandwidth())\n                      .attr(\"x\", d => xGroup(d._key))\n                      .attr(\"y\", 0);\n\n                  bars.enter()\n                      .append(\"rect\")\n                          .attr(\"class\", (d, i) => \"bar series series-\" + Object(_Legend__WEBPACK_IMPORTED_MODULE_2__[\"toColourKey\"])(d._colour))\n                          .attr(\"x\", d => xGroup(d._key))\n                          // .attr(\"y\", d => height - y(Math.min(0, d._y)))\n                      .attr(\"y\", height - y(0))\n                          .attr(\"width\", xGroup.bandwidth())\n                          .attr(\"height\", 0)\n                          .style(\"cursor\", \"pointer\")\n                          .style(\"fill\", d => this.getD3Colour(d)) // colours(d._colour))\n                          .style(\"stroke\", d => d3.hcl(this.getD3Colour(d)).darker())\n                      .on(\"contextmenu\", () => d3.event.preventDefault()) // No right click.\n                      .merge(bars)\n                      .on(\"click auxclick\", (d, i, nodes) => {\n                          this._dispatch.call(\"elementClick\", this, {\n                              e: d3.event,\n                              point: d,\n                              series: d._series,\n                              seriesIndex: s_i,\n                              value: d._y\n                          })\n                      })\n                      .on(\"mouseover\", (d, i, nodes) => { // Darken the bar on mouse over\n                          d3.select(nodes[i])\n                            .interrupt(\"hover:colour\")\n                            .transition(\"hover:colour\")\n                            .duration(400)\n                            .style(\"fill\", d3.hcl(this.getD3Colour(d)).darker());\n                          this._dispatch.call(\"tooltipShow\", this, {\n                              e: d3.event,\n                              point: d,\n                              series: s_d,\n                              seriesIndex: s_i,\n                              value: d._y\n                          })\n                      })\n                      .on(\"mouseout\", (d, i, nodes) => { // bar is regular colour on mouse out.\n                          d3.select(nodes[i])\n                            .interrupt(\"hover:colour\")\n                            .transition(\"hover:colour\")\n                            .duration(400)\n                            .style(\"fill\", d => this.getD3Colour(d));\n                          this._dispatch.call(\"tooltipHide\", this);\n                      })\n                      .interrupt(\"bar:growth\")    // Animate bars growing.\n                      .transition(\"bar:growth\")\n                      .delay(() => this.calcBarGrowth(s_i, nodes.length))\n                          .style(\"fill\", d => this.getD3Colour(d)) //colours(d._colour))\n                          .style(\"stroke\", d => d3.hcl(this.getD3Colour(d)).darker())\n                          .attr(\"y\", d => height - y(Math.min(0, d._y)))\n                          .attr(\"height\", d => (Math.abs(y(0) - y(d._y))));\n              });\n\n        // Labels loaded after our last bar grows.\n        if (this.showLabels()) {\n            element.transition(\"bar:growth\")\n               .on(\"end\", (d, i, nodes) => {\n                   if (i < nodes.length - 1) return;\n                   this.renderLabels(element, data, x, xGroup, y, colours);\n               })\n        }\n    }\n\n    calcBarGrowth(i, max) {\n        if (max < 10) return i * this._BAR_GROWTH / 2;\n        if (max < 35) return i * this._BAR_GROWTH / 4;\n        return 1;\n    }\n\n    prepareData(data, faceted) {\n        data = _Geometry__WEBPACK_IMPORTED_MODULE_0__[\"Geometry\"].prototype.prepareData.call(this, data, faceted);\n\n        const sortOrder = {};\n        this.xValues().forEach((d, i) => {\n            sortOrder[d] = sortOrder[d] || (\"\" + i);\n        });\n\n        let results = {};\n\n        // We want to calculate what bucket each bit of data belongs to.\n        const buckets = this.scaleX()\n                            .buckets(Object\n                                .values(data)\n                                .map(d => d.data)\n                                .reduce((acc, cur) => acc.concat(cur))\n                                .map(d => d._x));\n\n        // Sort data in to their appropriate buckets. This may be\n        // specific date buckets, or general buckets for continuous data.\n        Object.keys(data).forEach(key => {\n            let values = data[key].data;\n            values.forEach(d => {\n                d._bucket = buckets.bucket(d._x);\n                let bucket = results[d._bucket] || { _key: d._bucket, data: [] };\n                bucket.data.push(d);\n                results[d._bucket] = bucket;\n            })\n        });\n\n        return buckets.consolidateBuckets(Object.values(results))\n            .sort((lhs, rhs) => {\n                return sortOrder[\"\" + lhs._key] - sortOrder[\"\" + rhs._key];\n            });\n    }\n\n    getKeys(data) {\n        if (!data || !data.length) return [];\n\n        let keys = new Set();\n\n        // todo calculate buckets\n        Object.keys(data).forEach(key => {\n            let values = data[key].data;\n            values.forEach(d => keys.add(d._key))\n        });\n\n\n        return [...keys]\n    }\n\n    getD3XScale(data, width) {\n        data = data || this.prepareData(null, true);\n        width = width || this.width();\n\n        return d3.scaleBand()\n                 .rangeRound([0, width])\n                 .padding((data[0].data.length > 1 ? 0.2 : 0) + this._padding)\n                 .domain(data.map(d => d._key));\n    }\n\n    getD3YScale(data, height) {\n        data = data || this.prepareData(null, false);\n        height = height || this.height();\n\n\n        const max = Math.max(d3.max(data, d => d3.max(d.data, d => d._y)), 0);\n        const min = Math.min(0, d3.min(data, d => d3.min(d.data, d => d._y)));\n        return d3.scaleLinear()\n                 .rangeRound([height, 0])\n                 .nice()\n                 .domain([min, max]);\n    }\n\n    getD3XGroupScale(data, xscale) {\n        return d3.scaleBand()\n                 .padding(0)\n                 .domain(this.getKeys(data))\n                 .rangeRound([0, xscale.bandwidth()]);\n    }\n\n    renderLabels(selection, data, xscale, xgroup, yscale, colourScale, animate) {\n        animate = animate === undefined ? true : animate;\n        selection.selectAll(\".chart-labels\").remove();\n\n        let labels = selection.append(\"g\")\n                              .attr(\"class\", \"chart-labels\")\n                              .selectAll(\".label-group\")\n                              .data(data);\n\n        let maxWidth = 0;     // For calculating the max width of text.\n        let fontSize = 12;    // Our initial font size.\n        const buffer = 5;     // Buffer space between words and the top of a bar.\n        const calcDy = (y, ypos) => ((y >= 0 && ypos < 10) || ( y < 0 && this._height - ypos > 10)) ? fontSize + 2: -buffer;\n\n        // Want to figure out if the label is too dark / light for the\n        // bar.\n        const getInvertedColor = d => {\n            let invertedColor = d3.hcl(this.getD3Colour(d));\n            invertedColor.l += Math.min(invertedColor.l + 50, 100);\n            return invertedColor;\n        };\n        const shouldInvert = d => d3.hcl(this.getD3Colour(d)).l < 60;\n        const fillColour = d3.hcl(_Colours__WEBPACK_IMPORTED_MODULE_1__[\"colours\"].eighteen.darkGrey).brighter();\n        const lighterFillColour = d3.hcl(_Colours__WEBPACK_IMPORTED_MODULE_1__[\"colours\"].eighteen.midGrey);\n        const findColour = (d, dy, labelText) => (d._y >= 0 && dy > 0 || d._y < 0 && dy < 0) && shouldInvert(d)? getInvertedColor(d).toString() : (labelText === \"0\" ? lighterFillColour : fillColour);\n\n        labels.enter().each((series, s_i, s_nodes) => {\n            // We want to determine which groups may have missing values, and provide them.\n            const requiredGroups = {};\n            xgroup.domain().map(_Geometry__WEBPACK_IMPORTED_MODULE_0__[\"fromKey\"]).forEach(d => {\n                requiredGroups[d._colour] = d;\n            });\n\n            series.data.forEach(d => {\n                delete requiredGroups[d._colour]\n            });\n\n            const missingGroups = Object.values(requiredGroups);\n            missingGroups.forEach(d => {\n                d._x = series._key;\n                d._y = 0;\n            });\n\n            d3.select(s_nodes[s_i])\n              .append(\"g\")\n              .attr(\"class\", \"label-group\")\n              .attr(\"transform\", d => \"translate(\" + xscale(d._key) + \",0)\")\n              .selectAll(\".chart-label\")\n              .data(series.data.concat(Object.values(missingGroups)))\n              .enter()\n              .each((d, i, nodes) => {\n                  const labelText = this.formatLabel()(d._y);\n                  let ypos = yscale(d._y);\n                  let dy = calcDy(d._y, ypos);\n                  let text = d3.select(nodes[i])\n                               .append(\"text\")\n                               .text(labelText)\n                               .attr(\"class\", \"chart-label\")\n                               .attr(\"y\", ypos)\n                               .attr(\"dx\", animate ? -15 : 0)\n                               .attr(\"dy\", dy)\n                               .style(\"opacity\", 0)\n                               .style(\"pointer-events\", \"none\")\n                               .style(\"fill\", d => findColour(d, dy, labelText));\n\n                  // Set the x position, which is based on width.\n                  const width = text.node().getBBox().width;\n                  maxWidth = Math.max(width, maxWidth);\n                  text\n                      .attr(\"x\", xgroup(d._key) + xgroup.bandwidth() / 2 - width / 2);\n\n                  text\n                      .transition(\"labels\")\n                      .delay(() => animate ? this.calcBarGrowth(s_i, s_nodes.length) : 0) // Delay in lockstep with bar growth.\n                      .attr(\"dx\", 0)\n                      .style(\"opacity\", 1)\n              })\n        });\n\n\n        // Figure out if we don't have enough space to show our labels.\n        // We then want to resize, if possible.\n        if (xgroup.bandwidth() < maxWidth * 1.10) {\n            let scale = maxWidth / xgroup.bandwidth() * 1.10;\n            fontSize = Math.floor(fontSize / scale);\n\n            if (fontSize < 8) {\n                // The labels are too small.\n                labels.enter().selectAll(\"text\").remove();\n            } else {\n                labels.enter()\n                      .merge(labels)\n                      .selectAll(\"text\")\n                      .style(\"font-size\", fontSize + \"px\")\n                      .each((d, i, nodes) => {\n                          const text = d3.select(nodes[i]);\n                          const width = text.node().getBBox().width;\n                          const dy = calcDy(d._y, yscale(d._y));\n\n                          text\n                              .attr(\"x\", xgroup(d._key) + xgroup.bandwidth() / 2 - width / 2)\n                              .style(\"fill\", d => findColour(d, dy, text.text()))\n                              .attr(\"dy\", dy);\n                      })\n            }\n        }\n    }\n\n\n    immediatelyRenderLabels(show) {\n        const element = this.element();\n        if (!element) return;\n\n        if (!show) { // Hides the labels\n            element\n              .select('.chart-labels')\n              .interrupt(\"labels\")\n              .interrupt(\"labels:fade\")\n              .transition(\"labels:fade\")\n              .style(\"opacity\", 0)\n              .on(\"end\", (d, i, nodes) => {\n                  d3.select(nodes[i]).remove();\n              })\n        } else {\n            let labels = element.select('.chart-labels');\n            if (!labels.empty()) return;\n\n            const data = this.prepareData(null, true);\n            const allData = this.prepareData(null, false);\n\n            const xscale = this.getD3XScale(data),\n                  xgroup = this.getD3XGroupScale(data, xscale),\n                  yscale = this.getD3YScale(data),\n                  colourScale = this.d3ColourScale();\n\n            labels.remove();\n            this.renderLabels(element, data, xscale, xgroup, yscale, colourScale, false);\n        }\n\n    }\n\n\n}\n\n\nfunction histogram() {\n    return new Histogram();\n}\n\nfunction columnChart() {\n    return new Histogram(\"COLUMN_CHART\", 0.1);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvSGlzdG9ncmFtLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYjNqcy8uL3NyYy9IaXN0b2dyYW0uanM/YzZlYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKEMpIDIwMTMtMjAxNCwgMjAxOCBCcmFuZHNFeWUgKFBUWSkgTFREXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZiB0aGlzXG4vLyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmVcbi8vIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSxcbi8vICAgICBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvXG4vLyBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZ1xuLy8gY29uZGl0aW9uczpcbi8vXG4vLyAgICAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4vLyBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vICAgICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SIElNUExJRUQsXG4vLyAgICAgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEFcbi8vIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFRcbi8vIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRlxuLy8gQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFXG4vLyBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IHsgR2VvbWV0cnksIGZyb21LZXkgfSBmcm9tICcuL0dlb21ldHJ5JztcbmltcG9ydCB7IGNvbG91cnMgfSBmcm9tIFwiLi9Db2xvdXJzXCI7XG5pbXBvcnQgeyB0b0NvbG91cktleSB9IGZyb20gXCIuL0xlZ2VuZFwiO1xuXG5cbmNsYXNzIEhpc3RvZ3JhbSBleHRlbmRzIEdlb21ldHJ5IHtcblxuICAgIGNvbnN0cnVjdG9yKG5hbWUsIHBhZGRpbmcpIHtcbiAgICAgICAgc3VwZXIobmFtZSB8fCBcIkhJU1RPR1JBTVwiKTtcbiAgICAgICAgdGhpcy5fQkFSX0dST1dUSCA9IDEwMDtcbiAgICAgICAgdGhpcy5fcGFkZGluZyA9IHBhZGRpbmcgfHwgMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHBhZGRpbmcgYmV0d2VlbiBiYXIgZ3JvdXBzLiAwIHBhZGRpbmcgaXMgYSBzdGFuZGFyZCBoaXN0b2dyYW0uXG4gICAgICovXG4gICAgcGFkZGluZyhwYWRkaW5nKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5fcGFkZGluZztcbiAgICAgICAgdGhpcy5fcGFkZGluZyA9IHBhZGRpbmc7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJcXHRSZW5kZXJpbmcgSElTVE9HUkFNXCIpO1xuXG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLl9lbGVtZW50O1xuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5wcmVwYXJlRGF0YShudWxsLCB0cnVlKTtcbiAgICAgICAgY29uc3QgYWxsRGF0YSA9IHRoaXMucHJlcGFyZURhdGEobnVsbCwgZmFsc2UpO1xuICAgICAgICBjb25zdCB3aWR0aCA9IHRoaXMuX3dpZHRoLFxuICAgICAgICAgICAgICBoZWlnaHQgPSB0aGlzLl9oZWlnaHQ7XG5cbiAgICAgICAgZWxlbWVudC5jbGFzc2VkKFwiaGlzdG9ncmFtXCIsIHRydWUpO1xuXG4gICAgICAgIGNvbnNvbGUubG9nKFwiaGlzdGdvcmFtIHdpdGhcIiwgd2lkdGgsIFwiaGVpZ2h0XCIsIGhlaWdodCk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiXFx0ZGF0YVwiLCBkYXRhKTtcbiAgICAgICAgY29uc3QgeCA9IHRoaXMuZ2V0RDNYU2NhbGUoZGF0YSwgd2lkdGgpO1xuICAgICAgICBjb25zdCB5ID0gdGhpcy5nZXREM1lTY2FsZShhbGxEYXRhLCBoZWlnaHQpO1xuICAgICAgICBjb25zdCB4R3JvdXAgPSB0aGlzLmdldEQzWEdyb3VwU2NhbGUoZGF0YSwgeCk7XG4gICAgICAgIGNvbnN0IGNvbG91cnMgPSB0aGlzLmQzQ29sb3VyU2NhbGUoKTtcblxuICAgICAgICBsZXQgZ3JvdXBzID0gZWxlbWVudC5zZWxlY3QoXCIuYmFyc1wiKS5zZWxlY3RBbGwoJy5ncm91cCcpO1xuXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBHZXQgcmlkIG9mIGN1cnJlbnQgbGFiZWxzXG5cbiAgICAgICAgZWxlbWVudC5zZWxlY3QoXCIuY2hhcnQtbGFiZWxzXCIpXG4gICAgICAgICAgIC5yZW1vdmUoKTtcblxuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICBpZiAoZ3JvdXBzLmVtcHR5KCkpIHtcbiAgICAgICAgICAgIGdyb3VwcyA9IGVsZW1lbnRcbiAgICAgICAgICAgICAgICAuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJiYXJzXCIpXG4gICAgICAgICAgICAgICAgLnNlbGVjdEFsbChcIi5ncm91cFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEVuc3VyZSB0aGF0IHdlJ3JlIGFsd2F5cyB1c2luZyB0aGUgY29ycmVjdCBoZWlnaHQuXG4gICAgICAgIGVsZW1lbnQuc2VsZWN0KFwiLmJhcnNcIilcbiAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoMCwgXCIgKyBoZWlnaHQgKyBcIiksIHNjYWxlKDEsIC0xKVwiKTtcblxuICAgICAgICBncm91cHMgPSBncm91cHMuZGF0YShkYXRhKTtcblxuICAgICAgICBncm91cHMuZXhpdCgpLnJlbW92ZSgpO1xuXG4gICAgICAgIGdyb3Vwcy5lbnRlcigpXG4gICAgICAgICAgICAgIC5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwiZ3JvdXBcIilcbiAgICAgICAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIGQgPT4gXCJ0cmFuc2xhdGUoXCIgKyB4KGQuX2tleSkgKyBcIiwwKVwiKVxuICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCB4LmJhbmR3aWR0aCgpKVxuICAgICAgICAgICAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgXCIxMDAlXCIpXG4gICAgICAgICAgICAgIC5tZXJnZShncm91cHMpXG4gICAgICAgICAgICAgIC5pbnRlcnJ1cHQoXCJncm91cHM6bW92ZVwiKVxuICAgICAgICAgICAgICAudHJhbnNpdGlvbihcImdyb3Vwczptb3ZlXCIpXG4gICAgICAgICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBkID0+IFwidHJhbnNsYXRlKFwiICsgeChkLl9rZXkpICsgXCIsMClcIilcbiAgICAgICAgICAgICAgICAgIC5hdHRyKFwid2lkdGhcIiwgeC5iYW5kd2lkdGgoKSlcbiAgICAgICAgICAgICAgLmVhY2goKHNfZCwgc19pLCBub2RlcykgPT4ge1xuICAgICAgICAgICAgICAgICAgbGV0IGdyb3VwID0gZDMuc2VsZWN0KG5vZGVzW3NfaV0pO1xuXG4gICAgICAgICAgICAgICAgICBsZXQgYmFycyA9IGdyb3VwLnNlbGVjdEFsbChcIi5iYXJcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZGF0YShzX2QuZGF0YSk7XG5cbiAgICAgICAgICAgICAgICAgIGJhcnMuZXhpdCgpLnJlbW92ZSgpO1xuXG4gICAgICAgICAgICAgICAgICBiYXJzLmludGVycnVwdChcImJhcjptb3ZlXCIpICAgICAvLyBBbmltYXRlIHRoZSBiYXJzIHRvIHRoZWlyIG5ldyBwb3NpdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgICAudHJhbnNpdGlvbihcImJhcjptb3ZlXCIpXG4gICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCB4R3JvdXAuYmFuZHdpZHRoKCkpXG4gICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIGQgPT4geEdyb3VwKGQuX2tleSkpXG4gICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ5XCIsIDApO1xuXG4gICAgICAgICAgICAgICAgICBiYXJzLmVudGVyKClcbiAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKFwicmVjdFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIChkLCBpKSA9PiBcImJhciBzZXJpZXMgc2VyaWVzLVwiICsgdG9Db2xvdXJLZXkoZC5fY29sb3VyKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIGQgPT4geEdyb3VwKGQuX2tleSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIC5hdHRyKFwieVwiLCBkID0+IGhlaWdodCAtIHkoTWF0aC5taW4oMCwgZC5feSkpKVxuICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwieVwiLCBoZWlnaHQgLSB5KDApKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcIndpZHRoXCIsIHhHcm91cC5iYW5kd2lkdGgoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwiY3Vyc29yXCIsIFwicG9pbnRlclwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIGQgPT4gdGhpcy5nZXREM0NvbG91cihkKSkgLy8gY29sb3VycyhkLl9jb2xvdXIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJzdHJva2VcIiwgZCA9PiBkMy5oY2wodGhpcy5nZXREM0NvbG91cihkKSkuZGFya2VyKCkpXG4gICAgICAgICAgICAgICAgICAgICAgLm9uKFwiY29udGV4dG1lbnVcIiwgKCkgPT4gZDMuZXZlbnQucHJldmVudERlZmF1bHQoKSkgLy8gTm8gcmlnaHQgY2xpY2suXG4gICAgICAgICAgICAgICAgICAgICAgLm1lcmdlKGJhcnMpXG4gICAgICAgICAgICAgICAgICAgICAgLm9uKFwiY2xpY2sgYXV4Y2xpY2tcIiwgKGQsIGksIG5vZGVzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3BhdGNoLmNhbGwoXCJlbGVtZW50Q2xpY2tcIiwgdGhpcywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZTogZDMuZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludDogZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllczogZC5fc2VyaWVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzSW5kZXg6IHNfaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBkLl95XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAub24oXCJtb3VzZW92ZXJcIiwgKGQsIGksIG5vZGVzKSA9PiB7IC8vIERhcmtlbiB0aGUgYmFyIG9uIG1vdXNlIG92ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZDMuc2VsZWN0KG5vZGVzW2ldKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5pbnRlcnJ1cHQoXCJob3Zlcjpjb2xvdXJcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudHJhbnNpdGlvbihcImhvdmVyOmNvbG91clwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbig0MDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBkMy5oY2wodGhpcy5nZXREM0NvbG91cihkKSkuZGFya2VyKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXNwYXRjaC5jYWxsKFwidG9vbHRpcFNob3dcIiwgdGhpcywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZTogZDMuZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludDogZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllczogc19kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzSW5kZXg6IHNfaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBkLl95XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAub24oXCJtb3VzZW91dFwiLCAoZCwgaSwgbm9kZXMpID0+IHsgLy8gYmFyIGlzIHJlZ3VsYXIgY29sb3VyIG9uIG1vdXNlIG91dC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgZDMuc2VsZWN0KG5vZGVzW2ldKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5pbnRlcnJ1cHQoXCJob3Zlcjpjb2xvdXJcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudHJhbnNpdGlvbihcImhvdmVyOmNvbG91clwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbig0MDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBkID0+IHRoaXMuZ2V0RDNDb2xvdXIoZCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXNwYXRjaC5jYWxsKFwidG9vbHRpcEhpZGVcIiwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAuaW50ZXJydXB0KFwiYmFyOmdyb3d0aFwiKSAgICAvLyBBbmltYXRlIGJhcnMgZ3Jvd2luZy5cbiAgICAgICAgICAgICAgICAgICAgICAudHJhbnNpdGlvbihcImJhcjpncm93dGhcIilcbiAgICAgICAgICAgICAgICAgICAgICAuZGVsYXkoKCkgPT4gdGhpcy5jYWxjQmFyR3Jvd3RoKHNfaSwgbm9kZXMubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBkID0+IHRoaXMuZ2V0RDNDb2xvdXIoZCkpIC8vY29sb3VycyhkLl9jb2xvdXIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJzdHJva2VcIiwgZCA9PiBkMy5oY2wodGhpcy5nZXREM0NvbG91cihkKSkuZGFya2VyKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwieVwiLCBkID0+IGhlaWdodCAtIHkoTWF0aC5taW4oMCwgZC5feSkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcImhlaWdodFwiLCBkID0+IChNYXRoLmFicyh5KDApIC0geShkLl95KSkpKTtcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gTGFiZWxzIGxvYWRlZCBhZnRlciBvdXIgbGFzdCBiYXIgZ3Jvd3MuXG4gICAgICAgIGlmICh0aGlzLnNob3dMYWJlbHMoKSkge1xuICAgICAgICAgICAgZWxlbWVudC50cmFuc2l0aW9uKFwiYmFyOmdyb3d0aFwiKVxuICAgICAgICAgICAgICAgLm9uKFwiZW5kXCIsIChkLCBpLCBub2RlcykgPT4ge1xuICAgICAgICAgICAgICAgICAgIGlmIChpIDwgbm9kZXMubGVuZ3RoIC0gMSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyTGFiZWxzKGVsZW1lbnQsIGRhdGEsIHgsIHhHcm91cCwgeSwgY29sb3Vycyk7XG4gICAgICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2FsY0Jhckdyb3d0aChpLCBtYXgpIHtcbiAgICAgICAgaWYgKG1heCA8IDEwKSByZXR1cm4gaSAqIHRoaXMuX0JBUl9HUk9XVEggLyAyO1xuICAgICAgICBpZiAobWF4IDwgMzUpIHJldHVybiBpICogdGhpcy5fQkFSX0dST1dUSCAvIDQ7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIHByZXBhcmVEYXRhKGRhdGEsIGZhY2V0ZWQpIHtcbiAgICAgICAgZGF0YSA9IEdlb21ldHJ5LnByb3RvdHlwZS5wcmVwYXJlRGF0YS5jYWxsKHRoaXMsIGRhdGEsIGZhY2V0ZWQpO1xuXG4gICAgICAgIGNvbnN0IHNvcnRPcmRlciA9IHt9O1xuICAgICAgICB0aGlzLnhWYWx1ZXMoKS5mb3JFYWNoKChkLCBpKSA9PiB7XG4gICAgICAgICAgICBzb3J0T3JkZXJbZF0gPSBzb3J0T3JkZXJbZF0gfHwgKFwiXCIgKyBpKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbGV0IHJlc3VsdHMgPSB7fTtcblxuICAgICAgICAvLyBXZSB3YW50IHRvIGNhbGN1bGF0ZSB3aGF0IGJ1Y2tldCBlYWNoIGJpdCBvZiBkYXRhIGJlbG9uZ3MgdG8uXG4gICAgICAgIGNvbnN0IGJ1Y2tldHMgPSB0aGlzLnNjYWxlWCgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmJ1Y2tldHMoT2JqZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC52YWx1ZXMoZGF0YSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChkID0+IGQuZGF0YSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlZHVjZSgoYWNjLCBjdXIpID0+IGFjYy5jb25jYXQoY3VyKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChkID0+IGQuX3gpKTtcblxuICAgICAgICAvLyBTb3J0IGRhdGEgaW4gdG8gdGhlaXIgYXBwcm9wcmlhdGUgYnVja2V0cy4gVGhpcyBtYXkgYmVcbiAgICAgICAgLy8gc3BlY2lmaWMgZGF0ZSBidWNrZXRzLCBvciBnZW5lcmFsIGJ1Y2tldHMgZm9yIGNvbnRpbnVvdXMgZGF0YS5cbiAgICAgICAgT2JqZWN0LmtleXMoZGF0YSkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgbGV0IHZhbHVlcyA9IGRhdGFba2V5XS5kYXRhO1xuICAgICAgICAgICAgdmFsdWVzLmZvckVhY2goZCA9PiB7XG4gICAgICAgICAgICAgICAgZC5fYnVja2V0ID0gYnVja2V0cy5idWNrZXQoZC5feCk7XG4gICAgICAgICAgICAgICAgbGV0IGJ1Y2tldCA9IHJlc3VsdHNbZC5fYnVja2V0XSB8fCB7IF9rZXk6IGQuX2J1Y2tldCwgZGF0YTogW10gfTtcbiAgICAgICAgICAgICAgICBidWNrZXQuZGF0YS5wdXNoKGQpO1xuICAgICAgICAgICAgICAgIHJlc3VsdHNbZC5fYnVja2V0XSA9IGJ1Y2tldDtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBidWNrZXRzLmNvbnNvbGlkYXRlQnVja2V0cyhPYmplY3QudmFsdWVzKHJlc3VsdHMpKVxuICAgICAgICAgICAgLnNvcnQoKGxocywgcmhzKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNvcnRPcmRlcltcIlwiICsgbGhzLl9rZXldIC0gc29ydE9yZGVyW1wiXCIgKyByaHMuX2tleV07XG4gICAgICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBnZXRLZXlzKGRhdGEpIHtcbiAgICAgICAgaWYgKCFkYXRhIHx8ICFkYXRhLmxlbmd0aCkgcmV0dXJuIFtdO1xuXG4gICAgICAgIGxldCBrZXlzID0gbmV3IFNldCgpO1xuXG4gICAgICAgIC8vIHRvZG8gY2FsY3VsYXRlIGJ1Y2tldHNcbiAgICAgICAgT2JqZWN0LmtleXMoZGF0YSkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgbGV0IHZhbHVlcyA9IGRhdGFba2V5XS5kYXRhO1xuICAgICAgICAgICAgdmFsdWVzLmZvckVhY2goZCA9PiBrZXlzLmFkZChkLl9rZXkpKVxuICAgICAgICB9KTtcblxuXG4gICAgICAgIHJldHVybiBbLi4ua2V5c11cbiAgICB9XG5cbiAgICBnZXREM1hTY2FsZShkYXRhLCB3aWR0aCkge1xuICAgICAgICBkYXRhID0gZGF0YSB8fCB0aGlzLnByZXBhcmVEYXRhKG51bGwsIHRydWUpO1xuICAgICAgICB3aWR0aCA9IHdpZHRoIHx8IHRoaXMud2lkdGgoKTtcblxuICAgICAgICByZXR1cm4gZDMuc2NhbGVCYW5kKClcbiAgICAgICAgICAgICAgICAgLnJhbmdlUm91bmQoWzAsIHdpZHRoXSlcbiAgICAgICAgICAgICAgICAgLnBhZGRpbmcoKGRhdGFbMF0uZGF0YS5sZW5ndGggPiAxID8gMC4yIDogMCkgKyB0aGlzLl9wYWRkaW5nKVxuICAgICAgICAgICAgICAgICAuZG9tYWluKGRhdGEubWFwKGQgPT4gZC5fa2V5KSk7XG4gICAgfVxuXG4gICAgZ2V0RDNZU2NhbGUoZGF0YSwgaGVpZ2h0KSB7XG4gICAgICAgIGRhdGEgPSBkYXRhIHx8IHRoaXMucHJlcGFyZURhdGEobnVsbCwgZmFsc2UpO1xuICAgICAgICBoZWlnaHQgPSBoZWlnaHQgfHwgdGhpcy5oZWlnaHQoKTtcblxuXG4gICAgICAgIGNvbnN0IG1heCA9IE1hdGgubWF4KGQzLm1heChkYXRhLCBkID0+IGQzLm1heChkLmRhdGEsIGQgPT4gZC5feSkpLCAwKTtcbiAgICAgICAgY29uc3QgbWluID0gTWF0aC5taW4oMCwgZDMubWluKGRhdGEsIGQgPT4gZDMubWluKGQuZGF0YSwgZCA9PiBkLl95KSkpO1xuICAgICAgICByZXR1cm4gZDMuc2NhbGVMaW5lYXIoKVxuICAgICAgICAgICAgICAgICAucmFuZ2VSb3VuZChbaGVpZ2h0LCAwXSlcbiAgICAgICAgICAgICAgICAgLm5pY2UoKVxuICAgICAgICAgICAgICAgICAuZG9tYWluKFttaW4sIG1heF0pO1xuICAgIH1cblxuICAgIGdldEQzWEdyb3VwU2NhbGUoZGF0YSwgeHNjYWxlKSB7XG4gICAgICAgIHJldHVybiBkMy5zY2FsZUJhbmQoKVxuICAgICAgICAgICAgICAgICAucGFkZGluZygwKVxuICAgICAgICAgICAgICAgICAuZG9tYWluKHRoaXMuZ2V0S2V5cyhkYXRhKSlcbiAgICAgICAgICAgICAgICAgLnJhbmdlUm91bmQoWzAsIHhzY2FsZS5iYW5kd2lkdGgoKV0pO1xuICAgIH1cblxuICAgIHJlbmRlckxhYmVscyhzZWxlY3Rpb24sIGRhdGEsIHhzY2FsZSwgeGdyb3VwLCB5c2NhbGUsIGNvbG91clNjYWxlLCBhbmltYXRlKSB7XG4gICAgICAgIGFuaW1hdGUgPSBhbmltYXRlID09PSB1bmRlZmluZWQgPyB0cnVlIDogYW5pbWF0ZTtcbiAgICAgICAgc2VsZWN0aW9uLnNlbGVjdEFsbChcIi5jaGFydC1sYWJlbHNcIikucmVtb3ZlKCk7XG5cbiAgICAgICAgbGV0IGxhYmVscyA9IHNlbGVjdGlvbi5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwiY2hhcnQtbGFiZWxzXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKFwiLmxhYmVsLWdyb3VwXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZGF0YShkYXRhKTtcblxuICAgICAgICBsZXQgbWF4V2lkdGggPSAwOyAgICAgLy8gRm9yIGNhbGN1bGF0aW5nIHRoZSBtYXggd2lkdGggb2YgdGV4dC5cbiAgICAgICAgbGV0IGZvbnRTaXplID0gMTI7ICAgIC8vIE91ciBpbml0aWFsIGZvbnQgc2l6ZS5cbiAgICAgICAgY29uc3QgYnVmZmVyID0gNTsgICAgIC8vIEJ1ZmZlciBzcGFjZSBiZXR3ZWVuIHdvcmRzIGFuZCB0aGUgdG9wIG9mIGEgYmFyLlxuICAgICAgICBjb25zdCBjYWxjRHkgPSAoeSwgeXBvcykgPT4gKCh5ID49IDAgJiYgeXBvcyA8IDEwKSB8fCAoIHkgPCAwICYmIHRoaXMuX2hlaWdodCAtIHlwb3MgPiAxMCkpID8gZm9udFNpemUgKyAyOiAtYnVmZmVyO1xuXG4gICAgICAgIC8vIFdhbnQgdG8gZmlndXJlIG91dCBpZiB0aGUgbGFiZWwgaXMgdG9vIGRhcmsgLyBsaWdodCBmb3IgdGhlXG4gICAgICAgIC8vIGJhci5cbiAgICAgICAgY29uc3QgZ2V0SW52ZXJ0ZWRDb2xvciA9IGQgPT4ge1xuICAgICAgICAgICAgbGV0IGludmVydGVkQ29sb3IgPSBkMy5oY2wodGhpcy5nZXREM0NvbG91cihkKSk7XG4gICAgICAgICAgICBpbnZlcnRlZENvbG9yLmwgKz0gTWF0aC5taW4oaW52ZXJ0ZWRDb2xvci5sICsgNTAsIDEwMCk7XG4gICAgICAgICAgICByZXR1cm4gaW52ZXJ0ZWRDb2xvcjtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgc2hvdWxkSW52ZXJ0ID0gZCA9PiBkMy5oY2wodGhpcy5nZXREM0NvbG91cihkKSkubCA8IDYwO1xuICAgICAgICBjb25zdCBmaWxsQ29sb3VyID0gZDMuaGNsKGNvbG91cnMuZWlnaHRlZW4uZGFya0dyZXkpLmJyaWdodGVyKCk7XG4gICAgICAgIGNvbnN0IGxpZ2h0ZXJGaWxsQ29sb3VyID0gZDMuaGNsKGNvbG91cnMuZWlnaHRlZW4ubWlkR3JleSk7XG4gICAgICAgIGNvbnN0IGZpbmRDb2xvdXIgPSAoZCwgZHksIGxhYmVsVGV4dCkgPT4gKGQuX3kgPj0gMCAmJiBkeSA+IDAgfHwgZC5feSA8IDAgJiYgZHkgPCAwKSAmJiBzaG91bGRJbnZlcnQoZCk/IGdldEludmVydGVkQ29sb3IoZCkudG9TdHJpbmcoKSA6IChsYWJlbFRleHQgPT09IFwiMFwiID8gbGlnaHRlckZpbGxDb2xvdXIgOiBmaWxsQ29sb3VyKTtcblxuICAgICAgICBsYWJlbHMuZW50ZXIoKS5lYWNoKChzZXJpZXMsIHNfaSwgc19ub2RlcykgPT4ge1xuICAgICAgICAgICAgLy8gV2Ugd2FudCB0byBkZXRlcm1pbmUgd2hpY2ggZ3JvdXBzIG1heSBoYXZlIG1pc3NpbmcgdmFsdWVzLCBhbmQgcHJvdmlkZSB0aGVtLlxuICAgICAgICAgICAgY29uc3QgcmVxdWlyZWRHcm91cHMgPSB7fTtcbiAgICAgICAgICAgIHhncm91cC5kb21haW4oKS5tYXAoZnJvbUtleSkuZm9yRWFjaChkID0+IHtcbiAgICAgICAgICAgICAgICByZXF1aXJlZEdyb3Vwc1tkLl9jb2xvdXJdID0gZDtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBzZXJpZXMuZGF0YS5mb3JFYWNoKGQgPT4ge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSByZXF1aXJlZEdyb3Vwc1tkLl9jb2xvdXJdXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY29uc3QgbWlzc2luZ0dyb3VwcyA9IE9iamVjdC52YWx1ZXMocmVxdWlyZWRHcm91cHMpO1xuICAgICAgICAgICAgbWlzc2luZ0dyb3Vwcy5mb3JFYWNoKGQgPT4ge1xuICAgICAgICAgICAgICAgIGQuX3ggPSBzZXJpZXMuX2tleTtcbiAgICAgICAgICAgICAgICBkLl95ID0gMDtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBkMy5zZWxlY3Qoc19ub2Rlc1tzX2ldKVxuICAgICAgICAgICAgICAuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwibGFiZWwtZ3JvdXBcIilcbiAgICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgZCA9PiBcInRyYW5zbGF0ZShcIiArIHhzY2FsZShkLl9rZXkpICsgXCIsMClcIilcbiAgICAgICAgICAgICAgLnNlbGVjdEFsbChcIi5jaGFydC1sYWJlbFwiKVxuICAgICAgICAgICAgICAuZGF0YShzZXJpZXMuZGF0YS5jb25jYXQoT2JqZWN0LnZhbHVlcyhtaXNzaW5nR3JvdXBzKSkpXG4gICAgICAgICAgICAgIC5lbnRlcigpXG4gICAgICAgICAgICAgIC5lYWNoKChkLCBpLCBub2RlcykgPT4ge1xuICAgICAgICAgICAgICAgICAgY29uc3QgbGFiZWxUZXh0ID0gdGhpcy5mb3JtYXRMYWJlbCgpKGQuX3kpO1xuICAgICAgICAgICAgICAgICAgbGV0IHlwb3MgPSB5c2NhbGUoZC5feSk7XG4gICAgICAgICAgICAgICAgICBsZXQgZHkgPSBjYWxjRHkoZC5feSwgeXBvcyk7XG4gICAgICAgICAgICAgICAgICBsZXQgdGV4dCA9IGQzLnNlbGVjdChub2Rlc1tpXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50ZXh0KGxhYmVsVGV4dClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwiY2hhcnQtbGFiZWxcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcInlcIiwgeXBvcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcImR4XCIsIGFuaW1hdGUgPyAtMTUgOiAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiZHlcIiwgZHkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcInBvaW50ZXItZXZlbnRzXCIsIFwibm9uZVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcImZpbGxcIiwgZCA9PiBmaW5kQ29sb3VyKGQsIGR5LCBsYWJlbFRleHQpKTtcblxuICAgICAgICAgICAgICAgICAgLy8gU2V0IHRoZSB4IHBvc2l0aW9uLCB3aGljaCBpcyBiYXNlZCBvbiB3aWR0aC5cbiAgICAgICAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gdGV4dC5ub2RlKCkuZ2V0QkJveCgpLndpZHRoO1xuICAgICAgICAgICAgICAgICAgbWF4V2lkdGggPSBNYXRoLm1heCh3aWR0aCwgbWF4V2lkdGgpO1xuICAgICAgICAgICAgICAgICAgdGV4dFxuICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwieFwiLCB4Z3JvdXAoZC5fa2V5KSArIHhncm91cC5iYW5kd2lkdGgoKSAvIDIgLSB3aWR0aCAvIDIpO1xuXG4gICAgICAgICAgICAgICAgICB0ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgLnRyYW5zaXRpb24oXCJsYWJlbHNcIilcbiAgICAgICAgICAgICAgICAgICAgICAuZGVsYXkoKCkgPT4gYW5pbWF0ZSA/IHRoaXMuY2FsY0Jhckdyb3d0aChzX2ksIHNfbm9kZXMubGVuZ3RoKSA6IDApIC8vIERlbGF5IGluIGxvY2tzdGVwIHdpdGggYmFyIGdyb3d0aC5cbiAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcImR4XCIsIDApXG4gICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAxKVxuICAgICAgICAgICAgICB9KVxuICAgICAgICB9KTtcblxuXG4gICAgICAgIC8vIEZpZ3VyZSBvdXQgaWYgd2UgZG9uJ3QgaGF2ZSBlbm91Z2ggc3BhY2UgdG8gc2hvdyBvdXIgbGFiZWxzLlxuICAgICAgICAvLyBXZSB0aGVuIHdhbnQgdG8gcmVzaXplLCBpZiBwb3NzaWJsZS5cbiAgICAgICAgaWYgKHhncm91cC5iYW5kd2lkdGgoKSA8IG1heFdpZHRoICogMS4xMCkge1xuICAgICAgICAgICAgbGV0IHNjYWxlID0gbWF4V2lkdGggLyB4Z3JvdXAuYmFuZHdpZHRoKCkgKiAxLjEwO1xuICAgICAgICAgICAgZm9udFNpemUgPSBNYXRoLmZsb29yKGZvbnRTaXplIC8gc2NhbGUpO1xuXG4gICAgICAgICAgICBpZiAoZm9udFNpemUgPCA4KSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGxhYmVscyBhcmUgdG9vIHNtYWxsLlxuICAgICAgICAgICAgICAgIGxhYmVscy5lbnRlcigpLnNlbGVjdEFsbChcInRleHRcIikucmVtb3ZlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxhYmVscy5lbnRlcigpXG4gICAgICAgICAgICAgICAgICAgICAgLm1lcmdlKGxhYmVscylcbiAgICAgICAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKFwidGV4dFwiKVxuICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcImZvbnQtc2l6ZVwiLCBmb250U2l6ZSArIFwicHhcIilcbiAgICAgICAgICAgICAgICAgICAgICAuZWFjaCgoZCwgaSwgbm9kZXMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGV4dCA9IGQzLnNlbGVjdChub2Rlc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gdGV4dC5ub2RlKCkuZ2V0QkJveCgpLndpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkeSA9IGNhbGNEeShkLl95LCB5c2NhbGUoZC5feSkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwieFwiLCB4Z3JvdXAoZC5fa2V5KSArIHhncm91cC5iYW5kd2lkdGgoKSAvIDIgLSB3aWR0aCAvIDIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIGQgPT4gZmluZENvbG91cihkLCBkeSwgdGV4dC50ZXh0KCkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJkeVwiLCBkeSk7XG4gICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgaW1tZWRpYXRlbHlSZW5kZXJMYWJlbHMoc2hvdykge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5lbGVtZW50KCk7XG4gICAgICAgIGlmICghZWxlbWVudCkgcmV0dXJuO1xuXG4gICAgICAgIGlmICghc2hvdykgeyAvLyBIaWRlcyB0aGUgbGFiZWxzXG4gICAgICAgICAgICBlbGVtZW50XG4gICAgICAgICAgICAgIC5zZWxlY3QoJy5jaGFydC1sYWJlbHMnKVxuICAgICAgICAgICAgICAuaW50ZXJydXB0KFwibGFiZWxzXCIpXG4gICAgICAgICAgICAgIC5pbnRlcnJ1cHQoXCJsYWJlbHM6ZmFkZVwiKVxuICAgICAgICAgICAgICAudHJhbnNpdGlvbihcImxhYmVsczpmYWRlXCIpXG4gICAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMClcbiAgICAgICAgICAgICAgLm9uKFwiZW5kXCIsIChkLCBpLCBub2RlcykgPT4ge1xuICAgICAgICAgICAgICAgICAgZDMuc2VsZWN0KG5vZGVzW2ldKS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBsYWJlbHMgPSBlbGVtZW50LnNlbGVjdCgnLmNoYXJ0LWxhYmVscycpO1xuICAgICAgICAgICAgaWYgKCFsYWJlbHMuZW1wdHkoKSkgcmV0dXJuO1xuXG4gICAgICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5wcmVwYXJlRGF0YShudWxsLCB0cnVlKTtcbiAgICAgICAgICAgIGNvbnN0IGFsbERhdGEgPSB0aGlzLnByZXBhcmVEYXRhKG51bGwsIGZhbHNlKTtcblxuICAgICAgICAgICAgY29uc3QgeHNjYWxlID0gdGhpcy5nZXREM1hTY2FsZShkYXRhKSxcbiAgICAgICAgICAgICAgICAgIHhncm91cCA9IHRoaXMuZ2V0RDNYR3JvdXBTY2FsZShkYXRhLCB4c2NhbGUpLFxuICAgICAgICAgICAgICAgICAgeXNjYWxlID0gdGhpcy5nZXREM1lTY2FsZShkYXRhKSxcbiAgICAgICAgICAgICAgICAgIGNvbG91clNjYWxlID0gdGhpcy5kM0NvbG91clNjYWxlKCk7XG5cbiAgICAgICAgICAgIGxhYmVscy5yZW1vdmUoKTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyTGFiZWxzKGVsZW1lbnQsIGRhdGEsIHhzY2FsZSwgeGdyb3VwLCB5c2NhbGUsIGNvbG91clNjYWxlLCBmYWxzZSk7XG4gICAgICAgIH1cblxuICAgIH1cblxuXG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGhpc3RvZ3JhbSgpIHtcbiAgICByZXR1cm4gbmV3IEhpc3RvZ3JhbSgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29sdW1uQ2hhcnQoKSB7XG4gICAgcmV0dXJuIG5ldyBIaXN0b2dyYW0oXCJDT0xVTU5fQ0hBUlRcIiwgMC4xKTtcbn0iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/Histogram.js\n");

/***/ }),

/***/ "./src/Legend.js":
/*!***********************!*\
  !*** ./src/Legend.js ***!
  \***********************/
/*! exports provided: renderLegend, buckets, toColourKey */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"renderLegend\", function() { return renderLegend; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"buckets\", function() { return buckets; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toColourKey\", function() { return toColourKey; });\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers */ \"./src/helpers.js\");\n/* harmony import */ var _Colours__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Colours */ \"./src/Colours.js\");\n\n\n\n\nfunction renderLegend(element, buckets, colourScale, width, height, min) {\n    min = min || 2;\n    element.selectAll(\".legend\").remove();\n\n    // Only if we have multiple series.\n    if (!buckets || !buckets.colours.size) return 0;\n\n    const colours = Array.from(buckets.colours);\n    if (colours.length < min) return 0;\n\n    const maxWidth = Object(_helpers__WEBPACK_IMPORTED_MODULE_0__[\"maxBounding\"])(element, colours).width;\n\n    const legend = element.append(\"g\")\n                          .attr(\"class\", \"legend\");\n\n    let elements = legend.selectAll(\".legend-element\")\n                         .data(colours);\n\n    const position_start = 20;\n    let position = position_start;\n    let position_height = 0;\n\n    elements.enter()\n            .append(\"g\")\n            .attr(\"class\", (d, i) => \"legend-element series series-\" + i)\n            .style(\"cursor\", \"default\")\n            .each((d, i, nodes) => {\n                let element = d3.select(nodes[i]);\n\n                element.append(\"rect\")\n                       .attr(\"width\", 10)\n                       .attr(\"height\", 10)\n                       .attr(\"rx\", 2)\n                       .attr(\"ry\", 2)\n                       .attr(\"y\", -10)\n                       .style(\"fill\", d => colourScale(d));\n\n                element.append(\"text\")\n                       .text(d => d)\n                       .attr(\"dx\", 12)\n                       .style(\"fill\", _Colours__WEBPACK_IMPORTED_MODULE_1__[\"colours\"].eighteen.darkGrey);\n\n                element.append(\"title\")\n                       .text(d => d);\n\n                element.attr(\"transform\", \"translate(\" + position + \",\" + position_height +\")\");\n                const positionDelta = maxWidth + 20; // element.node().getBBox().width + 10;\n                position += positionDelta;\n\n                if (position >= width) {\n                    position = position_start;\n                    position_height += 15;\n                    element.attr(\"transform\", \"translate(\" + position + \",\" + position_height + \")\");\n                    position += positionDelta;\n                }\n\n            })\n            .on(\"mouseover\", (d, i, nodes) => {\n                element.selectAll(\".series:not(.series-\" + toColourKey(d) + \")\")\n                   .interrupt(\"legend:highlight\")\n                   .transition(\"legend:highlight\")\n                   .style(\"opacity\", 0.3);\n            })\n            .on(\"mouseout\", (d, i, nodes) => {\n                element.selectAll(\".series\")\n                   .interrupt(\"legend:highlight\")\n                   .transition(\"legend:highlight\")\n                   .style(\"opacity\", 1);\n            })\n            .style(\"opacity\", 0)\n            .transition()\n            .duration(1000)\n            .style(\"opacity\", 1);\n\n    const legendHeight = legend.node().getBBox().height;\n    legend.attr(\"transform\", \"translate(0,\" + (height - legendHeight) + \")\");\n    return legendHeight;\n}\n\n/**\n * Figures out what buckets we may be using in our data set, based on\n * colour and size differentiation. This may have to be run for each\n * geom and merged.\n * @param data\n * @param colour\n * @param size\n * @returns {{colours: Set, sizes: Set}}\n */\nfunction buckets(data, colour, size) {\n    if (!data || !data.length) return { colours: new Set(), sizes: new Set()};\n\n    const byColour = new Set(),\n          bySize = new Set();\n\n    data.forEach(d => {\n        byColour.add(colour(d));\n        bySize.add(size(d));\n    });\n\n    return {\n        colours: byColour,\n        sizes: bySize\n    }\n}\n\nfunction toColourKey(colour) {\n    // TODO this is not internationalised, and may break on things like brand names.\n    return \"colour-\" + colour.toString().toLowerCase().replace(/\\s+/g, '-').replace(/[^a-z0-9]/g, '');\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvTGVnZW5kLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYjNqcy8uL3NyYy9MZWdlbmQuanM/OTIwNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge21heEJvdW5kaW5nfSBmcm9tIFwiLi9oZWxwZXJzXCI7XG5pbXBvcnQge2NvbG91cnMgYXMgc2NoZW1hfSBmcm9tIFwiLi9Db2xvdXJzXCI7XG5cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbmRlckxlZ2VuZChlbGVtZW50LCBidWNrZXRzLCBjb2xvdXJTY2FsZSwgd2lkdGgsIGhlaWdodCwgbWluKSB7XG4gICAgbWluID0gbWluIHx8IDI7XG4gICAgZWxlbWVudC5zZWxlY3RBbGwoXCIubGVnZW5kXCIpLnJlbW92ZSgpO1xuXG4gICAgLy8gT25seSBpZiB3ZSBoYXZlIG11bHRpcGxlIHNlcmllcy5cbiAgICBpZiAoIWJ1Y2tldHMgfHwgIWJ1Y2tldHMuY29sb3Vycy5zaXplKSByZXR1cm4gMDtcblxuICAgIGNvbnN0IGNvbG91cnMgPSBBcnJheS5mcm9tKGJ1Y2tldHMuY29sb3Vycyk7XG4gICAgaWYgKGNvbG91cnMubGVuZ3RoIDwgbWluKSByZXR1cm4gMDtcblxuICAgIGNvbnN0IG1heFdpZHRoID0gbWF4Qm91bmRpbmcoZWxlbWVudCwgY29sb3Vycykud2lkdGg7XG5cbiAgICBjb25zdCBsZWdlbmQgPSBlbGVtZW50LmFwcGVuZChcImdcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImxlZ2VuZFwiKTtcblxuICAgIGxldCBlbGVtZW50cyA9IGxlZ2VuZC5zZWxlY3RBbGwoXCIubGVnZW5kLWVsZW1lbnRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAuZGF0YShjb2xvdXJzKTtcblxuICAgIGNvbnN0IHBvc2l0aW9uX3N0YXJ0ID0gMjA7XG4gICAgbGV0IHBvc2l0aW9uID0gcG9zaXRpb25fc3RhcnQ7XG4gICAgbGV0IHBvc2l0aW9uX2hlaWdodCA9IDA7XG5cbiAgICBlbGVtZW50cy5lbnRlcigpXG4gICAgICAgICAgICAuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCAoZCwgaSkgPT4gXCJsZWdlbmQtZWxlbWVudCBzZXJpZXMgc2VyaWVzLVwiICsgaSlcbiAgICAgICAgICAgIC5zdHlsZShcImN1cnNvclwiLCBcImRlZmF1bHRcIilcbiAgICAgICAgICAgIC5lYWNoKChkLCBpLCBub2RlcykgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBlbGVtZW50ID0gZDMuc2VsZWN0KG5vZGVzW2ldKTtcblxuICAgICAgICAgICAgICAgIGVsZW1lbnQuYXBwZW5kKFwicmVjdFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcIndpZHRoXCIsIDEwKVxuICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcImhlaWdodFwiLCAxMClcbiAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJyeFwiLCAyKVxuICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcInJ5XCIsIDIpXG4gICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwieVwiLCAtMTApXG4gICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcImZpbGxcIiwgZCA9PiBjb2xvdXJTY2FsZShkKSk7XG5cbiAgICAgICAgICAgICAgICBlbGVtZW50LmFwcGVuZChcInRleHRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgLnRleHQoZCA9PiBkKVxuICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcImR4XCIsIDEyKVxuICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIHNjaGVtYS5laWdodGVlbi5kYXJrR3JleSk7XG5cbiAgICAgICAgICAgICAgICBlbGVtZW50LmFwcGVuZChcInRpdGxlXCIpXG4gICAgICAgICAgICAgICAgICAgICAgIC50ZXh0KGQgPT4gZCk7XG5cbiAgICAgICAgICAgICAgICBlbGVtZW50LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyBwb3NpdGlvbiArIFwiLFwiICsgcG9zaXRpb25faGVpZ2h0ICtcIilcIik7XG4gICAgICAgICAgICAgICAgY29uc3QgcG9zaXRpb25EZWx0YSA9IG1heFdpZHRoICsgMjA7IC8vIGVsZW1lbnQubm9kZSgpLmdldEJCb3goKS53aWR0aCArIDEwO1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uICs9IHBvc2l0aW9uRGVsdGE7XG5cbiAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24gPj0gd2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSBwb3NpdGlvbl9zdGFydDtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25faGVpZ2h0ICs9IDE1O1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyBwb3NpdGlvbiArIFwiLFwiICsgcG9zaXRpb25faGVpZ2h0ICsgXCIpXCIpO1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiArPSBwb3NpdGlvbkRlbHRhO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbihcIm1vdXNlb3ZlclwiLCAoZCwgaSwgbm9kZXMpID0+IHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnNlbGVjdEFsbChcIi5zZXJpZXM6bm90KC5zZXJpZXMtXCIgKyB0b0NvbG91cktleShkKSArIFwiKVwiKVxuICAgICAgICAgICAgICAgICAgIC5pbnRlcnJ1cHQoXCJsZWdlbmQ6aGlnaGxpZ2h0XCIpXG4gICAgICAgICAgICAgICAgICAgLnRyYW5zaXRpb24oXCJsZWdlbmQ6aGlnaGxpZ2h0XCIpXG4gICAgICAgICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAwLjMpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbihcIm1vdXNlb3V0XCIsIChkLCBpLCBub2RlcykgPT4ge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuc2VsZWN0QWxsKFwiLnNlcmllc1wiKVxuICAgICAgICAgICAgICAgICAgIC5pbnRlcnJ1cHQoXCJsZWdlbmQ6aGlnaGxpZ2h0XCIpXG4gICAgICAgICAgICAgICAgICAgLnRyYW5zaXRpb24oXCJsZWdlbmQ6aGlnaGxpZ2h0XCIpXG4gICAgICAgICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAxKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDApXG4gICAgICAgICAgICAudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAuZHVyYXRpb24oMTAwMClcbiAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMSk7XG5cbiAgICBjb25zdCBsZWdlbmRIZWlnaHQgPSBsZWdlbmQubm9kZSgpLmdldEJCb3goKS5oZWlnaHQ7XG4gICAgbGVnZW5kLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoMCxcIiArIChoZWlnaHQgLSBsZWdlbmRIZWlnaHQpICsgXCIpXCIpO1xuICAgIHJldHVybiBsZWdlbmRIZWlnaHQ7XG59XG5cbi8qKlxuICogRmlndXJlcyBvdXQgd2hhdCBidWNrZXRzIHdlIG1heSBiZSB1c2luZyBpbiBvdXIgZGF0YSBzZXQsIGJhc2VkIG9uXG4gKiBjb2xvdXIgYW5kIHNpemUgZGlmZmVyZW50aWF0aW9uLiBUaGlzIG1heSBoYXZlIHRvIGJlIHJ1biBmb3IgZWFjaFxuICogZ2VvbSBhbmQgbWVyZ2VkLlxuICogQHBhcmFtIGRhdGFcbiAqIEBwYXJhbSBjb2xvdXJcbiAqIEBwYXJhbSBzaXplXG4gKiBAcmV0dXJucyB7e2NvbG91cnM6IFNldCwgc2l6ZXM6IFNldH19XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBidWNrZXRzKGRhdGEsIGNvbG91ciwgc2l6ZSkge1xuICAgIGlmICghZGF0YSB8fCAhZGF0YS5sZW5ndGgpIHJldHVybiB7IGNvbG91cnM6IG5ldyBTZXQoKSwgc2l6ZXM6IG5ldyBTZXQoKX07XG5cbiAgICBjb25zdCBieUNvbG91ciA9IG5ldyBTZXQoKSxcbiAgICAgICAgICBieVNpemUgPSBuZXcgU2V0KCk7XG5cbiAgICBkYXRhLmZvckVhY2goZCA9PiB7XG4gICAgICAgIGJ5Q29sb3VyLmFkZChjb2xvdXIoZCkpO1xuICAgICAgICBieVNpemUuYWRkKHNpemUoZCkpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29sb3VyczogYnlDb2xvdXIsXG4gICAgICAgIHNpemVzOiBieVNpemVcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0b0NvbG91cktleShjb2xvdXIpIHtcbiAgICAvLyBUT0RPIHRoaXMgaXMgbm90IGludGVybmF0aW9uYWxpc2VkLCBhbmQgbWF5IGJyZWFrIG9uIHRoaW5ncyBsaWtlIGJyYW5kIG5hbWVzLlxuICAgIHJldHVybiBcImNvbG91ci1cIiArIGNvbG91ci50b1N0cmluZygpLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvXFxzKy9nLCAnLScpLnJlcGxhY2UoL1teYS16MC05XS9nLCAnJyk7XG59Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/Legend.js\n");

/***/ }),

/***/ "./src/Line.js":
/*!*********************!*\
  !*** ./src/Line.js ***!
  \*********************/
/*! exports provided: line */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"line\", function() { return line; });\n/* harmony import */ var _Geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Geometry */ \"./src/Geometry.js\");\n// Copyright (C) 2013-2014, 2018 BrandsEye (PTY) LTD\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this\n// software and associated documentation files (the \"Software\"), to deal in the Software\n// without restriction, including without limitation the rights to use, copy, modify,\n//     merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following\n// conditions:\n//\n//     The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n//     INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n// CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n\nclass Line extends _Geometry__WEBPACK_IMPORTED_MODULE_0__[\"Geometry\"] {\n\n    constructor() {\n        super(\"LINE\", 2);\n    }\n\n    render() {\n        console.log(\"\\t Rendering LINE\");\n\n        const element = this._element;\n        const data = this.prepareData();\n        const width = this._width,\n              height = this._height;\n        const allData = data.map(d => d.data).reduce((acc, val) => acc.concat(val));\n\n        element.classed(\"line-chart\", true);\n\n\n        const x = this.getD3XScale(allData, width);\n        const y = this.getD3YScale(allData, height);\n\n        console.log(\"lines y range\", y.range());\n        console.log(\"lines y domain\", y.domain());\n\n        const colours = d3.scaleOrdinal(this.colourScale())\n                          .domain(this.getColourDomain(data));\n\n\n        //---------------------------------\n        // append the lines\n        let lineGroup = element.select(\".lines\");\n        lineGroup.selectAll(\"circle\").remove();\n\n        let circle = false;\n        let lastMouse = null;\n        let lastMin = null;\n\n        if (lineGroup.empty()) {\n            lineGroup = element\n                .append(\"g\")\n                .attr(\"class\", \"lines\")\n                .attr(\"width\", this.width())\n                .attr(\"height\", this.height());\n\n            // This is needed to provide area for mouse interactions.\n            lineGroup\n                .append(\"rect\")\n                .style(\"opacity\", \"0\")\n                .attr(\"width\", \"100%\")\n                .attr(\"height\", \"100%\");\n        }\n\n        lineGroup\n            .on(\"mousemove\", (d, i, nodes) => { // Darken the bar on mouse over\n                const mouse = d3.mouse(nodes[i]);\n\n                const xval = x.invert(mouse[0]);\n                const yval = y.invert(mouse[1]);\n                // let min = this.getClosestPoint(xval, yval, this.getTransformedData()[0].data);\n\n                let mins = data.map(d => getClosestPoint(xval, yval, d.data));\n                mins.forEach(d => d._dist =  [x(d._x), y(d._y)]);\n\n                mins = mins.filter(min => {\n                    const minScreenDist = Math.sqrt((mouse[0] - min._dist[0]) ** 2 + (mouse[1] - min._dist[1]) ** 2);\n                    min._min_screen = minScreenDist;\n                    return minScreenDist < 100;\n                });\n\n\n                if (!mins || !mins.length) {\n                    lastMouse = null;\n                    lineGroup.selectAll(\"circle\").remove();\n                    return;\n                }\n\n                mins = mins.sort((lhs, rhs) => lhs._min_screen - rhs._min_screen);\n                let min = mins[0];\n\n                if (circle) {\n                    if (lastMin && min._x.getTime() === lastMin._x.getTime()) return;\n                    lineGroup.selectAll(\"circle\").remove();\n                }\n\n                circle = true;\n                lastMouse = mouse;\n                lastMin = min;\n                lineGroup\n                    .append(\"circle\")\n                    .attr(\"cx\", x(min._x))\n                    .attr(\"cy\", y(min._y))\n                    .attr(\"r\", 10)\n                    .attr(\"fill\", d._colour)\n                    .style(\"opacity\", 0.1)\n                    .on(\"mouseover\", () => {\n                        this._dispatch.call(\"tooltipShow\", this, {\n                            e: d3.event,\n                            point: min,\n                            series: data[min._s_i],\n                            seriesIndex: min._s_i,\n                            value: min._y\n                        })\n                    })\n                    .on(\"mouseout\", (d, i, nodes) => { // bar is regular colour on mouse out.\n                        this._dispatch.call(\"tooltipHide\", this);\n                    })\n                    .transition()\n                    .style(\"opacity\", 0.5)\n\n            });\n\n        let lines = lineGroup.selectAll('.line');\n        lines = lines.data(data);\n\n        lines.exit().remove();\n\n        const line = d3.line()\n                       .x(d => x(d._x))\n                       .y(d => y(d._y));\n\n        lines\n            .enter()\n            .append(\"path\")\n                .attr(\"class\", \"line\")\n                .attr(\"fill\", \"none\")\n                .attr(\"stroke\", d => d3.hcl(colours(d._colour)).darker())\n                .attr(\"stroke-linejoin\", \"round\")\n                .attr(\"stroke-linecap\", \"round\")\n                .attr(\"stroke-width\", 2)\n                .style(\"opacity\", 0)\n            .transition()\n                .style(\"opacity\", 1)\n                .attr(\"d\", d => line(d.data));\n\n        lines\n            .transition()\n            .attr(\"d\", d => line(d.data));\n    }\n\n\n    getD3XScale(data, width) {\n        width = width || this.width();\n        data = data || this.prepareData()\n                           .map(d => d.data)\n                           .reduce((acc, val) => acc.concat(val));\n\n        return d3.scaleTime()\n                    .range([0, width])\n                 .domain(d3.extent(data, d => d._x));\n    }\n\n    getD3YScale(data, height) {\n        data = data || this.prepareData()\n                           .map(d => d.data)\n                           .reduce((acc, val) => acc.concat(val));\n        height = height || this.height();\n\n        return d3.scaleLinear()\n          .range([height, 0])\n          .nice(5)\n          .domain([Math.min(0, d3.min(data, d => d._y)), d3.max(data, d => d._y)]);\n\n    }\n}\n\n\nfunction getClosestPoint(xval, yval, data) {\n    let calcDist = d => Math.sqrt(Math.abs(d._x - xval) ** 2 + (d._y - yval) ** 2);\n    let min = data[0];\n    let minDist = calcDist(min);\n\n    data.forEach(d => {\n        let dist = calcDist(d);\n        if (dist < minDist) {\n            minDist = dist;\n            min = d;\n        }\n    });\n\n    return min;\n}\n\n\n\nfunction line() {\n    return new Line();\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvTGluZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2IzanMvLi9zcmMvTGluZS5qcz82OTViIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoQykgMjAxMy0yMDE0LCAyMDE4IEJyYW5kc0V5ZSAoUFRZKSBMVERcbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXNcbi8vIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZVxuLy8gd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LFxuLy8gICAgIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG9cbi8vIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nXG4vLyBjb25kaXRpb25zOlxuLy9cbi8vICAgICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbi8vIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gICAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1IgSU1QTElFRCxcbi8vICAgICBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQVxuLy8gUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxuLy8gSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GXG4vLyBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkVcbi8vIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5pbXBvcnQgeyBHZW9tZXRyeSB9IGZyb20gJy4vR2VvbWV0cnknO1xuXG5cbmNsYXNzIExpbmUgZXh0ZW5kcyBHZW9tZXRyeSB7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoXCJMSU5FXCIsIDIpO1xuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJcXHQgUmVuZGVyaW5nIExJTkVcIik7XG5cbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuX2VsZW1lbnQ7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLnByZXBhcmVEYXRhKCk7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gdGhpcy5fd2lkdGgsXG4gICAgICAgICAgICAgIGhlaWdodCA9IHRoaXMuX2hlaWdodDtcbiAgICAgICAgY29uc3QgYWxsRGF0YSA9IGRhdGEubWFwKGQgPT4gZC5kYXRhKS5yZWR1Y2UoKGFjYywgdmFsKSA9PiBhY2MuY29uY2F0KHZhbCkpO1xuXG4gICAgICAgIGVsZW1lbnQuY2xhc3NlZChcImxpbmUtY2hhcnRcIiwgdHJ1ZSk7XG5cblxuICAgICAgICBjb25zdCB4ID0gdGhpcy5nZXREM1hTY2FsZShhbGxEYXRhLCB3aWR0aCk7XG4gICAgICAgIGNvbnN0IHkgPSB0aGlzLmdldEQzWVNjYWxlKGFsbERhdGEsIGhlaWdodCk7XG5cbiAgICAgICAgY29uc29sZS5sb2coXCJsaW5lcyB5IHJhbmdlXCIsIHkucmFuZ2UoKSk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwibGluZXMgeSBkb21haW5cIiwgeS5kb21haW4oKSk7XG5cbiAgICAgICAgY29uc3QgY29sb3VycyA9IGQzLnNjYWxlT3JkaW5hbCh0aGlzLmNvbG91clNjYWxlKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC5kb21haW4odGhpcy5nZXRDb2xvdXJEb21haW4oZGF0YSkpO1xuXG5cbiAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gYXBwZW5kIHRoZSBsaW5lc1xuICAgICAgICBsZXQgbGluZUdyb3VwID0gZWxlbWVudC5zZWxlY3QoXCIubGluZXNcIik7XG4gICAgICAgIGxpbmVHcm91cC5zZWxlY3RBbGwoXCJjaXJjbGVcIikucmVtb3ZlKCk7XG5cbiAgICAgICAgbGV0IGNpcmNsZSA9IGZhbHNlO1xuICAgICAgICBsZXQgbGFzdE1vdXNlID0gbnVsbDtcbiAgICAgICAgbGV0IGxhc3RNaW4gPSBudWxsO1xuXG4gICAgICAgIGlmIChsaW5lR3JvdXAuZW1wdHkoKSkge1xuICAgICAgICAgICAgbGluZUdyb3VwID0gZWxlbWVudFxuICAgICAgICAgICAgICAgIC5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImxpbmVzXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCB0aGlzLndpZHRoKCkpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgdGhpcy5oZWlnaHQoKSk7XG5cbiAgICAgICAgICAgIC8vIFRoaXMgaXMgbmVlZGVkIHRvIHByb3ZpZGUgYXJlYSBmb3IgbW91c2UgaW50ZXJhY3Rpb25zLlxuICAgICAgICAgICAgbGluZUdyb3VwXG4gICAgICAgICAgICAgICAgLmFwcGVuZChcInJlY3RcIilcbiAgICAgICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMFwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwid2lkdGhcIiwgXCIxMDAlXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgXCIxMDAlXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGluZUdyb3VwXG4gICAgICAgICAgICAub24oXCJtb3VzZW1vdmVcIiwgKGQsIGksIG5vZGVzKSA9PiB7IC8vIERhcmtlbiB0aGUgYmFyIG9uIG1vdXNlIG92ZXJcbiAgICAgICAgICAgICAgICBjb25zdCBtb3VzZSA9IGQzLm1vdXNlKG5vZGVzW2ldKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHh2YWwgPSB4LmludmVydChtb3VzZVswXSk7XG4gICAgICAgICAgICAgICAgY29uc3QgeXZhbCA9IHkuaW52ZXJ0KG1vdXNlWzFdKTtcbiAgICAgICAgICAgICAgICAvLyBsZXQgbWluID0gdGhpcy5nZXRDbG9zZXN0UG9pbnQoeHZhbCwgeXZhbCwgdGhpcy5nZXRUcmFuc2Zvcm1lZERhdGEoKVswXS5kYXRhKTtcblxuICAgICAgICAgICAgICAgIGxldCBtaW5zID0gZGF0YS5tYXAoZCA9PiBnZXRDbG9zZXN0UG9pbnQoeHZhbCwgeXZhbCwgZC5kYXRhKSk7XG4gICAgICAgICAgICAgICAgbWlucy5mb3JFYWNoKGQgPT4gZC5fZGlzdCA9ICBbeChkLl94KSwgeShkLl95KV0pO1xuXG4gICAgICAgICAgICAgICAgbWlucyA9IG1pbnMuZmlsdGVyKG1pbiA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1pblNjcmVlbkRpc3QgPSBNYXRoLnNxcnQoKG1vdXNlWzBdIC0gbWluLl9kaXN0WzBdKSAqKiAyICsgKG1vdXNlWzFdIC0gbWluLl9kaXN0WzFdKSAqKiAyKTtcbiAgICAgICAgICAgICAgICAgICAgbWluLl9taW5fc2NyZWVuID0gbWluU2NyZWVuRGlzdDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1pblNjcmVlbkRpc3QgPCAxMDA7XG4gICAgICAgICAgICAgICAgfSk7XG5cblxuICAgICAgICAgICAgICAgIGlmICghbWlucyB8fCAhbWlucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdE1vdXNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgbGluZUdyb3VwLnNlbGVjdEFsbChcImNpcmNsZVwiKS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG1pbnMgPSBtaW5zLnNvcnQoKGxocywgcmhzKSA9PiBsaHMuX21pbl9zY3JlZW4gLSByaHMuX21pbl9zY3JlZW4pO1xuICAgICAgICAgICAgICAgIGxldCBtaW4gPSBtaW5zWzBdO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNpcmNsZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobGFzdE1pbiAmJiBtaW4uX3guZ2V0VGltZSgpID09PSBsYXN0TWluLl94LmdldFRpbWUoKSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICBsaW5lR3JvdXAuc2VsZWN0QWxsKFwiY2lyY2xlXCIpLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNpcmNsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgbGFzdE1vdXNlID0gbW91c2U7XG4gICAgICAgICAgICAgICAgbGFzdE1pbiA9IG1pbjtcbiAgICAgICAgICAgICAgICBsaW5lR3JvdXBcbiAgICAgICAgICAgICAgICAgICAgLmFwcGVuZChcImNpcmNsZVwiKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcImN4XCIsIHgobWluLl94KSlcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJjeVwiLCB5KG1pbi5feSkpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiclwiLCAxMClcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJmaWxsXCIsIGQuX2NvbG91cilcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAwLjEpXG4gICAgICAgICAgICAgICAgICAgIC5vbihcIm1vdXNlb3ZlclwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXNwYXRjaC5jYWxsKFwidG9vbHRpcFNob3dcIiwgdGhpcywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGU6IGQzLmV2ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50OiBtaW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzOiBkYXRhW21pbi5fc19pXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXNJbmRleDogbWluLl9zX2ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG1pbi5feVxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLm9uKFwibW91c2VvdXRcIiwgKGQsIGksIG5vZGVzKSA9PiB7IC8vIGJhciBpcyByZWd1bGFyIGNvbG91ciBvbiBtb3VzZSBvdXQuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXNwYXRjaC5jYWxsKFwidG9vbHRpcEhpZGVcIiwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKClcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAwLjUpXG5cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIGxldCBsaW5lcyA9IGxpbmVHcm91cC5zZWxlY3RBbGwoJy5saW5lJyk7XG4gICAgICAgIGxpbmVzID0gbGluZXMuZGF0YShkYXRhKTtcblxuICAgICAgICBsaW5lcy5leGl0KCkucmVtb3ZlKCk7XG5cbiAgICAgICAgY29uc3QgbGluZSA9IGQzLmxpbmUoKVxuICAgICAgICAgICAgICAgICAgICAgICAueChkID0+IHgoZC5feCkpXG4gICAgICAgICAgICAgICAgICAgICAgIC55KGQgPT4geShkLl95KSk7XG5cbiAgICAgICAgbGluZXNcbiAgICAgICAgICAgIC5lbnRlcigpXG4gICAgICAgICAgICAuYXBwZW5kKFwicGF0aFwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJsaW5lXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJmaWxsXCIsIFwibm9uZVwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwic3Ryb2tlXCIsIGQgPT4gZDMuaGNsKGNvbG91cnMoZC5fY29sb3VyKSkuZGFya2VyKCkpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJzdHJva2UtbGluZWpvaW5cIiwgXCJyb3VuZFwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwic3Ryb2tlLWxpbmVjYXBcIiwgXCJyb3VuZFwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwic3Ryb2tlLXdpZHRoXCIsIDIpXG4gICAgICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAwKVxuICAgICAgICAgICAgLnRyYW5zaXRpb24oKVxuICAgICAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMSlcbiAgICAgICAgICAgICAgICAuYXR0cihcImRcIiwgZCA9PiBsaW5lKGQuZGF0YSkpO1xuXG4gICAgICAgIGxpbmVzXG4gICAgICAgICAgICAudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAuYXR0cihcImRcIiwgZCA9PiBsaW5lKGQuZGF0YSkpO1xuICAgIH1cblxuXG4gICAgZ2V0RDNYU2NhbGUoZGF0YSwgd2lkdGgpIHtcbiAgICAgICAgd2lkdGggPSB3aWR0aCB8fCB0aGlzLndpZHRoKCk7XG4gICAgICAgIGRhdGEgPSBkYXRhIHx8IHRoaXMucHJlcGFyZURhdGEoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChkID0+IGQuZGF0YSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZWR1Y2UoKGFjYywgdmFsKSA9PiBhY2MuY29uY2F0KHZhbCkpO1xuXG4gICAgICAgIHJldHVybiBkMy5zY2FsZVRpbWUoKVxuICAgICAgICAgICAgICAgICAgICAucmFuZ2UoWzAsIHdpZHRoXSlcbiAgICAgICAgICAgICAgICAgLmRvbWFpbihkMy5leHRlbnQoZGF0YSwgZCA9PiBkLl94KSk7XG4gICAgfVxuXG4gICAgZ2V0RDNZU2NhbGUoZGF0YSwgaGVpZ2h0KSB7XG4gICAgICAgIGRhdGEgPSBkYXRhIHx8IHRoaXMucHJlcGFyZURhdGEoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChkID0+IGQuZGF0YSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZWR1Y2UoKGFjYywgdmFsKSA9PiBhY2MuY29uY2F0KHZhbCkpO1xuICAgICAgICBoZWlnaHQgPSBoZWlnaHQgfHwgdGhpcy5oZWlnaHQoKTtcblxuICAgICAgICByZXR1cm4gZDMuc2NhbGVMaW5lYXIoKVxuICAgICAgICAgIC5yYW5nZShbaGVpZ2h0LCAwXSlcbiAgICAgICAgICAubmljZSg1KVxuICAgICAgICAgIC5kb21haW4oW01hdGgubWluKDAsIGQzLm1pbihkYXRhLCBkID0+IGQuX3kpKSwgZDMubWF4KGRhdGEsIGQgPT4gZC5feSldKTtcblxuICAgIH1cbn1cblxuXG5mdW5jdGlvbiBnZXRDbG9zZXN0UG9pbnQoeHZhbCwgeXZhbCwgZGF0YSkge1xuICAgIGxldCBjYWxjRGlzdCA9IGQgPT4gTWF0aC5zcXJ0KE1hdGguYWJzKGQuX3ggLSB4dmFsKSAqKiAyICsgKGQuX3kgLSB5dmFsKSAqKiAyKTtcbiAgICBsZXQgbWluID0gZGF0YVswXTtcbiAgICBsZXQgbWluRGlzdCA9IGNhbGNEaXN0KG1pbik7XG5cbiAgICBkYXRhLmZvckVhY2goZCA9PiB7XG4gICAgICAgIGxldCBkaXN0ID0gY2FsY0Rpc3QoZCk7XG4gICAgICAgIGlmIChkaXN0IDwgbWluRGlzdCkge1xuICAgICAgICAgICAgbWluRGlzdCA9IGRpc3Q7XG4gICAgICAgICAgICBtaW4gPSBkO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gbWluO1xufVxuXG5cblxuZXhwb3J0IGZ1bmN0aW9uIGxpbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBMaW5lKCk7XG59Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/Line.js\n");

/***/ }),

/***/ "./src/LineChart.js":
/*!**************************!*\
  !*** ./src/LineChart.js ***!
  \**************************/
/*! exports provided: LineChart */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LineChart\", function() { return LineChart; });\n/* harmony import */ var _Colours__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Colours */ \"./src/Colours.js\");\n/* harmony import */ var _Chart__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Chart */ \"./src/Chart.js\");\n// Copyright (C) 2013-2014, 2018 BrandsEye (PTY) LTD\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this\n// software and associated documentation files (the \"Software\"), to deal in the Software\n// without restriction, including without limitation the rights to use, copy, modify,\n//     merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following\n// conditions:\n//\n//     The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n//     INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n// CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n\n\nclass LineChart extends _Chart__WEBPACK_IMPORTED_MODULE_1__[\"Chart\"] {\n\n    constructor() {\n        super();\n        this._xAxisTickFormat = d3.timeFormat(\"%B %d\");\n    }\n\n    //------------------------------------------------------\n\n    data(data) {\n        if (!arguments.length) return this._data;\n        if (data && data[0].key === undefined) {\n            data = [\n                {\n                    key: \"series 1\",\n                    values: data\n                }\n            ];\n        }\n        this._data = data;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    element(element) {\n        if (!arguments.length) return this._element;\n        this._element = element;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    showLabels(show) {\n        if (!arguments.length) return this._show_labels;\n        this._show_labels = show;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    // todo dispatch\n    showLegend(show) {\n        if (!arguments.length) return this._show_legend;\n        this._show_legend = show;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    x(x) {\n        if (!arguments.length) return this._x;\n        this._x = x;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    y(y) {\n        if (!arguments.length) return this._y;\n        this._y = y;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    width(width) {\n        if (!arguments.length) return this._width;\n        this._width = width;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    height(height) {\n        if (!arguments.length) return this._height;\n        this._height = height;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    colours(colours) {\n        if (!arguments.length) return this._colours;\n        this._colours = colours;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    backgroundColour(colour) {\n        if (!arguments.length) return this._backgroundColour;\n        this._backgroundColour = colour || \"#FFF\"; // never set it to null.\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    tickFormat(format) {\n        if (!arguments.length) return this._tickFormat;\n        this._tickFormat = format;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    xAxisTickFormat(format) {\n        if (!arguments.length) return this._xAxisTickFormat;\n        this._xAxisTickFormat = format || (d => d.toString());\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    labelFormat(format) {\n        if (!arguments.length) return this._labelFormat;\n        this._labelFormat = format || (d => d.toString());\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    // todo missing\n    labelCompression(compression) {\n        if (!arguments.length) return this._compression;\n        this._compression = compression;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    //todo missing\n    dataAxisLabel(label) {\n        if (!arguments.length) return this._dataAxisLabel;\n        this._dataAxisLabel = label;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    tooltip(tooltip) {\n        if (!arguments.length) return this._tooltip;\n        this._tooltip = tooltip;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    forceY(force) {\n        if (!arguments.length) return this._forceY;\n        this._forceY = force;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n// todo missing\n    duration(duration) {\n        if (!arguments.length) return this._duration;\n        this._duration = duration;\n        return this;\n    }\n\n// todo missing\n    coarseness(coarseness) {\n        if (!arguments.length) return this._coarseness;\n        this._coarseness = coarseness;\n        return this;\n    }\n\n    // todo missing\n    padding(padding) {\n        if (!arguments.length) return this._padding;\n        this._padding = padding;\n        return this;\n    }\n\n    // todo missing\n    xAxisTooltips(tooltips) {\n        if (!arguments.length) return this._xAxisTooltips;\n        this._xAxisTooltips = tooltips;\n        return this;\n    }\n\n    xAxisOverride(override) {\n        if (!arguments.length) return this._xAxisOverride;\n        this._xAxisOverride = override;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    dispatch() {\n        return this._dispatch;\n    }\n\n    //------------------------------------------------------\n\n    render() {\n        if (!this._element) throw new Error(\"No element set for ColumnChart. See #element()\");\n        if (!this._data) {\n            console.warn(\"No data set for ColumnChart. See #data()\");\n            return;\n        }\n\n        const data = this.getTransformedData();\n        const keys = this.getKeys();\n\n        //------------------------------------------------\n        // Set up the SVG area\n\n        let topLevel = d3.select(this._element).select(\"svg\");\n        if (topLevel.empty()) {\n            topLevel = d3.select(this._element).append(\"svg\");\n        }\n\n        topLevel\n            .style(\"width\", this._width + \"px\")\n            .style(\"height\", this._height + \"px\");\n\n\n        // ---------------------------------\n        // Layout the showLegend.\n        //\n        // We do this now because we need to know how much space the legend\n        // takes up in order to finish calculating the margins.\n\n        const legendHeight = this.renderLegend();\n\n        //----------------------------------\n        // Calculate margins.\n\n        const margin = {top: 20, right: 20, bottom: 40, left: 40};\n        margin.bottom += legendHeight ? legendHeight + 20 : 0;\n\n        if (this._dataAxisLabel) margin.left += 20 + 12;\n        if (data) {\n            let maxLabelLength = 0;\n            data.forEach(d => {\n                d.data.forEach(d => {\n                    let length = this._xAxisTickFormat(this._x(d)).length;\n                    if (length > maxLabelLength) maxLabelLength = length;\n                })\n            });\n            margin.bottom += maxLabelLength * 2 + 10;    // space for axes labels.\n        }\n\n        const width = this._width - margin.left - margin.right,\n            height = this._height - margin.top - margin.bottom;\n\n        //----------------------------------\n        // Calculate scales and so on.\n\n\n        const x = d3.scaleTime()\n            .range([0, width]);\n\n        const y = d3.scaleLinear()\n            .range([height, 0])\n            .nice(5);\n        this._xscale = x;\n        this._yscale = y;\n\n        // Scale the range of the data in the domains\n\n        const allData = data.map(d => d.data).reduce((acc, val) => acc.concat(val));\n        x.domain(d3.extent(allData, d => d._x));\n        y.domain([Math.min(0, d3.min(allData, d => d._y)), d3.max(allData, d => d._y)]);\n\n        //------------------------------\n\n        let svg = topLevel.select('.main-group');\n\n        if (svg.empty()) {\n            svg = topLevel\n                .append(\"g\")\n                .attr(\"class\", \"main-group\");\n        }\n\n        svg.attr(\"transform\", \"translate(\" + margin.left + \",\" + margin.top + \")\");\n\n        //---------------------------------\n        // append the lines\n        let lineGroup = svg.select(\".lines\");\n        lineGroup.selectAll(\"circle\").remove();\n\n        let circle = false;\n        let lastMouse = null;\n        let lastMin = null;\n\n        if (lineGroup.empty()) {\n            lineGroup = svg\n                .append(\"g\")\n                .attr(\"class\", \"lines\")\n\n            lineGroup\n                .append(\"rect\")\n                .style(\"opacity\", \"0\")\n                .attr(\"width\", \"100%\")\n                .attr(\"height\", \"100%\");\n        }\n\n        lineGroup\n            .on(\"mousemove\", (d, i, nodes) => { // Darken the bar on mouse over\n                const mouse = d3.mouse(nodes[i]);\n\n                const xval = x.invert(mouse[0]);\n                const yval = y.invert(mouse[1]);\n                // let min = this.getClosestPoint(xval, yval, this.getTransformedData()[0].data);\n\n                let mins = data.map(d => this.getClosestPoint(xval, yval, d.data));\n                mins.forEach(d => d._dist =  [x(d._x), y(d._y)])\n\n                mins = mins.filter(min => {\n                    const minScreenDist = Math.sqrt((mouse[0] - min._dist[0]) ** 2 + (mouse[1] - min._dist[1]) ** 2);\n                    min._min_screen = minScreenDist;\n                    return minScreenDist < 100;\n                });\n\n\n                if (!mins || !mins.length) {\n                    lastMouse = null;\n                    lineGroup.selectAll(\"circle\").remove();\n                    return;\n                }\n\n                mins = mins.sort((lhs, rhs) => lhs._min_screen - rhs._min_screen);\n                let min = mins[0];\n\n                if (circle) {\n                    if (lastMin && min._x.getTime() === lastMin._x.getTime()) return;\n                    lineGroup.selectAll(\"circle\").remove();\n                }\n\n                circle = true;\n                lastMouse = mouse;\n                lastMin = min;\n                lineGroup\n                    .append(\"circle\")\n                        .attr(\"cx\", x(min._x))\n                        .attr(\"cy\", y(min._y))\n                        .attr(\"r\", 10)\n                        .attr(\"fill\", this.getSeriesColour(min._s_i))\n                        .style(\"opacity\", 0.1)\n                    .on(\"mouseover\", () => {\n                        this._dispatch.call(\"tooltipShow\", this, {\n                            e: d3.event,\n                            point: min,\n                            series: data[min._s_i],\n                            seriesIndex: min._s_i,\n                            value: min._y\n                        })\n                    })\n                    .on(\"mouseout\", (d, i, nodes) => { // bar is regular colour on mouse out.\n                        this._dispatch.call(\"tooltipHide\", this);\n                    })\n                    .transition()\n                        .style(\"opacity\", 0.5)\n\n            });\n\n        let lines = lineGroup.selectAll('.line');\n        lines = lines.data(data);\n\n        lines.exit().remove();\n\n        const line = d3.line()\n            .x(d => x(d._x))\n            .y(d => y(d._y));\n\n        lines\n            .enter()\n            .append(\"path\")\n                .attr(\"class\", \"line\")\n                .attr(\"fill\", \"none\")\n                .attr(\"stroke\", (d, i) => this.getSeriesColour(i))\n                .attr(\"stroke-linejoin\", \"round\")\n                .attr(\"stroke-linecap\", \"round\")\n                .attr(\"stroke-width\", 1.5)\n                .style(\"opacity\", 0)\n\n            // .transition()\n            // .duration(this._duration)\n                .style(\"opacity\", 1)\n                .attr(\"d\", d => line(d.data));\n\n        lines\n            // .transition()\n            .attr(\"d\", d => line(d.data));\n\n\n        // Adding new groups, and hence adding new bars to those groups.\n        // groups.enter()\n        //     .append(\"g\")\n        //     .attr(\"class\", \"group\")\n        //     .attr(\"transform\", d => \"translate(\" + x(d.key) + \",0)\")\n        //     .attr(\"width\", x.bandwidth())\n        //     .attr(\"height\", \"100%\")\n        //     .merge(groups)\n        //     .interrupt(\"groups:move\")\n        //     .transition(\"groups:move\")\n        //     .attr(\"transform\", d => \"translate(\" + x(d.key) + \",0)\")\n        //     .attr(\"width\", x.bandwidth())\n        //     .each((s_d, s_i, nodes) => {\n        //         let group = d3.select(nodes[s_i])\n        //\n        //         let bars = group.selectAll(\".bar\")\n        //             .data(s_d.data);\n        //\n        //         bars.exit().remove();\n        //\n        //         bars.interrupt(\"bar:move\")     // Animate the bars to their new position.\n        //             .transition(\"bar:move\")\n        //             .attr(\"width\", xGroup.bandwidth())\n        //             .attr(\"x\", d => xGroup(d._key))\n        //             .attr(\"y\", 0);\n        //\n        //         bars.enter()\n        //             .append(\"rect\")\n        //             .attr(\"class\", (d, i) => \"bar series series-\" + i)\n        //             .attr(\"x\", d => xGroup(d._key))\n        //             .attr(\"y\", 0)\n        //             .attr(\"width\", xGroup.bandwidth())\n        //             .attr(\"height\", 0)\n        //             .style(\"fill\", (d, i) => this.getSeriesColour(i))\n        //             .style(\"cursor\", \"pointer\")\n        //             .on(\"mouseover\", (d, i, nodes) => { // Darken the bar on mouse over\n        //                 d3.select(nodes[i])\n        //                     .interrupt(\"hover:colour\")\n        //                     .transition(\"hover:colour\")\n        //                     .duration(400)\n        //                     .style(\"fill\", d3.hcl(this.getSeriesColour(i)).darker())\n        //                 this._dispatch.call(\"tooltipShow\", this, {\n        //                     e: d3.event,\n        //                     point: d,\n        //                     series: s_d,\n        //                     seriesIndex: s_i,\n        //                     value: d._y\n        //                 })\n        //             })\n        //             .on(\"mouseout\", (d, i, nodes) => { // bar is regular colour on mouse out.\n        //                 d3.select(nodes[i])\n        //                     .interrupt(\"hover:colour\")\n        //                     .transition(\"hover:colour\")\n        //                     .duration(400)\n        //                     .style(\"fill\", this.getSeriesColour(i));\n        //                 this._dispatch.call(\"tooltipHide\", this);\n        //             })\n        //             .on(\"click auxclick\", (d, i, nodes) => {\n        //                 this._dispatch.call(\"elementClick\", this, {\n        //                     e: d3.event,\n        //                     point: d,\n        //                     series: d._series,\n        //                     seriesIndex: s_i,\n        //                     value: this._y(d)\n        //                 })\n        //             })\n        //             .merge(bars)\n        //             .interrupt(\"bar:growth\")    // Animate bars growing.\n        //             .transition(\"bar:growth\")\n        //             .delay((d) => {\n        //                 return this.calcBarGrowth(s_i, nodes.length);\n        //             })\n        //             .duration(this._duration)\n        //             .style(\"fill\", (d, i) => this.getSeriesColour(i))\n        //             .attr(\"height\", d => height - y(d._y));\n        //\n        //     })\n\n        // ---------------------------------\n        // Labels loaded after our first bar grows.\n        // if (this._show_labels) {\n        //     svg.transition(\"bar:growth\")\n        //         .on(\"end\", (d, i, nodes) => {\n        //             if (i < nodes.length - 1) return;\n        //             this.renderLabels(svg, data, x, xGroup, y);\n        //         })\n        // }\n\n        // ---------------------------------\n        // Draw the y axis data label.\n\n        if (this._dataAxisLabel) {\n            this.renderDataAxisLabel(height, margin);\n        }\n\n        // ---------------------------------\n        // Set the background colour\n\n        d3.select(this._element).select(\".background\").remove();\n        if (this._backgroundColour) {\n            d3.select(this._element).select(\"svg\")\n                .append(\"rect\")\n                .attr(\"class\", \"background\")\n                .attr(\"width\", \"100%\")\n                .attr(\"height\", \"100%\")\n                .style(\"fill\", this._backgroundColour)\n                .lower();\n        }\n\n        //---------------------------------\n        // add the Y gridlines\n        svg.call(this.grid, width, d3.axisLeft(y).ticks(5));\n\n        //---------------------------------\n        // axes\n        svg.call(this.xaxis, height, d3.axisBottom(x).tickSize(0).tickPadding(5).tickFormat(this._xAxisTickFormat)); //); //\n        svg.call(this.yaxis, d3.axisLeft(y).ticks(5).tickFormat(this._tickFormat));\n    }\n\n    //------------------------------------------------------\n\n    /*\n     * Returns an object with two functions, #show() and #hide(),\n     * to show and hide the labels.\n     */\n    labels() {\n        return {\n\n            show: () => {\n                if (this._element) {\n                    let selection = this._element,\n                        data = this.getTransformedData(),\n                        xscale = this._xscale,\n                        xgroup = this._xgroupscale,\n                        yscale = this._yscale;\n\n                    if (selection) selection = d3.select(this._element).select(\"svg\").select(\"g\");\n                    if (!selection.empty() && data && xscale && yscale && xgroup) {\n                        let labels = selection.select('.chart-labels');\n                        if (!labels.empty()) return;\n                        labels.remove()\n                        this.renderLabels(selection, data, xscale, xgroup, yscale, false);\n                    }\n                }\n\n            },\n\n            hide: () => {\n                if (this._element) {\n                    d3.select(this._element)\n                        .select('.chart-labels')\n                        .interrupt(\"labels\")\n                        .interrupt(\"labels:fade\")\n                        .transition(\"labels:fade\")\n                        .style(\"opacity\", 0)\n                        .on(\"end\", (d, i, nodes) => {\n                            d3.select(nodes[i]).remove();\n                        })\n                }\n            }\n        }\n    }\n\n    //------------------------------------------------------\n\n    renderLabels(selection, data, xscale, xgroup, yscale, animate) {\n        animate = animate === undefined ? true : animate;\n        selection.selectAll(\".chart-labels\").remove();\n\n        let labels = selection.append(\"g\")\n            .attr(\"class\", \"chart-labels\")\n            // .selectAll(\".chart-label\")\n            .selectAll(\".label-group\")\n            .data(data)\n\n        let maxWidth = 0;     // For calculating the max width of text.\n        let fontSize = 12;    // Our initial font size.\n        const buffer = 5;     // Buffer space between words and the top of a bar.\n        const calcDy = (ypos) => ypos < 10 ? fontSize + buffer : -buffer;\n\n        labels.enter().each((series, s_i, s_nodes) => {\n            let group = d3.select(s_nodes[s_i])\n                .append(\"g\")\n                .attr(\"class\", \"label-group\")\n                .attr(\"transform\", d => \"translate(\" + xscale(d.key) + \",0)\")\n                .selectAll(\".chart-label\")\n                .data(series.data)\n                .enter()\n                .each((d, i, nodes) => {\n\n                    // Want to figure out if the label is too dark / light for the\n                    // bar.\n                    let invertedColor = d3.hcl(this.getSeriesColour(i));\n                    invertedColor.l += Math.min(invertedColor.l + 50, 100);\n                    let invert = d3.hcl(this.getSeriesColour(i)).l < 60;\n\n                    let ypos = yscale(d._y);\n                    let dy = calcDy(ypos);\n                    let text = d3.select(nodes[i])\n                        .append(\"text\")\n                        .text(this._labelFormat(d._y))\n                        .attr(\"class\", \"chart-label\")\n                        .attr(\"y\", ypos)\n                        .attr(\"dx\", animate ? -15 : 0)\n                        .attr(\"dy\", dy)\n                        .style(\"opacity\", 0)\n                        .style(\"pointer-events\", \"none\")\n                        // .style(\"font-family\", \"Open Sans, sans-serif\")\n                        // .style(\"font-weight\", \"normal\")\n                        // .style(\"font-size\", fontSize + \"px\")\n                        .style(\"fill\", dy > 0 && invert ? invertedColor.toString() : _Colours__WEBPACK_IMPORTED_MODULE_0__[\"colours\"].eighteen.darkGrey);\n\n                    // Set the x position, which is based on width.\n                    const width = text.node().getBBox().width;\n                    maxWidth = Math.max(width, maxWidth);\n                    text\n                        .attr(\"x\", xgroup(d._key) + xgroup.bandwidth() / 2 - width / 2);\n\n                    text\n                        .transition(\"labels\")\n                        .delay(() => animate ? this.calcBarGrowth(s_i, s_nodes.length) : 0) // Delay in lockstep with bar growth.\n                        .duration(this._duration)\n                        .attr(\"dx\", 0)\n                        .style(\"opacity\", 1)\n                })\n        })\n\n\n        // Figure out if we don't have enough space to show our labels.\n        // We then want to resize, if possible.\n        if (xgroup.bandwidth() < maxWidth * 1.05) {\n            let scale = maxWidth / xgroup.bandwidth() * 1.05;\n            fontSize = Math.floor(fontSize / scale);\n\n            if (fontSize < 8) {\n                // The labels are too small.\n                labels.enter().selectAll(\"text\").remove();\n            } else {\n                labels.enter()\n                    .merge(labels)\n                    .selectAll(\"text\")\n                    .style(\"font-size\", fontSize + \"px\")\n                    .each((d, i, nodes) => {\n                        const text = d3.select(nodes[i]);\n                        const width = text.node().getBBox().width;\n                        text\n                            .attr(\"x\", xgroup(d._key) + xgroup.bandwidth() / 2 - width / 2)\n                            .attr(\"dy\", calcDy(d._y));\n                    })\n            }\n        }\n    }\n\n    //------------------------------------------------------\n\n    renderDataAxisLabel(height, margins) {\n        let svg = d3.select(this._element).select('svg');\n        svg.selectAll(\".data-labels\").remove();\n\n        if (!this._dataAxisLabel) return;\n        let text = this._dataAxisLabel;\n        if (text.long) text = text.long;\n\n        let x = -(margins.top + height / 2);\n\n        let label = svg.append(\"g\")\n            .attr(\"class\", \"data-labels\")\n            .append(\"text\")\n            .text(text)\n            .attr(\"transform\", \"rotate(-90 0,0) translate(\" + x + \", 20)\")\n            // .style(\"font-family\", \"Open Sans, sans-serif\")\n            // .style(\"font-size\", \"12px\")\n            // .style(\"font-style\", \"italic\")\n            .style(\"fill\", _Colours__WEBPACK_IMPORTED_MODULE_0__[\"colours\"].eighteen.darkGrey);\n\n        let width = label.node().getBBox().width;\n        if (width >= height && this._dataAxisLabel.short) {\n            label.text(this._dataAxisLabel.short);\n            width = label.node().getBBox().width;\n        }\n\n        label.attr(\"dx\", -width / 2);\n    }\n\n    //------------------------------------------------------\n\n    grid(selection, width, axis) {\n        selection.select(\".grid\").remove();\n\n        let grid = selection.append(\"g\")\n            .attr(\"class\", \"grid\")\n            .call(axis\n                .tickSize(-width)\n                .tickFormat(\"\")\n            );\n\n        grid.selectAll(\"line\")\n            .style(\"stroke\", _Colours__WEBPACK_IMPORTED_MODULE_0__[\"colours\"].eighteen.lightGrey);\n        grid.selectAll(\".domain\").remove();\n\n        grid\n            .lower() // Always ensure that this is earlier in the dom. Things must be drawn on top of it.\n            .style(\"opacity\", 0)\n            .transition()\n            .delay(500)\n            .duration(500)\n            .style(\"opacity\", 1);\n    }\n\n    //------------------------------------------------------\n\n    xaxis(selection, height, xaxis) {\n        selection.select(\".x-axis\").remove();\n        let axis = selection.append(\"g\")\n            .attr(\"class\", \"x-axis\")\n            .attr(\"transform\", \"translate(0,\" + height + \")\")\n            .style(\"opacity\", 0)\n            .call(xaxis);\n\n        axis.select(\".domain\").remove();\n\n        axis\n            .selectAll(\"text\")\n            .style('text-anchor', 'end')\n            .attr('transform', 'rotate(-30, 0,0)');\n\n        axis\n            .transition()\n            .duration(1000)\n            .style(\"opacity\", 1);\n    }\n\n    //------------------------------------------------------\n\n    yaxis(selection, axis) {\n        selection.select(\".y-axis\").remove();\n        let x = selection.append(\"g\")\n            .attr(\"class\", \"y-axis\")\n            .call(axis.tickSize(0).tickPadding(10))\n            .style(\"opacity\", 0)\n            .transition()\n            .duration(1000)\n            .style(\"opacity\", 1);\n\n        x.selectAll(\"text\")\n            // .style(\"font-family\", \"Open Sans, sans-serif\")\n            .style(\"fill\", _Colours__WEBPACK_IMPORTED_MODULE_0__[\"colours\"].eighteen.darkGrey)\n    }\n\n    //------------------------------------------------------\n\n    calcBarGrowth(i, max) {\n        if (max < 10) return i * this._BAR_GROWTH / 2;\n        if (max < 35) return i * this._BAR_GROWTH / 4;\n        return 1;\n    }\n\n    getSeriesColour(i) {\n        if (i < 0 || !this._colours) return _Colours__WEBPACK_IMPORTED_MODULE_0__[\"colours\"].eighteen.midGrey;\n\n        i = i % this._colours.length;\n        return this._colours[i];\n    }\n\n    getSortedData() {\n        let data = this._data;\n        if (!data || !data.length) return [];\n\n        data = this._data.sort((lhs, rhs) => {\n            lhs = lhs.key.toLowerCase();\n            rhs = rhs.key.toLowerCase();\n\n            if (lhs === rhs) return 0;\n            if (lhs < rhs) return -1;\n            return 1;\n        });\n\n        return data;\n    }\n\n    getTransformedData() {\n        let data = this.getSortedData();\n        if (!data || !data.length) return [];\n\n        let results = [];\n\n        data.forEach((series, s_i) => {\n            let s = Object.assign({}, series);\n            results.push(s);\n\n            let data = [];\n            s.values.forEach((d) => {\n                data.push(Object.assign({\n                    _x: new Date(this._xAxisOverride ? this._xAxisOverride[this._x(d)] : this._x(d)),\n                    _series: series,\n                    _s_i: s_i,\n                    _key: series.key,\n                    _y: this._y(d)\n                }, d));\n            });\n\n            s.data = data;\n            delete s.values;\n        });\n\n        return results;\n    }\n\n    getKeys() {\n        let data = this._data;\n        if (!data || !data.length) return [];\n\n        return [...new Set(data.map(d => d.key))]\n    }\n\n    getClosestPoint(xval, yval, data) {\n        let calcDist = d => Math.sqrt(Math.abs(d._x - xval) ** 2 + (d._y - yval) ** 2);\n        let min = data[0];\n        let minDist = calcDist(min);\n\n        data.forEach(d => {\n            let dist = calcDist(d);\n            if (dist < minDist) {\n                minDist = dist;\n                min = d;\n            }\n        });\n\n        return min;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvTGluZUNoYXJ0LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYjNqcy8uL3NyYy9MaW5lQ2hhcnQuanM/ODk0ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKEMpIDIwMTMtMjAxNCwgMjAxOCBCcmFuZHNFeWUgKFBUWSkgTFREXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZiB0aGlzXG4vLyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmVcbi8vIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSxcbi8vICAgICBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvXG4vLyBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZ1xuLy8gY29uZGl0aW9uczpcbi8vXG4vLyAgICAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4vLyBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vICAgICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SIElNUExJRUQsXG4vLyAgICAgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEFcbi8vIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFRcbi8vIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRlxuLy8gQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFXG4vLyBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IHtjb2xvdXJzfSBmcm9tICcuL0NvbG91cnMnO1xuaW1wb3J0IHtDaGFydH0gZnJvbSAnLi9DaGFydCc7XG5cblxuZXhwb3J0IGNsYXNzIExpbmVDaGFydCBleHRlbmRzIENoYXJ0IHtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl94QXhpc1RpY2tGb3JtYXQgPSBkMy50aW1lRm9ybWF0KFwiJUIgJWRcIik7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGRhdGEoZGF0YSkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9kYXRhO1xuICAgICAgICBpZiAoZGF0YSAmJiBkYXRhWzBdLmtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBkYXRhID0gW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAga2V5OiBcInNlcmllcyAxXCIsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlczogZGF0YVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZGF0YSA9IGRhdGE7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBlbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fZWxlbWVudDtcbiAgICAgICAgdGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBzaG93TGFiZWxzKHNob3cpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fc2hvd19sYWJlbHM7XG4gICAgICAgIHRoaXMuX3Nob3dfbGFiZWxzID0gc2hvdztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8vIHRvZG8gZGlzcGF0Y2hcbiAgICBzaG93TGVnZW5kKHNob3cpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fc2hvd19sZWdlbmQ7XG4gICAgICAgIHRoaXMuX3Nob3dfbGVnZW5kID0gc2hvdztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHgoeCkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl94O1xuICAgICAgICB0aGlzLl94ID0geDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHkoeSkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl95O1xuICAgICAgICB0aGlzLl95ID0geTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHdpZHRoKHdpZHRoKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3dpZHRoO1xuICAgICAgICB0aGlzLl93aWR0aCA9IHdpZHRoO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgaGVpZ2h0KGhlaWdodCkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9oZWlnaHQ7XG4gICAgICAgIHRoaXMuX2hlaWdodCA9IGhlaWdodDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGNvbG91cnMoY29sb3Vycykge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9jb2xvdXJzO1xuICAgICAgICB0aGlzLl9jb2xvdXJzID0gY29sb3VycztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGJhY2tncm91bmRDb2xvdXIoY29sb3VyKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX2JhY2tncm91bmRDb2xvdXI7XG4gICAgICAgIHRoaXMuX2JhY2tncm91bmRDb2xvdXIgPSBjb2xvdXIgfHwgXCIjRkZGXCI7IC8vIG5ldmVyIHNldCBpdCB0byBudWxsLlxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgdGlja0Zvcm1hdChmb3JtYXQpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fdGlja0Zvcm1hdDtcbiAgICAgICAgdGhpcy5fdGlja0Zvcm1hdCA9IGZvcm1hdDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHhBeGlzVGlja0Zvcm1hdChmb3JtYXQpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5feEF4aXNUaWNrRm9ybWF0O1xuICAgICAgICB0aGlzLl94QXhpc1RpY2tGb3JtYXQgPSBmb3JtYXQgfHwgKGQgPT4gZC50b1N0cmluZygpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGxhYmVsRm9ybWF0KGZvcm1hdCkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9sYWJlbEZvcm1hdDtcbiAgICAgICAgdGhpcy5fbGFiZWxGb3JtYXQgPSBmb3JtYXQgfHwgKGQgPT4gZC50b1N0cmluZygpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8vIHRvZG8gbWlzc2luZ1xuICAgIGxhYmVsQ29tcHJlc3Npb24oY29tcHJlc3Npb24pIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fY29tcHJlc3Npb247XG4gICAgICAgIHRoaXMuX2NvbXByZXNzaW9uID0gY29tcHJlc3Npb247XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvL3RvZG8gbWlzc2luZ1xuICAgIGRhdGFBeGlzTGFiZWwobGFiZWwpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fZGF0YUF4aXNMYWJlbDtcbiAgICAgICAgdGhpcy5fZGF0YUF4aXNMYWJlbCA9IGxhYmVsO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgdG9vbHRpcCh0b29sdGlwKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3Rvb2x0aXA7XG4gICAgICAgIHRoaXMuX3Rvb2x0aXAgPSB0b29sdGlwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgZm9yY2VZKGZvcmNlKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX2ZvcmNlWTtcbiAgICAgICAgdGhpcy5fZm9yY2VZID0gZm9yY2U7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8vIHRvZG8gbWlzc2luZ1xuICAgIGR1cmF0aW9uKGR1cmF0aW9uKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX2R1cmF0aW9uO1xuICAgICAgICB0aGlzLl9kdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbi8vIHRvZG8gbWlzc2luZ1xuICAgIGNvYXJzZW5lc3MoY29hcnNlbmVzcykge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9jb2Fyc2VuZXNzO1xuICAgICAgICB0aGlzLl9jb2Fyc2VuZXNzID0gY29hcnNlbmVzcztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gdG9kbyBtaXNzaW5nXG4gICAgcGFkZGluZyhwYWRkaW5nKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3BhZGRpbmc7XG4gICAgICAgIHRoaXMuX3BhZGRpbmcgPSBwYWRkaW5nO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyB0b2RvIG1pc3NpbmdcbiAgICB4QXhpc1Rvb2x0aXBzKHRvb2x0aXBzKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3hBeGlzVG9vbHRpcHM7XG4gICAgICAgIHRoaXMuX3hBeGlzVG9vbHRpcHMgPSB0b29sdGlwcztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgeEF4aXNPdmVycmlkZShvdmVycmlkZSkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl94QXhpc092ZXJyaWRlO1xuICAgICAgICB0aGlzLl94QXhpc092ZXJyaWRlID0gb3ZlcnJpZGU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBkaXNwYXRjaCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc3BhdGNoO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGlmICghdGhpcy5fZWxlbWVudCkgdGhyb3cgbmV3IEVycm9yKFwiTm8gZWxlbWVudCBzZXQgZm9yIENvbHVtbkNoYXJ0LiBTZWUgI2VsZW1lbnQoKVwiKTtcbiAgICAgICAgaWYgKCF0aGlzLl9kYXRhKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJObyBkYXRhIHNldCBmb3IgQ29sdW1uQ2hhcnQuIFNlZSAjZGF0YSgpXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMuZ2V0VHJhbnNmb3JtZWREYXRhKCk7XG4gICAgICAgIGNvbnN0IGtleXMgPSB0aGlzLmdldEtleXMoKTtcblxuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBTZXQgdXAgdGhlIFNWRyBhcmVhXG5cbiAgICAgICAgbGV0IHRvcExldmVsID0gZDMuc2VsZWN0KHRoaXMuX2VsZW1lbnQpLnNlbGVjdChcInN2Z1wiKTtcbiAgICAgICAgaWYgKHRvcExldmVsLmVtcHR5KCkpIHtcbiAgICAgICAgICAgIHRvcExldmVsID0gZDMuc2VsZWN0KHRoaXMuX2VsZW1lbnQpLmFwcGVuZChcInN2Z1wiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRvcExldmVsXG4gICAgICAgICAgICAuc3R5bGUoXCJ3aWR0aFwiLCB0aGlzLl93aWR0aCArIFwicHhcIilcbiAgICAgICAgICAgIC5zdHlsZShcImhlaWdodFwiLCB0aGlzLl9oZWlnaHQgKyBcInB4XCIpO1xuXG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIExheW91dCB0aGUgc2hvd0xlZ2VuZC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gV2UgZG8gdGhpcyBub3cgYmVjYXVzZSB3ZSBuZWVkIHRvIGtub3cgaG93IG11Y2ggc3BhY2UgdGhlIGxlZ2VuZFxuICAgICAgICAvLyB0YWtlcyB1cCBpbiBvcmRlciB0byBmaW5pc2ggY2FsY3VsYXRpbmcgdGhlIG1hcmdpbnMuXG5cbiAgICAgICAgY29uc3QgbGVnZW5kSGVpZ2h0ID0gdGhpcy5yZW5kZXJMZWdlbmQoKTtcblxuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gQ2FsY3VsYXRlIG1hcmdpbnMuXG5cbiAgICAgICAgY29uc3QgbWFyZ2luID0ge3RvcDogMjAsIHJpZ2h0OiAyMCwgYm90dG9tOiA0MCwgbGVmdDogNDB9O1xuICAgICAgICBtYXJnaW4uYm90dG9tICs9IGxlZ2VuZEhlaWdodCA/IGxlZ2VuZEhlaWdodCArIDIwIDogMDtcblxuICAgICAgICBpZiAodGhpcy5fZGF0YUF4aXNMYWJlbCkgbWFyZ2luLmxlZnQgKz0gMjAgKyAxMjtcbiAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgIGxldCBtYXhMYWJlbExlbmd0aCA9IDA7XG4gICAgICAgICAgICBkYXRhLmZvckVhY2goZCA9PiB7XG4gICAgICAgICAgICAgICAgZC5kYXRhLmZvckVhY2goZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBsZW5ndGggPSB0aGlzLl94QXhpc1RpY2tGb3JtYXQodGhpcy5feChkKSkubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGVuZ3RoID4gbWF4TGFiZWxMZW5ndGgpIG1heExhYmVsTGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG1hcmdpbi5ib3R0b20gKz0gbWF4TGFiZWxMZW5ndGggKiAyICsgMTA7ICAgIC8vIHNwYWNlIGZvciBheGVzIGxhYmVscy5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHdpZHRoID0gdGhpcy5fd2lkdGggLSBtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodCxcbiAgICAgICAgICAgIGhlaWdodCA9IHRoaXMuX2hlaWdodCAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tO1xuXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBDYWxjdWxhdGUgc2NhbGVzIGFuZCBzbyBvbi5cblxuXG4gICAgICAgIGNvbnN0IHggPSBkMy5zY2FsZVRpbWUoKVxuICAgICAgICAgICAgLnJhbmdlKFswLCB3aWR0aF0pO1xuXG4gICAgICAgIGNvbnN0IHkgPSBkMy5zY2FsZUxpbmVhcigpXG4gICAgICAgICAgICAucmFuZ2UoW2hlaWdodCwgMF0pXG4gICAgICAgICAgICAubmljZSg1KTtcbiAgICAgICAgdGhpcy5feHNjYWxlID0geDtcbiAgICAgICAgdGhpcy5feXNjYWxlID0geTtcblxuICAgICAgICAvLyBTY2FsZSB0aGUgcmFuZ2Ugb2YgdGhlIGRhdGEgaW4gdGhlIGRvbWFpbnNcblxuICAgICAgICBjb25zdCBhbGxEYXRhID0gZGF0YS5tYXAoZCA9PiBkLmRhdGEpLnJlZHVjZSgoYWNjLCB2YWwpID0+IGFjYy5jb25jYXQodmFsKSk7XG4gICAgICAgIHguZG9tYWluKGQzLmV4dGVudChhbGxEYXRhLCBkID0+IGQuX3gpKTtcbiAgICAgICAgeS5kb21haW4oW01hdGgubWluKDAsIGQzLm1pbihhbGxEYXRhLCBkID0+IGQuX3kpKSwgZDMubWF4KGFsbERhdGEsIGQgPT4gZC5feSldKTtcblxuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgIGxldCBzdmcgPSB0b3BMZXZlbC5zZWxlY3QoJy5tYWluLWdyb3VwJyk7XG5cbiAgICAgICAgaWYgKHN2Zy5lbXB0eSgpKSB7XG4gICAgICAgICAgICBzdmcgPSB0b3BMZXZlbFxuICAgICAgICAgICAgICAgIC5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcIm1haW4tZ3JvdXBcIik7XG4gICAgICAgIH1cblxuICAgICAgICBzdmcuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIG1hcmdpbi5sZWZ0ICsgXCIsXCIgKyBtYXJnaW4udG9wICsgXCIpXCIpO1xuXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIGFwcGVuZCB0aGUgbGluZXNcbiAgICAgICAgbGV0IGxpbmVHcm91cCA9IHN2Zy5zZWxlY3QoXCIubGluZXNcIik7XG4gICAgICAgIGxpbmVHcm91cC5zZWxlY3RBbGwoXCJjaXJjbGVcIikucmVtb3ZlKCk7XG5cbiAgICAgICAgbGV0IGNpcmNsZSA9IGZhbHNlO1xuICAgICAgICBsZXQgbGFzdE1vdXNlID0gbnVsbDtcbiAgICAgICAgbGV0IGxhc3RNaW4gPSBudWxsO1xuXG4gICAgICAgIGlmIChsaW5lR3JvdXAuZW1wdHkoKSkge1xuICAgICAgICAgICAgbGluZUdyb3VwID0gc3ZnXG4gICAgICAgICAgICAgICAgLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwibGluZXNcIilcblxuICAgICAgICAgICAgbGluZUdyb3VwXG4gICAgICAgICAgICAgICAgLmFwcGVuZChcInJlY3RcIilcbiAgICAgICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMFwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwid2lkdGhcIiwgXCIxMDAlXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgXCIxMDAlXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGluZUdyb3VwXG4gICAgICAgICAgICAub24oXCJtb3VzZW1vdmVcIiwgKGQsIGksIG5vZGVzKSA9PiB7IC8vIERhcmtlbiB0aGUgYmFyIG9uIG1vdXNlIG92ZXJcbiAgICAgICAgICAgICAgICBjb25zdCBtb3VzZSA9IGQzLm1vdXNlKG5vZGVzW2ldKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHh2YWwgPSB4LmludmVydChtb3VzZVswXSk7XG4gICAgICAgICAgICAgICAgY29uc3QgeXZhbCA9IHkuaW52ZXJ0KG1vdXNlWzFdKTtcbiAgICAgICAgICAgICAgICAvLyBsZXQgbWluID0gdGhpcy5nZXRDbG9zZXN0UG9pbnQoeHZhbCwgeXZhbCwgdGhpcy5nZXRUcmFuc2Zvcm1lZERhdGEoKVswXS5kYXRhKTtcblxuICAgICAgICAgICAgICAgIGxldCBtaW5zID0gZGF0YS5tYXAoZCA9PiB0aGlzLmdldENsb3Nlc3RQb2ludCh4dmFsLCB5dmFsLCBkLmRhdGEpKTtcbiAgICAgICAgICAgICAgICBtaW5zLmZvckVhY2goZCA9PiBkLl9kaXN0ID0gIFt4KGQuX3gpLCB5KGQuX3kpXSlcblxuICAgICAgICAgICAgICAgIG1pbnMgPSBtaW5zLmZpbHRlcihtaW4gPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtaW5TY3JlZW5EaXN0ID0gTWF0aC5zcXJ0KChtb3VzZVswXSAtIG1pbi5fZGlzdFswXSkgKiogMiArIChtb3VzZVsxXSAtIG1pbi5fZGlzdFsxXSkgKiogMik7XG4gICAgICAgICAgICAgICAgICAgIG1pbi5fbWluX3NjcmVlbiA9IG1pblNjcmVlbkRpc3Q7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtaW5TY3JlZW5EaXN0IDwgMTAwO1xuICAgICAgICAgICAgICAgIH0pO1xuXG5cbiAgICAgICAgICAgICAgICBpZiAoIW1pbnMgfHwgIW1pbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RNb3VzZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVHcm91cC5zZWxlY3RBbGwoXCJjaXJjbGVcIikucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtaW5zID0gbWlucy5zb3J0KChsaHMsIHJocykgPT4gbGhzLl9taW5fc2NyZWVuIC0gcmhzLl9taW5fc2NyZWVuKTtcbiAgICAgICAgICAgICAgICBsZXQgbWluID0gbWluc1swXTtcblxuICAgICAgICAgICAgICAgIGlmIChjaXJjbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3RNaW4gJiYgbWluLl94LmdldFRpbWUoKSA9PT0gbGFzdE1pbi5feC5nZXRUaW1lKCkpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgbGluZUdyb3VwLnNlbGVjdEFsbChcImNpcmNsZVwiKS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjaXJjbGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGxhc3RNb3VzZSA9IG1vdXNlO1xuICAgICAgICAgICAgICAgIGxhc3RNaW4gPSBtaW47XG4gICAgICAgICAgICAgICAgbGluZUdyb3VwXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoXCJjaXJjbGVcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiY3hcIiwgeChtaW4uX3gpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJjeVwiLCB5KG1pbi5feSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcInJcIiwgMTApXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcImZpbGxcIiwgdGhpcy5nZXRTZXJpZXNDb2xvdXIobWluLl9zX2kpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAwLjEpXG4gICAgICAgICAgICAgICAgICAgIC5vbihcIm1vdXNlb3ZlclwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXNwYXRjaC5jYWxsKFwidG9vbHRpcFNob3dcIiwgdGhpcywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGU6IGQzLmV2ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50OiBtaW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzOiBkYXRhW21pbi5fc19pXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXNJbmRleDogbWluLl9zX2ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG1pbi5feVxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLm9uKFwibW91c2VvdXRcIiwgKGQsIGksIG5vZGVzKSA9PiB7IC8vIGJhciBpcyByZWd1bGFyIGNvbG91ciBvbiBtb3VzZSBvdXQuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXNwYXRjaC5jYWxsKFwidG9vbHRpcEhpZGVcIiwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMC41KVxuXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICBsZXQgbGluZXMgPSBsaW5lR3JvdXAuc2VsZWN0QWxsKCcubGluZScpO1xuICAgICAgICBsaW5lcyA9IGxpbmVzLmRhdGEoZGF0YSk7XG5cbiAgICAgICAgbGluZXMuZXhpdCgpLnJlbW92ZSgpO1xuXG4gICAgICAgIGNvbnN0IGxpbmUgPSBkMy5saW5lKClcbiAgICAgICAgICAgIC54KGQgPT4geChkLl94KSlcbiAgICAgICAgICAgIC55KGQgPT4geShkLl95KSk7XG5cbiAgICAgICAgbGluZXNcbiAgICAgICAgICAgIC5lbnRlcigpXG4gICAgICAgICAgICAuYXBwZW5kKFwicGF0aFwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJsaW5lXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJmaWxsXCIsIFwibm9uZVwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwic3Ryb2tlXCIsIChkLCBpKSA9PiB0aGlzLmdldFNlcmllc0NvbG91cihpKSlcbiAgICAgICAgICAgICAgICAuYXR0cihcInN0cm9rZS1saW5lam9pblwiLCBcInJvdW5kXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJzdHJva2UtbGluZWNhcFwiLCBcInJvdW5kXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJzdHJva2Utd2lkdGhcIiwgMS41KVxuICAgICAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMClcblxuICAgICAgICAgICAgLy8gLnRyYW5zaXRpb24oKVxuICAgICAgICAgICAgLy8gLmR1cmF0aW9uKHRoaXMuX2R1cmF0aW9uKVxuICAgICAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMSlcbiAgICAgICAgICAgICAgICAuYXR0cihcImRcIiwgZCA9PiBsaW5lKGQuZGF0YSkpO1xuXG4gICAgICAgIGxpbmVzXG4gICAgICAgICAgICAvLyAudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAuYXR0cihcImRcIiwgZCA9PiBsaW5lKGQuZGF0YSkpO1xuXG5cbiAgICAgICAgLy8gQWRkaW5nIG5ldyBncm91cHMsIGFuZCBoZW5jZSBhZGRpbmcgbmV3IGJhcnMgdG8gdGhvc2UgZ3JvdXBzLlxuICAgICAgICAvLyBncm91cHMuZW50ZXIoKVxuICAgICAgICAvLyAgICAgLmFwcGVuZChcImdcIilcbiAgICAgICAgLy8gICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJncm91cFwiKVxuICAgICAgICAvLyAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgZCA9PiBcInRyYW5zbGF0ZShcIiArIHgoZC5rZXkpICsgXCIsMClcIilcbiAgICAgICAgLy8gICAgIC5hdHRyKFwid2lkdGhcIiwgeC5iYW5kd2lkdGgoKSlcbiAgICAgICAgLy8gICAgIC5hdHRyKFwiaGVpZ2h0XCIsIFwiMTAwJVwiKVxuICAgICAgICAvLyAgICAgLm1lcmdlKGdyb3VwcylcbiAgICAgICAgLy8gICAgIC5pbnRlcnJ1cHQoXCJncm91cHM6bW92ZVwiKVxuICAgICAgICAvLyAgICAgLnRyYW5zaXRpb24oXCJncm91cHM6bW92ZVwiKVxuICAgICAgICAvLyAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgZCA9PiBcInRyYW5zbGF0ZShcIiArIHgoZC5rZXkpICsgXCIsMClcIilcbiAgICAgICAgLy8gICAgIC5hdHRyKFwid2lkdGhcIiwgeC5iYW5kd2lkdGgoKSlcbiAgICAgICAgLy8gICAgIC5lYWNoKChzX2QsIHNfaSwgbm9kZXMpID0+IHtcbiAgICAgICAgLy8gICAgICAgICBsZXQgZ3JvdXAgPSBkMy5zZWxlY3Qobm9kZXNbc19pXSlcbiAgICAgICAgLy9cbiAgICAgICAgLy8gICAgICAgICBsZXQgYmFycyA9IGdyb3VwLnNlbGVjdEFsbChcIi5iYXJcIilcbiAgICAgICAgLy8gICAgICAgICAgICAgLmRhdGEoc19kLmRhdGEpO1xuICAgICAgICAvL1xuICAgICAgICAvLyAgICAgICAgIGJhcnMuZXhpdCgpLnJlbW92ZSgpO1xuICAgICAgICAvL1xuICAgICAgICAvLyAgICAgICAgIGJhcnMuaW50ZXJydXB0KFwiYmFyOm1vdmVcIikgICAgIC8vIEFuaW1hdGUgdGhlIGJhcnMgdG8gdGhlaXIgbmV3IHBvc2l0aW9uLlxuICAgICAgICAvLyAgICAgICAgICAgICAudHJhbnNpdGlvbihcImJhcjptb3ZlXCIpXG4gICAgICAgIC8vICAgICAgICAgICAgIC5hdHRyKFwid2lkdGhcIiwgeEdyb3VwLmJhbmR3aWR0aCgpKVxuICAgICAgICAvLyAgICAgICAgICAgICAuYXR0cihcInhcIiwgZCA9PiB4R3JvdXAoZC5fa2V5KSlcbiAgICAgICAgLy8gICAgICAgICAgICAgLmF0dHIoXCJ5XCIsIDApO1xuICAgICAgICAvL1xuICAgICAgICAvLyAgICAgICAgIGJhcnMuZW50ZXIoKVxuICAgICAgICAvLyAgICAgICAgICAgICAuYXBwZW5kKFwicmVjdFwiKVxuICAgICAgICAvLyAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIChkLCBpKSA9PiBcImJhciBzZXJpZXMgc2VyaWVzLVwiICsgaSlcbiAgICAgICAgLy8gICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIGQgPT4geEdyb3VwKGQuX2tleSkpXG4gICAgICAgIC8vICAgICAgICAgICAgIC5hdHRyKFwieVwiLCAwKVxuICAgICAgICAvLyAgICAgICAgICAgICAuYXR0cihcIndpZHRoXCIsIHhHcm91cC5iYW5kd2lkdGgoKSlcbiAgICAgICAgLy8gICAgICAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgMClcbiAgICAgICAgLy8gICAgICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCAoZCwgaSkgPT4gdGhpcy5nZXRTZXJpZXNDb2xvdXIoaSkpXG4gICAgICAgIC8vICAgICAgICAgICAgIC5zdHlsZShcImN1cnNvclwiLCBcInBvaW50ZXJcIilcbiAgICAgICAgLy8gICAgICAgICAgICAgLm9uKFwibW91c2VvdmVyXCIsIChkLCBpLCBub2RlcykgPT4geyAvLyBEYXJrZW4gdGhlIGJhciBvbiBtb3VzZSBvdmVyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICBkMy5zZWxlY3Qobm9kZXNbaV0pXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgLmludGVycnVwdChcImhvdmVyOmNvbG91clwiKVxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKFwiaG92ZXI6Y29sb3VyXCIpXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKDQwMClcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIGQzLmhjbCh0aGlzLmdldFNlcmllc0NvbG91cihpKSkuZGFya2VyKCkpXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICB0aGlzLl9kaXNwYXRjaC5jYWxsKFwidG9vbHRpcFNob3dcIiwgdGhpcywge1xuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgIGU6IGQzLmV2ZW50LFxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgIHBvaW50OiBkLFxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgIHNlcmllczogc19kLFxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgIHNlcmllc0luZGV4OiBzX2ksXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGQuX3lcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgIH0pXG4gICAgICAgIC8vICAgICAgICAgICAgIH0pXG4gICAgICAgIC8vICAgICAgICAgICAgIC5vbihcIm1vdXNlb3V0XCIsIChkLCBpLCBub2RlcykgPT4geyAvLyBiYXIgaXMgcmVndWxhciBjb2xvdXIgb24gbW91c2Ugb3V0LlxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgZDMuc2VsZWN0KG5vZGVzW2ldKVxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgIC5pbnRlcnJ1cHQoXCJob3Zlcjpjb2xvdXJcIilcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAudHJhbnNpdGlvbihcImhvdmVyOmNvbG91clwiKVxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbig0MDApXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCB0aGlzLmdldFNlcmllc0NvbG91cihpKSk7XG4gICAgICAgIC8vICAgICAgICAgICAgICAgICB0aGlzLl9kaXNwYXRjaC5jYWxsKFwidG9vbHRpcEhpZGVcIiwgdGhpcyk7XG4gICAgICAgIC8vICAgICAgICAgICAgIH0pXG4gICAgICAgIC8vICAgICAgICAgICAgIC5vbihcImNsaWNrIGF1eGNsaWNrXCIsIChkLCBpLCBub2RlcykgPT4ge1xuICAgICAgICAvLyAgICAgICAgICAgICAgICAgdGhpcy5fZGlzcGF0Y2guY2FsbChcImVsZW1lbnRDbGlja1wiLCB0aGlzLCB7XG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgZTogZDMuZXZlbnQsXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgcG9pbnQ6IGQsXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgc2VyaWVzOiBkLl9zZXJpZXMsXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgc2VyaWVzSW5kZXg6IHNfaSxcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy5feShkKVxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgLy8gICAgICAgICAgICAgfSlcbiAgICAgICAgLy8gICAgICAgICAgICAgLm1lcmdlKGJhcnMpXG4gICAgICAgIC8vICAgICAgICAgICAgIC5pbnRlcnJ1cHQoXCJiYXI6Z3Jvd3RoXCIpICAgIC8vIEFuaW1hdGUgYmFycyBncm93aW5nLlxuICAgICAgICAvLyAgICAgICAgICAgICAudHJhbnNpdGlvbihcImJhcjpncm93dGhcIilcbiAgICAgICAgLy8gICAgICAgICAgICAgLmRlbGF5KChkKSA9PiB7XG4gICAgICAgIC8vICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jYWxjQmFyR3Jvd3RoKHNfaSwgbm9kZXMubGVuZ3RoKTtcbiAgICAgICAgLy8gICAgICAgICAgICAgfSlcbiAgICAgICAgLy8gICAgICAgICAgICAgLmR1cmF0aW9uKHRoaXMuX2R1cmF0aW9uKVxuICAgICAgICAvLyAgICAgICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIChkLCBpKSA9PiB0aGlzLmdldFNlcmllc0NvbG91cihpKSlcbiAgICAgICAgLy8gICAgICAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgZCA9PiBoZWlnaHQgLSB5KGQuX3kpKTtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gICAgIH0pXG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIExhYmVscyBsb2FkZWQgYWZ0ZXIgb3VyIGZpcnN0IGJhciBncm93cy5cbiAgICAgICAgLy8gaWYgKHRoaXMuX3Nob3dfbGFiZWxzKSB7XG4gICAgICAgIC8vICAgICBzdmcudHJhbnNpdGlvbihcImJhcjpncm93dGhcIilcbiAgICAgICAgLy8gICAgICAgICAub24oXCJlbmRcIiwgKGQsIGksIG5vZGVzKSA9PiB7XG4gICAgICAgIC8vICAgICAgICAgICAgIGlmIChpIDwgbm9kZXMubGVuZ3RoIC0gMSkgcmV0dXJuO1xuICAgICAgICAvLyAgICAgICAgICAgICB0aGlzLnJlbmRlckxhYmVscyhzdmcsIGRhdGEsIHgsIHhHcm91cCwgeSk7XG4gICAgICAgIC8vICAgICAgICAgfSlcbiAgICAgICAgLy8gfVxuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBEcmF3IHRoZSB5IGF4aXMgZGF0YSBsYWJlbC5cblxuICAgICAgICBpZiAodGhpcy5fZGF0YUF4aXNMYWJlbCkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJEYXRhQXhpc0xhYmVsKGhlaWdodCwgbWFyZ2luKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBTZXQgdGhlIGJhY2tncm91bmQgY29sb3VyXG5cbiAgICAgICAgZDMuc2VsZWN0KHRoaXMuX2VsZW1lbnQpLnNlbGVjdChcIi5iYWNrZ3JvdW5kXCIpLnJlbW92ZSgpO1xuICAgICAgICBpZiAodGhpcy5fYmFja2dyb3VuZENvbG91cikge1xuICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMuX2VsZW1lbnQpLnNlbGVjdChcInN2Z1wiKVxuICAgICAgICAgICAgICAgIC5hcHBlbmQoXCJyZWN0XCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImJhY2tncm91bmRcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcIndpZHRoXCIsIFwiMTAwJVwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIFwiMTAwJVwiKVxuICAgICAgICAgICAgICAgIC5zdHlsZShcImZpbGxcIiwgdGhpcy5fYmFja2dyb3VuZENvbG91cilcbiAgICAgICAgICAgICAgICAubG93ZXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIGFkZCB0aGUgWSBncmlkbGluZXNcbiAgICAgICAgc3ZnLmNhbGwodGhpcy5ncmlkLCB3aWR0aCwgZDMuYXhpc0xlZnQoeSkudGlja3MoNSkpO1xuXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIGF4ZXNcbiAgICAgICAgc3ZnLmNhbGwodGhpcy54YXhpcywgaGVpZ2h0LCBkMy5heGlzQm90dG9tKHgpLnRpY2tTaXplKDApLnRpY2tQYWRkaW5nKDUpLnRpY2tGb3JtYXQodGhpcy5feEF4aXNUaWNrRm9ybWF0KSk7IC8vKTsgLy9cbiAgICAgICAgc3ZnLmNhbGwodGhpcy55YXhpcywgZDMuYXhpc0xlZnQoeSkudGlja3MoNSkudGlja0Zvcm1hdCh0aGlzLl90aWNrRm9ybWF0KSk7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8qXG4gICAgICogUmV0dXJucyBhbiBvYmplY3Qgd2l0aCB0d28gZnVuY3Rpb25zLCAjc2hvdygpIGFuZCAjaGlkZSgpLFxuICAgICAqIHRvIHNob3cgYW5kIGhpZGUgdGhlIGxhYmVscy5cbiAgICAgKi9cbiAgICBsYWJlbHMoKSB7XG4gICAgICAgIHJldHVybiB7XG5cbiAgICAgICAgICAgIHNob3c6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgc2VsZWN0aW9uID0gdGhpcy5fZWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSB0aGlzLmdldFRyYW5zZm9ybWVkRGF0YSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgeHNjYWxlID0gdGhpcy5feHNjYWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgeGdyb3VwID0gdGhpcy5feGdyb3Vwc2NhbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB5c2NhbGUgPSB0aGlzLl95c2NhbGU7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvbikgc2VsZWN0aW9uID0gZDMuc2VsZWN0KHRoaXMuX2VsZW1lbnQpLnNlbGVjdChcInN2Z1wiKS5zZWxlY3QoXCJnXCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNlbGVjdGlvbi5lbXB0eSgpICYmIGRhdGEgJiYgeHNjYWxlICYmIHlzY2FsZSAmJiB4Z3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBsYWJlbHMgPSBzZWxlY3Rpb24uc2VsZWN0KCcuY2hhcnQtbGFiZWxzJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWxhYmVscy5lbXB0eSgpKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbHMucmVtb3ZlKClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyTGFiZWxzKHNlbGVjdGlvbiwgZGF0YSwgeHNjYWxlLCB4Z3JvdXAsIHlzY2FsZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBoaWRlOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2VsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMuX2VsZW1lbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc2VsZWN0KCcuY2hhcnQtbGFiZWxzJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5pbnRlcnJ1cHQoXCJsYWJlbHNcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5pbnRlcnJ1cHQoXCJsYWJlbHM6ZmFkZVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRyYW5zaXRpb24oXCJsYWJlbHM6ZmFkZVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm9uKFwiZW5kXCIsIChkLCBpLCBub2RlcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQzLnNlbGVjdChub2Rlc1tpXSkucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICByZW5kZXJMYWJlbHMoc2VsZWN0aW9uLCBkYXRhLCB4c2NhbGUsIHhncm91cCwgeXNjYWxlLCBhbmltYXRlKSB7XG4gICAgICAgIGFuaW1hdGUgPSBhbmltYXRlID09PSB1bmRlZmluZWQgPyB0cnVlIDogYW5pbWF0ZTtcbiAgICAgICAgc2VsZWN0aW9uLnNlbGVjdEFsbChcIi5jaGFydC1sYWJlbHNcIikucmVtb3ZlKCk7XG5cbiAgICAgICAgbGV0IGxhYmVscyA9IHNlbGVjdGlvbi5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwiY2hhcnQtbGFiZWxzXCIpXG4gICAgICAgICAgICAvLyAuc2VsZWN0QWxsKFwiLmNoYXJ0LWxhYmVsXCIpXG4gICAgICAgICAgICAuc2VsZWN0QWxsKFwiLmxhYmVsLWdyb3VwXCIpXG4gICAgICAgICAgICAuZGF0YShkYXRhKVxuXG4gICAgICAgIGxldCBtYXhXaWR0aCA9IDA7ICAgICAvLyBGb3IgY2FsY3VsYXRpbmcgdGhlIG1heCB3aWR0aCBvZiB0ZXh0LlxuICAgICAgICBsZXQgZm9udFNpemUgPSAxMjsgICAgLy8gT3VyIGluaXRpYWwgZm9udCBzaXplLlxuICAgICAgICBjb25zdCBidWZmZXIgPSA1OyAgICAgLy8gQnVmZmVyIHNwYWNlIGJldHdlZW4gd29yZHMgYW5kIHRoZSB0b3Agb2YgYSBiYXIuXG4gICAgICAgIGNvbnN0IGNhbGNEeSA9ICh5cG9zKSA9PiB5cG9zIDwgMTAgPyBmb250U2l6ZSArIGJ1ZmZlciA6IC1idWZmZXI7XG5cbiAgICAgICAgbGFiZWxzLmVudGVyKCkuZWFjaCgoc2VyaWVzLCBzX2ksIHNfbm9kZXMpID0+IHtcbiAgICAgICAgICAgIGxldCBncm91cCA9IGQzLnNlbGVjdChzX25vZGVzW3NfaV0pXG4gICAgICAgICAgICAgICAgLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwibGFiZWwtZ3JvdXBcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBkID0+IFwidHJhbnNsYXRlKFwiICsgeHNjYWxlKGQua2V5KSArIFwiLDApXCIpXG4gICAgICAgICAgICAgICAgLnNlbGVjdEFsbChcIi5jaGFydC1sYWJlbFwiKVxuICAgICAgICAgICAgICAgIC5kYXRhKHNlcmllcy5kYXRhKVxuICAgICAgICAgICAgICAgIC5lbnRlcigpXG4gICAgICAgICAgICAgICAgLmVhY2goKGQsIGksIG5vZGVzKSA9PiB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gV2FudCB0byBmaWd1cmUgb3V0IGlmIHRoZSBsYWJlbCBpcyB0b28gZGFyayAvIGxpZ2h0IGZvciB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gYmFyLlxuICAgICAgICAgICAgICAgICAgICBsZXQgaW52ZXJ0ZWRDb2xvciA9IGQzLmhjbCh0aGlzLmdldFNlcmllc0NvbG91cihpKSk7XG4gICAgICAgICAgICAgICAgICAgIGludmVydGVkQ29sb3IubCArPSBNYXRoLm1pbihpbnZlcnRlZENvbG9yLmwgKyA1MCwgMTAwKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGludmVydCA9IGQzLmhjbCh0aGlzLmdldFNlcmllc0NvbG91cihpKSkubCA8IDYwO1xuXG4gICAgICAgICAgICAgICAgICAgIGxldCB5cG9zID0geXNjYWxlKGQuX3kpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZHkgPSBjYWxjRHkoeXBvcyk7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0ZXh0ID0gZDMuc2VsZWN0KG5vZGVzW2ldKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC50ZXh0KHRoaXMuX2xhYmVsRm9ybWF0KGQuX3kpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImNoYXJ0LWxhYmVsXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcInlcIiwgeXBvcylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiZHhcIiwgYW5pbWF0ZSA/IC0xNSA6IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcImR5XCIsIGR5KVxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwicG9pbnRlci1ldmVudHNcIiwgXCJub25lXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAuc3R5bGUoXCJmb250LWZhbWlseVwiLCBcIk9wZW4gU2Fucywgc2Fucy1zZXJpZlwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gLnN0eWxlKFwiZm9udC13ZWlnaHRcIiwgXCJub3JtYWxcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIC5zdHlsZShcImZvbnQtc2l6ZVwiLCBmb250U2l6ZSArIFwicHhcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcImZpbGxcIiwgZHkgPiAwICYmIGludmVydCA/IGludmVydGVkQ29sb3IudG9TdHJpbmcoKSA6IGNvbG91cnMuZWlnaHRlZW4uZGFya0dyZXkpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFNldCB0aGUgeCBwb3NpdGlvbiwgd2hpY2ggaXMgYmFzZWQgb24gd2lkdGguXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gdGV4dC5ub2RlKCkuZ2V0QkJveCgpLndpZHRoO1xuICAgICAgICAgICAgICAgICAgICBtYXhXaWR0aCA9IE1hdGgubWF4KHdpZHRoLCBtYXhXaWR0aCk7XG4gICAgICAgICAgICAgICAgICAgIHRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwieFwiLCB4Z3JvdXAoZC5fa2V5KSArIHhncm91cC5iYW5kd2lkdGgoKSAvIDIgLSB3aWR0aCAvIDIpO1xuXG4gICAgICAgICAgICAgICAgICAgIHRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKFwibGFiZWxzXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAuZGVsYXkoKCkgPT4gYW5pbWF0ZSA/IHRoaXMuY2FsY0Jhckdyb3d0aChzX2ksIHNfbm9kZXMubGVuZ3RoKSA6IDApIC8vIERlbGF5IGluIGxvY2tzdGVwIHdpdGggYmFyIGdyb3d0aC5cbiAgICAgICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbih0aGlzLl9kdXJhdGlvbilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiZHhcIiwgMClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMSlcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICB9KVxuXG5cbiAgICAgICAgLy8gRmlndXJlIG91dCBpZiB3ZSBkb24ndCBoYXZlIGVub3VnaCBzcGFjZSB0byBzaG93IG91ciBsYWJlbHMuXG4gICAgICAgIC8vIFdlIHRoZW4gd2FudCB0byByZXNpemUsIGlmIHBvc3NpYmxlLlxuICAgICAgICBpZiAoeGdyb3VwLmJhbmR3aWR0aCgpIDwgbWF4V2lkdGggKiAxLjA1KSB7XG4gICAgICAgICAgICBsZXQgc2NhbGUgPSBtYXhXaWR0aCAvIHhncm91cC5iYW5kd2lkdGgoKSAqIDEuMDU7XG4gICAgICAgICAgICBmb250U2l6ZSA9IE1hdGguZmxvb3IoZm9udFNpemUgLyBzY2FsZSk7XG5cbiAgICAgICAgICAgIGlmIChmb250U2l6ZSA8IDgpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgbGFiZWxzIGFyZSB0b28gc21hbGwuXG4gICAgICAgICAgICAgICAgbGFiZWxzLmVudGVyKCkuc2VsZWN0QWxsKFwidGV4dFwiKS5yZW1vdmUoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGFiZWxzLmVudGVyKClcbiAgICAgICAgICAgICAgICAgICAgLm1lcmdlKGxhYmVscylcbiAgICAgICAgICAgICAgICAgICAgLnNlbGVjdEFsbChcInRleHRcIilcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwiZm9udC1zaXplXCIsIGZvbnRTaXplICsgXCJweFwiKVxuICAgICAgICAgICAgICAgICAgICAuZWFjaCgoZCwgaSwgbm9kZXMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRleHQgPSBkMy5zZWxlY3Qobm9kZXNbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgd2lkdGggPSB0ZXh0Lm5vZGUoKS5nZXRCQm94KCkud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIHhncm91cChkLl9rZXkpICsgeGdyb3VwLmJhbmR3aWR0aCgpIC8gMiAtIHdpZHRoIC8gMilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcImR5XCIsIGNhbGNEeShkLl95KSk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgcmVuZGVyRGF0YUF4aXNMYWJlbChoZWlnaHQsIG1hcmdpbnMpIHtcbiAgICAgICAgbGV0IHN2ZyA9IGQzLnNlbGVjdCh0aGlzLl9lbGVtZW50KS5zZWxlY3QoJ3N2ZycpO1xuICAgICAgICBzdmcuc2VsZWN0QWxsKFwiLmRhdGEtbGFiZWxzXCIpLnJlbW92ZSgpO1xuXG4gICAgICAgIGlmICghdGhpcy5fZGF0YUF4aXNMYWJlbCkgcmV0dXJuO1xuICAgICAgICBsZXQgdGV4dCA9IHRoaXMuX2RhdGFBeGlzTGFiZWw7XG4gICAgICAgIGlmICh0ZXh0LmxvbmcpIHRleHQgPSB0ZXh0Lmxvbmc7XG5cbiAgICAgICAgbGV0IHggPSAtKG1hcmdpbnMudG9wICsgaGVpZ2h0IC8gMik7XG5cbiAgICAgICAgbGV0IGxhYmVsID0gc3ZnLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJkYXRhLWxhYmVsc1wiKVxuICAgICAgICAgICAgLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgICAgIC50ZXh0KHRleHQpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInJvdGF0ZSgtOTAgMCwwKSB0cmFuc2xhdGUoXCIgKyB4ICsgXCIsIDIwKVwiKVxuICAgICAgICAgICAgLy8gLnN0eWxlKFwiZm9udC1mYW1pbHlcIiwgXCJPcGVuIFNhbnMsIHNhbnMtc2VyaWZcIilcbiAgICAgICAgICAgIC8vIC5zdHlsZShcImZvbnQtc2l6ZVwiLCBcIjEycHhcIilcbiAgICAgICAgICAgIC8vIC5zdHlsZShcImZvbnQtc3R5bGVcIiwgXCJpdGFsaWNcIilcbiAgICAgICAgICAgIC5zdHlsZShcImZpbGxcIiwgY29sb3Vycy5laWdodGVlbi5kYXJrR3JleSk7XG5cbiAgICAgICAgbGV0IHdpZHRoID0gbGFiZWwubm9kZSgpLmdldEJCb3goKS53aWR0aDtcbiAgICAgICAgaWYgKHdpZHRoID49IGhlaWdodCAmJiB0aGlzLl9kYXRhQXhpc0xhYmVsLnNob3J0KSB7XG4gICAgICAgICAgICBsYWJlbC50ZXh0KHRoaXMuX2RhdGFBeGlzTGFiZWwuc2hvcnQpO1xuICAgICAgICAgICAgd2lkdGggPSBsYWJlbC5ub2RlKCkuZ2V0QkJveCgpLndpZHRoO1xuICAgICAgICB9XG5cbiAgICAgICAgbGFiZWwuYXR0cihcImR4XCIsIC13aWR0aCAvIDIpO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBncmlkKHNlbGVjdGlvbiwgd2lkdGgsIGF4aXMpIHtcbiAgICAgICAgc2VsZWN0aW9uLnNlbGVjdChcIi5ncmlkXCIpLnJlbW92ZSgpO1xuXG4gICAgICAgIGxldCBncmlkID0gc2VsZWN0aW9uLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJncmlkXCIpXG4gICAgICAgICAgICAuY2FsbChheGlzXG4gICAgICAgICAgICAgICAgLnRpY2tTaXplKC13aWR0aClcbiAgICAgICAgICAgICAgICAudGlja0Zvcm1hdChcIlwiKVxuICAgICAgICAgICAgKTtcblxuICAgICAgICBncmlkLnNlbGVjdEFsbChcImxpbmVcIilcbiAgICAgICAgICAgIC5zdHlsZShcInN0cm9rZVwiLCBjb2xvdXJzLmVpZ2h0ZWVuLmxpZ2h0R3JleSk7XG4gICAgICAgIGdyaWQuc2VsZWN0QWxsKFwiLmRvbWFpblwiKS5yZW1vdmUoKTtcblxuICAgICAgICBncmlkXG4gICAgICAgICAgICAubG93ZXIoKSAvLyBBbHdheXMgZW5zdXJlIHRoYXQgdGhpcyBpcyBlYXJsaWVyIGluIHRoZSBkb20uIFRoaW5ncyBtdXN0IGJlIGRyYXduIG9uIHRvcCBvZiBpdC5cbiAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMClcbiAgICAgICAgICAgIC50cmFuc2l0aW9uKClcbiAgICAgICAgICAgIC5kZWxheSg1MDApXG4gICAgICAgICAgICAuZHVyYXRpb24oNTAwKVxuICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAxKTtcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgeGF4aXMoc2VsZWN0aW9uLCBoZWlnaHQsIHhheGlzKSB7XG4gICAgICAgIHNlbGVjdGlvbi5zZWxlY3QoXCIueC1heGlzXCIpLnJlbW92ZSgpO1xuICAgICAgICBsZXQgYXhpcyA9IHNlbGVjdGlvbi5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwieC1heGlzXCIpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZSgwLFwiICsgaGVpZ2h0ICsgXCIpXCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDApXG4gICAgICAgICAgICAuY2FsbCh4YXhpcyk7XG5cbiAgICAgICAgYXhpcy5zZWxlY3QoXCIuZG9tYWluXCIpLnJlbW92ZSgpO1xuXG4gICAgICAgIGF4aXNcbiAgICAgICAgICAgIC5zZWxlY3RBbGwoXCJ0ZXh0XCIpXG4gICAgICAgICAgICAuc3R5bGUoJ3RleHQtYW5jaG9yJywgJ2VuZCcpXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3JvdGF0ZSgtMzAsIDAsMCknKTtcblxuICAgICAgICBheGlzXG4gICAgICAgICAgICAudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAuZHVyYXRpb24oMTAwMClcbiAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMSk7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHlheGlzKHNlbGVjdGlvbiwgYXhpcykge1xuICAgICAgICBzZWxlY3Rpb24uc2VsZWN0KFwiLnktYXhpc1wiKS5yZW1vdmUoKTtcbiAgICAgICAgbGV0IHggPSBzZWxlY3Rpb24uYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcInktYXhpc1wiKVxuICAgICAgICAgICAgLmNhbGwoYXhpcy50aWNrU2l6ZSgwKS50aWNrUGFkZGluZygxMCkpXG4gICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDApXG4gICAgICAgICAgICAudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAuZHVyYXRpb24oMTAwMClcbiAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMSk7XG5cbiAgICAgICAgeC5zZWxlY3RBbGwoXCJ0ZXh0XCIpXG4gICAgICAgICAgICAvLyAuc3R5bGUoXCJmb250LWZhbWlseVwiLCBcIk9wZW4gU2Fucywgc2Fucy1zZXJpZlwiKVxuICAgICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBjb2xvdXJzLmVpZ2h0ZWVuLmRhcmtHcmV5KVxuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBjYWxjQmFyR3Jvd3RoKGksIG1heCkge1xuICAgICAgICBpZiAobWF4IDwgMTApIHJldHVybiBpICogdGhpcy5fQkFSX0dST1dUSCAvIDI7XG4gICAgICAgIGlmIChtYXggPCAzNSkgcmV0dXJuIGkgKiB0aGlzLl9CQVJfR1JPV1RIIC8gNDtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuXG4gICAgZ2V0U2VyaWVzQ29sb3VyKGkpIHtcbiAgICAgICAgaWYgKGkgPCAwIHx8ICF0aGlzLl9jb2xvdXJzKSByZXR1cm4gY29sb3Vycy5laWdodGVlbi5taWRHcmV5O1xuXG4gICAgICAgIGkgPSBpICUgdGhpcy5fY29sb3Vycy5sZW5ndGg7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb2xvdXJzW2ldO1xuICAgIH1cblxuICAgIGdldFNvcnRlZERhdGEoKSB7XG4gICAgICAgIGxldCBkYXRhID0gdGhpcy5fZGF0YTtcbiAgICAgICAgaWYgKCFkYXRhIHx8ICFkYXRhLmxlbmd0aCkgcmV0dXJuIFtdO1xuXG4gICAgICAgIGRhdGEgPSB0aGlzLl9kYXRhLnNvcnQoKGxocywgcmhzKSA9PiB7XG4gICAgICAgICAgICBsaHMgPSBsaHMua2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICByaHMgPSByaHMua2V5LnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgICAgIGlmIChsaHMgPT09IHJocykgcmV0dXJuIDA7XG4gICAgICAgICAgICBpZiAobGhzIDwgcmhzKSByZXR1cm4gLTE7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgZ2V0VHJhbnNmb3JtZWREYXRhKCkge1xuICAgICAgICBsZXQgZGF0YSA9IHRoaXMuZ2V0U29ydGVkRGF0YSgpO1xuICAgICAgICBpZiAoIWRhdGEgfHwgIWRhdGEubGVuZ3RoKSByZXR1cm4gW107XG5cbiAgICAgICAgbGV0IHJlc3VsdHMgPSBbXTtcblxuICAgICAgICBkYXRhLmZvckVhY2goKHNlcmllcywgc19pKSA9PiB7XG4gICAgICAgICAgICBsZXQgcyA9IE9iamVjdC5hc3NpZ24oe30sIHNlcmllcyk7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2gocyk7XG5cbiAgICAgICAgICAgIGxldCBkYXRhID0gW107XG4gICAgICAgICAgICBzLnZhbHVlcy5mb3JFYWNoKChkKSA9PiB7XG4gICAgICAgICAgICAgICAgZGF0YS5wdXNoKE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgICAgICAgICBfeDogbmV3IERhdGUodGhpcy5feEF4aXNPdmVycmlkZSA/IHRoaXMuX3hBeGlzT3ZlcnJpZGVbdGhpcy5feChkKV0gOiB0aGlzLl94KGQpKSxcbiAgICAgICAgICAgICAgICAgICAgX3Nlcmllczogc2VyaWVzLFxuICAgICAgICAgICAgICAgICAgICBfc19pOiBzX2ksXG4gICAgICAgICAgICAgICAgICAgIF9rZXk6IHNlcmllcy5rZXksXG4gICAgICAgICAgICAgICAgICAgIF95OiB0aGlzLl95KGQpXG4gICAgICAgICAgICAgICAgfSwgZCkpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHMuZGF0YSA9IGRhdGE7XG4gICAgICAgICAgICBkZWxldGUgcy52YWx1ZXM7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cblxuICAgIGdldEtleXMoKSB7XG4gICAgICAgIGxldCBkYXRhID0gdGhpcy5fZGF0YTtcbiAgICAgICAgaWYgKCFkYXRhIHx8ICFkYXRhLmxlbmd0aCkgcmV0dXJuIFtdO1xuXG4gICAgICAgIHJldHVybiBbLi4ubmV3IFNldChkYXRhLm1hcChkID0+IGQua2V5KSldXG4gICAgfVxuXG4gICAgZ2V0Q2xvc2VzdFBvaW50KHh2YWwsIHl2YWwsIGRhdGEpIHtcbiAgICAgICAgbGV0IGNhbGNEaXN0ID0gZCA9PiBNYXRoLnNxcnQoTWF0aC5hYnMoZC5feCAtIHh2YWwpICoqIDIgKyAoZC5feSAtIHl2YWwpICoqIDIpO1xuICAgICAgICBsZXQgbWluID0gZGF0YVswXTtcbiAgICAgICAgbGV0IG1pbkRpc3QgPSBjYWxjRGlzdChtaW4pO1xuXG4gICAgICAgIGRhdGEuZm9yRWFjaChkID0+IHtcbiAgICAgICAgICAgIGxldCBkaXN0ID0gY2FsY0Rpc3QoZCk7XG4gICAgICAgICAgICBpZiAoZGlzdCA8IG1pbkRpc3QpIHtcbiAgICAgICAgICAgICAgICBtaW5EaXN0ID0gZGlzdDtcbiAgICAgICAgICAgICAgICBtaW4gPSBkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gbWluO1xuICAgIH1cbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/LineChart.js\n");

/***/ }),

/***/ "./src/PieChart.js":
/*!*************************!*\
  !*** ./src/PieChart.js ***!
  \*************************/
/*! exports provided: PieChart */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PieChart\", function() { return PieChart; });\n/* harmony import */ var _Colours__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Colours */ \"./src/Colours.js\");\n/* harmony import */ var _Chart__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Chart */ \"./src/Chart.js\");\n// Copyright (C) 2013-2014, 2018 BrandsEye (PTY) LTD\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this\n// software and associated documentation files (the \"Software\"), to deal in the Software\n// without restriction, including without limitation the rights to use, copy, modify,\n//     merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following\n// conditions:\n//\n//     The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n//     INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n// CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n\nclass PieChart extends _Chart__WEBPACK_IMPORTED_MODULE_1__[\"Chart\"] {\n    constructor() {\n        super();\n        this._colours = [\"#98abc5\", \"#8a89a6\", \"#7b6888\", \"#6b486b\", \"#a05d56\", \"#d0743c\", \"#ff8c00\"];\n    }\n\n    //------------------------------------------------------\n\n    data(data) {\n        if (!arguments.length) return this._data;\n        if (data && data[0].key === undefined) {\n            data = [\n                {\n                    key: \"series 1\",\n                    values: data\n                }\n            ];\n        }\n        this._data = data;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    element(element) {\n        if (!arguments.length) return this._element;\n        this._element = element;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    showLabels(show) {\n        if (!arguments.length) return this._show_labels;\n        this._show_labels = show;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    // todo dispatch\n    showLegend(show) {\n        if (!arguments.length) return this._show_legend;\n        this._show_legend = show;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    x(x) {\n        if (!arguments.length) return this._x;\n        this._x = x;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    y(y) {\n        if (!arguments.length) return this._y;\n        this._y = y;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    width(width) {\n        if (!arguments.length) return this._width;\n        this._width = width;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    height(height) {\n        if (!arguments.length) return this._height;\n        this._height = height;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    colours(colours) {\n        if (!arguments.length) return this._colours;\n        this._colours = colours;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    backgroundColour(colour) {\n        if (!arguments.length) return this._backgroundColour;\n        this._backgroundColour = colour || \"#FFF\"; // never set it to null.\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    tickFormat(format) {\n        if (!arguments.length) return this._tickFormat;\n        this._tickFormat = format;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    xAxisTickFormat(format) {\n        if (!arguments.length) return this._xAxisTickFormat;\n        this._xAxisTickFormat = format || (d => d.toString());\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    labelFormat(format) {\n        if (!arguments.length) return this._labelFormat;\n        this._labelFormat = format || (d => d.toString());\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    // todo missing\n    labelCompression(compression) {\n        if (!arguments.length) return this._compression;\n        this._compression = compression;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    //todo missing\n    dataAxisLabel(label) {\n        if (!arguments.length) return this._dataAxisLabel;\n        this._dataAxisLabel = label;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    tooltip(tooltip) {\n        if (!arguments.length) return this._tooltip;\n        this._tooltip = tooltip;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    forceY(force) {\n        if (!arguments.length) return this._forceY;\n        this._forceY = force;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n// todo missing\n    duration(duration) {\n        if (!arguments.length) return this._duration;\n        this._duration = duration;\n        return this;\n    }\n\n// todo missing\n    coarseness(coarseness) {\n        if (!arguments.length) return this._coarseness;\n        this._coarseness = coarseness;\n        return this;\n    }\n\n    // todo missing\n    padding(padding) {\n        if (!arguments.length) return this._padding;\n        this._padding = padding;\n        return this;\n    }\n\n    // todo missing\n    xAxisTooltips(tooltips) {\n        if (!arguments.length) return this._xAxisTooltips;\n        this._xAxisTooltips = tooltips;\n        return this;\n    }\n\n    xAxisOverride(override) {\n        if (!arguments.length) return this._xAxisOverride;\n        this._xAxisOverride = override;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    dispatch() {\n        return this._dispatch;\n    }\n\n    //------------------------------------------------------\n\n    render() {\n        if (!this._element) throw new Error(\"No element set for ColumnChart. See #element()\");\n        if (!this._data) {\n            console.warn(\"No data set for ColumnChart. See #data()\");\n            return;\n        }\n\n        const data = this.getTransformedData();\n\n        //------------------------------------------------\n        // Set up the SVG area\n\n        let topLevel = d3.select(this._element).select(\"svg\");\n        if (topLevel.empty()) topLevel = d3.select(this._element).append(\"svg\");\n\n        topLevel\n            .style(\"width\", this._width + \"px\")\n            .style(\"height\", this._height + \"px\");\n\n        // ---------------------------------\n        // Layout the showLegend.\n        //\n        // We do this now because we need to know how much space the legend\n        // takes up in order to finish calculating the margins.\n\n        const legendHeight = this.renderLegend(topLevel, data, 0, this._width, this._height, d => d._key);\n\n        //----------------------------------\n        // Calculate margins.\n\n        const margin = {top: 20, right: 20, bottom: 40, left: 40};\n        margin.bottom += legendHeight ? legendHeight + 20 : 0;\n\n        // if (this._dataAxisLabel) margin.left += 20 + 12;\n        // if (data) {\n        //     let maxLabelLength = 0;\n        //     data.forEach(d => {\n        //         d.data.forEach(d => {\n        //             let length = this._xAxisTickFormat(this._x(d)).length;\n        //             if (length > maxLabelLength) maxLabelLength = length;\n        //         })\n        //     });\n        //     margin.bottom += maxLabelLength * 2 + 10;    // space for axes labels.\n        // }\n\n        const width = this._width - margin.left - margin.right,\n              height = this._height - margin.top - margin.bottom;\n        const radius = Math.min(width, height) / 2;\n        this._radius = radius;\n\n        //----------------------------------\n        // Calculate scales and so on.\n\n        let colour = d3.scaleOrdinal([\"#98abc5\", \"#8a89a6\", \"#7b6888\", \"#6b486b\", \"#a05d56\", \"#d0743c\", \"#ff8c00\"]);\n\n        //------------------------------\n\n        let svg = topLevel.select('.main-group');\n\n        if (svg.empty()) {\n            svg = topLevel\n                .append(\"g\")\n                .attr(\"class\", \"main-group\");\n        }\n\n        svg.attr(\"transform\", \"translate(\" + (margin.left + width / 2) + \",\" + (margin.top + height / 2) + \")\");\n\n        //---------------------------------\n        // Get rid of current labels.\n        svg.select(\".chart-labels\")\n            .remove();\n\n        //---------------------------------\n        // append the arcs for the pie chart\n\n        let pie = d3.pie()\n            .sort(null)\n            .value(d => d._y);\n        this._pie = pie;\n\n        let path = d3.arc()\n            .outerRadius(radius - 10)\n            .innerRadius(0);\n\n        let arcs = svg.select(\".slices\").selectAll('.arc');\n\n        if (arcs.empty()) {\n            arcs = svg\n                .append(\"g\")\n                .attr(\"class\", \"slices\")\n                .selectAll(\".arc\");\n        }\n\n        let pieData = pie(data);\n        arcs = arcs.data(pieData);\n        arcs.exit().remove();\n\n        function arcTween(d, i) {\n            this._current = this._current || (i <= 0 ? { startAngle: 0, endAngle: 0} : pieData[i - 1]);\n            let interpolator = d3.interpolate(this._current, d);\n            this._current = interpolator(0);\n\n            return function(t) {\n                return path(interpolator(t))\n            }\n        }\n\n        arcs.enter()\n            .append(\"path\")\n                .attr(\"class\", (d, i) => \"arc \" + \"series series-\" + i)\n                .style(\"cursor\", \"pointer\")\n            .on(\"mouseover\", (d, i, nodes) => { // Darken the pie on mouse over\n                // We want to shift the pie out a bit on mouseover.\n                // So we want to find the direction to move the pie in.\n                // We can just ask the path helper to give us the centroid,\n                // normalise it, and that is the direction to move in.\n                const centre = path.centroid(d);\n                const norm = Math.sqrt(centre[0] ** 2 + centre[1] ** 2);\n                centre[0] = centre[0] / norm;\n                centre[1] = centre[1] / norm;\n\n                d3.select(nodes[i])\n                    .interrupt(\"hover:colour\")\n                    .transition(\"hover:colour\")\n                    .duration(300)\n                        .attr(\"transform\", \"translate(\" + (centre[0] * 10) + \",\" + (centre[1] * 10) + \"), scale(1.1)\")\n                        .style(\"fill\", d3.hcl(this.getSeriesColour(i)).darker());\n                this._dispatch.call(\"tooltipShow\", this, {\n                    e: d3.event,\n                    point: d.data,\n                    series: d.data._series,\n                    seriesIndex: d.data._s_i,\n                    value: d.data._y\n                })\n            })\n            .on(\"mouseout\", (d, i, nodes) => { // pie is regular colour on mouse out.\n                d3.select(nodes[i])\n                    .interrupt(\"hover:colour\")\n                    .transition(\"hover:colour\")\n                    .duration(300)\n                        .attr(\"transform\", \"translate(0,0)\")\n                        .style(\"fill\", this.getSeriesColour(i));\n                this._dispatch.call(\"tooltipHide\", this);\n            })\n            .on(\"click auxclick\", (d, i, nodes) => {\n                this._dispatch.call(\"elementClick\", this, {\n                    e: d3.event,\n                    point: d.data,\n                    series: d.data._series,\n                    seriesIndex: d.data._s_i,\n                    value: d.data._y\n                })\n            })\n            .merge(arcs)\n            .transition()\n                .attrTween(\"d\", arcTween)\n                .attr(\"fill\", (d, i) => this.getSeriesColour(i) );\n\n        // arcs.append(\"text\")\n        //     .attr(\"transform\", function(d) { return \"translate(\" + label.centroid(d) + \")\"; })\n        //     .attr(\"dy\", \"0.35em\")\n        //     .text(d => {console.log(\"d is\", d); return d.data._y; });\n\n\n        // ---------------------------------\n        // Labels loaded after our first bar grows.\n        if (this._show_labels) {\n            svg.transition(\"bar:growth\")\n                .on(\"end\", (d, i, nodes) => {\n                    if (i < nodes.length - 1) return;\n                    this.renderLabels(svg, data);\n                })\n        }\n\n        // ---------------------------------\n        // Set the background colour\n\n        d3.select(this._element).select(\".background\").remove();\n        if (this._backgroundColour) {\n            d3.select(this._element).select(\"svg\")\n                .append(\"rect\")\n                    .attr(\"class\", \"background\")\n                    .attr(\"width\", \"100%\")\n                    .attr(\"height\", \"100%\")\n                    .style(\"fill\", this._backgroundColour)\n                .lower();\n        }\n\n    }\n\n    //------------------------------------------------------\n\n    /*\n     * Returns an object with two functions, #show() and #hide(),\n     * to show and hide the labels.\n     */\n    labels() {\n        return {\n\n            show: () => {\n                if (this._element) {\n                    let selection = this._element,\n                        data = this.getTransformedData();\n\n                    if (selection) selection = d3.select(this._element).select(\"svg\").select(\".main-group\");\n                    if (!selection.empty() && data) {\n                        let labels = selection.select('.chart-labels');\n                        if (!labels.empty()) return;\n                        labels.remove();\n                        this.renderLabels(selection, data);\n                    }\n                }\n\n            },\n\n            hide: () => {\n                if (this._element) {\n                    d3.select(this._element)\n                        .select('.chart-labels')\n                        .interrupt(\"labels\")\n                        .interrupt(\"labels:fade\")\n                        .transition(\"labels:fade\")\n                        .style(\"opacity\", 0)\n                        .on(\"end\", (d, i, nodes) => {\n                            d3.select(nodes[i]).remove();\n                        })\n                }\n            }\n        }\n    }\n\n    //------------------------------------------------------\n\n    renderLabels(selection, data, animate) {\n        selection.selectAll(\".chart-labels\").remove();\n\n        const radius = this._radius + 15;\n\n        let arc = d3.arc()\n            .outerRadius(radius)\n            .innerRadius(radius);\n\n        let labels = selection.append(\"g\")\n            .attr(\"class\", \"chart-labels\")\n            .selectAll(\".label-group\")\n            .data(this._pie(data));\n\n        labels.enter()\n            .each((d, i, nodes) => {\n                const centroid = arc.centroid(d);\n                const radians = d.endAngle - d.startAngle;\n                const arcLength = radians * radius;\n\n                let label = d3.select(nodes[i])\n                    .append(\"text\")\n                    .text(d => this._labelFormat(d.data._y))\n                        // .style(\"font-family\", \"Open Sans, sans-serif\")\n                        // .style(\"font-size\", \"12px\")\n                        .style(\"fill\", _Colours__WEBPACK_IMPORTED_MODULE_0__[\"colours\"].eighteen.darkGrey)\n                        .style(\"opacity\", 0)\n                        .attr(\"transform\", \"translate(\" + centroid + \")\");\n\n                const bounding = label.node().getBBox();\n                if (bounding.width < arcLength) {\n                    // label.attr(\"dx\", (bounding.width / 2) * (direction[0] < 0 ? -1 : 1));\n                    // label.attr(\"dy\", (bounding.height / 2) * (direction[1] < 0 ? -1 : 1));\n                    label.attr(\"dx\", -(bounding.width / 2));\n                    label.attr(\"dy\", (bounding.height / 2));\n\n                    label\n                        .transition()\n                        .duration(this._duration)\n                        .style(\"opacity\", 1)\n                }\n\n            })\n    }\n\n    //------------------------------------------------------\n\n    getSeriesColour(i) {\n        if (i < 0 || !this._colours) return _Colours__WEBPACK_IMPORTED_MODULE_0__[\"colours\"].eighteen.midGrey;\n\n        i = i % this._colours.length;\n        return this._colours[i];\n    }\n\n    getSortedData() {\n        let data = this._data;\n        if (!data || !data.length) return [];\n\n        data = this._data.sort((lhs, rhs) => {\n            lhs = lhs.key.toLowerCase();\n            rhs = rhs.key.toLowerCase();\n\n            if (lhs === rhs) return 0;\n            if (lhs < rhs) return -1;\n            return 1;\n        });\n\n        return data;\n    }\n\n    getTransformedData() {\n        let data = this.getSortedData();\n        if (!data || !data.length) return [];\n\n        let results = [];\n\n        let series = data[0];\n        series.values.forEach((d, d_i) => {\n\n            results.push(Object.assign({\n                _y: this._y(d),\n                _series_key: series.key,\n                _s_i: 0,\n                _series: series,\n                _key: this._xAxisOverride ? this._xAxisOverride[this._x(d)] : this._x(d)\n            }, d));\n        });\n\n        return results;\n    }\n\n    getKeys() {\n        let data = this._data;\n        if (!data || !data.length) return [];\n\n        return [...new Set(data.map(d => d.key))]\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvUGllQ2hhcnQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9iM2pzLy4vc3JjL1BpZUNoYXJ0LmpzPzczZGQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChDKSAyMDEzLTIwMTQsIDIwMTggQnJhbmRzRXllIChQVFkpIExURFxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpc1xuLy8gc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlXG4vLyB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksXG4vLyAgICAgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0b1xuLy8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcbi8vIGNvbmRpdGlvbnM6XG4vL1xuLy8gICAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuLy8gY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyAgICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUiBJTVBMSUVELFxuLy8gICAgIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBXG4vLyBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUXG4vLyBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0Zcbi8vIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRVxuLy8gT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCB7Y29sb3Vyc30gZnJvbSAnLi9Db2xvdXJzJztcbmltcG9ydCB7Q2hhcnR9IGZyb20gJy4vQ2hhcnQnO1xuXG5leHBvcnQgY2xhc3MgUGllQ2hhcnQgZXh0ZW5kcyBDaGFydCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX2NvbG91cnMgPSBbXCIjOThhYmM1XCIsIFwiIzhhODlhNlwiLCBcIiM3YjY4ODhcIiwgXCIjNmI0ODZiXCIsIFwiI2EwNWQ1NlwiLCBcIiNkMDc0M2NcIiwgXCIjZmY4YzAwXCJdO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBkYXRhKGRhdGEpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fZGF0YTtcbiAgICAgICAgaWYgKGRhdGEgJiYgZGF0YVswXS5rZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZGF0YSA9IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGtleTogXCJzZXJpZXMgMVwiLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZXM6IGRhdGFcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgZWxlbWVudChlbGVtZW50KSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX2VsZW1lbnQ7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgc2hvd0xhYmVscyhzaG93KSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3Nob3dfbGFiZWxzO1xuICAgICAgICB0aGlzLl9zaG93X2xhYmVscyA9IHNob3c7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvLyB0b2RvIGRpc3BhdGNoXG4gICAgc2hvd0xlZ2VuZChzaG93KSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3Nob3dfbGVnZW5kO1xuICAgICAgICB0aGlzLl9zaG93X2xlZ2VuZCA9IHNob3c7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB4KHgpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5feDtcbiAgICAgICAgdGhpcy5feCA9IHg7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB5KHkpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5feTtcbiAgICAgICAgdGhpcy5feSA9IHk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB3aWR0aCh3aWR0aCkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl93aWR0aDtcbiAgICAgICAgdGhpcy5fd2lkdGggPSB3aWR0aDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGhlaWdodChoZWlnaHQpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5faGVpZ2h0O1xuICAgICAgICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBjb2xvdXJzKGNvbG91cnMpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fY29sb3VycztcbiAgICAgICAgdGhpcy5fY29sb3VycyA9IGNvbG91cnM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBiYWNrZ3JvdW5kQ29sb3VyKGNvbG91cikge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9iYWNrZ3JvdW5kQ29sb3VyO1xuICAgICAgICB0aGlzLl9iYWNrZ3JvdW5kQ29sb3VyID0gY29sb3VyIHx8IFwiI0ZGRlwiOyAvLyBuZXZlciBzZXQgaXQgdG8gbnVsbC5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHRpY2tGb3JtYXQoZm9ybWF0KSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3RpY2tGb3JtYXQ7XG4gICAgICAgIHRoaXMuX3RpY2tGb3JtYXQgPSBmb3JtYXQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB4QXhpc1RpY2tGb3JtYXQoZm9ybWF0KSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3hBeGlzVGlja0Zvcm1hdDtcbiAgICAgICAgdGhpcy5feEF4aXNUaWNrRm9ybWF0ID0gZm9ybWF0IHx8IChkID0+IGQudG9TdHJpbmcoKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBsYWJlbEZvcm1hdChmb3JtYXQpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fbGFiZWxGb3JtYXQ7XG4gICAgICAgIHRoaXMuX2xhYmVsRm9ybWF0ID0gZm9ybWF0IHx8IChkID0+IGQudG9TdHJpbmcoKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvLyB0b2RvIG1pc3NpbmdcbiAgICBsYWJlbENvbXByZXNzaW9uKGNvbXByZXNzaW9uKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX2NvbXByZXNzaW9uO1xuICAgICAgICB0aGlzLl9jb21wcmVzc2lvbiA9IGNvbXByZXNzaW9uO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLy90b2RvIG1pc3NpbmdcbiAgICBkYXRhQXhpc0xhYmVsKGxhYmVsKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX2RhdGFBeGlzTGFiZWw7XG4gICAgICAgIHRoaXMuX2RhdGFBeGlzTGFiZWwgPSBsYWJlbDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHRvb2x0aXAodG9vbHRpcCkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl90b29sdGlwO1xuICAgICAgICB0aGlzLl90b29sdGlwID0gdG9vbHRpcDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGZvcmNlWShmb3JjZSkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9mb3JjZVk7XG4gICAgICAgIHRoaXMuX2ZvcmNlWSA9IGZvcmNlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vLyB0b2RvIG1pc3NpbmdcbiAgICBkdXJhdGlvbihkdXJhdGlvbikge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9kdXJhdGlvbjtcbiAgICAgICAgdGhpcy5fZHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4vLyB0b2RvIG1pc3NpbmdcbiAgICBjb2Fyc2VuZXNzKGNvYXJzZW5lc3MpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fY29hcnNlbmVzcztcbiAgICAgICAgdGhpcy5fY29hcnNlbmVzcyA9IGNvYXJzZW5lc3M7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIHRvZG8gbWlzc2luZ1xuICAgIHBhZGRpbmcocGFkZGluZykge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9wYWRkaW5nO1xuICAgICAgICB0aGlzLl9wYWRkaW5nID0gcGFkZGluZztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gdG9kbyBtaXNzaW5nXG4gICAgeEF4aXNUb29sdGlwcyh0b29sdGlwcykge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl94QXhpc1Rvb2x0aXBzO1xuICAgICAgICB0aGlzLl94QXhpc1Rvb2x0aXBzID0gdG9vbHRpcHM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHhBeGlzT3ZlcnJpZGUob3ZlcnJpZGUpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5feEF4aXNPdmVycmlkZTtcbiAgICAgICAgdGhpcy5feEF4aXNPdmVycmlkZSA9IG92ZXJyaWRlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgZGlzcGF0Y2goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaXNwYXRjaDtcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2VsZW1lbnQpIHRocm93IG5ldyBFcnJvcihcIk5vIGVsZW1lbnQgc2V0IGZvciBDb2x1bW5DaGFydC4gU2VlICNlbGVtZW50KClcIik7XG4gICAgICAgIGlmICghdGhpcy5fZGF0YSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiTm8gZGF0YSBzZXQgZm9yIENvbHVtbkNoYXJ0LiBTZWUgI2RhdGEoKVwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLmdldFRyYW5zZm9ybWVkRGF0YSgpO1xuXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIFNldCB1cCB0aGUgU1ZHIGFyZWFcblxuICAgICAgICBsZXQgdG9wTGV2ZWwgPSBkMy5zZWxlY3QodGhpcy5fZWxlbWVudCkuc2VsZWN0KFwic3ZnXCIpO1xuICAgICAgICBpZiAodG9wTGV2ZWwuZW1wdHkoKSkgdG9wTGV2ZWwgPSBkMy5zZWxlY3QodGhpcy5fZWxlbWVudCkuYXBwZW5kKFwic3ZnXCIpO1xuXG4gICAgICAgIHRvcExldmVsXG4gICAgICAgICAgICAuc3R5bGUoXCJ3aWR0aFwiLCB0aGlzLl93aWR0aCArIFwicHhcIilcbiAgICAgICAgICAgIC5zdHlsZShcImhlaWdodFwiLCB0aGlzLl9oZWlnaHQgKyBcInB4XCIpO1xuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBMYXlvdXQgdGhlIHNob3dMZWdlbmQuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFdlIGRvIHRoaXMgbm93IGJlY2F1c2Ugd2UgbmVlZCB0byBrbm93IGhvdyBtdWNoIHNwYWNlIHRoZSBsZWdlbmRcbiAgICAgICAgLy8gdGFrZXMgdXAgaW4gb3JkZXIgdG8gZmluaXNoIGNhbGN1bGF0aW5nIHRoZSBtYXJnaW5zLlxuXG4gICAgICAgIGNvbnN0IGxlZ2VuZEhlaWdodCA9IHRoaXMucmVuZGVyTGVnZW5kKHRvcExldmVsLCBkYXRhLCAwLCB0aGlzLl93aWR0aCwgdGhpcy5faGVpZ2h0LCBkID0+IGQuX2tleSk7XG5cbiAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIENhbGN1bGF0ZSBtYXJnaW5zLlxuXG4gICAgICAgIGNvbnN0IG1hcmdpbiA9IHt0b3A6IDIwLCByaWdodDogMjAsIGJvdHRvbTogNDAsIGxlZnQ6IDQwfTtcbiAgICAgICAgbWFyZ2luLmJvdHRvbSArPSBsZWdlbmRIZWlnaHQgPyBsZWdlbmRIZWlnaHQgKyAyMCA6IDA7XG5cbiAgICAgICAgLy8gaWYgKHRoaXMuX2RhdGFBeGlzTGFiZWwpIG1hcmdpbi5sZWZ0ICs9IDIwICsgMTI7XG4gICAgICAgIC8vIGlmIChkYXRhKSB7XG4gICAgICAgIC8vICAgICBsZXQgbWF4TGFiZWxMZW5ndGggPSAwO1xuICAgICAgICAvLyAgICAgZGF0YS5mb3JFYWNoKGQgPT4ge1xuICAgICAgICAvLyAgICAgICAgIGQuZGF0YS5mb3JFYWNoKGQgPT4ge1xuICAgICAgICAvLyAgICAgICAgICAgICBsZXQgbGVuZ3RoID0gdGhpcy5feEF4aXNUaWNrRm9ybWF0KHRoaXMuX3goZCkpLmxlbmd0aDtcbiAgICAgICAgLy8gICAgICAgICAgICAgaWYgKGxlbmd0aCA+IG1heExhYmVsTGVuZ3RoKSBtYXhMYWJlbExlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgLy8gICAgICAgICB9KVxuICAgICAgICAvLyAgICAgfSk7XG4gICAgICAgIC8vICAgICBtYXJnaW4uYm90dG9tICs9IG1heExhYmVsTGVuZ3RoICogMiArIDEwOyAgICAvLyBzcGFjZSBmb3IgYXhlcyBsYWJlbHMuXG4gICAgICAgIC8vIH1cblxuICAgICAgICBjb25zdCB3aWR0aCA9IHRoaXMuX3dpZHRoIC0gbWFyZ2luLmxlZnQgLSBtYXJnaW4ucmlnaHQsXG4gICAgICAgICAgICAgIGhlaWdodCA9IHRoaXMuX2hlaWdodCAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tO1xuICAgICAgICBjb25zdCByYWRpdXMgPSBNYXRoLm1pbih3aWR0aCwgaGVpZ2h0KSAvIDI7XG4gICAgICAgIHRoaXMuX3JhZGl1cyA9IHJhZGl1cztcblxuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHNjYWxlcyBhbmQgc28gb24uXG5cbiAgICAgICAgbGV0IGNvbG91ciA9IGQzLnNjYWxlT3JkaW5hbChbXCIjOThhYmM1XCIsIFwiIzhhODlhNlwiLCBcIiM3YjY4ODhcIiwgXCIjNmI0ODZiXCIsIFwiI2EwNWQ1NlwiLCBcIiNkMDc0M2NcIiwgXCIjZmY4YzAwXCJdKTtcblxuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgIGxldCBzdmcgPSB0b3BMZXZlbC5zZWxlY3QoJy5tYWluLWdyb3VwJyk7XG5cbiAgICAgICAgaWYgKHN2Zy5lbXB0eSgpKSB7XG4gICAgICAgICAgICBzdmcgPSB0b3BMZXZlbFxuICAgICAgICAgICAgICAgIC5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcIm1haW4tZ3JvdXBcIik7XG4gICAgICAgIH1cblxuICAgICAgICBzdmcuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIChtYXJnaW4ubGVmdCArIHdpZHRoIC8gMikgKyBcIixcIiArIChtYXJnaW4udG9wICsgaGVpZ2h0IC8gMikgKyBcIilcIik7XG5cbiAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gR2V0IHJpZCBvZiBjdXJyZW50IGxhYmVscy5cbiAgICAgICAgc3ZnLnNlbGVjdChcIi5jaGFydC1sYWJlbHNcIilcbiAgICAgICAgICAgIC5yZW1vdmUoKTtcblxuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBhcHBlbmQgdGhlIGFyY3MgZm9yIHRoZSBwaWUgY2hhcnRcblxuICAgICAgICBsZXQgcGllID0gZDMucGllKClcbiAgICAgICAgICAgIC5zb3J0KG51bGwpXG4gICAgICAgICAgICAudmFsdWUoZCA9PiBkLl95KTtcbiAgICAgICAgdGhpcy5fcGllID0gcGllO1xuXG4gICAgICAgIGxldCBwYXRoID0gZDMuYXJjKClcbiAgICAgICAgICAgIC5vdXRlclJhZGl1cyhyYWRpdXMgLSAxMClcbiAgICAgICAgICAgIC5pbm5lclJhZGl1cygwKTtcblxuICAgICAgICBsZXQgYXJjcyA9IHN2Zy5zZWxlY3QoXCIuc2xpY2VzXCIpLnNlbGVjdEFsbCgnLmFyYycpO1xuXG4gICAgICAgIGlmIChhcmNzLmVtcHR5KCkpIHtcbiAgICAgICAgICAgIGFyY3MgPSBzdmdcbiAgICAgICAgICAgICAgICAuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJzbGljZXNcIilcbiAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKFwiLmFyY1wiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBwaWVEYXRhID0gcGllKGRhdGEpO1xuICAgICAgICBhcmNzID0gYXJjcy5kYXRhKHBpZURhdGEpO1xuICAgICAgICBhcmNzLmV4aXQoKS5yZW1vdmUoKTtcblxuICAgICAgICBmdW5jdGlvbiBhcmNUd2VlbihkLCBpKSB7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50ID0gdGhpcy5fY3VycmVudCB8fCAoaSA8PSAwID8geyBzdGFydEFuZ2xlOiAwLCBlbmRBbmdsZTogMH0gOiBwaWVEYXRhW2kgLSAxXSk7XG4gICAgICAgICAgICBsZXQgaW50ZXJwb2xhdG9yID0gZDMuaW50ZXJwb2xhdGUodGhpcy5fY3VycmVudCwgZCk7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50ID0gaW50ZXJwb2xhdG9yKDApO1xuXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXRoKGludGVycG9sYXRvcih0KSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGFyY3MuZW50ZXIoKVxuICAgICAgICAgICAgLmFwcGVuZChcInBhdGhcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIChkLCBpKSA9PiBcImFyYyBcIiArIFwic2VyaWVzIHNlcmllcy1cIiArIGkpXG4gICAgICAgICAgICAgICAgLnN0eWxlKFwiY3Vyc29yXCIsIFwicG9pbnRlclwiKVxuICAgICAgICAgICAgLm9uKFwibW91c2VvdmVyXCIsIChkLCBpLCBub2RlcykgPT4geyAvLyBEYXJrZW4gdGhlIHBpZSBvbiBtb3VzZSBvdmVyXG4gICAgICAgICAgICAgICAgLy8gV2Ugd2FudCB0byBzaGlmdCB0aGUgcGllIG91dCBhIGJpdCBvbiBtb3VzZW92ZXIuXG4gICAgICAgICAgICAgICAgLy8gU28gd2Ugd2FudCB0byBmaW5kIHRoZSBkaXJlY3Rpb24gdG8gbW92ZSB0aGUgcGllIGluLlxuICAgICAgICAgICAgICAgIC8vIFdlIGNhbiBqdXN0IGFzayB0aGUgcGF0aCBoZWxwZXIgdG8gZ2l2ZSB1cyB0aGUgY2VudHJvaWQsXG4gICAgICAgICAgICAgICAgLy8gbm9ybWFsaXNlIGl0LCBhbmQgdGhhdCBpcyB0aGUgZGlyZWN0aW9uIHRvIG1vdmUgaW4uXG4gICAgICAgICAgICAgICAgY29uc3QgY2VudHJlID0gcGF0aC5jZW50cm9pZChkKTtcbiAgICAgICAgICAgICAgICBjb25zdCBub3JtID0gTWF0aC5zcXJ0KGNlbnRyZVswXSAqKiAyICsgY2VudHJlWzFdICoqIDIpO1xuICAgICAgICAgICAgICAgIGNlbnRyZVswXSA9IGNlbnRyZVswXSAvIG5vcm07XG4gICAgICAgICAgICAgICAgY2VudHJlWzFdID0gY2VudHJlWzFdIC8gbm9ybTtcblxuICAgICAgICAgICAgICAgIGQzLnNlbGVjdChub2Rlc1tpXSlcbiAgICAgICAgICAgICAgICAgICAgLmludGVycnVwdChcImhvdmVyOmNvbG91clwiKVxuICAgICAgICAgICAgICAgICAgICAudHJhbnNpdGlvbihcImhvdmVyOmNvbG91clwiKVxuICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24oMzAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyAoY2VudHJlWzBdICogMTApICsgXCIsXCIgKyAoY2VudHJlWzFdICogMTApICsgXCIpLCBzY2FsZSgxLjEpXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIGQzLmhjbCh0aGlzLmdldFNlcmllc0NvbG91cihpKSkuZGFya2VyKCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3BhdGNoLmNhbGwoXCJ0b29sdGlwU2hvd1wiLCB0aGlzLCB7XG4gICAgICAgICAgICAgICAgICAgIGU6IGQzLmV2ZW50LFxuICAgICAgICAgICAgICAgICAgICBwb2ludDogZC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICBzZXJpZXM6IGQuZGF0YS5fc2VyaWVzLFxuICAgICAgICAgICAgICAgICAgICBzZXJpZXNJbmRleDogZC5kYXRhLl9zX2ksXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBkLmRhdGEuX3lcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbihcIm1vdXNlb3V0XCIsIChkLCBpLCBub2RlcykgPT4geyAvLyBwaWUgaXMgcmVndWxhciBjb2xvdXIgb24gbW91c2Ugb3V0LlxuICAgICAgICAgICAgICAgIGQzLnNlbGVjdChub2Rlc1tpXSlcbiAgICAgICAgICAgICAgICAgICAgLmludGVycnVwdChcImhvdmVyOmNvbG91clwiKVxuICAgICAgICAgICAgICAgICAgICAudHJhbnNpdGlvbihcImhvdmVyOmNvbG91clwiKVxuICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24oMzAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoMCwwKVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCB0aGlzLmdldFNlcmllc0NvbG91cihpKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGlzcGF0Y2guY2FsbChcInRvb2x0aXBIaWRlXCIsIHRoaXMpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbihcImNsaWNrIGF1eGNsaWNrXCIsIChkLCBpLCBub2RlcykgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3BhdGNoLmNhbGwoXCJlbGVtZW50Q2xpY2tcIiwgdGhpcywge1xuICAgICAgICAgICAgICAgICAgICBlOiBkMy5ldmVudCxcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQ6IGQuZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgc2VyaWVzOiBkLmRhdGEuX3NlcmllcyxcbiAgICAgICAgICAgICAgICAgICAgc2VyaWVzSW5kZXg6IGQuZGF0YS5fc19pLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZC5kYXRhLl95XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAubWVyZ2UoYXJjcylcbiAgICAgICAgICAgIC50cmFuc2l0aW9uKClcbiAgICAgICAgICAgICAgICAuYXR0clR3ZWVuKFwiZFwiLCBhcmNUd2VlbilcbiAgICAgICAgICAgICAgICAuYXR0cihcImZpbGxcIiwgKGQsIGkpID0+IHRoaXMuZ2V0U2VyaWVzQ29sb3VyKGkpICk7XG5cbiAgICAgICAgLy8gYXJjcy5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgICAgIC8vICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBmdW5jdGlvbihkKSB7IHJldHVybiBcInRyYW5zbGF0ZShcIiArIGxhYmVsLmNlbnRyb2lkKGQpICsgXCIpXCI7IH0pXG4gICAgICAgIC8vICAgICAuYXR0cihcImR5XCIsIFwiMC4zNWVtXCIpXG4gICAgICAgIC8vICAgICAudGV4dChkID0+IHtjb25zb2xlLmxvZyhcImQgaXNcIiwgZCk7IHJldHVybiBkLmRhdGEuX3k7IH0pO1xuXG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIExhYmVscyBsb2FkZWQgYWZ0ZXIgb3VyIGZpcnN0IGJhciBncm93cy5cbiAgICAgICAgaWYgKHRoaXMuX3Nob3dfbGFiZWxzKSB7XG4gICAgICAgICAgICBzdmcudHJhbnNpdGlvbihcImJhcjpncm93dGhcIilcbiAgICAgICAgICAgICAgICAub24oXCJlbmRcIiwgKGQsIGksIG5vZGVzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpIDwgbm9kZXMubGVuZ3RoIC0gMSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckxhYmVscyhzdmcsIGRhdGEpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gU2V0IHRoZSBiYWNrZ3JvdW5kIGNvbG91clxuXG4gICAgICAgIGQzLnNlbGVjdCh0aGlzLl9lbGVtZW50KS5zZWxlY3QoXCIuYmFja2dyb3VuZFwiKS5yZW1vdmUoKTtcbiAgICAgICAgaWYgKHRoaXMuX2JhY2tncm91bmRDb2xvdXIpIHtcbiAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzLl9lbGVtZW50KS5zZWxlY3QoXCJzdmdcIilcbiAgICAgICAgICAgICAgICAuYXBwZW5kKFwicmVjdFwiKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwiYmFja2dyb3VuZFwiKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcIndpZHRoXCIsIFwiMTAwJVwiKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcImhlaWdodFwiLCBcIjEwMCVcIilcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCB0aGlzLl9iYWNrZ3JvdW5kQ29sb3VyKVxuICAgICAgICAgICAgICAgIC5sb3dlcigpO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLypcbiAgICAgKiBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIHR3byBmdW5jdGlvbnMsICNzaG93KCkgYW5kICNoaWRlKCksXG4gICAgICogdG8gc2hvdyBhbmQgaGlkZSB0aGUgbGFiZWxzLlxuICAgICAqL1xuICAgIGxhYmVscygpIHtcbiAgICAgICAgcmV0dXJuIHtcblxuICAgICAgICAgICAgc2hvdzogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9lbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzZWxlY3Rpb24gPSB0aGlzLl9lbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHRoaXMuZ2V0VHJhbnNmb3JtZWREYXRhKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvbikgc2VsZWN0aW9uID0gZDMuc2VsZWN0KHRoaXMuX2VsZW1lbnQpLnNlbGVjdChcInN2Z1wiKS5zZWxlY3QoXCIubWFpbi1ncm91cFwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzZWxlY3Rpb24uZW1wdHkoKSAmJiBkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbGFiZWxzID0gc2VsZWN0aW9uLnNlbGVjdCgnLmNoYXJ0LWxhYmVscycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFsYWJlbHMuZW1wdHkoKSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWxzLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJMYWJlbHMoc2VsZWN0aW9uLCBkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgaGlkZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9lbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzLl9lbGVtZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgLnNlbGVjdCgnLmNoYXJ0LWxhYmVscycpXG4gICAgICAgICAgICAgICAgICAgICAgICAuaW50ZXJydXB0KFwibGFiZWxzXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAuaW50ZXJydXB0KFwibGFiZWxzOmZhZGVcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKFwibGFiZWxzOmZhZGVcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5vbihcImVuZFwiLCAoZCwgaSwgbm9kZXMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkMy5zZWxlY3Qobm9kZXNbaV0pLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgcmVuZGVyTGFiZWxzKHNlbGVjdGlvbiwgZGF0YSwgYW5pbWF0ZSkge1xuICAgICAgICBzZWxlY3Rpb24uc2VsZWN0QWxsKFwiLmNoYXJ0LWxhYmVsc1wiKS5yZW1vdmUoKTtcblxuICAgICAgICBjb25zdCByYWRpdXMgPSB0aGlzLl9yYWRpdXMgKyAxNTtcblxuICAgICAgICBsZXQgYXJjID0gZDMuYXJjKClcbiAgICAgICAgICAgIC5vdXRlclJhZGl1cyhyYWRpdXMpXG4gICAgICAgICAgICAuaW5uZXJSYWRpdXMocmFkaXVzKTtcblxuICAgICAgICBsZXQgbGFiZWxzID0gc2VsZWN0aW9uLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJjaGFydC1sYWJlbHNcIilcbiAgICAgICAgICAgIC5zZWxlY3RBbGwoXCIubGFiZWwtZ3JvdXBcIilcbiAgICAgICAgICAgIC5kYXRhKHRoaXMuX3BpZShkYXRhKSk7XG5cbiAgICAgICAgbGFiZWxzLmVudGVyKClcbiAgICAgICAgICAgIC5lYWNoKChkLCBpLCBub2RlcykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNlbnRyb2lkID0gYXJjLmNlbnRyb2lkKGQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJhZGlhbnMgPSBkLmVuZEFuZ2xlIC0gZC5zdGFydEFuZ2xlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFyY0xlbmd0aCA9IHJhZGlhbnMgKiByYWRpdXM7XG5cbiAgICAgICAgICAgICAgICBsZXQgbGFiZWwgPSBkMy5zZWxlY3Qobm9kZXNbaV0pXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgICAgICAgICAgICAgICAgIC50ZXh0KGQgPT4gdGhpcy5fbGFiZWxGb3JtYXQoZC5kYXRhLl95KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIC5zdHlsZShcImZvbnQtZmFtaWx5XCIsIFwiT3BlbiBTYW5zLCBzYW5zLXNlcmlmXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAuc3R5bGUoXCJmb250LXNpemVcIiwgXCIxMnB4XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIGNvbG91cnMuZWlnaHRlZW4uZGFya0dyZXkpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDApXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIGNlbnRyb2lkICsgXCIpXCIpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgYm91bmRpbmcgPSBsYWJlbC5ub2RlKCkuZ2V0QkJveCgpO1xuICAgICAgICAgICAgICAgIGlmIChib3VuZGluZy53aWR0aCA8IGFyY0xlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBsYWJlbC5hdHRyKFwiZHhcIiwgKGJvdW5kaW5nLndpZHRoIC8gMikgKiAoZGlyZWN0aW9uWzBdIDwgMCA/IC0xIDogMSkpO1xuICAgICAgICAgICAgICAgICAgICAvLyBsYWJlbC5hdHRyKFwiZHlcIiwgKGJvdW5kaW5nLmhlaWdodCAvIDIpICogKGRpcmVjdGlvblsxXSA8IDAgPyAtMSA6IDEpKTtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWwuYXR0cihcImR4XCIsIC0oYm91bmRpbmcud2lkdGggLyAyKSk7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsLmF0dHIoXCJkeVwiLCAoYm91bmRpbmcuaGVpZ2h0IC8gMikpO1xuXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsXG4gICAgICAgICAgICAgICAgICAgICAgICAudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24odGhpcy5fZHVyYXRpb24pXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDEpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9KVxuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBnZXRTZXJpZXNDb2xvdXIoaSkge1xuICAgICAgICBpZiAoaSA8IDAgfHwgIXRoaXMuX2NvbG91cnMpIHJldHVybiBjb2xvdXJzLmVpZ2h0ZWVuLm1pZEdyZXk7XG5cbiAgICAgICAgaSA9IGkgJSB0aGlzLl9jb2xvdXJzLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbG91cnNbaV07XG4gICAgfVxuXG4gICAgZ2V0U29ydGVkRGF0YSgpIHtcbiAgICAgICAgbGV0IGRhdGEgPSB0aGlzLl9kYXRhO1xuICAgICAgICBpZiAoIWRhdGEgfHwgIWRhdGEubGVuZ3RoKSByZXR1cm4gW107XG5cbiAgICAgICAgZGF0YSA9IHRoaXMuX2RhdGEuc29ydCgobGhzLCByaHMpID0+IHtcbiAgICAgICAgICAgIGxocyA9IGxocy5rZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIHJocyA9IHJocy5rZXkudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICAgICAgaWYgKGxocyA9PT0gcmhzKSByZXR1cm4gMDtcbiAgICAgICAgICAgIGlmIChsaHMgPCByaHMpIHJldHVybiAtMTtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICBnZXRUcmFuc2Zvcm1lZERhdGEoKSB7XG4gICAgICAgIGxldCBkYXRhID0gdGhpcy5nZXRTb3J0ZWREYXRhKCk7XG4gICAgICAgIGlmICghZGF0YSB8fCAhZGF0YS5sZW5ndGgpIHJldHVybiBbXTtcblxuICAgICAgICBsZXQgcmVzdWx0cyA9IFtdO1xuXG4gICAgICAgIGxldCBzZXJpZXMgPSBkYXRhWzBdO1xuICAgICAgICBzZXJpZXMudmFsdWVzLmZvckVhY2goKGQsIGRfaSkgPT4ge1xuXG4gICAgICAgICAgICByZXN1bHRzLnB1c2goT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICAgICAgX3k6IHRoaXMuX3koZCksXG4gICAgICAgICAgICAgICAgX3Nlcmllc19rZXk6IHNlcmllcy5rZXksXG4gICAgICAgICAgICAgICAgX3NfaTogMCxcbiAgICAgICAgICAgICAgICBfc2VyaWVzOiBzZXJpZXMsXG4gICAgICAgICAgICAgICAgX2tleTogdGhpcy5feEF4aXNPdmVycmlkZSA/IHRoaXMuX3hBeGlzT3ZlcnJpZGVbdGhpcy5feChkKV0gOiB0aGlzLl94KGQpXG4gICAgICAgICAgICB9LCBkKSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cblxuICAgIGdldEtleXMoKSB7XG4gICAgICAgIGxldCBkYXRhID0gdGhpcy5fZGF0YTtcbiAgICAgICAgaWYgKCFkYXRhIHx8ICFkYXRhLmxlbmd0aCkgcmV0dXJuIFtdO1xuXG4gICAgICAgIHJldHVybiBbLi4ubmV3IFNldChkYXRhLm1hcChkID0+IGQua2V5KSldXG4gICAgfVxufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/PieChart.js\n");

/***/ }),

/***/ "./src/Points.js":
/*!***********************!*\
  !*** ./src/Points.js ***!
  \***********************/
/*! exports provided: points */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"points\", function() { return points; });\n/* harmony import */ var _Geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Geometry */ \"./src/Geometry.js\");\n// Copyright (C) 2013-2014, 2018 BrandsEye (PTY) LTD\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this\n// software and associated documentation files (the \"Software\"), to deal in the Software\n// without restriction, including without limitation the rights to use, copy, modify,\n//     merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following\n// conditions:\n//\n//     The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n//     INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n// CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n\nclass Point extends _Geometry__WEBPACK_IMPORTED_MODULE_0__[\"Geometry\"] {\n\n    constructor() {\n        super(\"POINT\", 3);\n    }\n\n    render() {\n        console.log(\"\\tRendering POINTS\");\n\n        const element = this._element;\n        const data = this.prepareData();\n        const width = this._width,\n              height = this._height;\n\n        element.classed(\"points\", true);\n\n\n        const x = this.getD3XScale(data, width);\n        const y = this.getD3YScale(data, height);\n\n        const colours = d3.scaleOrdinal(this.colourScale())\n                          .domain(this.getColourDomain(data));\n\n        let groups = element.selectAll('.point-groups');\n        groups = groups.data(data);\n\n        groups.exit().remove();\n\n        groups.enter()\n              .append(\"g\")\n              .attr(\"class\", \"point-groups\")\n              .merge(groups.selectAll(\".point-groups\"))\n              .each((d, i, nodes) => {\n                  const group = d3.select(nodes[i]);\n                  const points = group.selectAll(\".point\")\n                      .data(d.data);\n\n                  points.enter()\n                      .append(\"circle\")\n                          .style(\"opacity\", 0.4)\n                          .attr(\"cx\", d => x(d._x))\n                          .attr(\"cy\", d => y(d._y))\n                          .attr(\"fill\", d => colours(d._colour))\n                          .attr(\"r\", 5);\n              });\n    }\n\n    getD3XScale(data, width) {\n        width = width || this.width();\n        data = data || this.prepareData()\n        return d3.scaleLinear()\n                 .rangeRound([0, width])\n                 .domain([Math.min(0, d3.min(data, d => d3.min(d.data, d => d._x))),\n                     d3.max(data, d => d3.max(d.data, d => d._x))]);\n\n    }\n\n    getD3YScale(data, height) {\n        data = data || this.prepareData();\n        height = height || this.height();\n\n        return d3.scaleLinear()\n                 .rangeRound([height, 0])\n                 .nice()\n                 .domain([Math.min(0, d3.min(data, d => d3.min(d.data, d => d._y))),\n                     d3.max(data, d => d3.max(d.data, d => d._y))]);\n\n    }\n}\n\n\nfunction points() {\n    return new Point();\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvUG9pbnRzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYjNqcy8uL3NyYy9Qb2ludHMuanM/MGJjOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKEMpIDIwMTMtMjAxNCwgMjAxOCBCcmFuZHNFeWUgKFBUWSkgTFREXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZiB0aGlzXG4vLyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmVcbi8vIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSxcbi8vICAgICBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvXG4vLyBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZ1xuLy8gY29uZGl0aW9uczpcbi8vXG4vLyAgICAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4vLyBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vICAgICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SIElNUExJRUQsXG4vLyAgICAgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEFcbi8vIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFRcbi8vIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRlxuLy8gQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFXG4vLyBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IHsgR2VvbWV0cnkgfSBmcm9tICcuL0dlb21ldHJ5JztcblxuXG5jbGFzcyBQb2ludCBleHRlbmRzIEdlb21ldHJ5IHtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihcIlBPSU5UXCIsIDMpO1xuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJcXHRSZW5kZXJpbmcgUE9JTlRTXCIpO1xuXG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLl9lbGVtZW50O1xuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5wcmVwYXJlRGF0YSgpO1xuICAgICAgICBjb25zdCB3aWR0aCA9IHRoaXMuX3dpZHRoLFxuICAgICAgICAgICAgICBoZWlnaHQgPSB0aGlzLl9oZWlnaHQ7XG5cbiAgICAgICAgZWxlbWVudC5jbGFzc2VkKFwicG9pbnRzXCIsIHRydWUpO1xuXG5cbiAgICAgICAgY29uc3QgeCA9IHRoaXMuZ2V0RDNYU2NhbGUoZGF0YSwgd2lkdGgpO1xuICAgICAgICBjb25zdCB5ID0gdGhpcy5nZXREM1lTY2FsZShkYXRhLCBoZWlnaHQpO1xuXG4gICAgICAgIGNvbnN0IGNvbG91cnMgPSBkMy5zY2FsZU9yZGluYWwodGhpcy5jb2xvdXJTY2FsZSgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAuZG9tYWluKHRoaXMuZ2V0Q29sb3VyRG9tYWluKGRhdGEpKTtcblxuICAgICAgICBsZXQgZ3JvdXBzID0gZWxlbWVudC5zZWxlY3RBbGwoJy5wb2ludC1ncm91cHMnKTtcbiAgICAgICAgZ3JvdXBzID0gZ3JvdXBzLmRhdGEoZGF0YSk7XG5cbiAgICAgICAgZ3JvdXBzLmV4aXQoKS5yZW1vdmUoKTtcblxuICAgICAgICBncm91cHMuZW50ZXIoKVxuICAgICAgICAgICAgICAuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwicG9pbnQtZ3JvdXBzXCIpXG4gICAgICAgICAgICAgIC5tZXJnZShncm91cHMuc2VsZWN0QWxsKFwiLnBvaW50LWdyb3Vwc1wiKSlcbiAgICAgICAgICAgICAgLmVhY2goKGQsIGksIG5vZGVzKSA9PiB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBncm91cCA9IGQzLnNlbGVjdChub2Rlc1tpXSk7XG4gICAgICAgICAgICAgICAgICBjb25zdCBwb2ludHMgPSBncm91cC5zZWxlY3RBbGwoXCIucG9pbnRcIilcbiAgICAgICAgICAgICAgICAgICAgICAuZGF0YShkLmRhdGEpO1xuXG4gICAgICAgICAgICAgICAgICBwb2ludHMuZW50ZXIoKVxuICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoXCJjaXJjbGVcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAwLjQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiY3hcIiwgZCA9PiB4KGQuX3gpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcImN5XCIsIGQgPT4geShkLl95KSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJmaWxsXCIsIGQgPT4gY29sb3VycyhkLl9jb2xvdXIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcInJcIiwgNSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgIH1cblxuICAgIGdldEQzWFNjYWxlKGRhdGEsIHdpZHRoKSB7XG4gICAgICAgIHdpZHRoID0gd2lkdGggfHwgdGhpcy53aWR0aCgpO1xuICAgICAgICBkYXRhID0gZGF0YSB8fCB0aGlzLnByZXBhcmVEYXRhKClcbiAgICAgICAgcmV0dXJuIGQzLnNjYWxlTGluZWFyKClcbiAgICAgICAgICAgICAgICAgLnJhbmdlUm91bmQoWzAsIHdpZHRoXSlcbiAgICAgICAgICAgICAgICAgLmRvbWFpbihbTWF0aC5taW4oMCwgZDMubWluKGRhdGEsIGQgPT4gZDMubWluKGQuZGF0YSwgZCA9PiBkLl94KSkpLFxuICAgICAgICAgICAgICAgICAgICAgZDMubWF4KGRhdGEsIGQgPT4gZDMubWF4KGQuZGF0YSwgZCA9PiBkLl94KSldKTtcblxuICAgIH1cblxuICAgIGdldEQzWVNjYWxlKGRhdGEsIGhlaWdodCkge1xuICAgICAgICBkYXRhID0gZGF0YSB8fCB0aGlzLnByZXBhcmVEYXRhKCk7XG4gICAgICAgIGhlaWdodCA9IGhlaWdodCB8fCB0aGlzLmhlaWdodCgpO1xuXG4gICAgICAgIHJldHVybiBkMy5zY2FsZUxpbmVhcigpXG4gICAgICAgICAgICAgICAgIC5yYW5nZVJvdW5kKFtoZWlnaHQsIDBdKVxuICAgICAgICAgICAgICAgICAubmljZSgpXG4gICAgICAgICAgICAgICAgIC5kb21haW4oW01hdGgubWluKDAsIGQzLm1pbihkYXRhLCBkID0+IGQzLm1pbihkLmRhdGEsIGQgPT4gZC5feSkpKSxcbiAgICAgICAgICAgICAgICAgICAgIGQzLm1heChkYXRhLCBkID0+IGQzLm1heChkLmRhdGEsIGQgPT4gZC5feSkpXSk7XG5cbiAgICB9XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIHBvaW50cygpIHtcbiAgICByZXR1cm4gbmV3IFBvaW50KCk7XG59Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/Points.js\n");

/***/ }),

/***/ "./src/Scales.js":
/*!***********************!*\
  !*** ./src/Scales.js ***!
  \***********************/
/*! exports provided: scaleTime, scaleIdentity, scaleDiscrete, chooseScale */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"scaleTime\", function() { return scaleTime; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"scaleIdentity\", function() { return scaleIdentity; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"scaleDiscrete\", function() { return scaleDiscrete; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"chooseScale\", function() { return chooseScale; });\n/* harmony import */ var _Bucket__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Bucket */ \"./src/Bucket.js\");\n// Copyright (C) 2013-2014, 2018 BrandsEye (PTY) LTD\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this\n// software and associated documentation files (the \"Software\"), to deal in the Software\n// without restriction, including without limitation the rights to use, copy, modify,\n//     merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following\n// conditions:\n//\n//     The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n//     INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n// CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n\nclass ScaleTime {\n    transform(val) {\n        if (val instanceof Date) return val;\n        if (typeof val !== 'string') throw new Error(\"Value is not a string and cannot be converted to a date\");\n        return new Date(val);\n    }\n\n    buckets(data) {\n        return new _Bucket__WEBPACK_IMPORTED_MODULE_0__[\"DateBucket\"](data);\n    }\n}\n\nclass ScaleIdentity {\n    transform(val) {\n        return val;\n    }\n\n    buckets(data) {\n        return new _Bucket__WEBPACK_IMPORTED_MODULE_0__[\"ContinuousBucket\"](data);\n    }\n}\n\nclass ScaleDiscrete {\n    transform(val) {\n        return val;\n    }\n\n    buckets(data) {\n        return new _Bucket__WEBPACK_IMPORTED_MODULE_0__[\"DiscreteBucket\"](data);\n    }\n}\n\n\nfunction scaleTime() {\n    return new ScaleTime();\n}\n\nfunction scaleIdentity() {\n    return new ScaleIdentity();\n}\n\nfunction scaleDiscrete() {\n    return new ScaleDiscrete();\n}\n\nfunction chooseScale(exampleValue) {\n    if (exampleValue === undefined) throw new Error(\"No value provided for chooseScale\");\n    if (Date.parse(exampleValue)) return scaleTime();\n    if (exampleValue instanceof Date) return scaleTime();\n    if (typeof exampleValue === 'string') return scaleDiscrete();\n    if (typeof exampleValue === 'number') return scaleIdentity();\n\n    throw new Error(\"Unable to determine wanted scale for example value [\" + exampleValue + \"]\");\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvU2NhbGVzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYjNqcy8uL3NyYy9TY2FsZXMuanM/ZmRlOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKEMpIDIwMTMtMjAxNCwgMjAxOCBCcmFuZHNFeWUgKFBUWSkgTFREXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZiB0aGlzXG4vLyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmVcbi8vIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSxcbi8vICAgICBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvXG4vLyBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZ1xuLy8gY29uZGl0aW9uczpcbi8vXG4vLyAgICAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4vLyBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vICAgICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SIElNUExJRUQsXG4vLyAgICAgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEFcbi8vIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFRcbi8vIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRlxuLy8gQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFXG4vLyBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IHtEYXRlQnVja2V0LCBDb250aW51b3VzQnVja2V0LCBEaXNjcmV0ZUJ1Y2tldH0gZnJvbSBcIi4vQnVja2V0XCI7XG5cblxuY2xhc3MgU2NhbGVUaW1lIHtcbiAgICB0cmFuc2Zvcm0odmFsKSB7XG4gICAgICAgIGlmICh2YWwgaW5zdGFuY2VvZiBEYXRlKSByZXR1cm4gdmFsO1xuICAgICAgICBpZiAodHlwZW9mIHZhbCAhPT0gJ3N0cmluZycpIHRocm93IG5ldyBFcnJvcihcIlZhbHVlIGlzIG5vdCBhIHN0cmluZyBhbmQgY2Fubm90IGJlIGNvbnZlcnRlZCB0byBhIGRhdGVcIik7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSh2YWwpO1xuICAgIH1cblxuICAgIGJ1Y2tldHMoZGF0YSkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGVCdWNrZXQoZGF0YSk7XG4gICAgfVxufVxuXG5jbGFzcyBTY2FsZUlkZW50aXR5IHtcbiAgICB0cmFuc2Zvcm0odmFsKSB7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuXG4gICAgYnVja2V0cyhkYXRhKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29udGludW91c0J1Y2tldChkYXRhKTtcbiAgICB9XG59XG5cbmNsYXNzIFNjYWxlRGlzY3JldGUge1xuICAgIHRyYW5zZm9ybSh2YWwpIHtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG5cbiAgICBidWNrZXRzKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEaXNjcmV0ZUJ1Y2tldChkYXRhKTtcbiAgICB9XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlVGltZSgpIHtcbiAgICByZXR1cm4gbmV3IFNjYWxlVGltZSgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2NhbGVJZGVudGl0eSgpIHtcbiAgICByZXR1cm4gbmV3IFNjYWxlSWRlbnRpdHkoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlRGlzY3JldGUoKSB7XG4gICAgcmV0dXJuIG5ldyBTY2FsZURpc2NyZXRlKCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjaG9vc2VTY2FsZShleGFtcGxlVmFsdWUpIHtcbiAgICBpZiAoZXhhbXBsZVZhbHVlID09PSB1bmRlZmluZWQpIHRocm93IG5ldyBFcnJvcihcIk5vIHZhbHVlIHByb3ZpZGVkIGZvciBjaG9vc2VTY2FsZVwiKTtcbiAgICBpZiAoRGF0ZS5wYXJzZShleGFtcGxlVmFsdWUpKSByZXR1cm4gc2NhbGVUaW1lKCk7XG4gICAgaWYgKGV4YW1wbGVWYWx1ZSBpbnN0YW5jZW9mIERhdGUpIHJldHVybiBzY2FsZVRpbWUoKTtcbiAgICBpZiAodHlwZW9mIGV4YW1wbGVWYWx1ZSA9PT0gJ3N0cmluZycpIHJldHVybiBzY2FsZURpc2NyZXRlKCk7XG4gICAgaWYgKHR5cGVvZiBleGFtcGxlVmFsdWUgPT09ICdudW1iZXInKSByZXR1cm4gc2NhbGVJZGVudGl0eSgpO1xuXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGRldGVybWluZSB3YW50ZWQgc2NhbGUgZm9yIGV4YW1wbGUgdmFsdWUgW1wiICsgZXhhbXBsZVZhbHVlICsgXCJdXCIpO1xufSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/Scales.js\n");

/***/ }),

/***/ "./src/Statistics.js":
/*!***************************!*\
  !*** ./src/Statistics.js ***!
  \***************************/
/*! exports provided: freedmanDiaconis */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"freedmanDiaconis\", function() { return freedmanDiaconis; });\n/* harmony import */ var compute_iqr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! compute-iqr */ \"./node_modules/compute-iqr/lib/index.js\");\n/* harmony import */ var compute_iqr__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(compute_iqr__WEBPACK_IMPORTED_MODULE_0__);\n// Copyright (C) 2013-2014, 2018 BrandsEye (PTY) LTD\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this\n// software and associated documentation files (the \"Software\"), to deal in the Software\n// without restriction, including without limitation the rights to use, copy, modify,\n//     merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following\n// conditions:\n//\n//     The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n//     INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n// CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n\n/**\n * Calculates the number of buckets to split a real value domain\n * in to when calculating a histogram.\n *\n * https://en.wikipedia.org/wiki/Histogram\n *\n * @return {number}\n */\nfunction freedmanDiaconis(data) {\n    return 2 * compute_iqr__WEBPACK_IMPORTED_MODULE_0___default()(data) / Math.pow(data.length, 1/3);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvU3RhdGlzdGljcy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2IzanMvLi9zcmMvU3RhdGlzdGljcy5qcz9kNThlIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoQykgMjAxMy0yMDE0LCAyMDE4IEJyYW5kc0V5ZSAoUFRZKSBMVERcbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXNcbi8vIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZVxuLy8gd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LFxuLy8gICAgIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG9cbi8vIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nXG4vLyBjb25kaXRpb25zOlxuLy9cbi8vICAgICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbi8vIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gICAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1IgSU1QTElFRCxcbi8vICAgICBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQVxuLy8gUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxuLy8gSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GXG4vLyBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkVcbi8vIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5pbXBvcnQgaXFyIGZyb20gJ2NvbXB1dGUtaXFyJztcblxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIG51bWJlciBvZiBidWNrZXRzIHRvIHNwbGl0IGEgcmVhbCB2YWx1ZSBkb21haW5cbiAqIGluIHRvIHdoZW4gY2FsY3VsYXRpbmcgYSBoaXN0b2dyYW0uXG4gKlxuICogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSGlzdG9ncmFtXG4gKlxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJlZWRtYW5EaWFjb25pcyhkYXRhKSB7XG4gICAgcmV0dXJuIDIgKiBpcXIoZGF0YSkgLyBNYXRoLnBvdyhkYXRhLmxlbmd0aCwgMS8zKTtcbn0iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/Statistics.js\n");

/***/ }),

/***/ "./src/helpers.js":
/*!************************!*\
  !*** ./src/helpers.js ***!
  \************************/
/*! exports provided: maxBounding */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"maxBounding\", function() { return maxBounding; });\n// Copyright (C) 2013-2014, 2018 BrandsEye (PTY) LTD\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this\n// software and associated documentation files (the \"Software\"), to deal in the Software\n// without restriction, including without limitation the rights to use, copy, modify,\n//     merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following\n// conditions:\n//\n//     The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n//     INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n// CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n/**\n * Given an array of text, this places things in the DOM to figure out how\n * much pixel space the text takes up.\n */\nfunction maxBounding(selection, text, font, fontSize) {\n    // font = font || \"Open Sans, sans-serif\";\n    // fontSize = fontSize || \"12\";\n\n    let width = 0;\n    let height = 0;\n    selection.append(\"g\")\n            .attr(\"class\", \"text-size\")\n            .style(\"opacity\", 0)\n            .attr(\"transform\", \"translate(-100, -100)\")\n        .selectAll(\".text-measurement\")\n        .data(text)\n        .enter()\n        .append(\"text\")\n        .text(d => d)\n        .each((d, i, nodes) => {\n            let node = nodes[i];\n            let bb = node.getBBox();\n            width = Math.max(width, bb.width);\n            height = Math.max(height, bb.height)\n        });\n\n    selection.select(\".text-size\").remove();\n    return {\n        width: width,\n        height: height\n    }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaGVscGVycy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2IzanMvLi9zcmMvaGVscGVycy5qcz9kN2MyIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoQykgMjAxMy0yMDE0LCAyMDE4IEJyYW5kc0V5ZSAoUFRZKSBMVERcbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXNcbi8vIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZVxuLy8gd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LFxuLy8gICAgIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG9cbi8vIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nXG4vLyBjb25kaXRpb25zOlxuLy9cbi8vICAgICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbi8vIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gICAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1IgSU1QTElFRCxcbi8vICAgICBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQVxuLy8gUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxuLy8gSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GXG4vLyBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkVcbi8vIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5cbi8qKlxuICogR2l2ZW4gYW4gYXJyYXkgb2YgdGV4dCwgdGhpcyBwbGFjZXMgdGhpbmdzIGluIHRoZSBET00gdG8gZmlndXJlIG91dCBob3dcbiAqIG11Y2ggcGl4ZWwgc3BhY2UgdGhlIHRleHQgdGFrZXMgdXAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXhCb3VuZGluZyhzZWxlY3Rpb24sIHRleHQsIGZvbnQsIGZvbnRTaXplKSB7XG4gICAgLy8gZm9udCA9IGZvbnQgfHwgXCJPcGVuIFNhbnMsIHNhbnMtc2VyaWZcIjtcbiAgICAvLyBmb250U2l6ZSA9IGZvbnRTaXplIHx8IFwiMTJcIjtcblxuICAgIGxldCB3aWR0aCA9IDA7XG4gICAgbGV0IGhlaWdodCA9IDA7XG4gICAgc2VsZWN0aW9uLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJ0ZXh0LXNpemVcIilcbiAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMClcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKC0xMDAsIC0xMDApXCIpXG4gICAgICAgIC5zZWxlY3RBbGwoXCIudGV4dC1tZWFzdXJlbWVudFwiKVxuICAgICAgICAuZGF0YSh0ZXh0KVxuICAgICAgICAuZW50ZXIoKVxuICAgICAgICAuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgICAudGV4dChkID0+IGQpXG4gICAgICAgIC5lYWNoKChkLCBpLCBub2RlcykgPT4ge1xuICAgICAgICAgICAgbGV0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgICAgIGxldCBiYiA9IG5vZGUuZ2V0QkJveCgpO1xuICAgICAgICAgICAgd2lkdGggPSBNYXRoLm1heCh3aWR0aCwgYmIud2lkdGgpO1xuICAgICAgICAgICAgaGVpZ2h0ID0gTWF0aC5tYXgoaGVpZ2h0LCBiYi5oZWlnaHQpXG4gICAgICAgIH0pO1xuXG4gICAgc2VsZWN0aW9uLnNlbGVjdChcIi50ZXh0LXNpemVcIikucmVtb3ZlKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgIH1cbn1cblxuXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/helpers.js\n");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! exports provided: ColumnChart, BarChart, PieChart, LineChart, colours, chart, histogram, columnChart, line, points, scaleTime, scaleIdentity, scaleDiscrete, chooseScale */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _ColumnChart__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ColumnChart */ \"./src/ColumnChart.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ColumnChart\", function() { return _ColumnChart__WEBPACK_IMPORTED_MODULE_0__[\"ColumnChart\"]; });\n\n/* harmony import */ var _BarChart__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BarChart */ \"./src/BarChart.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"BarChart\", function() { return _BarChart__WEBPACK_IMPORTED_MODULE_1__[\"BarChart\"]; });\n\n/* harmony import */ var _PieChart__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./PieChart */ \"./src/PieChart.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"PieChart\", function() { return _PieChart__WEBPACK_IMPORTED_MODULE_2__[\"PieChart\"]; });\n\n/* harmony import */ var _LineChart__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./LineChart */ \"./src/LineChart.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"LineChart\", function() { return _LineChart__WEBPACK_IMPORTED_MODULE_3__[\"LineChart\"]; });\n\n/* harmony import */ var _Colours__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Colours */ \"./src/Colours.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"colours\", function() { return _Colours__WEBPACK_IMPORTED_MODULE_4__[\"colours\"]; });\n\n/* harmony import */ var _FantasticChart__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./FantasticChart */ \"./src/FantasticChart.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"chart\", function() { return _FantasticChart__WEBPACK_IMPORTED_MODULE_5__[\"chart\"]; });\n\n/* harmony import */ var _Histogram__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Histogram */ \"./src/Histogram.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"histogram\", function() { return _Histogram__WEBPACK_IMPORTED_MODULE_6__[\"histogram\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"columnChart\", function() { return _Histogram__WEBPACK_IMPORTED_MODULE_6__[\"columnChart\"]; });\n\n/* harmony import */ var _Line__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Line */ \"./src/Line.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"line\", function() { return _Line__WEBPACK_IMPORTED_MODULE_7__[\"line\"]; });\n\n/* harmony import */ var _Points__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Points */ \"./src/Points.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"points\", function() { return _Points__WEBPACK_IMPORTED_MODULE_8__[\"points\"]; });\n\n/* harmony import */ var _Scales__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Scales */ \"./src/Scales.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"scaleTime\", function() { return _Scales__WEBPACK_IMPORTED_MODULE_9__[\"scaleTime\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"scaleIdentity\", function() { return _Scales__WEBPACK_IMPORTED_MODULE_9__[\"scaleIdentity\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"scaleDiscrete\", function() { return _Scales__WEBPACK_IMPORTED_MODULE_9__[\"scaleDiscrete\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"chooseScale\", function() { return _Scales__WEBPACK_IMPORTED_MODULE_9__[\"chooseScale\"]; });\n\n// Copyright (C) 2013-2014, 2018 BrandsEye (PTY) LTD\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this\n// software and associated documentation files (the \"Software\"), to deal in the Software\n// without restriction, including without limitation the rights to use, copy, modify,\n//     merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following\n// conditions:\n//\n//     The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n//     INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n// CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n\n\n\n\n// For the Fantastic Chart\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9iM2pzLy4vc3JjL2luZGV4LmpzP2I2MzUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChDKSAyMDEzLTIwMTQsIDIwMTggQnJhbmRzRXllIChQVFkpIExURFxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpc1xuLy8gc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlXG4vLyB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksXG4vLyAgICAgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0b1xuLy8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcbi8vIGNvbmRpdGlvbnM6XG4vL1xuLy8gICAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuLy8gY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyAgICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUiBJTVBMSUVELFxuLy8gICAgIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBXG4vLyBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUXG4vLyBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0Zcbi8vIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRVxuLy8gT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbmV4cG9ydCB7IENvbHVtbkNoYXJ0IGFzIENvbHVtbkNoYXJ0IH0gZnJvbSAnLi9Db2x1bW5DaGFydCc7XG5leHBvcnQgeyBCYXJDaGFydCBhcyBCYXJDaGFydCB9IGZyb20gJy4vQmFyQ2hhcnQnO1xuZXhwb3J0IHsgUGllQ2hhcnQgYXMgUGllQ2hhcnQgfSBmcm9tICcuL1BpZUNoYXJ0JztcbmV4cG9ydCB7IExpbmVDaGFydCBhcyBMaW5lQ2hhcnQgfSBmcm9tICcuL0xpbmVDaGFydCc7XG5leHBvcnQgeyBjb2xvdXJzIH0gZnJvbSAnLi9Db2xvdXJzJztcblxuLy8gRm9yIHRoZSBGYW50YXN0aWMgQ2hhcnRcbmV4cG9ydCB7IGNoYXJ0IH0gZnJvbSAnLi9GYW50YXN0aWNDaGFydCc7XG5leHBvcnQgeyBoaXN0b2dyYW0sIGNvbHVtbkNoYXJ0IH0gZnJvbSAnLi9IaXN0b2dyYW0nO1xuZXhwb3J0IHsgbGluZSB9IGZyb20gJy4vTGluZSc7XG5leHBvcnQgeyBwb2ludHMgfSBmcm9tICcuL1BvaW50cyc7XG5leHBvcnQgeyBzY2FsZVRpbWUsIHNjYWxlSWRlbnRpdHksIHNjYWxlRGlzY3JldGUsIGNob29zZVNjYWxlIH0gZnJvbSAnLi9TY2FsZXMnOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/index.js\n");

/***/ })

/******/ });