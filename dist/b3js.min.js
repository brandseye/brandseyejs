var b3js=function(C){var A={};function t(I){if(A[I])return A[I].exports;var g=A[I]={i:I,l:!1,exports:{}};return C[I].call(g.exports,g,g.exports,t),g.l=!0,g.exports}return t.m=C,t.c=A,t.d=function(I,g,C){t.o(I,g)||Object.defineProperty(I,g,{enumerable:!0,get:C})},t.r=function(I){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(I,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(I,"__esModule",{value:!0})},t.t=function(g,I){if(1&I&&(g=t(g)),8&I)return g;if(4&I&&"object"==typeof g&&g&&g.__esModule)return g;var C=Object.create(null);if(t.r(C),Object.defineProperty(C,"default",{enumerable:!0,value:g}),2&I&&"string"!=typeof g)for(var A in g)t.d(C,A,function(I){return g[I]}.bind(null,A));return C},t.n=function(I){var g=I&&I.__esModule?function(){return I.default}:function(){return I};return t.d(g,"a",g),g},t.o=function(I,g){return Object.prototype.hasOwnProperty.call(I,g)},t.p="",t(t.s="./src/index.js")}({"./node_modules/compute-iqr/lib/index.js":
/*!***********************************************!*\
  !*** ./node_modules/compute-iqr/lib/index.js ***!
  \***********************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("/**\n*\n*\tCOMPUTE: iqr\n*\n*\n*\tDESCRIPTION:\n*\t\t- Computes the interquartile range for an array of values.\n*\n*\n*\tNOTES:\n*\t\t[1]\n*\n*\n*\tTODO:\n*\t\t[1]\n*\n*\n*\tLICENSE:\n*\t\tMIT\n*\n*\tCopyright (c) 2014. Athan Reines.\n*\n*\n*\tAUTHOR:\n*\t\tAthan Reines. kgryte@gmail.com. 2014.\n*\n*/\n\n\n\n// MODULES //\n\nvar isObject = __webpack_require__( /*! validate.io-object */ \"./node_modules/validate.io-object/lib/index.js\" ),\n\tquantile = __webpack_require__( /*! compute-quantile */ \"./node_modules/compute-quantile/lib/index.js\" );\n\n\n// FUNCTIONS //\n\n/**\n* FUNCTION: ascending( a, b )\n*\tComparator function used to sort values in ascending order.\n*\n* @private\n* @param {Number} a\n* @param {Number} b\n* @returns {Number} difference between `a` and `b`\n*/\nfunction ascending( a, b ) {\n\treturn a - b;\n} // end FUNCTION ascending()\n\n\n// INTERQUARTILE RANGE //\n\n/**\n* FUNCTION: iqr( arr )\n*\tComputes the interquartile range for an array.\n*\n* @param {Array} arr - array of values\n* @returns {Number} interquartile range\n*/\nfunction iqr( arr, opts ) {\n\tif ( !Array.isArray( arr ) ) {\n\t\tthrow new TypeError( 'iqr()::invalid input argument. Must provide an array.' );\n\t}\n\tif ( arguments.length > 1 ) {\n\t\tif ( !isObject( opts ) ) {\n\t\t\tthrow new TypeError( 'iqr()::invalid input argument. Options should be an object.' );\n\t\t}\n\t} else {\n\t\topts = {\n\t\t\t'sorted': false\n\t\t};\n\t}\n\tif ( !opts.sorted ) {\n\t\tarr = arr.slice();\n\t\tarr.sort( ascending );\n\t\topts.sorted = true;\n\t}\n\treturn quantile( arr, 0.75, opts ) - quantile( arr, 0.25, opts );\n} // end FUNCTION iqr()\n\n\n// EXPORTS //\n\nmodule.exports = iqr;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY29tcHV0ZS1pcXIvbGliL2luZGV4LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYjNqcy8uL25vZGVfbW9kdWxlcy9jb21wdXRlLWlxci9saWIvaW5kZXguanM/MDBhOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbipcbipcdENPTVBVVEU6IGlxclxuKlxuKlxuKlx0REVTQ1JJUFRJT046XG4qXHRcdC0gQ29tcHV0ZXMgdGhlIGludGVycXVhcnRpbGUgcmFuZ2UgZm9yIGFuIGFycmF5IG9mIHZhbHVlcy5cbipcbipcbipcdE5PVEVTOlxuKlx0XHRbMV1cbipcbipcbipcdFRPRE86XG4qXHRcdFsxXVxuKlxuKlxuKlx0TElDRU5TRTpcbipcdFx0TUlUXG4qXG4qXHRDb3B5cmlnaHQgKGMpIDIwMTQuIEF0aGFuIFJlaW5lcy5cbipcbipcbipcdEFVVEhPUjpcbipcdFx0QXRoYW4gUmVpbmVzLiBrZ3J5dGVAZ21haWwuY29tLiAyMDE0LlxuKlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBpc09iamVjdCA9IHJlcXVpcmUoICd2YWxpZGF0ZS5pby1vYmplY3QnICksXG5cdHF1YW50aWxlID0gcmVxdWlyZSggJ2NvbXB1dGUtcXVhbnRpbGUnICk7XG5cblxuLy8gRlVOQ1RJT05TIC8vXG5cbi8qKlxuKiBGVU5DVElPTjogYXNjZW5kaW5nKCBhLCBiIClcbipcdENvbXBhcmF0b3IgZnVuY3Rpb24gdXNlZCB0byBzb3J0IHZhbHVlcyBpbiBhc2NlbmRpbmcgb3JkZXIuXG4qXG4qIEBwcml2YXRlXG4qIEBwYXJhbSB7TnVtYmVyfSBhXG4qIEBwYXJhbSB7TnVtYmVyfSBiXG4qIEByZXR1cm5zIHtOdW1iZXJ9IGRpZmZlcmVuY2UgYmV0d2VlbiBgYWAgYW5kIGBiYFxuKi9cbmZ1bmN0aW9uIGFzY2VuZGluZyggYSwgYiApIHtcblx0cmV0dXJuIGEgLSBiO1xufSAvLyBlbmQgRlVOQ1RJT04gYXNjZW5kaW5nKClcblxuXG4vLyBJTlRFUlFVQVJUSUxFIFJBTkdFIC8vXG5cbi8qKlxuKiBGVU5DVElPTjogaXFyKCBhcnIgKVxuKlx0Q29tcHV0ZXMgdGhlIGludGVycXVhcnRpbGUgcmFuZ2UgZm9yIGFuIGFycmF5LlxuKlxuKiBAcGFyYW0ge0FycmF5fSBhcnIgLSBhcnJheSBvZiB2YWx1ZXNcbiogQHJldHVybnMge051bWJlcn0gaW50ZXJxdWFydGlsZSByYW5nZVxuKi9cbmZ1bmN0aW9uIGlxciggYXJyLCBvcHRzICkge1xuXHRpZiAoICFBcnJheS5pc0FycmF5KCBhcnIgKSApIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCAnaXFyKCk6OmludmFsaWQgaW5wdXQgYXJndW1lbnQuIE11c3QgcHJvdmlkZSBhbiBhcnJheS4nICk7XG5cdH1cblx0aWYgKCBhcmd1bWVudHMubGVuZ3RoID4gMSApIHtcblx0XHRpZiAoICFpc09iamVjdCggb3B0cyApICkge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvciggJ2lxcigpOjppbnZhbGlkIGlucHV0IGFyZ3VtZW50LiBPcHRpb25zIHNob3VsZCBiZSBhbiBvYmplY3QuJyApO1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRvcHRzID0ge1xuXHRcdFx0J3NvcnRlZCc6IGZhbHNlXG5cdFx0fTtcblx0fVxuXHRpZiAoICFvcHRzLnNvcnRlZCApIHtcblx0XHRhcnIgPSBhcnIuc2xpY2UoKTtcblx0XHRhcnIuc29ydCggYXNjZW5kaW5nICk7XG5cdFx0b3B0cy5zb3J0ZWQgPSB0cnVlO1xuXHR9XG5cdHJldHVybiBxdWFudGlsZSggYXJyLCAwLjc1LCBvcHRzICkgLSBxdWFudGlsZSggYXJyLCAwLjI1LCBvcHRzICk7XG59IC8vIGVuZCBGVU5DVElPTiBpcXIoKVxuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBpcXI7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/compute-iqr/lib/index.js\n")},"./node_modules/compute-quantile/lib/index.js":
/*!****************************************************!*\
  !*** ./node_modules/compute-quantile/lib/index.js ***!
  \****************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("/**\n*\n*\tCOMPUTE: quantile\n*\n*\n*\tDESCRIPTION:\n*\t\t- Computes a quantile for a numeric array.\n*\n*\n*\tNOTES:\n*\t\t[1]\n*\n*\n*\tTODO:\n*\t\t[1]\n*\n*\n*\tLICENSE:\n*\t\tMIT\n*\n*\tCopyright (c) 2014. Athan Reines.\n*\n*\n*\tAUTHOR:\n*\t\tAthan Reines. kgryte@gmail.com. 2014.\n*\n*/\n\n\n\n// MODULES //\n\nvar isObject = __webpack_require__( /*! validate.io-object */ \"./node_modules/validate.io-object/lib/index.js\" );\n\n\n// FUNCTIONS //\n\n/**\n* FUNCTION: ascending( a, b )\n*\tComparator function used to sort values in ascending order.\n*\n* @private\n* @param {Number} a\n* @param {Number} b\n* @returns {Number} difference between `a` and `b`\n*/\nfunction ascending( a, b ) {\n\treturn a - b;\n} // end FUNCTION ascending()\n\n\n// QUANTILE //\n\n/**\n* FUNCTION: quantile( arr, prob[, opts] )\n*\tComputes a quantile for a numeric array.\n*\n* @private\n* @param {Array} arr - 1d array\n* @param {Number} prob - quantile prob [0,1]\n* @param {Object} [opts] - method options:\n\t`method`: method used to interpolate a quantile value\n\t`sorted`: boolean flag indicating if the input array is sorted\n* @returns {Number} quantile value\n*/\nfunction quantile( arr, p, opts ) {\n\tif ( !Array.isArray( arr ) ) {\n\t\tthrow new TypeError( 'quantile()::invalid input argument. First argument must be an array.' );\n\t}\n\tif ( typeof p !== 'number' || p !== p ) {\n\t\tthrow new TypeError( 'quantile()::invalid input argument. Quantile probability must be numeric.' );\n\t}\n\tif ( p < 0 || p > 1 ) {\n\t\tthrow new TypeError( 'quantile()::invalid input argument. Quantile probability must be on the interval [0,1].' );\n\t}\n\tif ( arguments.length > 2 ) {\n\t\tif ( !isObject( opts ) ) {\n\t\t\tthrow new TypeError( 'quantile()::invalid input argument. Options must be an object.' );\n\t\t}\n\t\tif ( opts.hasOwnProperty( 'sorted' ) && typeof opts.sorted !== 'boolean' ) {\n\t\t\tthrow new TypeError( 'quantile()::invalid input argument. Sorted flag must be a boolean.' );\n\t\t}\n\t\tif ( opts.hasOwnProperty( 'method' ) && typeof opts.method !== 'string' ) {\n\t\t\tthrow new TypeError( 'quantile()::invalid input argument. Method must be a string.' );\n\t\t}\n\t\t// TODO: validate that the requested method is supported. list.indexOf( method )\n\t} else {\n\t\topts = {};\n\t}\n\tvar len = arr.length,\n\t\tid;\n\n\tif ( !opts.sorted ) {\n\t\tarr = arr.slice();\n\t\tarr.sort( ascending );\n\t}\n\n\t// Cases...\n\n\t// [0] 0th percentile is the minimum value...\n\tif ( p === 0.0 ) {\n\t\treturn arr[ 0 ];\n\t}\n\t// [1] 100th percentile is the maximum value...\n\tif ( p === 1.0 ) {\n\t\treturn arr[ len-1 ];\n\t}\n\t// Calculate the vector index marking the quantile:\n\tid = ( len*p ) - 1;\n\n\t// [2] Is the index an integer?\n\tif ( id === Math.floor( id ) ) {\n\t\t// Value is the average between the value at id and id+1:\n\t\treturn ( arr[ id ] + arr[ id+1 ] ) / 2.0;\n\t}\n\t// [3] Round up to the next index:\n\tid = Math.ceil( id );\n\treturn arr[ id ];\n} // end FUNCTION quantile()\n\n\n// EXPORTS //\n\nmodule.exports = quantile;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY29tcHV0ZS1xdWFudGlsZS9saWIvaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9iM2pzLy4vbm9kZV9tb2R1bGVzL2NvbXB1dGUtcXVhbnRpbGUvbGliL2luZGV4LmpzP2FhZjciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4qXG4qXHRDT01QVVRFOiBxdWFudGlsZVxuKlxuKlxuKlx0REVTQ1JJUFRJT046XG4qXHRcdC0gQ29tcHV0ZXMgYSBxdWFudGlsZSBmb3IgYSBudW1lcmljIGFycmF5LlxuKlxuKlxuKlx0Tk9URVM6XG4qXHRcdFsxXVxuKlxuKlxuKlx0VE9ETzpcbipcdFx0WzFdXG4qXG4qXG4qXHRMSUNFTlNFOlxuKlx0XHRNSVRcbipcbipcdENvcHlyaWdodCAoYykgMjAxNC4gQXRoYW4gUmVpbmVzLlxuKlxuKlxuKlx0QVVUSE9SOlxuKlx0XHRBdGhhbiBSZWluZXMuIGtncnl0ZUBnbWFpbC5jb20uIDIwMTQuXG4qXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSggJ3ZhbGlkYXRlLmlvLW9iamVjdCcgKTtcblxuXG4vLyBGVU5DVElPTlMgLy9cblxuLyoqXG4qIEZVTkNUSU9OOiBhc2NlbmRpbmcoIGEsIGIgKVxuKlx0Q29tcGFyYXRvciBmdW5jdGlvbiB1c2VkIHRvIHNvcnQgdmFsdWVzIGluIGFzY2VuZGluZyBvcmRlci5cbipcbiogQHByaXZhdGVcbiogQHBhcmFtIHtOdW1iZXJ9IGFcbiogQHBhcmFtIHtOdW1iZXJ9IGJcbiogQHJldHVybnMge051bWJlcn0gZGlmZmVyZW5jZSBiZXR3ZWVuIGBhYCBhbmQgYGJgXG4qL1xuZnVuY3Rpb24gYXNjZW5kaW5nKCBhLCBiICkge1xuXHRyZXR1cm4gYSAtIGI7XG59IC8vIGVuZCBGVU5DVElPTiBhc2NlbmRpbmcoKVxuXG5cbi8vIFFVQU5USUxFIC8vXG5cbi8qKlxuKiBGVU5DVElPTjogcXVhbnRpbGUoIGFyciwgcHJvYlssIG9wdHNdIClcbipcdENvbXB1dGVzIGEgcXVhbnRpbGUgZm9yIGEgbnVtZXJpYyBhcnJheS5cbipcbiogQHByaXZhdGVcbiogQHBhcmFtIHtBcnJheX0gYXJyIC0gMWQgYXJyYXlcbiogQHBhcmFtIHtOdW1iZXJ9IHByb2IgLSBxdWFudGlsZSBwcm9iIFswLDFdXG4qIEBwYXJhbSB7T2JqZWN0fSBbb3B0c10gLSBtZXRob2Qgb3B0aW9uczpcblx0YG1ldGhvZGA6IG1ldGhvZCB1c2VkIHRvIGludGVycG9sYXRlIGEgcXVhbnRpbGUgdmFsdWVcblx0YHNvcnRlZGA6IGJvb2xlYW4gZmxhZyBpbmRpY2F0aW5nIGlmIHRoZSBpbnB1dCBhcnJheSBpcyBzb3J0ZWRcbiogQHJldHVybnMge051bWJlcn0gcXVhbnRpbGUgdmFsdWVcbiovXG5mdW5jdGlvbiBxdWFudGlsZSggYXJyLCBwLCBvcHRzICkge1xuXHRpZiAoICFBcnJheS5pc0FycmF5KCBhcnIgKSApIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCAncXVhbnRpbGUoKTo6aW52YWxpZCBpbnB1dCBhcmd1bWVudC4gRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhbiBhcnJheS4nICk7XG5cdH1cblx0aWYgKCB0eXBlb2YgcCAhPT0gJ251bWJlcicgfHwgcCAhPT0gcCApIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCAncXVhbnRpbGUoKTo6aW52YWxpZCBpbnB1dCBhcmd1bWVudC4gUXVhbnRpbGUgcHJvYmFiaWxpdHkgbXVzdCBiZSBudW1lcmljLicgKTtcblx0fVxuXHRpZiAoIHAgPCAwIHx8IHAgPiAxICkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoICdxdWFudGlsZSgpOjppbnZhbGlkIGlucHV0IGFyZ3VtZW50LiBRdWFudGlsZSBwcm9iYWJpbGl0eSBtdXN0IGJlIG9uIHRoZSBpbnRlcnZhbCBbMCwxXS4nICk7XG5cdH1cblx0aWYgKCBhcmd1bWVudHMubGVuZ3RoID4gMiApIHtcblx0XHRpZiAoICFpc09iamVjdCggb3B0cyApICkge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvciggJ3F1YW50aWxlKCk6OmludmFsaWQgaW5wdXQgYXJndW1lbnQuIE9wdGlvbnMgbXVzdCBiZSBhbiBvYmplY3QuJyApO1xuXHRcdH1cblx0XHRpZiAoIG9wdHMuaGFzT3duUHJvcGVydHkoICdzb3J0ZWQnICkgJiYgdHlwZW9mIG9wdHMuc29ydGVkICE9PSAnYm9vbGVhbicgKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCAncXVhbnRpbGUoKTo6aW52YWxpZCBpbnB1dCBhcmd1bWVudC4gU29ydGVkIGZsYWcgbXVzdCBiZSBhIGJvb2xlYW4uJyApO1xuXHRcdH1cblx0XHRpZiAoIG9wdHMuaGFzT3duUHJvcGVydHkoICdtZXRob2QnICkgJiYgdHlwZW9mIG9wdHMubWV0aG9kICE9PSAnc3RyaW5nJyApIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoICdxdWFudGlsZSgpOjppbnZhbGlkIGlucHV0IGFyZ3VtZW50LiBNZXRob2QgbXVzdCBiZSBhIHN0cmluZy4nICk7XG5cdFx0fVxuXHRcdC8vIFRPRE86IHZhbGlkYXRlIHRoYXQgdGhlIHJlcXVlc3RlZCBtZXRob2QgaXMgc3VwcG9ydGVkLiBsaXN0LmluZGV4T2YoIG1ldGhvZCApXG5cdH0gZWxzZSB7XG5cdFx0b3B0cyA9IHt9O1xuXHR9XG5cdHZhciBsZW4gPSBhcnIubGVuZ3RoLFxuXHRcdGlkO1xuXG5cdGlmICggIW9wdHMuc29ydGVkICkge1xuXHRcdGFyciA9IGFyci5zbGljZSgpO1xuXHRcdGFyci5zb3J0KCBhc2NlbmRpbmcgKTtcblx0fVxuXG5cdC8vIENhc2VzLi4uXG5cblx0Ly8gWzBdIDB0aCBwZXJjZW50aWxlIGlzIHRoZSBtaW5pbXVtIHZhbHVlLi4uXG5cdGlmICggcCA9PT0gMC4wICkge1xuXHRcdHJldHVybiBhcnJbIDAgXTtcblx0fVxuXHQvLyBbMV0gMTAwdGggcGVyY2VudGlsZSBpcyB0aGUgbWF4aW11bSB2YWx1ZS4uLlxuXHRpZiAoIHAgPT09IDEuMCApIHtcblx0XHRyZXR1cm4gYXJyWyBsZW4tMSBdO1xuXHR9XG5cdC8vIENhbGN1bGF0ZSB0aGUgdmVjdG9yIGluZGV4IG1hcmtpbmcgdGhlIHF1YW50aWxlOlxuXHRpZCA9ICggbGVuKnAgKSAtIDE7XG5cblx0Ly8gWzJdIElzIHRoZSBpbmRleCBhbiBpbnRlZ2VyP1xuXHRpZiAoIGlkID09PSBNYXRoLmZsb29yKCBpZCApICkge1xuXHRcdC8vIFZhbHVlIGlzIHRoZSBhdmVyYWdlIGJldHdlZW4gdGhlIHZhbHVlIGF0IGlkIGFuZCBpZCsxOlxuXHRcdHJldHVybiAoIGFyclsgaWQgXSArIGFyclsgaWQrMSBdICkgLyAyLjA7XG5cdH1cblx0Ly8gWzNdIFJvdW5kIHVwIHRvIHRoZSBuZXh0IGluZGV4OlxuXHRpZCA9IE1hdGguY2VpbCggaWQgKTtcblx0cmV0dXJuIGFyclsgaWQgXTtcbn0gLy8gZW5kIEZVTkNUSU9OIHF1YW50aWxlKClcblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gcXVhbnRpbGU7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/compute-quantile/lib/index.js\n")},"./node_modules/validate.io-array/lib/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/validate.io-array/lib/index.js ***!
  \*****************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\n\n/**\n* FUNCTION: isArray( value )\n*\tValidates if a value is an array.\n*\n* @param {*} value - value to be validated\n* @returns {Boolean} boolean indicating whether value is an array\n*/\nfunction isArray( value ) {\n\treturn Object.prototype.toString.call( value ) === '[object Array]';\n} // end FUNCTION isArray()\n\n// EXPORTS //\n\nmodule.exports = Array.isArray || isArray;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdmFsaWRhdGUuaW8tYXJyYXkvbGliL2luZGV4LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYjNqcy8uL25vZGVfbW9kdWxlcy92YWxpZGF0ZS5pby1hcnJheS9saWIvaW5kZXguanM/NjMzNyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKlxuKiBGVU5DVElPTjogaXNBcnJheSggdmFsdWUgKVxuKlx0VmFsaWRhdGVzIGlmIGEgdmFsdWUgaXMgYW4gYXJyYXkuXG4qXG4qIEBwYXJhbSB7Kn0gdmFsdWUgLSB2YWx1ZSB0byBiZSB2YWxpZGF0ZWRcbiogQHJldHVybnMge0Jvb2xlYW59IGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHZhbHVlIGlzIGFuIGFycmF5XG4qL1xuZnVuY3Rpb24gaXNBcnJheSggdmFsdWUgKSB7XG5cdHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoIHZhbHVlICkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59IC8vIGVuZCBGVU5DVElPTiBpc0FycmF5KClcblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgaXNBcnJheTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/validate.io-array/lib/index.js\n")},"./node_modules/validate.io-object/lib/index.js":
/*!******************************************************!*\
  !*** ./node_modules/validate.io-object/lib/index.js ***!
  \******************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\n\n// MODULES //\n\nvar isArray = __webpack_require__( /*! validate.io-array */ \"./node_modules/validate.io-array/lib/index.js\" );\n\n\n// ISOBJECT //\n\n/**\n* FUNCTION: isObject( value )\n*\tValidates if a value is a object; e.g., {}.\n*\n* @param {*} value - value to be validated\n* @returns {Boolean} boolean indicating whether value is a object\n*/\nfunction isObject( value ) {\n\treturn ( typeof value === 'object' && value !== null && !isArray( value ) );\n} // end FUNCTION isObject()\n\n\n// EXPORTS //\n\nmodule.exports = isObject;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdmFsaWRhdGUuaW8tb2JqZWN0L2xpYi9pbmRleC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2IzanMvLi9ub2RlX21vZHVsZXMvdmFsaWRhdGUuaW8tb2JqZWN0L2xpYi9pbmRleC5qcz8yMjlmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLy8gTU9EVUxFUyAvL1xuXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoICd2YWxpZGF0ZS5pby1hcnJheScgKTtcblxuXG4vLyBJU09CSkVDVCAvL1xuXG4vKipcbiogRlVOQ1RJT046IGlzT2JqZWN0KCB2YWx1ZSApXG4qXHRWYWxpZGF0ZXMgaWYgYSB2YWx1ZSBpcyBhIG9iamVjdDsgZS5nLiwge30uXG4qXG4qIEBwYXJhbSB7Kn0gdmFsdWUgLSB2YWx1ZSB0byBiZSB2YWxpZGF0ZWRcbiogQHJldHVybnMge0Jvb2xlYW59IGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHZhbHVlIGlzIGEgb2JqZWN0XG4qL1xuZnVuY3Rpb24gaXNPYmplY3QoIHZhbHVlICkge1xuXHRyZXR1cm4gKCB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsICYmICFpc0FycmF5KCB2YWx1ZSApICk7XG59IC8vIGVuZCBGVU5DVElPTiBpc09iamVjdCgpXG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/validate.io-object/lib/index.js\n")},"./src/BarChart.js":
/*!*************************!*\
  !*** ./src/BarChart.js ***!
  \*************************/
/*! exports provided: BarChart */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BarChart", function() { return BarChart; });\n/* harmony import */ var _Colours__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Colours */ "./src/Colours.js");\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers */ "./src/helpers.js");\n/* harmony import */ var _Chart__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Chart */ "./src/Chart.js");\n// Copyright (C) 2013-2014, 2018 BrandsEye (PTY) LTD\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this\n// software and associated documentation files (the "Software"), to deal in the Software\n// without restriction, including without limitation the rights to use, copy, modify,\n//     merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following\n// conditions:\n//\n//     The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n//     INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n// CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n\n\n\n\nclass BarChart extends _Chart__WEBPACK_IMPORTED_MODULE_2__["Chart"] {\n\n    //------------------------------------------------------\n\n    data(data) {\n        if (!arguments.length) return this._data;\n        if (data && data[0].key === undefined) {\n            data = [\n                {\n                    key: "series 1",\n                    values: data\n                }\n            ];\n        }\n        this._data = data;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    element(element) {\n        if (!arguments.length) return this._element;\n        this._element = element;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    showLabels(show) {\n        if (!arguments.length) return this._show_labels;\n        this._show_labels = show;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    // todo dispatch\n    showLegend(show) {\n        if (!arguments.length) return this._show_legend;\n        this._show_legend = show;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    x(x) {\n        if (!arguments.length) return this._x;\n        this._x = x;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    y(y) {\n        if (!arguments.length) return this._y;\n        this._y = y;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    width(width) {\n        if (!arguments.length) return this._width;\n        this._width = width;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    height(height) {\n        if (!arguments.length) return this._height;\n        this._height = height;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    colours(colours) {\n        if (!arguments.length) return this._colours;\n        this._colours = colours;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    backgroundColour(colour) {\n        if (!arguments.length) return this._backgroundColour;\n        this._backgroundColour = colour || "#FFF"; // never set it to null.\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    tickFormat(format) {\n        if (!arguments.length) return this._tickFormat;\n        this._tickFormat = format;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    xAxisTickFormat(format) {\n        if (!arguments.length) return this._xAxisTickFormat;\n        this._xAxisTickFormat = format || (d => d.toString());\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    labelFormat(format) {\n        if (!arguments.length) return this._labelFormat;\n        this._labelFormat = format || (d => d.toString());\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    // todo missing\n    labelCompression(compression) {\n        if (!arguments.length) return this._compression;\n        this._compression = compression;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    //todo missing\n    dataAxisLabel(label) {\n        if (!arguments.length) return this._dataAxisLabel;\n        this._dataAxisLabel = label;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    tooltip(tooltip) {\n        if (!arguments.length) return this._tooltip;\n        this._tooltip = tooltip;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    forceY(force) {\n        if (!arguments.length) return this._forceY;\n        this._forceY = force;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n// todo missing\n    duration(duration) {\n        if (!arguments.length) return this._duration;\n        this._duration = duration;\n        return this;\n    }\n\n// todo missing\n    coarseness(coarseness) {\n        if (!arguments.length) return this._coarseness;\n        this._coarseness = coarseness;\n        return this;\n    }\n\n    // todo missing\n    padding(padding) {\n        if (!arguments.length) return this._padding;\n        this._padding = padding;\n        return this;\n    }\n\n    // todo missing\n    xAxisTooltips(tooltips) {\n        if (!arguments.length) return this._xAxisTooltips;\n        this._xAxisTooltips = tooltips;\n        return this;\n    }\n\n    xAxisOverride(override) {\n        if (!arguments.length) return this._xAxisOverride;\n        this._xAxisOverride = override;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    dispatch() {\n        return this._dispatch;\n    }\n\n    //------------------------------------------------------\n\n    render() {\n        if (!this._element) throw new Error("No element set for ColumnChart. See #element()");\n        if (!this._data) {\n            console.warn("No data set for ColumnChart. See #data()");\n            return;\n        }\n\n        const data = this.getTransformedData();\n        const keys = this.getKeys();\n\n        //------------------------------------------------\n        // Set up the SVG area\n\n        let topLevel = d3.select(this._element).select("svg");\n        if (topLevel.empty()) topLevel = d3.select(this._element).append("svg")\n\n        topLevel\n            .style("width", this._width + "px")\n            .style("height", this._height + "px");\n\n\n        // ---------------------------------\n        // Measure max data axis text length\n\n        const dataAxisBB = Object(_helpers__WEBPACK_IMPORTED_MODULE_1__["maxBounding"])(topLevel, data.map(d => this._xAxisTickFormat(d.key)));\n\n        // ---------------------------------\n        // Layout the showLegend.\n        //\n        // We do this now because we need to know how much space the legend\n        // takes up in order to finish calculating the margins.\n\n        const legendHeight = this.renderLegend();\n\n        //----------------------------------\n        // Calculate margins.\n\n        const margin = {top: 20, right: 20, bottom: 40, left: 10};\n        margin.bottom += legendHeight ? legendHeight + 20 : 0;\n        margin.left += dataAxisBB.width + 10;\n        if (this._dataAxisLabel) margin.bottom += 10 + 12;\n\n        const width = this._width - margin.left - margin.right,\n              height = this._height - margin.top - margin.bottom;\n\n        //----------------------------------\n        // Calculate scales and so on.\n\n        const x = d3.scaleLinear()\n            .rangeRound([0, width])\n            .nice();\n\n        const y = d3.scaleBand()\n            .rangeRound([0, height])\n            .padding(this._data.length > 1 ? 0.08 : 0.1);\n\n        const yGroup = d3.scaleBand()\n            .padding(0);\n\n        this._xscale = x;\n        this._ygroupscale = yGroup;\n        this._yscale = y;\n\n        // Scale the range of the data in the domains\n        y.domain(data.map(d => d.key));\n        yGroup.rangeRound([0, y.bandwidth()]).domain(keys);\n        x.domain([0, d3.max(data, d => d3.max(d.data, d => d._y))]);\n\n        //------------------------------\n\n        let svg = topLevel.select(\'.main-group\');\n\n        if (svg.empty()) {\n            svg = topLevel\n                .append("g")\n                .attr("class", "main-group")\n        }\n\n        svg.attr("transform", "translate(" + margin.left + "," + margin.top + ")");\n\n        //---------------------------------\n        // Get rid of current labels.\n        svg.select(".chart-labels")\n            .remove();\n\n        //---------------------------------\n        // append the rectangles for the bar chart\n        let groups = svg.select(".bars").selectAll(\'.group\');\n\n        if (groups.empty()) {\n            groups = svg\n                .append("g")\n                .attr("class", "bars")\n                .selectAll(".group");\n        }\n\n        groups = groups.data(data);\n\n        groups.exit().remove();\n\n        // Adding new groups, and hence adding new bars to those groups.\n        groups.enter()\n            .append("g")\n                .attr("class", "group")\n                .attr("transform", d => "translate(0," + y(d.key) + ")")\n                .attr("height", height - y.bandwidth())\n                .attr("width", "100%")\n            .merge(groups)\n            .interrupt("groups:move")\n            .transition("groups:move")\n                .attr("transform", d => "translate(0," + y(d.key) + ")")\n                .attr("height", y.bandwidth())\n            .each((s_d, s_i, nodes) => {\n                let group = d3.select(nodes[s_i]);\n\n                let bars = group.selectAll(".bar")\n                    .data(s_d.data);\n\n                bars.exit().remove();\n\n                bars.interrupt("bar:move")     // Animate the bars to their new position.\n                    .transition("bar:move")\n                        .attr("height", yGroup.bandwidth())\n                        .attr("y", d => yGroup(d._key))\n                        .attr("x", 0);\n\n                bars.enter()\n                    .append("rect")\n                        .attr("class", (d, i) => "bar series series-" + i)\n                        .attr("y", d => yGroup(d._key))\n                        .attr("x", 0)\n                        .attr("height", yGroup.bandwidth())\n                        .attr("width", 0)\n                        .style("fill", (d, i) => this.getSeriesColour(i))\n                        .style("cursor", "pointer")\n                    .on("mouseover", (d, i, nodes) => { // Darken the bar on mouse over\n                        d3.select(nodes[i])\n                            .interrupt("hover:colour")\n                            .transition("hover:colour")\n                            .duration(400)\n                            .style("fill", d3.hcl(this.getSeriesColour(i)).darker())\n                        this._dispatch.call("tooltipShow", this, {\n                            e: d3.event,\n                            point: d,\n                            series: s_d,\n                            seriesIndex: s_i,\n                            value: d._y\n                        })\n                    })\n                    .on("mouseout", (d, i, nodes) => { // bar is regular colour on mouse out.\n                        d3.select(nodes[i])\n                            .interrupt("hover:colour")\n                            .transition("hover:colour")\n                            .duration(400)\n                            .style("fill", this.getSeriesColour(i));\n                        this._dispatch.call("tooltipHide", this);\n                    })\n                    .on("click auxclick", (d, i, nodes) => {\n                        this._dispatch.call("elementClick", this, {\n                            e: d3.event,\n                            point: d,\n                            series: d._series,\n                            seriesIndex: s_i,\n                            value: this._y(d)\n                        })\n                    })\n                    .merge(bars)\n                    .interrupt("bar:growth")    // Animate bars growing.\n                    .transition("bar:growth")\n                    .delay(() => {\n                        return this.calcBarGrowth(s_i, nodes.length);\n                    })\n                    .duration(this._duration)\n                        .style("fill", (d, i) => this.getSeriesColour(i))\n                        .attr("width", d => x(d._y));\n\n            });\n\n        // ---------------------------------\n        // Labels loaded after our first bar grows.\n        if (this._show_labels) {\n            svg.transition("bar:growth")\n                .on("end", (d, i, nodes) => {\n                    if (i < nodes.length - 1) return;\n                    this.renderLabels(svg, data, x, yGroup, y);\n                })\n        }\n\n        // ---------------------------------\n        // Draw the data axis data label.\n\n        if (this._dataAxisLabel) {\n            this.renderDataAxisLabel(width, margin);\n        }\n\n        // ---------------------------------\n        // Set the background colour\n\n        d3.select(this._element).select(".background").remove();\n        if (this._backgroundColour) {\n            d3.select(this._element).select("svg")\n                .append("rect")\n                    .attr("class", "background")\n                    .attr("width", "100%")\n                    .attr("height", "100%")\n                    .style("fill", this._backgroundColour)\n                .lower();\n        }\n\n        //---------------------------------\n        // add the Y gridlines\n        svg.call(this.grid, height, d3.axisBottom(x).ticks(5));\n\n        //---------------------------------\n        // axes\n        svg.call(this.labelAxis, d3.axisLeft(y).tickSize(0).tickPadding(5).tickFormat(this._xAxisTickFormat));\n        svg.call(this.dataAxis, height, d3.axisBottom(x).ticks(5).tickFormat(this._tickFormat));\n    }\n\n    //------------------------------------------------------\n\n    /*\n     * Returns an object with two functions, #show() and #hide(),\n     * to show and hide the labels.\n     */\n    labels() {\n        return {\n\n            show: () => {\n                if (this._element) {\n                    let selection = this._element,\n                        data = this.getTransformedData(),\n                        xscale = this._xscale,\n                        ygroup = this._ygroupscale,\n                        yscale = this._yscale;\n\n                    if (selection) selection = d3.select(this._element).select("svg").select("g");\n                    if (!selection.empty() && data && xscale && yscale && ygroup) {\n                        let labels = selection.select(\'.chart-labels\');\n                        if (!labels.empty()) return;\n                        labels.remove()\n                        this.renderLabels(selection, data, xscale, ygroup, yscale, false);\n                    }\n                }\n\n            },\n\n            hide: () => {\n                if (this._element) {\n                    d3.select(this._element)\n                        .select(\'.chart-labels\')\n                        .interrupt("labels")\n                        .interrupt("labels:fade")\n                        .transition("labels:fade")\n                        .style("opacity", 0)\n                        .on("end", (d, i, nodes) => {\n                            d3.select(nodes[i]).remove();\n                        })\n                }\n            }\n        }\n    }\n\n    //------------------------------------------------------\n\n    renderLabels(selection, data, xscale, ygroup, yscale, animate) {\n        animate = animate === undefined ? true : animate;\n        selection.selectAll(".chart-labels").remove();\n\n        let labels = selection.append("g")\n            .attr("class", "chart-labels")\n            .selectAll(".label-group")\n            .data(data);\n\n        let fontSize = this._font_size;    // Our initial font size.\n        const buffer = 5;     // Buffer space between words and the top of a bar.\n\n        labels.enter().each((series, s_i, s_nodes) => {\n            let group = d3.select(s_nodes[s_i])\n                .append("g")\n                .attr("class", "label-group")\n                .attr("transform", d => "translate(0," + yscale(d.key) + ")")\n                .selectAll(".chart-label")\n                .data(series.data)\n                .enter()\n                .each((d, i, nodes) => {\n\n                    // Want to figure out if the label is too dark / light for the\n                    // bar.\n                    let invertedColor = d3.hcl(this.getSeriesColour(i));\n                    invertedColor.l += Math.min(invertedColor.l + 50, 100);\n                    let invert = d3.hcl(this.getSeriesColour(i)).l < 60;\n\n                    let xpos = xscale(d._y);\n\n                    let text = d3.select(nodes[i])\n                        .append("text")\n                        .text(this._labelFormat(d._y))\n                            .attr("class", "chart-label")\n                            .attr("x", xpos + buffer)\n                            .attr("dx", animate ? -15 : 0)\n                            .style("opacity", 0)\n                            .style("pointer-events", "none")\n                            .style("font-size", fontSize + "px");\n\n\n                    const bb = text.node().getBBox();\n                    const oversize = xpos + bb.width + buffer > xscale.range()[1];\n\n                    text\n                        .attr("y", ygroup(d._key) + fontSize / 2 + ygroup.bandwidth() / 2)\n                        .attr("x", oversize ? xpos - buffer - bb.width : xpos + buffer)\n                        .style("fill", oversize && invert ? invertedColor.toString() : _Colours__WEBPACK_IMPORTED_MODULE_0__["colours"].eighteen.darkGrey);\n\n                    text\n                        .transition("labels")\n                        .delay(() => animate ? this.calcBarGrowth(s_i, s_nodes.length) : 0) // Delay in lockstep with bar growth.\n                        .duration(this._duration)\n                        .attr("dx", 0)\n                        .style("opacity", 1)\n                })\n        });\n\n    }\n\n    //------------------------------------------------------\n\n    renderDataAxisLabel(width, margins) {\n        let svg = d3.select(this._element).select(\'svg\');\n        svg.selectAll(".data-labels").remove();\n\n        if (!this._dataAxisLabel) return;\n        let text = this._dataAxisLabel;\n        if (text.long) text = text.long;\n\n        let x = (margins.left + width / 2);\n\n        let label = svg.append("g")\n            .attr("class", "data-labels")\n            .append("text")\n            .text(text)\n            .attr("transform", "translate(" + x + "," + (this._height - margins.bottom + 50) + ")")\n            .style("fill", _Colours__WEBPACK_IMPORTED_MODULE_0__["colours"].eighteen.darkGrey);\n\n        let textWidth = label.node().getBBox().width;\n        if (textWidth >= width && this._dataAxisLabel.short) {\n            label.text(this._dataAxisLabel.short);\n            textWidth = label.node().getBBox().width;\n        }\n\n        label.attr("dx", -textWidth / 2);\n    }\n\n    //------------------------------------------------------\n\n\n\n    grid(selection, height, axis) {\n        selection.select(".grid").remove();\n\n        let grid = selection.append("g")\n            .attr("class", "grid")\n            .call(axis\n                .tickSize(height)\n                .tickFormat("")\n            );\n\n        grid.selectAll("line")\n            .style("stroke", _Colours__WEBPACK_IMPORTED_MODULE_0__["colours"].eighteen.lightGrey);\n        grid.selectAll(".domain").remove();\n\n        grid\n            .lower() // Always ensure that this is earlier in the dom. Things must be drawn on top of it.\n            .style("opacity", 0)\n            .transition()\n            .delay(500)\n            .duration(500)\n            .style("opacity", 1);\n    }\n\n    //------------------------------------------------------\n\n    labelAxis(selection, axis_object) {\n        selection.select(".label-axis").remove();\n        let axis = selection.append("g")\n            .attr("class", "label-axis")\n            .style("opacity", 0)\n            .call(axis_object);\n\n        axis.select(".domain").remove();\n\n        let max = 0;\n        axis.selectAll("text")\n            .style("font-size", this._font_size + "px")\n            .style("fill", _Colours__WEBPACK_IMPORTED_MODULE_0__["colours"].eighteen.darkGrey)\n            .nodes()\n            .forEach(text => max = Math.max(max, text.getBBox().width));\n\n        axis\n            .transition()\n            .duration(1000)\n            .style("opacity", 1);\n    }\n\n    //------------------------------------------------------\n\n    dataAxis(selection, height, axis_object) {\n        selection.select(".data-axis").remove();\n        let axis = selection.append("g")\n                .attr("class", "data-axis")\n                .attr("transform", "translate(0," + height + ")")\n            .call(axis_object.tickSize(0).tickPadding(10))\n                .style("opacity", 0)\n            .transition()\n            .duration(1000)\n                .style("opacity", 1);\n\n        axis.selectAll("text")\n                .style("fill", _Colours__WEBPACK_IMPORTED_MODULE_0__["colours"].eighteen.darkGrey)\n    }\n\n    //------------------------------------------------------\n\n    calcBarGrowth(i, max) {\n        if (max < 10) return i * this._BAR_GROWTH / 2;\n        if (max < 35) return i * this._BAR_GROWTH / 4;\n        return 1;\n    }\n\n    getSeriesColour(i) {\n        if (i < 0 || !this._colours) return _Colours__WEBPACK_IMPORTED_MODULE_0__["colours"].eighteen.midGrey;\n\n        i = i % this._colours.length;\n        return this._colours[i];\n    }\n\n    getSortedData() {\n        let data = this._data;\n        if (!data || !data.length) return [];\n\n        data = this._data.sort((lhs, rhs) => {\n            lhs = lhs.key.toLowerCase();\n            rhs = rhs.key.toLowerCase();\n\n            if (lhs === rhs) return 0;\n            if (lhs < rhs) return -1;\n            return 1;\n        });\n\n        return data;\n    }\n\n    getTransformedData() {\n        let data = this.getSortedData();\n        if (!data || !data.length) return [];\n\n        let results = [];\n\n        const getX = d => this._xAxisOverride ? this._xAxisOverride[this._x(d)] : this._x(d);\n\n        data.forEach((series, s_i) => {\n            series.values.forEach((d, d_i) => {\n                let field = results.find(bucket => bucket.key === getX(d));\n                if (!field) {\n                    field = {\n                        data: [],\n                        key: getX(d)\n                    };\n                    results.push(field);\n                }\n\n                field.data.push(Object.assign({\n                    _series: series,\n                    _s_i: s_i,\n                    _key: series.key,\n                    _y: this._y(d)\n                }, d));\n            })\n        });\n\n        return results;\n    }\n\n    getKeys() {\n        let data = this._data;\n        if (!data || !data.length) return [];\n\n        return [...new Set(data.map(d => d.key))]\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvQmFyQ2hhcnQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9iM2pzLy4vc3JjL0JhckNoYXJ0LmpzPzNjODUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChDKSAyMDEzLTIwMTQsIDIwMTggQnJhbmRzRXllIChQVFkpIExURFxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpc1xuLy8gc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlXG4vLyB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksXG4vLyAgICAgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0b1xuLy8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcbi8vIGNvbmRpdGlvbnM6XG4vL1xuLy8gICAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuLy8gY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyAgICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUiBJTVBMSUVELFxuLy8gICAgIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBXG4vLyBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUXG4vLyBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0Zcbi8vIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRVxuLy8gT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cblxuaW1wb3J0IHsgY29sb3VycyB9IGZyb20gJy4vQ29sb3Vycyc7XG5pbXBvcnQgeyBtYXhCb3VuZGluZyB9IGZyb20gXCIuL2hlbHBlcnNcIjtcbmltcG9ydCB7IENoYXJ0IH0gZnJvbSBcIi4vQ2hhcnRcIjtcblxuXG5leHBvcnQgY2xhc3MgQmFyQ2hhcnQgZXh0ZW5kcyBDaGFydCB7XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgZGF0YShkYXRhKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX2RhdGE7XG4gICAgICAgIGlmIChkYXRhICYmIGRhdGFbMF0ua2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRhdGEgPSBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBrZXk6IFwic2VyaWVzIDFcIixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzOiBkYXRhXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGVsZW1lbnQoZWxlbWVudCkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9lbGVtZW50O1xuICAgICAgICB0aGlzLl9lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHNob3dMYWJlbHMoc2hvdykge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9zaG93X2xhYmVscztcbiAgICAgICAgdGhpcy5fc2hvd19sYWJlbHMgPSBzaG93O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLy8gdG9kbyBkaXNwYXRjaFxuICAgIHNob3dMZWdlbmQoc2hvdykge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9zaG93X2xlZ2VuZDtcbiAgICAgICAgdGhpcy5fc2hvd19sZWdlbmQgPSBzaG93O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgeCh4KSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3g7XG4gICAgICAgIHRoaXMuX3ggPSB4O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgeSh5KSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3k7XG4gICAgICAgIHRoaXMuX3kgPSB5O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgd2lkdGgod2lkdGgpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fd2lkdGg7XG4gICAgICAgIHRoaXMuX3dpZHRoID0gd2lkdGg7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBoZWlnaHQoaGVpZ2h0KSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX2hlaWdodDtcbiAgICAgICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgY29sb3Vycyhjb2xvdXJzKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX2NvbG91cnM7XG4gICAgICAgIHRoaXMuX2NvbG91cnMgPSBjb2xvdXJzO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgYmFja2dyb3VuZENvbG91cihjb2xvdXIpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fYmFja2dyb3VuZENvbG91cjtcbiAgICAgICAgdGhpcy5fYmFja2dyb3VuZENvbG91ciA9IGNvbG91ciB8fCBcIiNGRkZcIjsgLy8gbmV2ZXIgc2V0IGl0IHRvIG51bGwuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB0aWNrRm9ybWF0KGZvcm1hdCkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl90aWNrRm9ybWF0O1xuICAgICAgICB0aGlzLl90aWNrRm9ybWF0ID0gZm9ybWF0O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgeEF4aXNUaWNrRm9ybWF0KGZvcm1hdCkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl94QXhpc1RpY2tGb3JtYXQ7XG4gICAgICAgIHRoaXMuX3hBeGlzVGlja0Zvcm1hdCA9IGZvcm1hdCB8fCAoZCA9PiBkLnRvU3RyaW5nKCkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgbGFiZWxGb3JtYXQoZm9ybWF0KSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX2xhYmVsRm9ybWF0O1xuICAgICAgICB0aGlzLl9sYWJlbEZvcm1hdCA9IGZvcm1hdCB8fCAoZCA9PiBkLnRvU3RyaW5nKCkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLy8gdG9kbyBtaXNzaW5nXG4gICAgbGFiZWxDb21wcmVzc2lvbihjb21wcmVzc2lvbikge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9jb21wcmVzc2lvbjtcbiAgICAgICAgdGhpcy5fY29tcHJlc3Npb24gPSBjb21wcmVzc2lvbjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8vdG9kbyBtaXNzaW5nXG4gICAgZGF0YUF4aXNMYWJlbChsYWJlbCkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9kYXRhQXhpc0xhYmVsO1xuICAgICAgICB0aGlzLl9kYXRhQXhpc0xhYmVsID0gbGFiZWw7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB0b29sdGlwKHRvb2x0aXApIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fdG9vbHRpcDtcbiAgICAgICAgdGhpcy5fdG9vbHRpcCA9IHRvb2x0aXA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBmb3JjZVkoZm9yY2UpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fZm9yY2VZO1xuICAgICAgICB0aGlzLl9mb3JjZVkgPSBmb3JjZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLy8gdG9kbyBtaXNzaW5nXG4gICAgZHVyYXRpb24oZHVyYXRpb24pIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fZHVyYXRpb247XG4gICAgICAgIHRoaXMuX2R1cmF0aW9uID0gZHVyYXRpb247XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuLy8gdG9kbyBtaXNzaW5nXG4gICAgY29hcnNlbmVzcyhjb2Fyc2VuZXNzKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX2NvYXJzZW5lc3M7XG4gICAgICAgIHRoaXMuX2NvYXJzZW5lc3MgPSBjb2Fyc2VuZXNzO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyB0b2RvIG1pc3NpbmdcbiAgICBwYWRkaW5nKHBhZGRpbmcpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fcGFkZGluZztcbiAgICAgICAgdGhpcy5fcGFkZGluZyA9IHBhZGRpbmc7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIHRvZG8gbWlzc2luZ1xuICAgIHhBeGlzVG9vbHRpcHModG9vbHRpcHMpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5feEF4aXNUb29sdGlwcztcbiAgICAgICAgdGhpcy5feEF4aXNUb29sdGlwcyA9IHRvb2x0aXBzO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB4QXhpc092ZXJyaWRlKG92ZXJyaWRlKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3hBeGlzT3ZlcnJpZGU7XG4gICAgICAgIHRoaXMuX3hBeGlzT3ZlcnJpZGUgPSBvdmVycmlkZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGRpc3BhdGNoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGlzcGF0Y2g7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9lbGVtZW50KSB0aHJvdyBuZXcgRXJyb3IoXCJObyBlbGVtZW50IHNldCBmb3IgQ29sdW1uQ2hhcnQuIFNlZSAjZWxlbWVudCgpXCIpO1xuICAgICAgICBpZiAoIXRoaXMuX2RhdGEpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIk5vIGRhdGEgc2V0IGZvciBDb2x1bW5DaGFydC4gU2VlICNkYXRhKClcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5nZXRUcmFuc2Zvcm1lZERhdGEoKTtcbiAgICAgICAgY29uc3Qga2V5cyA9IHRoaXMuZ2V0S2V5cygpO1xuXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIFNldCB1cCB0aGUgU1ZHIGFyZWFcblxuICAgICAgICBsZXQgdG9wTGV2ZWwgPSBkMy5zZWxlY3QodGhpcy5fZWxlbWVudCkuc2VsZWN0KFwic3ZnXCIpO1xuICAgICAgICBpZiAodG9wTGV2ZWwuZW1wdHkoKSkgdG9wTGV2ZWwgPSBkMy5zZWxlY3QodGhpcy5fZWxlbWVudCkuYXBwZW5kKFwic3ZnXCIpXG5cbiAgICAgICAgdG9wTGV2ZWxcbiAgICAgICAgICAgIC5zdHlsZShcIndpZHRoXCIsIHRoaXMuX3dpZHRoICsgXCJweFwiKVxuICAgICAgICAgICAgLnN0eWxlKFwiaGVpZ2h0XCIsIHRoaXMuX2hlaWdodCArIFwicHhcIik7XG5cblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gTWVhc3VyZSBtYXggZGF0YSBheGlzIHRleHQgbGVuZ3RoXG5cbiAgICAgICAgY29uc3QgZGF0YUF4aXNCQiA9IG1heEJvdW5kaW5nKHRvcExldmVsLCBkYXRhLm1hcChkID0+IHRoaXMuX3hBeGlzVGlja0Zvcm1hdChkLmtleSkpKTtcblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gTGF5b3V0IHRoZSBzaG93TGVnZW5kLlxuICAgICAgICAvL1xuICAgICAgICAvLyBXZSBkbyB0aGlzIG5vdyBiZWNhdXNlIHdlIG5lZWQgdG8ga25vdyBob3cgbXVjaCBzcGFjZSB0aGUgbGVnZW5kXG4gICAgICAgIC8vIHRha2VzIHVwIGluIG9yZGVyIHRvIGZpbmlzaCBjYWxjdWxhdGluZyB0aGUgbWFyZ2lucy5cblxuICAgICAgICBjb25zdCBsZWdlbmRIZWlnaHQgPSB0aGlzLnJlbmRlckxlZ2VuZCgpO1xuXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBDYWxjdWxhdGUgbWFyZ2lucy5cblxuICAgICAgICBjb25zdCBtYXJnaW4gPSB7dG9wOiAyMCwgcmlnaHQ6IDIwLCBib3R0b206IDQwLCBsZWZ0OiAxMH07XG4gICAgICAgIG1hcmdpbi5ib3R0b20gKz0gbGVnZW5kSGVpZ2h0ID8gbGVnZW5kSGVpZ2h0ICsgMjAgOiAwO1xuICAgICAgICBtYXJnaW4ubGVmdCArPSBkYXRhQXhpc0JCLndpZHRoICsgMTA7XG4gICAgICAgIGlmICh0aGlzLl9kYXRhQXhpc0xhYmVsKSBtYXJnaW4uYm90dG9tICs9IDEwICsgMTI7XG5cbiAgICAgICAgY29uc3Qgd2lkdGggPSB0aGlzLl93aWR0aCAtIG1hcmdpbi5sZWZ0IC0gbWFyZ2luLnJpZ2h0LFxuICAgICAgICAgICAgICBoZWlnaHQgPSB0aGlzLl9oZWlnaHQgLSBtYXJnaW4udG9wIC0gbWFyZ2luLmJvdHRvbTtcblxuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHNjYWxlcyBhbmQgc28gb24uXG5cbiAgICAgICAgY29uc3QgeCA9IGQzLnNjYWxlTGluZWFyKClcbiAgICAgICAgICAgIC5yYW5nZVJvdW5kKFswLCB3aWR0aF0pXG4gICAgICAgICAgICAubmljZSgpO1xuXG4gICAgICAgIGNvbnN0IHkgPSBkMy5zY2FsZUJhbmQoKVxuICAgICAgICAgICAgLnJhbmdlUm91bmQoWzAsIGhlaWdodF0pXG4gICAgICAgICAgICAucGFkZGluZyh0aGlzLl9kYXRhLmxlbmd0aCA+IDEgPyAwLjA4IDogMC4xKTtcblxuICAgICAgICBjb25zdCB5R3JvdXAgPSBkMy5zY2FsZUJhbmQoKVxuICAgICAgICAgICAgLnBhZGRpbmcoMCk7XG5cbiAgICAgICAgdGhpcy5feHNjYWxlID0geDtcbiAgICAgICAgdGhpcy5feWdyb3Vwc2NhbGUgPSB5R3JvdXA7XG4gICAgICAgIHRoaXMuX3lzY2FsZSA9IHk7XG5cbiAgICAgICAgLy8gU2NhbGUgdGhlIHJhbmdlIG9mIHRoZSBkYXRhIGluIHRoZSBkb21haW5zXG4gICAgICAgIHkuZG9tYWluKGRhdGEubWFwKGQgPT4gZC5rZXkpKTtcbiAgICAgICAgeUdyb3VwLnJhbmdlUm91bmQoWzAsIHkuYmFuZHdpZHRoKCldKS5kb21haW4oa2V5cyk7XG4gICAgICAgIHguZG9tYWluKFswLCBkMy5tYXgoZGF0YSwgZCA9PiBkMy5tYXgoZC5kYXRhLCBkID0+IGQuX3kpKV0pO1xuXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgbGV0IHN2ZyA9IHRvcExldmVsLnNlbGVjdCgnLm1haW4tZ3JvdXAnKTtcblxuICAgICAgICBpZiAoc3ZnLmVtcHR5KCkpIHtcbiAgICAgICAgICAgIHN2ZyA9IHRvcExldmVsXG4gICAgICAgICAgICAgICAgLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwibWFpbi1ncm91cFwiKVxuICAgICAgICB9XG5cbiAgICAgICAgc3ZnLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyBtYXJnaW4ubGVmdCArIFwiLFwiICsgbWFyZ2luLnRvcCArIFwiKVwiKTtcblxuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBHZXQgcmlkIG9mIGN1cnJlbnQgbGFiZWxzLlxuICAgICAgICBzdmcuc2VsZWN0KFwiLmNoYXJ0LWxhYmVsc1wiKVxuICAgICAgICAgICAgLnJlbW92ZSgpO1xuXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIGFwcGVuZCB0aGUgcmVjdGFuZ2xlcyBmb3IgdGhlIGJhciBjaGFydFxuICAgICAgICBsZXQgZ3JvdXBzID0gc3ZnLnNlbGVjdChcIi5iYXJzXCIpLnNlbGVjdEFsbCgnLmdyb3VwJyk7XG5cbiAgICAgICAgaWYgKGdyb3Vwcy5lbXB0eSgpKSB7XG4gICAgICAgICAgICBncm91cHMgPSBzdmdcbiAgICAgICAgICAgICAgICAuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJiYXJzXCIpXG4gICAgICAgICAgICAgICAgLnNlbGVjdEFsbChcIi5ncm91cFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdyb3VwcyA9IGdyb3Vwcy5kYXRhKGRhdGEpO1xuXG4gICAgICAgIGdyb3Vwcy5leGl0KCkucmVtb3ZlKCk7XG5cbiAgICAgICAgLy8gQWRkaW5nIG5ldyBncm91cHMsIGFuZCBoZW5jZSBhZGRpbmcgbmV3IGJhcnMgdG8gdGhvc2UgZ3JvdXBzLlxuICAgICAgICBncm91cHMuZW50ZXIoKVxuICAgICAgICAgICAgLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwiZ3JvdXBcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBkID0+IFwidHJhbnNsYXRlKDAsXCIgKyB5KGQua2V5KSArIFwiKVwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIGhlaWdodCAtIHkuYmFuZHdpZHRoKCkpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCBcIjEwMCVcIilcbiAgICAgICAgICAgIC5tZXJnZShncm91cHMpXG4gICAgICAgICAgICAuaW50ZXJydXB0KFwiZ3JvdXBzOm1vdmVcIilcbiAgICAgICAgICAgIC50cmFuc2l0aW9uKFwiZ3JvdXBzOm1vdmVcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBkID0+IFwidHJhbnNsYXRlKDAsXCIgKyB5KGQua2V5KSArIFwiKVwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIHkuYmFuZHdpZHRoKCkpXG4gICAgICAgICAgICAuZWFjaCgoc19kLCBzX2ksIG5vZGVzKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGdyb3VwID0gZDMuc2VsZWN0KG5vZGVzW3NfaV0pO1xuXG4gICAgICAgICAgICAgICAgbGV0IGJhcnMgPSBncm91cC5zZWxlY3RBbGwoXCIuYmFyXCIpXG4gICAgICAgICAgICAgICAgICAgIC5kYXRhKHNfZC5kYXRhKTtcblxuICAgICAgICAgICAgICAgIGJhcnMuZXhpdCgpLnJlbW92ZSgpO1xuXG4gICAgICAgICAgICAgICAgYmFycy5pbnRlcnJ1cHQoXCJiYXI6bW92ZVwiKSAgICAgLy8gQW5pbWF0ZSB0aGUgYmFycyB0byB0aGVpciBuZXcgcG9zaXRpb24uXG4gICAgICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKFwiYmFyOm1vdmVcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIHlHcm91cC5iYW5kd2lkdGgoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwieVwiLCBkID0+IHlHcm91cChkLl9rZXkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIDApO1xuXG4gICAgICAgICAgICAgICAgYmFycy5lbnRlcigpXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoXCJyZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIChkLCBpKSA9PiBcImJhciBzZXJpZXMgc2VyaWVzLVwiICsgaSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwieVwiLCBkID0+IHlHcm91cChkLl9rZXkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIDApXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcImhlaWdodFwiLCB5R3JvdXAuYmFuZHdpZHRoKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcIndpZHRoXCIsIDApXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIChkLCBpKSA9PiB0aGlzLmdldFNlcmllc0NvbG91cihpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcImN1cnNvclwiLCBcInBvaW50ZXJcIilcbiAgICAgICAgICAgICAgICAgICAgLm9uKFwibW91c2VvdmVyXCIsIChkLCBpLCBub2RlcykgPT4geyAvLyBEYXJrZW4gdGhlIGJhciBvbiBtb3VzZSBvdmVyXG4gICAgICAgICAgICAgICAgICAgICAgICBkMy5zZWxlY3Qobm9kZXNbaV0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmludGVycnVwdChcImhvdmVyOmNvbG91clwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKFwiaG92ZXI6Y29sb3VyXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKDQwMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIGQzLmhjbCh0aGlzLmdldFNlcmllc0NvbG91cihpKSkuZGFya2VyKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXNwYXRjaC5jYWxsKFwidG9vbHRpcFNob3dcIiwgdGhpcywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGU6IGQzLmV2ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50OiBkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllczogc19kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllc0luZGV4OiBzX2ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGQuX3lcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5vbihcIm1vdXNlb3V0XCIsIChkLCBpLCBub2RlcykgPT4geyAvLyBiYXIgaXMgcmVndWxhciBjb2xvdXIgb24gbW91c2Ugb3V0LlxuICAgICAgICAgICAgICAgICAgICAgICAgZDMuc2VsZWN0KG5vZGVzW2ldKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5pbnRlcnJ1cHQoXCJob3Zlcjpjb2xvdXJcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudHJhbnNpdGlvbihcImhvdmVyOmNvbG91clwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbig0MDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCB0aGlzLmdldFNlcmllc0NvbG91cihpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXNwYXRjaC5jYWxsKFwidG9vbHRpcEhpZGVcIiwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5vbihcImNsaWNrIGF1eGNsaWNrXCIsIChkLCBpLCBub2RlcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlzcGF0Y2guY2FsbChcImVsZW1lbnRDbGlja1wiLCB0aGlzLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZTogZDMuZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQ6IGQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzOiBkLl9zZXJpZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzSW5kZXg6IHNfaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy5feShkKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLm1lcmdlKGJhcnMpXG4gICAgICAgICAgICAgICAgICAgIC5pbnRlcnJ1cHQoXCJiYXI6Z3Jvd3RoXCIpICAgIC8vIEFuaW1hdGUgYmFycyBncm93aW5nLlxuICAgICAgICAgICAgICAgICAgICAudHJhbnNpdGlvbihcImJhcjpncm93dGhcIilcbiAgICAgICAgICAgICAgICAgICAgLmRlbGF5KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNhbGNCYXJHcm93dGgoc19pLCBub2Rlcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24odGhpcy5fZHVyYXRpb24pXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIChkLCBpKSA9PiB0aGlzLmdldFNlcmllc0NvbG91cihpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwid2lkdGhcIiwgZCA9PiB4KGQuX3kpKTtcblxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIExhYmVscyBsb2FkZWQgYWZ0ZXIgb3VyIGZpcnN0IGJhciBncm93cy5cbiAgICAgICAgaWYgKHRoaXMuX3Nob3dfbGFiZWxzKSB7XG4gICAgICAgICAgICBzdmcudHJhbnNpdGlvbihcImJhcjpncm93dGhcIilcbiAgICAgICAgICAgICAgICAub24oXCJlbmRcIiwgKGQsIGksIG5vZGVzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpIDwgbm9kZXMubGVuZ3RoIC0gMSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckxhYmVscyhzdmcsIGRhdGEsIHgsIHlHcm91cCwgeSk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBEcmF3IHRoZSBkYXRhIGF4aXMgZGF0YSBsYWJlbC5cblxuICAgICAgICBpZiAodGhpcy5fZGF0YUF4aXNMYWJlbCkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJEYXRhQXhpc0xhYmVsKHdpZHRoLCBtYXJnaW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIFNldCB0aGUgYmFja2dyb3VuZCBjb2xvdXJcblxuICAgICAgICBkMy5zZWxlY3QodGhpcy5fZWxlbWVudCkuc2VsZWN0KFwiLmJhY2tncm91bmRcIikucmVtb3ZlKCk7XG4gICAgICAgIGlmICh0aGlzLl9iYWNrZ3JvdW5kQ29sb3VyKSB7XG4gICAgICAgICAgICBkMy5zZWxlY3QodGhpcy5fZWxlbWVudCkuc2VsZWN0KFwic3ZnXCIpXG4gICAgICAgICAgICAgICAgLmFwcGVuZChcInJlY3RcIilcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImJhY2tncm91bmRcIilcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCBcIjEwMCVcIilcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgXCIxMDAlXCIpXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZShcImZpbGxcIiwgdGhpcy5fYmFja2dyb3VuZENvbG91cilcbiAgICAgICAgICAgICAgICAubG93ZXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIGFkZCB0aGUgWSBncmlkbGluZXNcbiAgICAgICAgc3ZnLmNhbGwodGhpcy5ncmlkLCBoZWlnaHQsIGQzLmF4aXNCb3R0b20oeCkudGlja3MoNSkpO1xuXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIGF4ZXNcbiAgICAgICAgc3ZnLmNhbGwodGhpcy5sYWJlbEF4aXMsIGQzLmF4aXNMZWZ0KHkpLnRpY2tTaXplKDApLnRpY2tQYWRkaW5nKDUpLnRpY2tGb3JtYXQodGhpcy5feEF4aXNUaWNrRm9ybWF0KSk7XG4gICAgICAgIHN2Zy5jYWxsKHRoaXMuZGF0YUF4aXMsIGhlaWdodCwgZDMuYXhpc0JvdHRvbSh4KS50aWNrcyg1KS50aWNrRm9ybWF0KHRoaXMuX3RpY2tGb3JtYXQpKTtcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLypcbiAgICAgKiBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIHR3byBmdW5jdGlvbnMsICNzaG93KCkgYW5kICNoaWRlKCksXG4gICAgICogdG8gc2hvdyBhbmQgaGlkZSB0aGUgbGFiZWxzLlxuICAgICAqL1xuICAgIGxhYmVscygpIHtcbiAgICAgICAgcmV0dXJuIHtcblxuICAgICAgICAgICAgc2hvdzogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9lbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzZWxlY3Rpb24gPSB0aGlzLl9lbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHRoaXMuZ2V0VHJhbnNmb3JtZWREYXRhKCksXG4gICAgICAgICAgICAgICAgICAgICAgICB4c2NhbGUgPSB0aGlzLl94c2NhbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB5Z3JvdXAgPSB0aGlzLl95Z3JvdXBzY2FsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHlzY2FsZSA9IHRoaXMuX3lzY2FsZTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uKSBzZWxlY3Rpb24gPSBkMy5zZWxlY3QodGhpcy5fZWxlbWVudCkuc2VsZWN0KFwic3ZnXCIpLnNlbGVjdChcImdcIik7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2VsZWN0aW9uLmVtcHR5KCkgJiYgZGF0YSAmJiB4c2NhbGUgJiYgeXNjYWxlICYmIHlncm91cCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGxhYmVscyA9IHNlbGVjdGlvbi5zZWxlY3QoJy5jaGFydC1sYWJlbHMnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbGFiZWxzLmVtcHR5KCkpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVscy5yZW1vdmUoKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJMYWJlbHMoc2VsZWN0aW9uLCBkYXRhLCB4c2NhbGUsIHlncm91cCwgeXNjYWxlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGhpZGU6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBkMy5zZWxlY3QodGhpcy5fZWxlbWVudClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZWxlY3QoJy5jaGFydC1sYWJlbHMnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmludGVycnVwdChcImxhYmVsc1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmludGVycnVwdChcImxhYmVsczpmYWRlXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAudHJhbnNpdGlvbihcImxhYmVsczpmYWRlXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDApXG4gICAgICAgICAgICAgICAgICAgICAgICAub24oXCJlbmRcIiwgKGQsIGksIG5vZGVzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZDMuc2VsZWN0KG5vZGVzW2ldKS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHJlbmRlckxhYmVscyhzZWxlY3Rpb24sIGRhdGEsIHhzY2FsZSwgeWdyb3VwLCB5c2NhbGUsIGFuaW1hdGUpIHtcbiAgICAgICAgYW5pbWF0ZSA9IGFuaW1hdGUgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBhbmltYXRlO1xuICAgICAgICBzZWxlY3Rpb24uc2VsZWN0QWxsKFwiLmNoYXJ0LWxhYmVsc1wiKS5yZW1vdmUoKTtcblxuICAgICAgICBsZXQgbGFiZWxzID0gc2VsZWN0aW9uLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJjaGFydC1sYWJlbHNcIilcbiAgICAgICAgICAgIC5zZWxlY3RBbGwoXCIubGFiZWwtZ3JvdXBcIilcbiAgICAgICAgICAgIC5kYXRhKGRhdGEpO1xuXG4gICAgICAgIGxldCBmb250U2l6ZSA9IHRoaXMuX2ZvbnRfc2l6ZTsgICAgLy8gT3VyIGluaXRpYWwgZm9udCBzaXplLlxuICAgICAgICBjb25zdCBidWZmZXIgPSA1OyAgICAgLy8gQnVmZmVyIHNwYWNlIGJldHdlZW4gd29yZHMgYW5kIHRoZSB0b3Agb2YgYSBiYXIuXG5cbiAgICAgICAgbGFiZWxzLmVudGVyKCkuZWFjaCgoc2VyaWVzLCBzX2ksIHNfbm9kZXMpID0+IHtcbiAgICAgICAgICAgIGxldCBncm91cCA9IGQzLnNlbGVjdChzX25vZGVzW3NfaV0pXG4gICAgICAgICAgICAgICAgLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwibGFiZWwtZ3JvdXBcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBkID0+IFwidHJhbnNsYXRlKDAsXCIgKyB5c2NhbGUoZC5rZXkpICsgXCIpXCIpXG4gICAgICAgICAgICAgICAgLnNlbGVjdEFsbChcIi5jaGFydC1sYWJlbFwiKVxuICAgICAgICAgICAgICAgIC5kYXRhKHNlcmllcy5kYXRhKVxuICAgICAgICAgICAgICAgIC5lbnRlcigpXG4gICAgICAgICAgICAgICAgLmVhY2goKGQsIGksIG5vZGVzKSA9PiB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gV2FudCB0byBmaWd1cmUgb3V0IGlmIHRoZSBsYWJlbCBpcyB0b28gZGFyayAvIGxpZ2h0IGZvciB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gYmFyLlxuICAgICAgICAgICAgICAgICAgICBsZXQgaW52ZXJ0ZWRDb2xvciA9IGQzLmhjbCh0aGlzLmdldFNlcmllc0NvbG91cihpKSk7XG4gICAgICAgICAgICAgICAgICAgIGludmVydGVkQ29sb3IubCArPSBNYXRoLm1pbihpbnZlcnRlZENvbG9yLmwgKyA1MCwgMTAwKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGludmVydCA9IGQzLmhjbCh0aGlzLmdldFNlcmllc0NvbG91cihpKSkubCA8IDYwO1xuXG4gICAgICAgICAgICAgICAgICAgIGxldCB4cG9zID0geHNjYWxlKGQuX3kpO1xuXG4gICAgICAgICAgICAgICAgICAgIGxldCB0ZXh0ID0gZDMuc2VsZWN0KG5vZGVzW2ldKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC50ZXh0KHRoaXMuX2xhYmVsRm9ybWF0KGQuX3kpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJjaGFydC1sYWJlbFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwieFwiLCB4cG9zICsgYnVmZmVyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiZHhcIiwgYW5pbWF0ZSA/IC0xNSA6IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcInBvaW50ZXItZXZlbnRzXCIsIFwibm9uZVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcImZvbnQtc2l6ZVwiLCBmb250U2l6ZSArIFwicHhcIik7XG5cblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBiYiA9IHRleHQubm9kZSgpLmdldEJCb3goKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3ZlcnNpemUgPSB4cG9zICsgYmIud2lkdGggKyBidWZmZXIgPiB4c2NhbGUucmFuZ2UoKVsxXTtcblxuICAgICAgICAgICAgICAgICAgICB0ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcInlcIiwgeWdyb3VwKGQuX2tleSkgKyBmb250U2l6ZSAvIDIgKyB5Z3JvdXAuYmFuZHdpZHRoKCkgLyAyKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIG92ZXJzaXplID8geHBvcyAtIGJ1ZmZlciAtIGJiLndpZHRoIDogeHBvcyArIGJ1ZmZlcilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcImZpbGxcIiwgb3ZlcnNpemUgJiYgaW52ZXJ0ID8gaW52ZXJ0ZWRDb2xvci50b1N0cmluZygpIDogY29sb3Vycy5laWdodGVlbi5kYXJrR3JleSk7XG5cbiAgICAgICAgICAgICAgICAgICAgdGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgLnRyYW5zaXRpb24oXCJsYWJlbHNcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5kZWxheSgoKSA9PiBhbmltYXRlID8gdGhpcy5jYWxjQmFyR3Jvd3RoKHNfaSwgc19ub2Rlcy5sZW5ndGgpIDogMCkgLy8gRGVsYXkgaW4gbG9ja3N0ZXAgd2l0aCBiYXIgZ3Jvd3RoLlxuICAgICAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKHRoaXMuX2R1cmF0aW9uKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJkeFwiLCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAxKVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuXG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHJlbmRlckRhdGFBeGlzTGFiZWwod2lkdGgsIG1hcmdpbnMpIHtcbiAgICAgICAgbGV0IHN2ZyA9IGQzLnNlbGVjdCh0aGlzLl9lbGVtZW50KS5zZWxlY3QoJ3N2ZycpO1xuICAgICAgICBzdmcuc2VsZWN0QWxsKFwiLmRhdGEtbGFiZWxzXCIpLnJlbW92ZSgpO1xuXG4gICAgICAgIGlmICghdGhpcy5fZGF0YUF4aXNMYWJlbCkgcmV0dXJuO1xuICAgICAgICBsZXQgdGV4dCA9IHRoaXMuX2RhdGFBeGlzTGFiZWw7XG4gICAgICAgIGlmICh0ZXh0LmxvbmcpIHRleHQgPSB0ZXh0Lmxvbmc7XG5cbiAgICAgICAgbGV0IHggPSAobWFyZ2lucy5sZWZ0ICsgd2lkdGggLyAyKTtcblxuICAgICAgICBsZXQgbGFiZWwgPSBzdmcuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImRhdGEtbGFiZWxzXCIpXG4gICAgICAgICAgICAuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgICAgICAgLnRleHQodGV4dClcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgeCArIFwiLFwiICsgKHRoaXMuX2hlaWdodCAtIG1hcmdpbnMuYm90dG9tICsgNTApICsgXCIpXCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIGNvbG91cnMuZWlnaHRlZW4uZGFya0dyZXkpO1xuXG4gICAgICAgIGxldCB0ZXh0V2lkdGggPSBsYWJlbC5ub2RlKCkuZ2V0QkJveCgpLndpZHRoO1xuICAgICAgICBpZiAodGV4dFdpZHRoID49IHdpZHRoICYmIHRoaXMuX2RhdGFBeGlzTGFiZWwuc2hvcnQpIHtcbiAgICAgICAgICAgIGxhYmVsLnRleHQodGhpcy5fZGF0YUF4aXNMYWJlbC5zaG9ydCk7XG4gICAgICAgICAgICB0ZXh0V2lkdGggPSBsYWJlbC5ub2RlKCkuZ2V0QkJveCgpLndpZHRoO1xuICAgICAgICB9XG5cbiAgICAgICAgbGFiZWwuYXR0cihcImR4XCIsIC10ZXh0V2lkdGggLyAyKTtcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cblxuICAgIGdyaWQoc2VsZWN0aW9uLCBoZWlnaHQsIGF4aXMpIHtcbiAgICAgICAgc2VsZWN0aW9uLnNlbGVjdChcIi5ncmlkXCIpLnJlbW92ZSgpO1xuXG4gICAgICAgIGxldCBncmlkID0gc2VsZWN0aW9uLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJncmlkXCIpXG4gICAgICAgICAgICAuY2FsbChheGlzXG4gICAgICAgICAgICAgICAgLnRpY2tTaXplKGhlaWdodClcbiAgICAgICAgICAgICAgICAudGlja0Zvcm1hdChcIlwiKVxuICAgICAgICAgICAgKTtcblxuICAgICAgICBncmlkLnNlbGVjdEFsbChcImxpbmVcIilcbiAgICAgICAgICAgIC5zdHlsZShcInN0cm9rZVwiLCBjb2xvdXJzLmVpZ2h0ZWVuLmxpZ2h0R3JleSk7XG4gICAgICAgIGdyaWQuc2VsZWN0QWxsKFwiLmRvbWFpblwiKS5yZW1vdmUoKTtcblxuICAgICAgICBncmlkXG4gICAgICAgICAgICAubG93ZXIoKSAvLyBBbHdheXMgZW5zdXJlIHRoYXQgdGhpcyBpcyBlYXJsaWVyIGluIHRoZSBkb20uIFRoaW5ncyBtdXN0IGJlIGRyYXduIG9uIHRvcCBvZiBpdC5cbiAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMClcbiAgICAgICAgICAgIC50cmFuc2l0aW9uKClcbiAgICAgICAgICAgIC5kZWxheSg1MDApXG4gICAgICAgICAgICAuZHVyYXRpb24oNTAwKVxuICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAxKTtcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgbGFiZWxBeGlzKHNlbGVjdGlvbiwgYXhpc19vYmplY3QpIHtcbiAgICAgICAgc2VsZWN0aW9uLnNlbGVjdChcIi5sYWJlbC1heGlzXCIpLnJlbW92ZSgpO1xuICAgICAgICBsZXQgYXhpcyA9IHNlbGVjdGlvbi5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwibGFiZWwtYXhpc1wiKVxuICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAwKVxuICAgICAgICAgICAgLmNhbGwoYXhpc19vYmplY3QpO1xuXG4gICAgICAgIGF4aXMuc2VsZWN0KFwiLmRvbWFpblwiKS5yZW1vdmUoKTtcblxuICAgICAgICBsZXQgbWF4ID0gMDtcbiAgICAgICAgYXhpcy5zZWxlY3RBbGwoXCJ0ZXh0XCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJmb250LXNpemVcIiwgdGhpcy5fZm9udF9zaXplICsgXCJweFwiKVxuICAgICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBjb2xvdXJzLmVpZ2h0ZWVuLmRhcmtHcmV5KVxuICAgICAgICAgICAgLm5vZGVzKClcbiAgICAgICAgICAgIC5mb3JFYWNoKHRleHQgPT4gbWF4ID0gTWF0aC5tYXgobWF4LCB0ZXh0LmdldEJCb3goKS53aWR0aCkpO1xuXG4gICAgICAgIGF4aXNcbiAgICAgICAgICAgIC50cmFuc2l0aW9uKClcbiAgICAgICAgICAgIC5kdXJhdGlvbigxMDAwKVxuICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAxKTtcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgZGF0YUF4aXMoc2VsZWN0aW9uLCBoZWlnaHQsIGF4aXNfb2JqZWN0KSB7XG4gICAgICAgIHNlbGVjdGlvbi5zZWxlY3QoXCIuZGF0YS1heGlzXCIpLnJlbW92ZSgpO1xuICAgICAgICBsZXQgYXhpcyA9IHNlbGVjdGlvbi5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImRhdGEtYXhpc1wiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKDAsXCIgKyBoZWlnaHQgKyBcIilcIilcbiAgICAgICAgICAgIC5jYWxsKGF4aXNfb2JqZWN0LnRpY2tTaXplKDApLnRpY2tQYWRkaW5nKDEwKSlcbiAgICAgICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDApXG4gICAgICAgICAgICAudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAuZHVyYXRpb24oMTAwMClcbiAgICAgICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDEpO1xuXG4gICAgICAgIGF4aXMuc2VsZWN0QWxsKFwidGV4dFwiKVxuICAgICAgICAgICAgICAgIC5zdHlsZShcImZpbGxcIiwgY29sb3Vycy5laWdodGVlbi5kYXJrR3JleSlcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgY2FsY0Jhckdyb3d0aChpLCBtYXgpIHtcbiAgICAgICAgaWYgKG1heCA8IDEwKSByZXR1cm4gaSAqIHRoaXMuX0JBUl9HUk9XVEggLyAyO1xuICAgICAgICBpZiAobWF4IDwgMzUpIHJldHVybiBpICogdGhpcy5fQkFSX0dST1dUSCAvIDQ7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIGdldFNlcmllc0NvbG91cihpKSB7XG4gICAgICAgIGlmIChpIDwgMCB8fCAhdGhpcy5fY29sb3VycykgcmV0dXJuIGNvbG91cnMuZWlnaHRlZW4ubWlkR3JleTtcblxuICAgICAgICBpID0gaSAlIHRoaXMuX2NvbG91cnMubGVuZ3RoO1xuICAgICAgICByZXR1cm4gdGhpcy5fY29sb3Vyc1tpXTtcbiAgICB9XG5cbiAgICBnZXRTb3J0ZWREYXRhKCkge1xuICAgICAgICBsZXQgZGF0YSA9IHRoaXMuX2RhdGE7XG4gICAgICAgIGlmICghZGF0YSB8fCAhZGF0YS5sZW5ndGgpIHJldHVybiBbXTtcblxuICAgICAgICBkYXRhID0gdGhpcy5fZGF0YS5zb3J0KChsaHMsIHJocykgPT4ge1xuICAgICAgICAgICAgbGhzID0gbGhzLmtleS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgcmhzID0gcmhzLmtleS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgICAgICBpZiAobGhzID09PSByaHMpIHJldHVybiAwO1xuICAgICAgICAgICAgaWYgKGxocyA8IHJocykgcmV0dXJuIC0xO1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIGdldFRyYW5zZm9ybWVkRGF0YSgpIHtcbiAgICAgICAgbGV0IGRhdGEgPSB0aGlzLmdldFNvcnRlZERhdGEoKTtcbiAgICAgICAgaWYgKCFkYXRhIHx8ICFkYXRhLmxlbmd0aCkgcmV0dXJuIFtdO1xuXG4gICAgICAgIGxldCByZXN1bHRzID0gW107XG5cbiAgICAgICAgY29uc3QgZ2V0WCA9IGQgPT4gdGhpcy5feEF4aXNPdmVycmlkZSA/IHRoaXMuX3hBeGlzT3ZlcnJpZGVbdGhpcy5feChkKV0gOiB0aGlzLl94KGQpO1xuXG4gICAgICAgIGRhdGEuZm9yRWFjaCgoc2VyaWVzLCBzX2kpID0+IHtcbiAgICAgICAgICAgIHNlcmllcy52YWx1ZXMuZm9yRWFjaCgoZCwgZF9pKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGZpZWxkID0gcmVzdWx0cy5maW5kKGJ1Y2tldCA9PiBidWNrZXQua2V5ID09PSBnZXRYKGQpKTtcbiAgICAgICAgICAgICAgICBpZiAoIWZpZWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6IGdldFgoZClcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGZpZWxkKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmaWVsZC5kYXRhLnB1c2goT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICAgICAgICAgIF9zZXJpZXM6IHNlcmllcyxcbiAgICAgICAgICAgICAgICAgICAgX3NfaTogc19pLFxuICAgICAgICAgICAgICAgICAgICBfa2V5OiBzZXJpZXMua2V5LFxuICAgICAgICAgICAgICAgICAgICBfeTogdGhpcy5feShkKVxuICAgICAgICAgICAgICAgIH0sIGQpKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cblxuICAgIGdldEtleXMoKSB7XG4gICAgICAgIGxldCBkYXRhID0gdGhpcy5fZGF0YTtcbiAgICAgICAgaWYgKCFkYXRhIHx8ICFkYXRhLmxlbmd0aCkgcmV0dXJuIFtdO1xuXG4gICAgICAgIHJldHVybiBbLi4ubmV3IFNldChkYXRhLm1hcChkID0+IGQua2V5KSldXG4gICAgfVxufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/BarChart.js\n')},"./src/Chart.js":
/*!**********************!*\
  !*** ./src/Chart.js ***!
  \**********************/
/*! exports provided: Chart */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Chart", function() { return Chart; });\n/* harmony import */ var _Colours__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Colours */ "./src/Colours.js");\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers */ "./src/helpers.js");\n// Copyright (C) 2013-2014, 2018 BrandsEye (PTY) LTD\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this\n// software and associated documentation files (the "Software"), to deal in the Software\n// without restriction, including without limitation the rights to use, copy, modify,\n//     merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following\n// conditions:\n//\n//     The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n//     INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n// CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n\n\n\nclass Chart {\n    constructor() {\n        this._x = (d) => d.x;\n        this._y = (d) => d.y;\n        this._height = 420;\n        this._width = 420;\n        this._BAR_GROWTH = 100;\n        this._duration = 300;\n        this._dispatch = d3.dispatch(\'elementClick\', \'elementMiddleClick\', \'elementRightClick\',\n            \'tooltipShow\', \'tooltipHide\');\n        this._xAxisTickFormat = this._tickFormat = this._labelFormat = d => d.toString();\n        this._colours = [ _Colours__WEBPACK_IMPORTED_MODULE_0__["colours"].eighteen.midGrey, _Colours__WEBPACK_IMPORTED_MODULE_0__["colours"].eighteen.lightGrey, _Colours__WEBPACK_IMPORTED_MODULE_0__["colours"].eighteen.darkGrey ];\n        this._backgroundColour = "#FFF";\n        this._interbarProportion = null;\n    }\n\n    renderLegend(svg, data, min, width, height, getter) {\n        svg = svg || d3.select(this._element).select("svg");\n        svg.selectAll(".legend").remove();\n        if (!this._show_legend) return 0;\n\n        min = min || 2;\n        data = data || this.getSortedData();\n        width = width || this._width;\n        height = height || this._height;\n        getter = getter || (d => d.key);\n\n        // Only if we have multiple series.\n        if (!data || data.length < min) return 0;\n\n        let maxWidth = Object(_helpers__WEBPACK_IMPORTED_MODULE_1__["maxBounding"])(svg, data.map(getter)).width;\n\n        const legend = svg.append("g")\n            .attr("class", "legend");\n\n        let elements = legend.selectAll(".legend-element")\n            .data(data);\n\n        const position_start = 20;\n        let position = position_start;\n        let position_height = 0;\n\n        elements.enter()\n            .append("g")\n            .attr("class", (d, i) => "legend-element series series-" + i)\n            .style("cursor", "default")\n            .each((d, i, nodes) => {\n                let element = d3.select(nodes[i]);\n\n                element.append("rect")\n                    .attr("width", 10)\n                    .attr("height", 10)\n                    .attr("rx", 2)\n                    .attr("ry", 2)\n                    .attr("y", -10)\n                    .style("fill", () => this.getSeriesColour(i));\n\n                element.append("text")\n                    .text(getter)\n                    .attr("dx", 12)\n                    .style("font-family", "Open Sans, sans-serif")\n                    .style("font-weight", "normal")\n                    .style("font-size", "12px")\n                    .style("fill", _Colours__WEBPACK_IMPORTED_MODULE_0__["colours"].eighteen.darkGrey);\n\n                element.append("title")\n                    .text(getter);\n\n                element.attr("transform", "translate(" + position + "," + position_height +")");\n                const positionDelta = maxWidth + 20; // element.node().getBBox().width + 10;\n                position += positionDelta;\n\n                if (position >= width) {\n                    position = position_start;\n                    position_height += 15;\n                    element.attr("transform", "translate(" + position + "," + position_height + ")");\n                    position += positionDelta;\n                }\n\n            })\n            .on("mouseover", (d, i, nodes) => {\n                svg.selectAll(".series:not(.series-" + i + ")")\n                    .interrupt("legend:highlight")\n                    .transition("legend:highlight")\n                    .style("opacity", 0.3);\n            })\n            .on("mouseout", (d, i, nodes) => {\n                svg.selectAll(".series")\n                    .interrupt("legend:highlight")\n                    .transition("legend:highlight")\n                    .style("opacity", 1);\n            })\n            .style("opacity", 0)\n            .transition()\n            .duration(1000)\n            .style("opacity", 1);\n\n        const legendHeight = legend.node().getBBox().height;\n        legend.attr("transform", "translate(0," + (height - legendHeight) + ")");\n        return legendHeight;\n    }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvQ2hhcnQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9iM2pzLy4vc3JjL0NoYXJ0LmpzPzYyYWUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChDKSAyMDEzLTIwMTQsIDIwMTggQnJhbmRzRXllIChQVFkpIExURFxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpc1xuLy8gc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlXG4vLyB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksXG4vLyAgICAgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0b1xuLy8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcbi8vIGNvbmRpdGlvbnM6XG4vL1xuLy8gICAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuLy8gY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyAgICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUiBJTVBMSUVELFxuLy8gICAgIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBXG4vLyBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUXG4vLyBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0Zcbi8vIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRVxuLy8gT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCB7Y29sb3Vyc30gZnJvbSAnLi9Db2xvdXJzJztcbmltcG9ydCB7IG1heEJvdW5kaW5nIH0gZnJvbSBcIi4vaGVscGVyc1wiO1xuXG5cblxuZXhwb3J0IGNsYXNzIENoYXJ0IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5feCA9IChkKSA9PiBkLng7XG4gICAgICAgIHRoaXMuX3kgPSAoZCkgPT4gZC55O1xuICAgICAgICB0aGlzLl9oZWlnaHQgPSA0MjA7XG4gICAgICAgIHRoaXMuX3dpZHRoID0gNDIwO1xuICAgICAgICB0aGlzLl9CQVJfR1JPV1RIID0gMTAwO1xuICAgICAgICB0aGlzLl9kdXJhdGlvbiA9IDMwMDtcbiAgICAgICAgdGhpcy5fZGlzcGF0Y2ggPSBkMy5kaXNwYXRjaCgnZWxlbWVudENsaWNrJywgJ2VsZW1lbnRNaWRkbGVDbGljaycsICdlbGVtZW50UmlnaHRDbGljaycsXG4gICAgICAgICAgICAndG9vbHRpcFNob3cnLCAndG9vbHRpcEhpZGUnKTtcbiAgICAgICAgdGhpcy5feEF4aXNUaWNrRm9ybWF0ID0gdGhpcy5fdGlja0Zvcm1hdCA9IHRoaXMuX2xhYmVsRm9ybWF0ID0gZCA9PiBkLnRvU3RyaW5nKCk7XG4gICAgICAgIHRoaXMuX2NvbG91cnMgPSBbIGNvbG91cnMuZWlnaHRlZW4ubWlkR3JleSwgY29sb3Vycy5laWdodGVlbi5saWdodEdyZXksIGNvbG91cnMuZWlnaHRlZW4uZGFya0dyZXkgXTtcbiAgICAgICAgdGhpcy5fYmFja2dyb3VuZENvbG91ciA9IFwiI0ZGRlwiO1xuICAgICAgICB0aGlzLl9pbnRlcmJhclByb3BvcnRpb24gPSBudWxsO1xuICAgIH1cblxuICAgIHJlbmRlckxlZ2VuZChzdmcsIGRhdGEsIG1pbiwgd2lkdGgsIGhlaWdodCwgZ2V0dGVyKSB7XG4gICAgICAgIHN2ZyA9IHN2ZyB8fCBkMy5zZWxlY3QodGhpcy5fZWxlbWVudCkuc2VsZWN0KFwic3ZnXCIpO1xuICAgICAgICBzdmcuc2VsZWN0QWxsKFwiLmxlZ2VuZFwiKS5yZW1vdmUoKTtcbiAgICAgICAgaWYgKCF0aGlzLl9zaG93X2xlZ2VuZCkgcmV0dXJuIDA7XG5cbiAgICAgICAgbWluID0gbWluIHx8IDI7XG4gICAgICAgIGRhdGEgPSBkYXRhIHx8IHRoaXMuZ2V0U29ydGVkRGF0YSgpO1xuICAgICAgICB3aWR0aCA9IHdpZHRoIHx8IHRoaXMuX3dpZHRoO1xuICAgICAgICBoZWlnaHQgPSBoZWlnaHQgfHwgdGhpcy5faGVpZ2h0O1xuICAgICAgICBnZXR0ZXIgPSBnZXR0ZXIgfHwgKGQgPT4gZC5rZXkpO1xuXG4gICAgICAgIC8vIE9ubHkgaWYgd2UgaGF2ZSBtdWx0aXBsZSBzZXJpZXMuXG4gICAgICAgIGlmICghZGF0YSB8fCBkYXRhLmxlbmd0aCA8IG1pbikgcmV0dXJuIDA7XG5cbiAgICAgICAgbGV0IG1heFdpZHRoID0gbWF4Qm91bmRpbmcoc3ZnLCBkYXRhLm1hcChnZXR0ZXIpKS53aWR0aDtcblxuICAgICAgICBjb25zdCBsZWdlbmQgPSBzdmcuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImxlZ2VuZFwiKTtcblxuICAgICAgICBsZXQgZWxlbWVudHMgPSBsZWdlbmQuc2VsZWN0QWxsKFwiLmxlZ2VuZC1lbGVtZW50XCIpXG4gICAgICAgICAgICAuZGF0YShkYXRhKTtcblxuICAgICAgICBjb25zdCBwb3NpdGlvbl9zdGFydCA9IDIwO1xuICAgICAgICBsZXQgcG9zaXRpb24gPSBwb3NpdGlvbl9zdGFydDtcbiAgICAgICAgbGV0IHBvc2l0aW9uX2hlaWdodCA9IDA7XG5cbiAgICAgICAgZWxlbWVudHMuZW50ZXIoKVxuICAgICAgICAgICAgLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgKGQsIGkpID0+IFwibGVnZW5kLWVsZW1lbnQgc2VyaWVzIHNlcmllcy1cIiArIGkpXG4gICAgICAgICAgICAuc3R5bGUoXCJjdXJzb3JcIiwgXCJkZWZhdWx0XCIpXG4gICAgICAgICAgICAuZWFjaCgoZCwgaSwgbm9kZXMpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgZWxlbWVudCA9IGQzLnNlbGVjdChub2Rlc1tpXSk7XG5cbiAgICAgICAgICAgICAgICBlbGVtZW50LmFwcGVuZChcInJlY3RcIilcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCAxMClcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgMTApXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFwicnhcIiwgMilcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJyeVwiLCAyKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcInlcIiwgLTEwKVxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJmaWxsXCIsICgpID0+IHRoaXMuZ2V0U2VyaWVzQ29sb3VyKGkpKTtcblxuICAgICAgICAgICAgICAgIGVsZW1lbnQuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgICAgICAgICAgICAgICAudGV4dChnZXR0ZXIpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiZHhcIiwgMTIpXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZShcImZvbnQtZmFtaWx5XCIsIFwiT3BlbiBTYW5zLCBzYW5zLXNlcmlmXCIpXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZShcImZvbnQtd2VpZ2h0XCIsIFwibm9ybWFsXCIpXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZShcImZvbnQtc2l6ZVwiLCBcIjEycHhcIilcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBjb2xvdXJzLmVpZ2h0ZWVuLmRhcmtHcmV5KTtcblxuICAgICAgICAgICAgICAgIGVsZW1lbnQuYXBwZW5kKFwidGl0bGVcIilcbiAgICAgICAgICAgICAgICAgICAgLnRleHQoZ2V0dGVyKTtcblxuICAgICAgICAgICAgICAgIGVsZW1lbnQuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIHBvc2l0aW9uICsgXCIsXCIgKyBwb3NpdGlvbl9oZWlnaHQgK1wiKVwiKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwb3NpdGlvbkRlbHRhID0gbWF4V2lkdGggKyAyMDsgLy8gZWxlbWVudC5ub2RlKCkuZ2V0QkJveCgpLndpZHRoICsgMTA7XG4gICAgICAgICAgICAgICAgcG9zaXRpb24gKz0gcG9zaXRpb25EZWx0YTtcblxuICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA+PSB3aWR0aCkge1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IHBvc2l0aW9uX3N0YXJ0O1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbl9oZWlnaHQgKz0gMTU7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIHBvc2l0aW9uICsgXCIsXCIgKyBwb3NpdGlvbl9oZWlnaHQgKyBcIilcIik7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uICs9IHBvc2l0aW9uRGVsdGE7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLm9uKFwibW91c2VvdmVyXCIsIChkLCBpLCBub2RlcykgPT4ge1xuICAgICAgICAgICAgICAgIHN2Zy5zZWxlY3RBbGwoXCIuc2VyaWVzOm5vdCguc2VyaWVzLVwiICsgaSArIFwiKVwiKVxuICAgICAgICAgICAgICAgICAgICAuaW50ZXJydXB0KFwibGVnZW5kOmhpZ2hsaWdodFwiKVxuICAgICAgICAgICAgICAgICAgICAudHJhbnNpdGlvbihcImxlZ2VuZDpoaWdobGlnaHRcIilcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAwLjMpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbihcIm1vdXNlb3V0XCIsIChkLCBpLCBub2RlcykgPT4ge1xuICAgICAgICAgICAgICAgIHN2Zy5zZWxlY3RBbGwoXCIuc2VyaWVzXCIpXG4gICAgICAgICAgICAgICAgICAgIC5pbnRlcnJ1cHQoXCJsZWdlbmQ6aGlnaGxpZ2h0XCIpXG4gICAgICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKFwibGVnZW5kOmhpZ2hsaWdodFwiKVxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDEpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMClcbiAgICAgICAgICAgIC50cmFuc2l0aW9uKClcbiAgICAgICAgICAgIC5kdXJhdGlvbigxMDAwKVxuICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAxKTtcblxuICAgICAgICBjb25zdCBsZWdlbmRIZWlnaHQgPSBsZWdlbmQubm9kZSgpLmdldEJCb3goKS5oZWlnaHQ7XG4gICAgICAgIGxlZ2VuZC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKDAsXCIgKyAoaGVpZ2h0IC0gbGVnZW5kSGVpZ2h0KSArIFwiKVwiKTtcbiAgICAgICAgcmV0dXJuIGxlZ2VuZEhlaWdodDtcbiAgICB9XG59Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/Chart.js\n')},"./src/Colours.js":
/*!************************!*\
  !*** ./src/Colours.js ***!
  \************************/
/*! exports provided: colours */function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"colours\", function() { return colours; });\n// Copyright (C) 2013-2014, 2018 BrandsEye (PTY) LTD\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this\n// software and associated documentation files (the \"Software\"), to deal in the Software\n// without restriction, including without limitation the rights to use, copy, modify,\n//     merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following\n// conditions:\n//\n//     The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n//     INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n// CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\nlet colours = {\n  // **brandseye.colours.scheme** is our basic colour scheme.\n    scheme: [\n        '#58B6FF',\n        '#5473BD',\n        '#DF71FC',\n        '#9856B0',\n        '#ff58a3',\n        '#D22D6F',\n        '#fc6a4b',\n        '#E53E39',\n        '#FFD658',\n        '#E8AF44',\n        '#43C278',\n        '#318F58'\n    ],\n    // And **brandseye.colours.allColours** defines a large number of colours.\n    allColours: [\n        '#f0f8ff', '#faebd7', '#00ffff', '#7fffd4', '#f0ffff', '#f5f5dc', '#ffe4c4', '#000000', '#ffebcd', '#0000ff', '#8a2be2',\n        '#a52a2a', '#deb887', '#5f9ea0', '#7fff00', '#d2691e', '#ff7f50', '#6495ed', '#fff8dc', '#dc143c', '#00ffff', '#00008b',\n        '#008b8b', '#b8860b', '#a9a9a9', '#006400', '#bdb76b', '#8b008b', '#556b2f', '#ff8c00', '#9932cc', '#8b0000', '#e9967a',\n        '#8fbc8f', '#483d8b', '#2f4f4f', '#00ced1', '#9400d3', '#ff1493', '#00bfff', '#696969', '#1e90ff', '#d19275', '#b22222',\n        '#fffaf0', '#228b22', '#ff00ff', '#dcdcdc', '#f8f8ff', '#ffd700', '#daa520', '#808080', '#008000', '#adff2f', '#f0fff0',\n        '#ff69b4', '#cd5c5c', '#4b0082', '#fffff0', '#f0e68c', '#e6e6fa', '#fff0f5', '#7cfc00', '#fffacd', '#add8e6', '#f08080',\n        '#e0ffff', '#fafad2', '#d3d3d3', '#90ee90', '#ffb6c1', '#ffa07a', '#20b2aa', '#87cefa', '#8470ff', '#778899', '#b0c4de',\n        '#ffffe0', '#00ff00', '#32cd32', '#faf0e6', '#ff00ff', '#800000', '#66cdaa', '#0000cd', '#ba55d3', '#9370d8', '#3cb371',\n        '#7b68ee', '#00fa9a', '#48d1cc', '#c71585', '#191970', '#f5fffa', '#ffe4e1', '#ffe4b5', '#ffdead', '#000080', '#fdf5e6',\n        '#808000', '#6b8e23', '#ffa500', '#ff4500', '#da70d6', '#eee8aa', '#98fb98', '#afeeee', '#d87093', '#ffefd5', '#ffdab9',\n        '#cd853f', '#ffc0cb', '#dda0dd', '#b0e0e6', '#800080', '#ff0000', '#bc8f8f', '#4169e1', '#8b4513', '#fa8072', '#f4a460',\n        '#2e8b57', '#fff5ee', '#a0522d', '#c0c0c0', '#87ceeb', '#6a5acd', '#708090', '#fffafa', '#00ff7f', '#4682b4', '#d2b48c',\n        '#008080', '#d8bfd8', '#ff6347', '#40e0d0', '#ee82ee', '#d02090', '#f5deb3', '#ffffff', '#f5f5f5', '#ffff00', '#9acd32'\n    ],\n\n    // These are the new brandseye colours for 2018, defined in reporting v.4.5.8\n    eighteen: {\n      good: \"#00c9a0\",       // Bright Green\n      series: [\n        \"#eba25d\",           // Muted orange\n        \"#9cd261\",           // Green\n        \"#958cb5\",           // Purple\n      ],\n      lightGrey: \"#e9e9e9\",  // gridlines, bars and columns, neutral sentiment\n      midGrey: \"#c0c0c0\",    // table borders, bars and columns if light grey is too lightGrey\n      darkGrey: \"#444444\",   // All text\n      sentiment: {\n        positive: \"#00b0b9\", // blue\n        neutral: \"#e0e0e0\",  // light grey\n        negative: \"#ee2737\", // Red\n        net: \"#1c1f2a\"       // Elite\n      }\n    }\n\n\n\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvQ29sb3Vycy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2IzanMvLi9zcmMvQ29sb3Vycy5qcz8yY2RhIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoQykgMjAxMy0yMDE0LCAyMDE4IEJyYW5kc0V5ZSAoUFRZKSBMVERcbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXNcbi8vIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZVxuLy8gd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LFxuLy8gICAgIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG9cbi8vIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nXG4vLyBjb25kaXRpb25zOlxuLy9cbi8vICAgICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbi8vIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gICAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1IgSU1QTElFRCxcbi8vICAgICBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQVxuLy8gUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxuLy8gSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GXG4vLyBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkVcbi8vIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5cbmV4cG9ydCBsZXQgY29sb3VycyA9IHtcbiAgLy8gKipicmFuZHNleWUuY29sb3Vycy5zY2hlbWUqKiBpcyBvdXIgYmFzaWMgY29sb3VyIHNjaGVtZS5cbiAgICBzY2hlbWU6IFtcbiAgICAgICAgJyM1OEI2RkYnLFxuICAgICAgICAnIzU0NzNCRCcsXG4gICAgICAgICcjREY3MUZDJyxcbiAgICAgICAgJyM5ODU2QjAnLFxuICAgICAgICAnI2ZmNThhMycsXG4gICAgICAgICcjRDIyRDZGJyxcbiAgICAgICAgJyNmYzZhNGInLFxuICAgICAgICAnI0U1M0UzOScsXG4gICAgICAgICcjRkZENjU4JyxcbiAgICAgICAgJyNFOEFGNDQnLFxuICAgICAgICAnIzQzQzI3OCcsXG4gICAgICAgICcjMzE4RjU4J1xuICAgIF0sXG4gICAgLy8gQW5kICoqYnJhbmRzZXllLmNvbG91cnMuYWxsQ29sb3VycyoqIGRlZmluZXMgYSBsYXJnZSBudW1iZXIgb2YgY29sb3Vycy5cbiAgICBhbGxDb2xvdXJzOiBbXG4gICAgICAgICcjZjBmOGZmJywgJyNmYWViZDcnLCAnIzAwZmZmZicsICcjN2ZmZmQ0JywgJyNmMGZmZmYnLCAnI2Y1ZjVkYycsICcjZmZlNGM0JywgJyMwMDAwMDAnLCAnI2ZmZWJjZCcsICcjMDAwMGZmJywgJyM4YTJiZTInLFxuICAgICAgICAnI2E1MmEyYScsICcjZGViODg3JywgJyM1ZjllYTAnLCAnIzdmZmYwMCcsICcjZDI2OTFlJywgJyNmZjdmNTAnLCAnIzY0OTVlZCcsICcjZmZmOGRjJywgJyNkYzE0M2MnLCAnIzAwZmZmZicsICcjMDAwMDhiJyxcbiAgICAgICAgJyMwMDhiOGInLCAnI2I4ODYwYicsICcjYTlhOWE5JywgJyMwMDY0MDAnLCAnI2JkYjc2YicsICcjOGIwMDhiJywgJyM1NTZiMmYnLCAnI2ZmOGMwMCcsICcjOTkzMmNjJywgJyM4YjAwMDAnLCAnI2U5OTY3YScsXG4gICAgICAgICcjOGZiYzhmJywgJyM0ODNkOGInLCAnIzJmNGY0ZicsICcjMDBjZWQxJywgJyM5NDAwZDMnLCAnI2ZmMTQ5MycsICcjMDBiZmZmJywgJyM2OTY5NjknLCAnIzFlOTBmZicsICcjZDE5Mjc1JywgJyNiMjIyMjInLFxuICAgICAgICAnI2ZmZmFmMCcsICcjMjI4YjIyJywgJyNmZjAwZmYnLCAnI2RjZGNkYycsICcjZjhmOGZmJywgJyNmZmQ3MDAnLCAnI2RhYTUyMCcsICcjODA4MDgwJywgJyMwMDgwMDAnLCAnI2FkZmYyZicsICcjZjBmZmYwJyxcbiAgICAgICAgJyNmZjY5YjQnLCAnI2NkNWM1YycsICcjNGIwMDgyJywgJyNmZmZmZjAnLCAnI2YwZTY4YycsICcjZTZlNmZhJywgJyNmZmYwZjUnLCAnIzdjZmMwMCcsICcjZmZmYWNkJywgJyNhZGQ4ZTYnLCAnI2YwODA4MCcsXG4gICAgICAgICcjZTBmZmZmJywgJyNmYWZhZDInLCAnI2QzZDNkMycsICcjOTBlZTkwJywgJyNmZmI2YzEnLCAnI2ZmYTA3YScsICcjMjBiMmFhJywgJyM4N2NlZmEnLCAnIzg0NzBmZicsICcjNzc4ODk5JywgJyNiMGM0ZGUnLFxuICAgICAgICAnI2ZmZmZlMCcsICcjMDBmZjAwJywgJyMzMmNkMzInLCAnI2ZhZjBlNicsICcjZmYwMGZmJywgJyM4MDAwMDAnLCAnIzY2Y2RhYScsICcjMDAwMGNkJywgJyNiYTU1ZDMnLCAnIzkzNzBkOCcsICcjM2NiMzcxJyxcbiAgICAgICAgJyM3YjY4ZWUnLCAnIzAwZmE5YScsICcjNDhkMWNjJywgJyNjNzE1ODUnLCAnIzE5MTk3MCcsICcjZjVmZmZhJywgJyNmZmU0ZTEnLCAnI2ZmZTRiNScsICcjZmZkZWFkJywgJyMwMDAwODAnLCAnI2ZkZjVlNicsXG4gICAgICAgICcjODA4MDAwJywgJyM2YjhlMjMnLCAnI2ZmYTUwMCcsICcjZmY0NTAwJywgJyNkYTcwZDYnLCAnI2VlZThhYScsICcjOThmYjk4JywgJyNhZmVlZWUnLCAnI2Q4NzA5MycsICcjZmZlZmQ1JywgJyNmZmRhYjknLFxuICAgICAgICAnI2NkODUzZicsICcjZmZjMGNiJywgJyNkZGEwZGQnLCAnI2IwZTBlNicsICcjODAwMDgwJywgJyNmZjAwMDAnLCAnI2JjOGY4ZicsICcjNDE2OWUxJywgJyM4YjQ1MTMnLCAnI2ZhODA3MicsICcjZjRhNDYwJyxcbiAgICAgICAgJyMyZThiNTcnLCAnI2ZmZjVlZScsICcjYTA1MjJkJywgJyNjMGMwYzAnLCAnIzg3Y2VlYicsICcjNmE1YWNkJywgJyM3MDgwOTAnLCAnI2ZmZmFmYScsICcjMDBmZjdmJywgJyM0NjgyYjQnLCAnI2QyYjQ4YycsXG4gICAgICAgICcjMDA4MDgwJywgJyNkOGJmZDgnLCAnI2ZmNjM0NycsICcjNDBlMGQwJywgJyNlZTgyZWUnLCAnI2QwMjA5MCcsICcjZjVkZWIzJywgJyNmZmZmZmYnLCAnI2Y1ZjVmNScsICcjZmZmZjAwJywgJyM5YWNkMzInXG4gICAgXSxcblxuICAgIC8vIFRoZXNlIGFyZSB0aGUgbmV3IGJyYW5kc2V5ZSBjb2xvdXJzIGZvciAyMDE4LCBkZWZpbmVkIGluIHJlcG9ydGluZyB2LjQuNS44XG4gICAgZWlnaHRlZW46IHtcbiAgICAgIGdvb2Q6IFwiIzAwYzlhMFwiLCAgICAgICAvLyBCcmlnaHQgR3JlZW5cbiAgICAgIHNlcmllczogW1xuICAgICAgICBcIiNlYmEyNWRcIiwgICAgICAgICAgIC8vIE11dGVkIG9yYW5nZVxuICAgICAgICBcIiM5Y2QyNjFcIiwgICAgICAgICAgIC8vIEdyZWVuXG4gICAgICAgIFwiIzk1OGNiNVwiLCAgICAgICAgICAgLy8gUHVycGxlXG4gICAgICBdLFxuICAgICAgbGlnaHRHcmV5OiBcIiNlOWU5ZTlcIiwgIC8vIGdyaWRsaW5lcywgYmFycyBhbmQgY29sdW1ucywgbmV1dHJhbCBzZW50aW1lbnRcbiAgICAgIG1pZEdyZXk6IFwiI2MwYzBjMFwiLCAgICAvLyB0YWJsZSBib3JkZXJzLCBiYXJzIGFuZCBjb2x1bW5zIGlmIGxpZ2h0IGdyZXkgaXMgdG9vIGxpZ2h0R3JleVxuICAgICAgZGFya0dyZXk6IFwiIzQ0NDQ0NFwiLCAgIC8vIEFsbCB0ZXh0XG4gICAgICBzZW50aW1lbnQ6IHtcbiAgICAgICAgcG9zaXRpdmU6IFwiIzAwYjBiOVwiLCAvLyBibHVlXG4gICAgICAgIG5ldXRyYWw6IFwiI2UwZTBlMFwiLCAgLy8gbGlnaHQgZ3JleVxuICAgICAgICBuZWdhdGl2ZTogXCIjZWUyNzM3XCIsIC8vIFJlZFxuICAgICAgICBuZXQ6IFwiIzFjMWYyYVwiICAgICAgIC8vIEVsaXRlXG4gICAgICB9XG4gICAgfVxuXG5cblxufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/Colours.js\n")},"./src/ColumnChart.js":
/*!****************************!*\
  !*** ./src/ColumnChart.js ***!
  \****************************/
/*! exports provided: ColumnChart */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ColumnChart", function() { return ColumnChart; });\n/* harmony import */ var _Colours__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Colours */ "./src/Colours.js");\n/* harmony import */ var _Chart__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Chart */ "./src/Chart.js");\n// Copyright (C) 2013-2014, 2018 BrandsEye (PTY) LTD\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this\n// software and associated documentation files (the "Software"), to deal in the Software\n// without restriction, including without limitation the rights to use, copy, modify,\n//     merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following\n// conditions:\n//\n//     The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n//     INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n// CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n\n\nclass ColumnChart extends _Chart__WEBPACK_IMPORTED_MODULE_1__["Chart"] {\n\n    //------------------------------------------------------\n\n    data(data) {\n        if (!arguments.length) return this._data;\n        if (data && data[0].key === undefined) {\n            data = [\n                {\n                    key: "series 1",\n                    values: data\n                }\n            ];\n        }\n        this._data = data;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    element(element) {\n        if (!arguments.length) return this._element;\n        this._element = element;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    showLabels(show) {\n        if (!arguments.length) return this._show_labels;\n        this._show_labels = show;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    // todo dispatch\n    showLegend(show) {\n        if (!arguments.length) return this._show_legend;\n        this._show_legend = show;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    x(x) {\n        if (!arguments.length) return this._x;\n        this._x = x;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    y(y) {\n        if (!arguments.length) return this._y;\n        this._y = y;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    width(width) {\n        if (!arguments.length) return this._width;\n        this._width = width;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    height(height) {\n        if (!arguments.length) return this._height;\n        this._height = height;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    colours(colours) {\n        if (!arguments.length) return this._colours;\n        this._colours = colours;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    backgroundColour(colour) {\n        if (!arguments.length) return this._backgroundColour;\n        this._backgroundColour = colour || "#FFF"; // never set it to null.\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    tickFormat(format) {\n        if (!arguments.length) return this._tickFormat;\n        this._tickFormat = format;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    xAxisTickFormat(format) {\n        if (!arguments.length) return this._xAxisTickFormat;\n        this._xAxisTickFormat = format || (d => d.toString());\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    labelFormat(format) {\n        if (!arguments.length) return this._labelFormat;\n        this._labelFormat = format || (d => d.toString());\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    // todo missing\n    labelCompression(compression) {\n        if (!arguments.length) return this._compression;\n        this._compression = compression;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    //todo missing\n    dataAxisLabel(label) {\n        if (!arguments.length) return this._dataAxisLabel;\n        this._dataAxisLabel = label;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    tooltip(tooltip) {\n        if (!arguments.length) return this._tooltip;\n        this._tooltip = tooltip;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    forceY(force) {\n        if (!arguments.length) return this._forceY;\n        this._forceY = force;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n// todo missing\n    duration(duration) {\n        if (!arguments.length) return this._duration;\n        this._duration = duration;\n        return this;\n    }\n\n// todo missing\n    coarseness(coarseness) {\n        if (!arguments.length) return this._coarseness;\n        this._coarseness = coarseness;\n        return this;\n    }\n\n    // todo missing\n    padding(padding) {\n        if (!arguments.length) return this._padding;\n        this._padding = padding;\n        return this;\n    }\n\n    // todo missing\n    xAxisTooltips(tooltips) {\n        if (!arguments.length) return this._xAxisTooltips;\n        this._xAxisTooltips = tooltips;\n        return this;\n    }\n\n    xAxisOverride(override) {\n        if (!arguments.length) return this._xAxisOverride;\n        this._xAxisOverride = override;\n        return this;\n    }\n\n    interbarProportion(proportion) {\n        if (!arguments.length) return this._interbarProportion;\n        this._interbarProportion = proportion;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    dispatch() {\n        return this._dispatch;\n    }\n\n    //------------------------------------------------------\n\n    render() {\n        if (!this._element) throw new Error("No element set for ColumnChart. See #element()");\n        if (!this._data) {\n            console.warn("No data set for ColumnChart. See #data()");\n            return;\n        }\n\n        const data = this.getTransformedData();\n        const keys = this.getKeys();\n\n        //------------------------------------------------\n        // Set up the SVG area\n\n        let topLevel = d3.select(this._element).select("svg");\n        if (topLevel.empty()) {\n            topLevel = d3.select(this._element).append("svg");\n        }\n\n        topLevel\n            .style("width", this._width + "px")\n            .style("height", this._height + "px");\n\n\n        // ---------------------------------\n        // Layout the showLegend.\n        //\n        // We do this now because we need to know how much space the legend\n        // takes up in order to finish calculating the margins.\n\n        const legendHeight = this.renderLegend();\n\n        //----------------------------------\n        // Calculate margins.\n\n        const margin = {top: 20, right: 20, bottom: 40, left: 40};\n        margin.bottom += legendHeight ? legendHeight + 20 : 0;\n\n        if (this._dataAxisLabel) margin.left += 20 + 12;\n        if (data) {\n            let maxLabelLength = 0;\n            data.forEach(d => {\n                d.data.forEach(d => {\n                    let length = this._xAxisTickFormat(this._x(d)).length;\n                    if (length > maxLabelLength) maxLabelLength = length;\n                })\n            });\n            margin.bottom += maxLabelLength * 2 + 10;    // space for axes labels.\n        }\n\n        const width = this._width - margin.left - margin.right,\n            height = this._height - margin.top - margin.bottom;\n\n        //----------------------------------\n        // Calculate scales and so on.\n\n        const x = d3.scaleBand()\n            .range([0, width])\n            .padding(this._interbarProportion !== null ? this._interbarProportion : (this._data.length > 1 ? 0.08 : 0.1));\n\n        const xGroup = d3.scaleBand()\n            .padding(0);\n\n        const y = d3.scaleLinear()\n            .rangeRound([height, 0])\n            .nice();\n        this._xscale = x;\n        this._xgroupscale = xGroup;\n        this._yscale = y;\n\n        // Scale the range of the data in the domains\n        x.domain(data.map(d => d.key));\n        xGroup.rangeRound([0, x.bandwidth()]).domain(keys);\n        y.domain([0, d3.max(data, d => d3.max(d.data, d => d._y))]);\n\n        //------------------------------\n\n        let svg = topLevel.select(\'.main-group\');\n\n        if (svg.empty()) {\n            svg = topLevel\n                .append("g")\n                .attr("class", "main-group");\n        }\n\n        svg.attr("transform", "translate(" + margin.left + "," + margin.top + ")");\n\n        //---------------------------------\n        // Get rid of current labels.\n        svg.select(".chart-labels")\n            .remove();\n\n        //---------------------------------\n        // append the rectangles for the bar chart\n        let groups = svg.select(".bars").selectAll(\'.group\');\n\n        if (groups.empty()) {\n            groups = svg\n                .append("g")\n                .attr("class", "bars")\n                .selectAll(".group");\n        }\n\n        svg.select(".bars")\n            .attr("transform", "translate(0, " + height + "), scale(1, -1)")\n\n        groups = groups.data(data);\n\n        groups.exit().remove();\n\n        // Adding new groups, and hence adding new bars to those groups.\n        groups.enter()\n            .append("g")\n            .attr("class", "group")\n            .attr("transform", d => "translate(" + x(d.key) + ",0)")\n            .attr("width", x.bandwidth())\n            .attr("height", "100%")\n            .merge(groups)\n            .interrupt("groups:move")\n            .transition("groups:move")\n            .attr("transform", d => "translate(" + x(d.key) + ",0)")\n            .attr("width", x.bandwidth())\n            .each((s_d, s_i, nodes) => {\n                let group = d3.select(nodes[s_i])\n\n                let bars = group.selectAll(".bar")\n                    .data(s_d.data);\n\n                bars.exit().remove();\n\n                bars.interrupt("bar:move")     // Animate the bars to their new position.\n                    .transition("bar:move")\n                    .attr("width", xGroup.bandwidth())\n                    .attr("x", d => xGroup(d._key))\n                    .attr("y", 0);\n\n                bars.enter()\n                    .append("rect")\n                    .attr("class", (d, i) => "bar series series-" + i)\n                    .attr("x", d => xGroup(d._key))\n                    .attr("y", 0)\n                    .attr("width", xGroup.bandwidth())\n                    .attr("height", 0)\n                    .style("fill", (d, i) => this.getSeriesColour(i))\n                    .style("cursor", "pointer")\n                    .on("mouseover", (d, i, nodes) => { // Darken the bar on mouse over\n                        d3.select(nodes[i])\n                            .interrupt("hover:colour")\n                            .transition("hover:colour")\n                            .duration(400)\n                            .style("fill", d3.hcl(this.getSeriesColour(i)).darker())\n                        this._dispatch.call("tooltipShow", this, {\n                            e: d3.event,\n                            point: d,\n                            series: s_d,\n                            seriesIndex: s_i,\n                            value: d._y\n                        })\n                    })\n                    .on("mouseout", (d, i, nodes) => { // bar is regular colour on mouse out.\n                        d3.select(nodes[i])\n                            .interrupt("hover:colour")\n                            .transition("hover:colour")\n                            .duration(400)\n                            .style("fill", this.getSeriesColour(i));\n                        this._dispatch.call("tooltipHide", this);\n                    })\n                    .on("click auxclick", (d, i, nodes) => {\n                        this._dispatch.call("elementClick", this, {\n                            e: d3.event,\n                            point: d,\n                            series: d._series,\n                            seriesIndex: s_i,\n                            value: this._y(d)\n                        })\n                    })\n                    .merge(bars)\n                    .interrupt("bar:growth")    // Animate bars growing.\n                    .transition("bar:growth")\n                    .delay((d) => {\n                        return this.calcBarGrowth(s_i, nodes.length);\n                    })\n                    .duration(this._duration)\n                    .style("fill", (d, i) => this.getSeriesColour(i))\n                    .attr("height", d => height - y(d._y));\n\n            })\n\n        // ---------------------------------\n        // Labels loaded after our first bar grows.\n        if (this._show_labels) {\n            svg.transition("bar:growth")\n                .on("end", (d, i, nodes) => {\n                    if (i < nodes.length - 1) return;\n                    this.renderLabels(svg, data, x, xGroup, y);\n                })\n        }\n\n        // ---------------------------------\n        // Draw the y axis data label.\n\n        if (this._dataAxisLabel) {\n            this.renderDataAxisLabel(height, margin);\n        }\n\n        // ---------------------------------\n        // Set the background colour\n\n        d3.select(this._element).select(".background").remove();\n        if (this._backgroundColour) {\n            d3.select(this._element).select("svg")\n                .append("rect")\n                .attr("class", "background")\n                .attr("width", "100%")\n                .attr("height", "100%")\n                .style("fill", this._backgroundColour)\n                .lower();\n        }\n\n        //---------------------------------\n        // add the Y gridlines\n        svg.call(this.grid, width, d3.axisLeft(y).ticks(5));\n\n        //---------------------------------\n        // axes\n        svg.call(this.xaxis, height, x.bandwidth(), d3.axisBottom(x).tickSize(0).tickPadding(5).tickFormat(this._xAxisTickFormat));\n        svg.call(this.yaxis, d3.axisLeft(y).ticks(5).tickFormat(this._tickFormat));\n    }\n\n    //------------------------------------------------------\n\n    /*\n     * Returns an object with two functions, #show() and #hide(),\n     * to show and hide the labels.\n     */\n    labels() {\n        return {\n\n            show: () => {\n                if (this._element) {\n                    let selection = this._element,\n                        data = this.getTransformedData(),\n                        xscale = this._xscale,\n                        xgroup = this._xgroupscale,\n                        yscale = this._yscale;\n\n                    if (selection) selection = d3.select(this._element).select("svg").select("g");\n                    if (!selection.empty() && data && xscale && yscale && xgroup) {\n                        let labels = selection.select(\'.chart-labels\');\n                        if (!labels.empty()) return;\n                        labels.remove()\n                        this.renderLabels(selection, data, xscale, xgroup, yscale, false);\n                    }\n                }\n\n            },\n\n            hide: () => {\n                if (this._element) {\n                    d3.select(this._element)\n                        .select(\'.chart-labels\')\n                        .interrupt("labels")\n                        .interrupt("labels:fade")\n                        .transition("labels:fade")\n                        .style("opacity", 0)\n                        .on("end", (d, i, nodes) => {\n                            d3.select(nodes[i]).remove();\n                        })\n                }\n            }\n        }\n    }\n\n    //------------------------------------------------------\n\n    renderLabels(selection, data, xscale, xgroup, yscale, animate) {\n        animate = animate === undefined ? true : animate;\n        selection.selectAll(".chart-labels").remove();\n\n        let labels = selection.append("g")\n            .attr("class", "chart-labels")\n            // .selectAll(".chart-label")\n            .selectAll(".label-group")\n            .data(data)\n\n        let maxWidth = 0;     // For calculating the max width of text.\n        let fontSize = 12;    // Our initial font size.\n        const buffer = 5;     // Buffer space between words and the top of a bar.\n        const calcDy = (ypos) => ypos < 10 ? fontSize + buffer : -buffer;\n\n        // Want to figure out if the label is too dark / light for the\n        // bar.\n        const getInvertedColor = (i) => {\n            let invertedColor = d3.hcl(this.getSeriesColour(i));\n            invertedColor.l += Math.min(invertedColor.l + 50, 100);\n            return invertedColor;\n        };\n        const shouldInvert = (i) => d3.hcl(this.getSeriesColour(i)).l < 60;\n\n        labels.enter().each((series, s_i, s_nodes) => {\n            let group = d3.select(s_nodes[s_i])\n                .append("g")\n                .attr("class", "label-group")\n                .attr("transform", d => "translate(" + xscale(d.key) + ",0)")\n                .selectAll(".chart-label")\n                .data(series.data)\n                .enter()\n                .each((d, i, nodes) => {\n                    let ypos = yscale(d._y);\n                    let dy = calcDy(ypos);\n                    let text = d3.select(nodes[i])\n                        .append("text")\n                        .text(this._labelFormat(d._y))\n                        .attr("class", "chart-label")\n                        .attr("y", ypos)\n                        .attr("dx", animate ? -15 : 0)\n                        .attr("dy", dy)\n                        .style("opacity", 0)\n                        .style("pointer-events", "none")\n                        // .style("font-family", "Open Sans, sans-serif")\n                        // .style("font-weight", "normal")\n                        // .style("font-size", fontSize + "px")\n                        .style("fill", dy > 0 && shouldInvert(i)? getInvertedColor(i).toString() : _Colours__WEBPACK_IMPORTED_MODULE_0__["colours"].eighteen.darkGrey);\n\n                    // Set the x position, which is based on width.\n                    const width = text.node().getBBox().width;\n                    maxWidth = Math.max(width, maxWidth);\n                    text\n                        .attr("x", xgroup(d._key) + xgroup.bandwidth() / 2 - width / 2);\n\n                    text\n                        .transition("labels")\n                        .delay(() => animate ? this.calcBarGrowth(s_i, s_nodes.length) : 0) // Delay in lockstep with bar growth.\n                        .duration(this._duration)\n                        .attr("dx", 0)\n                        .style("opacity", 1)\n                })\n        })\n\n\n        // Figure out if we don\'t have enough space to show our labels.\n        // We then want to resize, if possible.\n        if (xgroup.bandwidth() < maxWidth * 1.05) {\n            let scale = maxWidth / xgroup.bandwidth() * 1.05;\n            fontSize = Math.floor(fontSize / scale);\n\n            if (fontSize < 8) {\n                // The labels are too small.\n                labels.enter().selectAll("text").remove();\n            } else {\n                labels.enter()\n                    .merge(labels)\n                    .selectAll("text")\n                    .style("font-size", fontSize + "px")\n                    .each((d, i, nodes) => {\n                        const text = d3.select(nodes[i]);\n                        const width = text.node().getBBox().width;\n                        const dy = calcDy(yscale(d._y));\n\n                        text\n                            .attr("x", xgroup(d._key) + xgroup.bandwidth() / 2 - width / 2)\n                            .style("fill", dy > 0 && shouldInvert(i) ? getInvertedColor(i).toString() : _Colours__WEBPACK_IMPORTED_MODULE_0__["colours"].eighteen.darkGrey)\n                            .attr("dy", dy);\n                    })\n            }\n        }\n    }\n\n    //------------------------------------------------------\n\n    renderDataAxisLabel(height, margins) {\n        let svg = d3.select(this._element).select(\'svg\');\n        svg.selectAll(".data-labels").remove();\n\n        if (!this._dataAxisLabel) return;\n        let text = this._dataAxisLabel;\n        if (text.long) text = text.long;\n\n        let x = -(margins.top + height / 2);\n\n        let label = svg.append("g")\n            .attr("class", "data-labels")\n            .append("text")\n            .text(text)\n            .attr("transform", "rotate(-90 0,0) translate(" + x + ", 20)")\n            // .style("font-family", "Open Sans, sans-serif")\n            // .style("font-size", "12px")\n            // .style("font-style", "italic")\n            .style("fill", _Colours__WEBPACK_IMPORTED_MODULE_0__["colours"].eighteen.darkGrey);\n\n        let width = label.node().getBBox().width;\n        if (width >= height && this._dataAxisLabel.short) {\n            label.text(this._dataAxisLabel.short);\n            width = label.node().getBBox().width;\n        }\n\n        label.attr("dx", -width / 2);\n    }\n\n    //------------------------------------------------------\n\n    grid(selection, width, axis) {\n        selection.select(".grid").remove();\n\n        let grid = selection.append("g")\n            .attr("class", "grid")\n            .call(axis\n                .tickSize(-width)\n                .tickFormat("")\n            );\n\n        grid.selectAll("line")\n            .style("stroke", _Colours__WEBPACK_IMPORTED_MODULE_0__["colours"].eighteen.lightGrey);\n        grid.selectAll(".domain").remove();\n\n        grid\n            .lower() // Always ensure that this is earlier in the dom. Things must be drawn on top of it.\n            .style("opacity", 0)\n            .transition()\n            .delay(500)\n            .duration(500)\n            .style("opacity", 1);\n    }\n\n    //------------------------------------------------------\n\n    xaxis(selection, height, width, xaxis) {\n        selection.select(".x-axis").remove();\n        let axis = selection.append("g")\n            .attr("class", "x-axis")\n            .attr("transform", "translate(0," + height + ")")\n            .style("opacity", 0)\n            .call(xaxis);\n\n        axis.select(".domain").remove();\n\n        let max = 0;\n        const fontSize = 12;\n        axis.selectAll("text")\n            // .style("font-family", "Open Sans, sans-serif")\n            // .style("font-size", fontSize + "px")\n            .style("fill", _Colours__WEBPACK_IMPORTED_MODULE_0__["colours"].eighteen.darkGrey)\n            .nodes()\n            .forEach(text => max = Math.max(max, text.getBBox().width));\n\n        if (max >= width - 10) {\n            const bad = max >= width * 2;\n            const angle = bad ? -90 : -30;\n            const fontSize = width <= 13 ? 8 : 12;\n            const x = bad ? -fontSize : 0;\n            const y = bad ? 5 : 2;\n\n            axis.selectAll("text")\n                .style(\'text-anchor\', \'end\')\n                .style("font-size", fontSize + "px")\n                .attr("transform", () => "translate(" + x + "," + y + ") rotate(" + angle + " 0,0)")\n        }\n\n        axis\n            .transition()\n            .duration(1000)\n            .style("opacity", 1);\n    }\n\n    //------------------------------------------------------\n\n    yaxis(selection, axis) {\n        selection.select(".y-axis").remove();\n        let x = selection.append("g")\n            .attr("class", "y-axis")\n            .call(axis.tickSize(0).tickPadding(10))\n            .style("opacity", 0)\n            .transition()\n            .duration(1000)\n            .style("opacity", 1);\n\n        x.selectAll("text")\n            // .style("font-family", "Open Sans, sans-serif")\n            .style("fill", _Colours__WEBPACK_IMPORTED_MODULE_0__["colours"].eighteen.darkGrey)\n    }\n\n    //------------------------------------------------------\n\n    calcBarGrowth(i, max) {\n        if (max < 10) return i * this._BAR_GROWTH / 2;\n        if (max < 35) return i * this._BAR_GROWTH / 4;\n        return 1;\n    }\n\n    getSeriesColour(i) {\n        if (i < 0 || !this._colours) return _Colours__WEBPACK_IMPORTED_MODULE_0__["colours"].eighteen.midGrey;\n\n        i = i % this._colours.length;\n        return this._colours[i];\n    }\n\n    getSortedData() {\n        let data = this._data;\n        if (!data || !data.length) return [];\n\n        data = this._data.sort((lhs, rhs) => {\n            lhs = lhs.key.toLowerCase();\n            rhs = rhs.key.toLowerCase();\n\n            if (lhs === rhs) return 0;\n            if (lhs < rhs) return -1;\n            return 1;\n        });\n\n        return data;\n    }\n\n    getTransformedData() {\n        let data = this.getSortedData();\n        if (!data || !data.length) return [];\n\n        let results = [];\n\n        const getX = d => this._xAxisOverride ? this._xAxisOverride[this._x(d)] : this._x(d);\n\n        data.forEach((series, s_i) => {\n            series.values.forEach((d, d_i) => {\n                let field = results.find(bucket => bucket.key === getX(d));\n                if (!field) {\n                    field = {\n                        data: [],\n                        key: getX(d)\n                    };\n                    results.push(field);\n                }\n\n                field.data.push(Object.assign({\n                    _series: series,\n                    _s_i: s_i,\n                    _key: series.key,\n                    _y: this._y(d)\n                }, d));\n            })\n        });\n\n        return results;\n    }\n\n    getKeys() {\n        let data = this._data;\n        if (!data || !data.length) return [];\n\n        return [...new Set(data.map(d => d.key))]\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvQ29sdW1uQ2hhcnQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9iM2pzLy4vc3JjL0NvbHVtbkNoYXJ0LmpzPzNlNDAiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChDKSAyMDEzLTIwMTQsIDIwMTggQnJhbmRzRXllIChQVFkpIExURFxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpc1xuLy8gc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlXG4vLyB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksXG4vLyAgICAgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0b1xuLy8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcbi8vIGNvbmRpdGlvbnM6XG4vL1xuLy8gICAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuLy8gY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyAgICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUiBJTVBMSUVELFxuLy8gICAgIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBXG4vLyBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUXG4vLyBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0Zcbi8vIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRVxuLy8gT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCB7Y29sb3Vyc30gZnJvbSAnLi9Db2xvdXJzJztcbmltcG9ydCB7Q2hhcnR9IGZyb20gJy4vQ2hhcnQnO1xuXG5cbmV4cG9ydCBjbGFzcyBDb2x1bW5DaGFydCBleHRlbmRzIENoYXJ0IHtcblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBkYXRhKGRhdGEpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fZGF0YTtcbiAgICAgICAgaWYgKGRhdGEgJiYgZGF0YVswXS5rZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZGF0YSA9IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGtleTogXCJzZXJpZXMgMVwiLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZXM6IGRhdGFcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgZWxlbWVudChlbGVtZW50KSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX2VsZW1lbnQ7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgc2hvd0xhYmVscyhzaG93KSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3Nob3dfbGFiZWxzO1xuICAgICAgICB0aGlzLl9zaG93X2xhYmVscyA9IHNob3c7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvLyB0b2RvIGRpc3BhdGNoXG4gICAgc2hvd0xlZ2VuZChzaG93KSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3Nob3dfbGVnZW5kO1xuICAgICAgICB0aGlzLl9zaG93X2xlZ2VuZCA9IHNob3c7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB4KHgpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5feDtcbiAgICAgICAgdGhpcy5feCA9IHg7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB5KHkpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5feTtcbiAgICAgICAgdGhpcy5feSA9IHk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB3aWR0aCh3aWR0aCkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl93aWR0aDtcbiAgICAgICAgdGhpcy5fd2lkdGggPSB3aWR0aDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGhlaWdodChoZWlnaHQpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5faGVpZ2h0O1xuICAgICAgICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBjb2xvdXJzKGNvbG91cnMpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fY29sb3VycztcbiAgICAgICAgdGhpcy5fY29sb3VycyA9IGNvbG91cnM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBiYWNrZ3JvdW5kQ29sb3VyKGNvbG91cikge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9iYWNrZ3JvdW5kQ29sb3VyO1xuICAgICAgICB0aGlzLl9iYWNrZ3JvdW5kQ29sb3VyID0gY29sb3VyIHx8IFwiI0ZGRlwiOyAvLyBuZXZlciBzZXQgaXQgdG8gbnVsbC5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHRpY2tGb3JtYXQoZm9ybWF0KSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3RpY2tGb3JtYXQ7XG4gICAgICAgIHRoaXMuX3RpY2tGb3JtYXQgPSBmb3JtYXQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB4QXhpc1RpY2tGb3JtYXQoZm9ybWF0KSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3hBeGlzVGlja0Zvcm1hdDtcbiAgICAgICAgdGhpcy5feEF4aXNUaWNrRm9ybWF0ID0gZm9ybWF0IHx8IChkID0+IGQudG9TdHJpbmcoKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBsYWJlbEZvcm1hdChmb3JtYXQpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fbGFiZWxGb3JtYXQ7XG4gICAgICAgIHRoaXMuX2xhYmVsRm9ybWF0ID0gZm9ybWF0IHx8IChkID0+IGQudG9TdHJpbmcoKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvLyB0b2RvIG1pc3NpbmdcbiAgICBsYWJlbENvbXByZXNzaW9uKGNvbXByZXNzaW9uKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX2NvbXByZXNzaW9uO1xuICAgICAgICB0aGlzLl9jb21wcmVzc2lvbiA9IGNvbXByZXNzaW9uO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLy90b2RvIG1pc3NpbmdcbiAgICBkYXRhQXhpc0xhYmVsKGxhYmVsKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX2RhdGFBeGlzTGFiZWw7XG4gICAgICAgIHRoaXMuX2RhdGFBeGlzTGFiZWwgPSBsYWJlbDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHRvb2x0aXAodG9vbHRpcCkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl90b29sdGlwO1xuICAgICAgICB0aGlzLl90b29sdGlwID0gdG9vbHRpcDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGZvcmNlWShmb3JjZSkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9mb3JjZVk7XG4gICAgICAgIHRoaXMuX2ZvcmNlWSA9IGZvcmNlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vLyB0b2RvIG1pc3NpbmdcbiAgICBkdXJhdGlvbihkdXJhdGlvbikge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9kdXJhdGlvbjtcbiAgICAgICAgdGhpcy5fZHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4vLyB0b2RvIG1pc3NpbmdcbiAgICBjb2Fyc2VuZXNzKGNvYXJzZW5lc3MpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fY29hcnNlbmVzcztcbiAgICAgICAgdGhpcy5fY29hcnNlbmVzcyA9IGNvYXJzZW5lc3M7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIHRvZG8gbWlzc2luZ1xuICAgIHBhZGRpbmcocGFkZGluZykge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9wYWRkaW5nO1xuICAgICAgICB0aGlzLl9wYWRkaW5nID0gcGFkZGluZztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gdG9kbyBtaXNzaW5nXG4gICAgeEF4aXNUb29sdGlwcyh0b29sdGlwcykge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl94QXhpc1Rvb2x0aXBzO1xuICAgICAgICB0aGlzLl94QXhpc1Rvb2x0aXBzID0gdG9vbHRpcHM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHhBeGlzT3ZlcnJpZGUob3ZlcnJpZGUpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5feEF4aXNPdmVycmlkZTtcbiAgICAgICAgdGhpcy5feEF4aXNPdmVycmlkZSA9IG92ZXJyaWRlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpbnRlcmJhclByb3BvcnRpb24ocHJvcG9ydGlvbikge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9pbnRlcmJhclByb3BvcnRpb247XG4gICAgICAgIHRoaXMuX2ludGVyYmFyUHJvcG9ydGlvbiA9IHByb3BvcnRpb247XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBkaXNwYXRjaCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc3BhdGNoO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGlmICghdGhpcy5fZWxlbWVudCkgdGhyb3cgbmV3IEVycm9yKFwiTm8gZWxlbWVudCBzZXQgZm9yIENvbHVtbkNoYXJ0LiBTZWUgI2VsZW1lbnQoKVwiKTtcbiAgICAgICAgaWYgKCF0aGlzLl9kYXRhKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJObyBkYXRhIHNldCBmb3IgQ29sdW1uQ2hhcnQuIFNlZSAjZGF0YSgpXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMuZ2V0VHJhbnNmb3JtZWREYXRhKCk7XG4gICAgICAgIGNvbnN0IGtleXMgPSB0aGlzLmdldEtleXMoKTtcblxuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBTZXQgdXAgdGhlIFNWRyBhcmVhXG5cbiAgICAgICAgbGV0IHRvcExldmVsID0gZDMuc2VsZWN0KHRoaXMuX2VsZW1lbnQpLnNlbGVjdChcInN2Z1wiKTtcbiAgICAgICAgaWYgKHRvcExldmVsLmVtcHR5KCkpIHtcbiAgICAgICAgICAgIHRvcExldmVsID0gZDMuc2VsZWN0KHRoaXMuX2VsZW1lbnQpLmFwcGVuZChcInN2Z1wiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRvcExldmVsXG4gICAgICAgICAgICAuc3R5bGUoXCJ3aWR0aFwiLCB0aGlzLl93aWR0aCArIFwicHhcIilcbiAgICAgICAgICAgIC5zdHlsZShcImhlaWdodFwiLCB0aGlzLl9oZWlnaHQgKyBcInB4XCIpO1xuXG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIExheW91dCB0aGUgc2hvd0xlZ2VuZC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gV2UgZG8gdGhpcyBub3cgYmVjYXVzZSB3ZSBuZWVkIHRvIGtub3cgaG93IG11Y2ggc3BhY2UgdGhlIGxlZ2VuZFxuICAgICAgICAvLyB0YWtlcyB1cCBpbiBvcmRlciB0byBmaW5pc2ggY2FsY3VsYXRpbmcgdGhlIG1hcmdpbnMuXG5cbiAgICAgICAgY29uc3QgbGVnZW5kSGVpZ2h0ID0gdGhpcy5yZW5kZXJMZWdlbmQoKTtcblxuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gQ2FsY3VsYXRlIG1hcmdpbnMuXG5cbiAgICAgICAgY29uc3QgbWFyZ2luID0ge3RvcDogMjAsIHJpZ2h0OiAyMCwgYm90dG9tOiA0MCwgbGVmdDogNDB9O1xuICAgICAgICBtYXJnaW4uYm90dG9tICs9IGxlZ2VuZEhlaWdodCA/IGxlZ2VuZEhlaWdodCArIDIwIDogMDtcblxuICAgICAgICBpZiAodGhpcy5fZGF0YUF4aXNMYWJlbCkgbWFyZ2luLmxlZnQgKz0gMjAgKyAxMjtcbiAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgIGxldCBtYXhMYWJlbExlbmd0aCA9IDA7XG4gICAgICAgICAgICBkYXRhLmZvckVhY2goZCA9PiB7XG4gICAgICAgICAgICAgICAgZC5kYXRhLmZvckVhY2goZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBsZW5ndGggPSB0aGlzLl94QXhpc1RpY2tGb3JtYXQodGhpcy5feChkKSkubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGVuZ3RoID4gbWF4TGFiZWxMZW5ndGgpIG1heExhYmVsTGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG1hcmdpbi5ib3R0b20gKz0gbWF4TGFiZWxMZW5ndGggKiAyICsgMTA7ICAgIC8vIHNwYWNlIGZvciBheGVzIGxhYmVscy5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHdpZHRoID0gdGhpcy5fd2lkdGggLSBtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodCxcbiAgICAgICAgICAgIGhlaWdodCA9IHRoaXMuX2hlaWdodCAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tO1xuXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBDYWxjdWxhdGUgc2NhbGVzIGFuZCBzbyBvbi5cblxuICAgICAgICBjb25zdCB4ID0gZDMuc2NhbGVCYW5kKClcbiAgICAgICAgICAgIC5yYW5nZShbMCwgd2lkdGhdKVxuICAgICAgICAgICAgLnBhZGRpbmcodGhpcy5faW50ZXJiYXJQcm9wb3J0aW9uICE9PSBudWxsID8gdGhpcy5faW50ZXJiYXJQcm9wb3J0aW9uIDogKHRoaXMuX2RhdGEubGVuZ3RoID4gMSA/IDAuMDggOiAwLjEpKTtcblxuICAgICAgICBjb25zdCB4R3JvdXAgPSBkMy5zY2FsZUJhbmQoKVxuICAgICAgICAgICAgLnBhZGRpbmcoMCk7XG5cbiAgICAgICAgY29uc3QgeSA9IGQzLnNjYWxlTGluZWFyKClcbiAgICAgICAgICAgIC5yYW5nZVJvdW5kKFtoZWlnaHQsIDBdKVxuICAgICAgICAgICAgLm5pY2UoKTtcbiAgICAgICAgdGhpcy5feHNjYWxlID0geDtcbiAgICAgICAgdGhpcy5feGdyb3Vwc2NhbGUgPSB4R3JvdXA7XG4gICAgICAgIHRoaXMuX3lzY2FsZSA9IHk7XG5cbiAgICAgICAgLy8gU2NhbGUgdGhlIHJhbmdlIG9mIHRoZSBkYXRhIGluIHRoZSBkb21haW5zXG4gICAgICAgIHguZG9tYWluKGRhdGEubWFwKGQgPT4gZC5rZXkpKTtcbiAgICAgICAgeEdyb3VwLnJhbmdlUm91bmQoWzAsIHguYmFuZHdpZHRoKCldKS5kb21haW4oa2V5cyk7XG4gICAgICAgIHkuZG9tYWluKFswLCBkMy5tYXgoZGF0YSwgZCA9PiBkMy5tYXgoZC5kYXRhLCBkID0+IGQuX3kpKV0pO1xuXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgbGV0IHN2ZyA9IHRvcExldmVsLnNlbGVjdCgnLm1haW4tZ3JvdXAnKTtcblxuICAgICAgICBpZiAoc3ZnLmVtcHR5KCkpIHtcbiAgICAgICAgICAgIHN2ZyA9IHRvcExldmVsXG4gICAgICAgICAgICAgICAgLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwibWFpbi1ncm91cFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN2Zy5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgbWFyZ2luLmxlZnQgKyBcIixcIiArIG1hcmdpbi50b3AgKyBcIilcIik7XG5cbiAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gR2V0IHJpZCBvZiBjdXJyZW50IGxhYmVscy5cbiAgICAgICAgc3ZnLnNlbGVjdChcIi5jaGFydC1sYWJlbHNcIilcbiAgICAgICAgICAgIC5yZW1vdmUoKTtcblxuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBhcHBlbmQgdGhlIHJlY3RhbmdsZXMgZm9yIHRoZSBiYXIgY2hhcnRcbiAgICAgICAgbGV0IGdyb3VwcyA9IHN2Zy5zZWxlY3QoXCIuYmFyc1wiKS5zZWxlY3RBbGwoJy5ncm91cCcpO1xuXG4gICAgICAgIGlmIChncm91cHMuZW1wdHkoKSkge1xuICAgICAgICAgICAgZ3JvdXBzID0gc3ZnXG4gICAgICAgICAgICAgICAgLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwiYmFyc1wiKVxuICAgICAgICAgICAgICAgIC5zZWxlY3RBbGwoXCIuZ3JvdXBcIik7XG4gICAgICAgIH1cblxuICAgICAgICBzdmcuc2VsZWN0KFwiLmJhcnNcIilcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKDAsIFwiICsgaGVpZ2h0ICsgXCIpLCBzY2FsZSgxLCAtMSlcIilcblxuICAgICAgICBncm91cHMgPSBncm91cHMuZGF0YShkYXRhKTtcblxuICAgICAgICBncm91cHMuZXhpdCgpLnJlbW92ZSgpO1xuXG4gICAgICAgIC8vIEFkZGluZyBuZXcgZ3JvdXBzLCBhbmQgaGVuY2UgYWRkaW5nIG5ldyBiYXJzIHRvIHRob3NlIGdyb3Vwcy5cbiAgICAgICAgZ3JvdXBzLmVudGVyKClcbiAgICAgICAgICAgIC5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwiZ3JvdXBcIilcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIGQgPT4gXCJ0cmFuc2xhdGUoXCIgKyB4KGQua2V5KSArIFwiLDApXCIpXG4gICAgICAgICAgICAuYXR0cihcIndpZHRoXCIsIHguYmFuZHdpZHRoKCkpXG4gICAgICAgICAgICAuYXR0cihcImhlaWdodFwiLCBcIjEwMCVcIilcbiAgICAgICAgICAgIC5tZXJnZShncm91cHMpXG4gICAgICAgICAgICAuaW50ZXJydXB0KFwiZ3JvdXBzOm1vdmVcIilcbiAgICAgICAgICAgIC50cmFuc2l0aW9uKFwiZ3JvdXBzOm1vdmVcIilcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIGQgPT4gXCJ0cmFuc2xhdGUoXCIgKyB4KGQua2V5KSArIFwiLDApXCIpXG4gICAgICAgICAgICAuYXR0cihcIndpZHRoXCIsIHguYmFuZHdpZHRoKCkpXG4gICAgICAgICAgICAuZWFjaCgoc19kLCBzX2ksIG5vZGVzKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGdyb3VwID0gZDMuc2VsZWN0KG5vZGVzW3NfaV0pXG5cbiAgICAgICAgICAgICAgICBsZXQgYmFycyA9IGdyb3VwLnNlbGVjdEFsbChcIi5iYXJcIilcbiAgICAgICAgICAgICAgICAgICAgLmRhdGEoc19kLmRhdGEpO1xuXG4gICAgICAgICAgICAgICAgYmFycy5leGl0KCkucmVtb3ZlKCk7XG5cbiAgICAgICAgICAgICAgICBiYXJzLmludGVycnVwdChcImJhcjptb3ZlXCIpICAgICAvLyBBbmltYXRlIHRoZSBiYXJzIHRvIHRoZWlyIG5ldyBwb3NpdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgLnRyYW5zaXRpb24oXCJiYXI6bW92ZVwiKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcIndpZHRoXCIsIHhHcm91cC5iYW5kd2lkdGgoKSlcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIGQgPT4geEdyb3VwKGQuX2tleSkpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFwieVwiLCAwKTtcblxuICAgICAgICAgICAgICAgIGJhcnMuZW50ZXIoKVxuICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKFwicmVjdFwiKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIChkLCBpKSA9PiBcImJhciBzZXJpZXMgc2VyaWVzLVwiICsgaSlcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIGQgPT4geEdyb3VwKGQuX2tleSkpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFwieVwiLCAwKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcIndpZHRoXCIsIHhHcm91cC5iYW5kd2lkdGgoKSlcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgMClcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCAoZCwgaSkgPT4gdGhpcy5nZXRTZXJpZXNDb2xvdXIoaSkpXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZShcImN1cnNvclwiLCBcInBvaW50ZXJcIilcbiAgICAgICAgICAgICAgICAgICAgLm9uKFwibW91c2VvdmVyXCIsIChkLCBpLCBub2RlcykgPT4geyAvLyBEYXJrZW4gdGhlIGJhciBvbiBtb3VzZSBvdmVyXG4gICAgICAgICAgICAgICAgICAgICAgICBkMy5zZWxlY3Qobm9kZXNbaV0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmludGVycnVwdChcImhvdmVyOmNvbG91clwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKFwiaG92ZXI6Y29sb3VyXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKDQwMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIGQzLmhjbCh0aGlzLmdldFNlcmllc0NvbG91cihpKSkuZGFya2VyKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXNwYXRjaC5jYWxsKFwidG9vbHRpcFNob3dcIiwgdGhpcywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGU6IGQzLmV2ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50OiBkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllczogc19kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllc0luZGV4OiBzX2ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGQuX3lcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5vbihcIm1vdXNlb3V0XCIsIChkLCBpLCBub2RlcykgPT4geyAvLyBiYXIgaXMgcmVndWxhciBjb2xvdXIgb24gbW91c2Ugb3V0LlxuICAgICAgICAgICAgICAgICAgICAgICAgZDMuc2VsZWN0KG5vZGVzW2ldKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5pbnRlcnJ1cHQoXCJob3Zlcjpjb2xvdXJcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudHJhbnNpdGlvbihcImhvdmVyOmNvbG91clwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbig0MDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCB0aGlzLmdldFNlcmllc0NvbG91cihpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXNwYXRjaC5jYWxsKFwidG9vbHRpcEhpZGVcIiwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5vbihcImNsaWNrIGF1eGNsaWNrXCIsIChkLCBpLCBub2RlcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlzcGF0Y2guY2FsbChcImVsZW1lbnRDbGlja1wiLCB0aGlzLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZTogZDMuZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQ6IGQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzOiBkLl9zZXJpZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzSW5kZXg6IHNfaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy5feShkKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLm1lcmdlKGJhcnMpXG4gICAgICAgICAgICAgICAgICAgIC5pbnRlcnJ1cHQoXCJiYXI6Z3Jvd3RoXCIpICAgIC8vIEFuaW1hdGUgYmFycyBncm93aW5nLlxuICAgICAgICAgICAgICAgICAgICAudHJhbnNpdGlvbihcImJhcjpncm93dGhcIilcbiAgICAgICAgICAgICAgICAgICAgLmRlbGF5KChkKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jYWxjQmFyR3Jvd3RoKHNfaSwgbm9kZXMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKHRoaXMuX2R1cmF0aW9uKVxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIChkLCBpKSA9PiB0aGlzLmdldFNlcmllc0NvbG91cihpKSlcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgZCA9PiBoZWlnaHQgLSB5KGQuX3kpKTtcblxuICAgICAgICAgICAgfSlcblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gTGFiZWxzIGxvYWRlZCBhZnRlciBvdXIgZmlyc3QgYmFyIGdyb3dzLlxuICAgICAgICBpZiAodGhpcy5fc2hvd19sYWJlbHMpIHtcbiAgICAgICAgICAgIHN2Zy50cmFuc2l0aW9uKFwiYmFyOmdyb3d0aFwiKVxuICAgICAgICAgICAgICAgIC5vbihcImVuZFwiLCAoZCwgaSwgbm9kZXMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPCBub2Rlcy5sZW5ndGggLSAxKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyTGFiZWxzKHN2ZywgZGF0YSwgeCwgeEdyb3VwLCB5KTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIERyYXcgdGhlIHkgYXhpcyBkYXRhIGxhYmVsLlxuXG4gICAgICAgIGlmICh0aGlzLl9kYXRhQXhpc0xhYmVsKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlckRhdGFBeGlzTGFiZWwoaGVpZ2h0LCBtYXJnaW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIFNldCB0aGUgYmFja2dyb3VuZCBjb2xvdXJcblxuICAgICAgICBkMy5zZWxlY3QodGhpcy5fZWxlbWVudCkuc2VsZWN0KFwiLmJhY2tncm91bmRcIikucmVtb3ZlKCk7XG4gICAgICAgIGlmICh0aGlzLl9iYWNrZ3JvdW5kQ29sb3VyKSB7XG4gICAgICAgICAgICBkMy5zZWxlY3QodGhpcy5fZWxlbWVudCkuc2VsZWN0KFwic3ZnXCIpXG4gICAgICAgICAgICAgICAgLmFwcGVuZChcInJlY3RcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwiYmFja2dyb3VuZFwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwid2lkdGhcIiwgXCIxMDAlXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgXCIxMDAlXCIpXG4gICAgICAgICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCB0aGlzLl9iYWNrZ3JvdW5kQ29sb3VyKVxuICAgICAgICAgICAgICAgIC5sb3dlcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gYWRkIHRoZSBZIGdyaWRsaW5lc1xuICAgICAgICBzdmcuY2FsbCh0aGlzLmdyaWQsIHdpZHRoLCBkMy5heGlzTGVmdCh5KS50aWNrcyg1KSk7XG5cbiAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gYXhlc1xuICAgICAgICBzdmcuY2FsbCh0aGlzLnhheGlzLCBoZWlnaHQsIHguYmFuZHdpZHRoKCksIGQzLmF4aXNCb3R0b20oeCkudGlja1NpemUoMCkudGlja1BhZGRpbmcoNSkudGlja0Zvcm1hdCh0aGlzLl94QXhpc1RpY2tGb3JtYXQpKTtcbiAgICAgICAgc3ZnLmNhbGwodGhpcy55YXhpcywgZDMuYXhpc0xlZnQoeSkudGlja3MoNSkudGlja0Zvcm1hdCh0aGlzLl90aWNrRm9ybWF0KSk7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8qXG4gICAgICogUmV0dXJucyBhbiBvYmplY3Qgd2l0aCB0d28gZnVuY3Rpb25zLCAjc2hvdygpIGFuZCAjaGlkZSgpLFxuICAgICAqIHRvIHNob3cgYW5kIGhpZGUgdGhlIGxhYmVscy5cbiAgICAgKi9cbiAgICBsYWJlbHMoKSB7XG4gICAgICAgIHJldHVybiB7XG5cbiAgICAgICAgICAgIHNob3c6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgc2VsZWN0aW9uID0gdGhpcy5fZWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSB0aGlzLmdldFRyYW5zZm9ybWVkRGF0YSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgeHNjYWxlID0gdGhpcy5feHNjYWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgeGdyb3VwID0gdGhpcy5feGdyb3Vwc2NhbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB5c2NhbGUgPSB0aGlzLl95c2NhbGU7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvbikgc2VsZWN0aW9uID0gZDMuc2VsZWN0KHRoaXMuX2VsZW1lbnQpLnNlbGVjdChcInN2Z1wiKS5zZWxlY3QoXCJnXCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNlbGVjdGlvbi5lbXB0eSgpICYmIGRhdGEgJiYgeHNjYWxlICYmIHlzY2FsZSAmJiB4Z3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBsYWJlbHMgPSBzZWxlY3Rpb24uc2VsZWN0KCcuY2hhcnQtbGFiZWxzJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWxhYmVscy5lbXB0eSgpKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbHMucmVtb3ZlKClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyTGFiZWxzKHNlbGVjdGlvbiwgZGF0YSwgeHNjYWxlLCB4Z3JvdXAsIHlzY2FsZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBoaWRlOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2VsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMuX2VsZW1lbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc2VsZWN0KCcuY2hhcnQtbGFiZWxzJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5pbnRlcnJ1cHQoXCJsYWJlbHNcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5pbnRlcnJ1cHQoXCJsYWJlbHM6ZmFkZVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRyYW5zaXRpb24oXCJsYWJlbHM6ZmFkZVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm9uKFwiZW5kXCIsIChkLCBpLCBub2RlcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQzLnNlbGVjdChub2Rlc1tpXSkucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICByZW5kZXJMYWJlbHMoc2VsZWN0aW9uLCBkYXRhLCB4c2NhbGUsIHhncm91cCwgeXNjYWxlLCBhbmltYXRlKSB7XG4gICAgICAgIGFuaW1hdGUgPSBhbmltYXRlID09PSB1bmRlZmluZWQgPyB0cnVlIDogYW5pbWF0ZTtcbiAgICAgICAgc2VsZWN0aW9uLnNlbGVjdEFsbChcIi5jaGFydC1sYWJlbHNcIikucmVtb3ZlKCk7XG5cbiAgICAgICAgbGV0IGxhYmVscyA9IHNlbGVjdGlvbi5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwiY2hhcnQtbGFiZWxzXCIpXG4gICAgICAgICAgICAvLyAuc2VsZWN0QWxsKFwiLmNoYXJ0LWxhYmVsXCIpXG4gICAgICAgICAgICAuc2VsZWN0QWxsKFwiLmxhYmVsLWdyb3VwXCIpXG4gICAgICAgICAgICAuZGF0YShkYXRhKVxuXG4gICAgICAgIGxldCBtYXhXaWR0aCA9IDA7ICAgICAvLyBGb3IgY2FsY3VsYXRpbmcgdGhlIG1heCB3aWR0aCBvZiB0ZXh0LlxuICAgICAgICBsZXQgZm9udFNpemUgPSAxMjsgICAgLy8gT3VyIGluaXRpYWwgZm9udCBzaXplLlxuICAgICAgICBjb25zdCBidWZmZXIgPSA1OyAgICAgLy8gQnVmZmVyIHNwYWNlIGJldHdlZW4gd29yZHMgYW5kIHRoZSB0b3Agb2YgYSBiYXIuXG4gICAgICAgIGNvbnN0IGNhbGNEeSA9ICh5cG9zKSA9PiB5cG9zIDwgMTAgPyBmb250U2l6ZSArIGJ1ZmZlciA6IC1idWZmZXI7XG5cbiAgICAgICAgLy8gV2FudCB0byBmaWd1cmUgb3V0IGlmIHRoZSBsYWJlbCBpcyB0b28gZGFyayAvIGxpZ2h0IGZvciB0aGVcbiAgICAgICAgLy8gYmFyLlxuICAgICAgICBjb25zdCBnZXRJbnZlcnRlZENvbG9yID0gKGkpID0+IHtcbiAgICAgICAgICAgIGxldCBpbnZlcnRlZENvbG9yID0gZDMuaGNsKHRoaXMuZ2V0U2VyaWVzQ29sb3VyKGkpKTtcbiAgICAgICAgICAgIGludmVydGVkQ29sb3IubCArPSBNYXRoLm1pbihpbnZlcnRlZENvbG9yLmwgKyA1MCwgMTAwKTtcbiAgICAgICAgICAgIHJldHVybiBpbnZlcnRlZENvbG9yO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBzaG91bGRJbnZlcnQgPSAoaSkgPT4gZDMuaGNsKHRoaXMuZ2V0U2VyaWVzQ29sb3VyKGkpKS5sIDwgNjA7XG5cbiAgICAgICAgbGFiZWxzLmVudGVyKCkuZWFjaCgoc2VyaWVzLCBzX2ksIHNfbm9kZXMpID0+IHtcbiAgICAgICAgICAgIGxldCBncm91cCA9IGQzLnNlbGVjdChzX25vZGVzW3NfaV0pXG4gICAgICAgICAgICAgICAgLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwibGFiZWwtZ3JvdXBcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBkID0+IFwidHJhbnNsYXRlKFwiICsgeHNjYWxlKGQua2V5KSArIFwiLDApXCIpXG4gICAgICAgICAgICAgICAgLnNlbGVjdEFsbChcIi5jaGFydC1sYWJlbFwiKVxuICAgICAgICAgICAgICAgIC5kYXRhKHNlcmllcy5kYXRhKVxuICAgICAgICAgICAgICAgIC5lbnRlcigpXG4gICAgICAgICAgICAgICAgLmVhY2goKGQsIGksIG5vZGVzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB5cG9zID0geXNjYWxlKGQuX3kpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZHkgPSBjYWxjRHkoeXBvcyk7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0ZXh0ID0gZDMuc2VsZWN0KG5vZGVzW2ldKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC50ZXh0KHRoaXMuX2xhYmVsRm9ybWF0KGQuX3kpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImNoYXJ0LWxhYmVsXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcInlcIiwgeXBvcylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiZHhcIiwgYW5pbWF0ZSA/IC0xNSA6IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcImR5XCIsIGR5KVxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwicG9pbnRlci1ldmVudHNcIiwgXCJub25lXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAuc3R5bGUoXCJmb250LWZhbWlseVwiLCBcIk9wZW4gU2Fucywgc2Fucy1zZXJpZlwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gLnN0eWxlKFwiZm9udC13ZWlnaHRcIiwgXCJub3JtYWxcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIC5zdHlsZShcImZvbnQtc2l6ZVwiLCBmb250U2l6ZSArIFwicHhcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcImZpbGxcIiwgZHkgPiAwICYmIHNob3VsZEludmVydChpKT8gZ2V0SW52ZXJ0ZWRDb2xvcihpKS50b1N0cmluZygpIDogY29sb3Vycy5laWdodGVlbi5kYXJrR3JleSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gU2V0IHRoZSB4IHBvc2l0aW9uLCB3aGljaCBpcyBiYXNlZCBvbiB3aWR0aC5cbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgd2lkdGggPSB0ZXh0Lm5vZGUoKS5nZXRCQm94KCkud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIG1heFdpZHRoID0gTWF0aC5tYXgod2lkdGgsIG1heFdpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgdGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIHhncm91cChkLl9rZXkpICsgeGdyb3VwLmJhbmR3aWR0aCgpIC8gMiAtIHdpZHRoIC8gMik7XG5cbiAgICAgICAgICAgICAgICAgICAgdGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgLnRyYW5zaXRpb24oXCJsYWJlbHNcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5kZWxheSgoKSA9PiBhbmltYXRlID8gdGhpcy5jYWxjQmFyR3Jvd3RoKHNfaSwgc19ub2Rlcy5sZW5ndGgpIDogMCkgLy8gRGVsYXkgaW4gbG9ja3N0ZXAgd2l0aCBiYXIgZ3Jvd3RoLlxuICAgICAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKHRoaXMuX2R1cmF0aW9uKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJkeFwiLCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAxKVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgIH0pXG5cblxuICAgICAgICAvLyBGaWd1cmUgb3V0IGlmIHdlIGRvbid0IGhhdmUgZW5vdWdoIHNwYWNlIHRvIHNob3cgb3VyIGxhYmVscy5cbiAgICAgICAgLy8gV2UgdGhlbiB3YW50IHRvIHJlc2l6ZSwgaWYgcG9zc2libGUuXG4gICAgICAgIGlmICh4Z3JvdXAuYmFuZHdpZHRoKCkgPCBtYXhXaWR0aCAqIDEuMDUpIHtcbiAgICAgICAgICAgIGxldCBzY2FsZSA9IG1heFdpZHRoIC8geGdyb3VwLmJhbmR3aWR0aCgpICogMS4wNTtcbiAgICAgICAgICAgIGZvbnRTaXplID0gTWF0aC5mbG9vcihmb250U2l6ZSAvIHNjYWxlKTtcblxuICAgICAgICAgICAgaWYgKGZvbnRTaXplIDwgOCkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBsYWJlbHMgYXJlIHRvbyBzbWFsbC5cbiAgICAgICAgICAgICAgICBsYWJlbHMuZW50ZXIoKS5zZWxlY3RBbGwoXCJ0ZXh0XCIpLnJlbW92ZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsYWJlbHMuZW50ZXIoKVxuICAgICAgICAgICAgICAgICAgICAubWVyZ2UobGFiZWxzKVxuICAgICAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKFwidGV4dFwiKVxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJmb250LXNpemVcIiwgZm9udFNpemUgKyBcInB4XCIpXG4gICAgICAgICAgICAgICAgICAgIC5lYWNoKChkLCBpLCBub2RlcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGV4dCA9IGQzLnNlbGVjdChub2Rlc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB3aWR0aCA9IHRleHQubm9kZSgpLmdldEJCb3goKS53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGR5ID0gY2FsY0R5KHlzY2FsZShkLl95KSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcInhcIiwgeGdyb3VwKGQuX2tleSkgKyB4Z3JvdXAuYmFuZHdpZHRoKCkgLyAyIC0gd2lkdGggLyAyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcImZpbGxcIiwgZHkgPiAwICYmIHNob3VsZEludmVydChpKSA/IGdldEludmVydGVkQ29sb3IoaSkudG9TdHJpbmcoKSA6IGNvbG91cnMuZWlnaHRlZW4uZGFya0dyZXkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJkeVwiLCBkeSk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgcmVuZGVyRGF0YUF4aXNMYWJlbChoZWlnaHQsIG1hcmdpbnMpIHtcbiAgICAgICAgbGV0IHN2ZyA9IGQzLnNlbGVjdCh0aGlzLl9lbGVtZW50KS5zZWxlY3QoJ3N2ZycpO1xuICAgICAgICBzdmcuc2VsZWN0QWxsKFwiLmRhdGEtbGFiZWxzXCIpLnJlbW92ZSgpO1xuXG4gICAgICAgIGlmICghdGhpcy5fZGF0YUF4aXNMYWJlbCkgcmV0dXJuO1xuICAgICAgICBsZXQgdGV4dCA9IHRoaXMuX2RhdGFBeGlzTGFiZWw7XG4gICAgICAgIGlmICh0ZXh0LmxvbmcpIHRleHQgPSB0ZXh0Lmxvbmc7XG5cbiAgICAgICAgbGV0IHggPSAtKG1hcmdpbnMudG9wICsgaGVpZ2h0IC8gMik7XG5cbiAgICAgICAgbGV0IGxhYmVsID0gc3ZnLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJkYXRhLWxhYmVsc1wiKVxuICAgICAgICAgICAgLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgICAgIC50ZXh0KHRleHQpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInJvdGF0ZSgtOTAgMCwwKSB0cmFuc2xhdGUoXCIgKyB4ICsgXCIsIDIwKVwiKVxuICAgICAgICAgICAgLy8gLnN0eWxlKFwiZm9udC1mYW1pbHlcIiwgXCJPcGVuIFNhbnMsIHNhbnMtc2VyaWZcIilcbiAgICAgICAgICAgIC8vIC5zdHlsZShcImZvbnQtc2l6ZVwiLCBcIjEycHhcIilcbiAgICAgICAgICAgIC8vIC5zdHlsZShcImZvbnQtc3R5bGVcIiwgXCJpdGFsaWNcIilcbiAgICAgICAgICAgIC5zdHlsZShcImZpbGxcIiwgY29sb3Vycy5laWdodGVlbi5kYXJrR3JleSk7XG5cbiAgICAgICAgbGV0IHdpZHRoID0gbGFiZWwubm9kZSgpLmdldEJCb3goKS53aWR0aDtcbiAgICAgICAgaWYgKHdpZHRoID49IGhlaWdodCAmJiB0aGlzLl9kYXRhQXhpc0xhYmVsLnNob3J0KSB7XG4gICAgICAgICAgICBsYWJlbC50ZXh0KHRoaXMuX2RhdGFBeGlzTGFiZWwuc2hvcnQpO1xuICAgICAgICAgICAgd2lkdGggPSBsYWJlbC5ub2RlKCkuZ2V0QkJveCgpLndpZHRoO1xuICAgICAgICB9XG5cbiAgICAgICAgbGFiZWwuYXR0cihcImR4XCIsIC13aWR0aCAvIDIpO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBncmlkKHNlbGVjdGlvbiwgd2lkdGgsIGF4aXMpIHtcbiAgICAgICAgc2VsZWN0aW9uLnNlbGVjdChcIi5ncmlkXCIpLnJlbW92ZSgpO1xuXG4gICAgICAgIGxldCBncmlkID0gc2VsZWN0aW9uLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJncmlkXCIpXG4gICAgICAgICAgICAuY2FsbChheGlzXG4gICAgICAgICAgICAgICAgLnRpY2tTaXplKC13aWR0aClcbiAgICAgICAgICAgICAgICAudGlja0Zvcm1hdChcIlwiKVxuICAgICAgICAgICAgKTtcblxuICAgICAgICBncmlkLnNlbGVjdEFsbChcImxpbmVcIilcbiAgICAgICAgICAgIC5zdHlsZShcInN0cm9rZVwiLCBjb2xvdXJzLmVpZ2h0ZWVuLmxpZ2h0R3JleSk7XG4gICAgICAgIGdyaWQuc2VsZWN0QWxsKFwiLmRvbWFpblwiKS5yZW1vdmUoKTtcblxuICAgICAgICBncmlkXG4gICAgICAgICAgICAubG93ZXIoKSAvLyBBbHdheXMgZW5zdXJlIHRoYXQgdGhpcyBpcyBlYXJsaWVyIGluIHRoZSBkb20uIFRoaW5ncyBtdXN0IGJlIGRyYXduIG9uIHRvcCBvZiBpdC5cbiAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMClcbiAgICAgICAgICAgIC50cmFuc2l0aW9uKClcbiAgICAgICAgICAgIC5kZWxheSg1MDApXG4gICAgICAgICAgICAuZHVyYXRpb24oNTAwKVxuICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAxKTtcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgeGF4aXMoc2VsZWN0aW9uLCBoZWlnaHQsIHdpZHRoLCB4YXhpcykge1xuICAgICAgICBzZWxlY3Rpb24uc2VsZWN0KFwiLngtYXhpc1wiKS5yZW1vdmUoKTtcbiAgICAgICAgbGV0IGF4aXMgPSBzZWxlY3Rpb24uYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcIngtYXhpc1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoMCxcIiArIGhlaWdodCArIFwiKVwiKVxuICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAwKVxuICAgICAgICAgICAgLmNhbGwoeGF4aXMpO1xuXG4gICAgICAgIGF4aXMuc2VsZWN0KFwiLmRvbWFpblwiKS5yZW1vdmUoKTtcblxuICAgICAgICBsZXQgbWF4ID0gMDtcbiAgICAgICAgY29uc3QgZm9udFNpemUgPSAxMjtcbiAgICAgICAgYXhpcy5zZWxlY3RBbGwoXCJ0ZXh0XCIpXG4gICAgICAgICAgICAvLyAuc3R5bGUoXCJmb250LWZhbWlseVwiLCBcIk9wZW4gU2Fucywgc2Fucy1zZXJpZlwiKVxuICAgICAgICAgICAgLy8gLnN0eWxlKFwiZm9udC1zaXplXCIsIGZvbnRTaXplICsgXCJweFwiKVxuICAgICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBjb2xvdXJzLmVpZ2h0ZWVuLmRhcmtHcmV5KVxuICAgICAgICAgICAgLm5vZGVzKClcbiAgICAgICAgICAgIC5mb3JFYWNoKHRleHQgPT4gbWF4ID0gTWF0aC5tYXgobWF4LCB0ZXh0LmdldEJCb3goKS53aWR0aCkpO1xuXG4gICAgICAgIGlmIChtYXggPj0gd2lkdGggLSAxMCkge1xuICAgICAgICAgICAgY29uc3QgYmFkID0gbWF4ID49IHdpZHRoICogMjtcbiAgICAgICAgICAgIGNvbnN0IGFuZ2xlID0gYmFkID8gLTkwIDogLTMwO1xuICAgICAgICAgICAgY29uc3QgZm9udFNpemUgPSB3aWR0aCA8PSAxMyA/IDggOiAxMjtcbiAgICAgICAgICAgIGNvbnN0IHggPSBiYWQgPyAtZm9udFNpemUgOiAwO1xuICAgICAgICAgICAgY29uc3QgeSA9IGJhZCA/IDUgOiAyO1xuXG4gICAgICAgICAgICBheGlzLnNlbGVjdEFsbChcInRleHRcIilcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ3RleHQtYW5jaG9yJywgJ2VuZCcpXG4gICAgICAgICAgICAgICAgLnN0eWxlKFwiZm9udC1zaXplXCIsIGZvbnRTaXplICsgXCJweFwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsICgpID0+IFwidHJhbnNsYXRlKFwiICsgeCArIFwiLFwiICsgeSArIFwiKSByb3RhdGUoXCIgKyBhbmdsZSArIFwiIDAsMClcIilcbiAgICAgICAgfVxuXG4gICAgICAgIGF4aXNcbiAgICAgICAgICAgIC50cmFuc2l0aW9uKClcbiAgICAgICAgICAgIC5kdXJhdGlvbigxMDAwKVxuICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAxKTtcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgeWF4aXMoc2VsZWN0aW9uLCBheGlzKSB7XG4gICAgICAgIHNlbGVjdGlvbi5zZWxlY3QoXCIueS1heGlzXCIpLnJlbW92ZSgpO1xuICAgICAgICBsZXQgeCA9IHNlbGVjdGlvbi5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwieS1heGlzXCIpXG4gICAgICAgICAgICAuY2FsbChheGlzLnRpY2tTaXplKDApLnRpY2tQYWRkaW5nKDEwKSlcbiAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMClcbiAgICAgICAgICAgIC50cmFuc2l0aW9uKClcbiAgICAgICAgICAgIC5kdXJhdGlvbigxMDAwKVxuICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAxKTtcblxuICAgICAgICB4LnNlbGVjdEFsbChcInRleHRcIilcbiAgICAgICAgICAgIC8vIC5zdHlsZShcImZvbnQtZmFtaWx5XCIsIFwiT3BlbiBTYW5zLCBzYW5zLXNlcmlmXCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIGNvbG91cnMuZWlnaHRlZW4uZGFya0dyZXkpXG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGNhbGNCYXJHcm93dGgoaSwgbWF4KSB7XG4gICAgICAgIGlmIChtYXggPCAxMCkgcmV0dXJuIGkgKiB0aGlzLl9CQVJfR1JPV1RIIC8gMjtcbiAgICAgICAgaWYgKG1heCA8IDM1KSByZXR1cm4gaSAqIHRoaXMuX0JBUl9HUk9XVEggLyA0O1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICBnZXRTZXJpZXNDb2xvdXIoaSkge1xuICAgICAgICBpZiAoaSA8IDAgfHwgIXRoaXMuX2NvbG91cnMpIHJldHVybiBjb2xvdXJzLmVpZ2h0ZWVuLm1pZEdyZXk7XG5cbiAgICAgICAgaSA9IGkgJSB0aGlzLl9jb2xvdXJzLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbG91cnNbaV07XG4gICAgfVxuXG4gICAgZ2V0U29ydGVkRGF0YSgpIHtcbiAgICAgICAgbGV0IGRhdGEgPSB0aGlzLl9kYXRhO1xuICAgICAgICBpZiAoIWRhdGEgfHwgIWRhdGEubGVuZ3RoKSByZXR1cm4gW107XG5cbiAgICAgICAgZGF0YSA9IHRoaXMuX2RhdGEuc29ydCgobGhzLCByaHMpID0+IHtcbiAgICAgICAgICAgIGxocyA9IGxocy5rZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIHJocyA9IHJocy5rZXkudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICAgICAgaWYgKGxocyA9PT0gcmhzKSByZXR1cm4gMDtcbiAgICAgICAgICAgIGlmIChsaHMgPCByaHMpIHJldHVybiAtMTtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICBnZXRUcmFuc2Zvcm1lZERhdGEoKSB7XG4gICAgICAgIGxldCBkYXRhID0gdGhpcy5nZXRTb3J0ZWREYXRhKCk7XG4gICAgICAgIGlmICghZGF0YSB8fCAhZGF0YS5sZW5ndGgpIHJldHVybiBbXTtcblxuICAgICAgICBsZXQgcmVzdWx0cyA9IFtdO1xuXG4gICAgICAgIGNvbnN0IGdldFggPSBkID0+IHRoaXMuX3hBeGlzT3ZlcnJpZGUgPyB0aGlzLl94QXhpc092ZXJyaWRlW3RoaXMuX3goZCldIDogdGhpcy5feChkKTtcblxuICAgICAgICBkYXRhLmZvckVhY2goKHNlcmllcywgc19pKSA9PiB7XG4gICAgICAgICAgICBzZXJpZXMudmFsdWVzLmZvckVhY2goKGQsIGRfaSkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBmaWVsZCA9IHJlc3VsdHMuZmluZChidWNrZXQgPT4gYnVja2V0LmtleSA9PT0gZ2V0WChkKSk7XG4gICAgICAgICAgICAgICAgaWYgKCFmaWVsZCkge1xuICAgICAgICAgICAgICAgICAgICBmaWVsZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiBnZXRYKGQpXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChmaWVsZCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZmllbGQuZGF0YS5wdXNoKE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgICAgICAgICBfc2VyaWVzOiBzZXJpZXMsXG4gICAgICAgICAgICAgICAgICAgIF9zX2k6IHNfaSxcbiAgICAgICAgICAgICAgICAgICAgX2tleTogc2VyaWVzLmtleSxcbiAgICAgICAgICAgICAgICAgICAgX3k6IHRoaXMuX3koZClcbiAgICAgICAgICAgICAgICB9LCBkKSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG5cbiAgICBnZXRLZXlzKCkge1xuICAgICAgICBsZXQgZGF0YSA9IHRoaXMuX2RhdGE7XG4gICAgICAgIGlmICghZGF0YSB8fCAhZGF0YS5sZW5ndGgpIHJldHVybiBbXTtcblxuICAgICAgICByZXR1cm4gWy4uLm5ldyBTZXQoZGF0YS5tYXAoZCA9PiBkLmtleSkpXVxuICAgIH1cbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/ColumnChart.js\n')},"./src/Legend.js":
/*!***********************!*\
  !*** ./src/Legend.js ***!
  \***********************/
/*! exports provided: removeLegend, renderLegend, getColour, buckets, toColourKey */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeLegend", function() { return removeLegend; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "renderLegend", function() { return renderLegend; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getColour", function() { return getColour; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "buckets", function() { return buckets; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toColourKey", function() { return toColourKey; });\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers */ "./src/helpers.js");\n/* harmony import */ var _Colours__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Colours */ "./src/Colours.js");\n// Copyright (C) 2013-2014, 2018 BrandsEye (PTY) LTD\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this\n// software and associated documentation files (the "Software"), to deal in the Software\n// without restriction, including without limitation the rights to use, copy, modify,\n//     merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following\n// conditions:\n//\n//     The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n//     INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n// CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n\nfunction removeLegend(element) {\n    element.selectAll(".legend").remove();\n}\n\nfunction renderLegend(element, geomBuckets, colourScale, width, height, min, options) {\n    if (!options) options = { }\n    let fontSize = options.fontSize || 12\n\n    min = min || 2;\n    removeLegend(element);\n\n    // Only if we have multiple series.\n    if (!geomBuckets.find(b => b.colours.size)) return 0\n\n    const legend = element.append("g").attr("class", "legend");\n\n    let position = 0\n    let position_height = 0\n    let maxWidth = width - 40\n\n    geomBuckets.forEach(buckets => {\n        let gm = legend.append("g").attr("class", "geometry-legend")\n        const colours = Array.from(buckets.colours);\n        if (colours.length < min) return 0;\n\n        const boundings = Object(_helpers__WEBPACK_IMPORTED_MODULE_0__["getBoundings"])(element, colours);\n\n        let elements = gm.selectAll(".legend-element").data(colours);\n\n        elements.enter()\n            .append("g")\n            .attr("class", (d, i) => "legend-element series series-" + toColourKey(d))\n            .style("cursor", "default")\n            .each((d, i, nodes) => {\n                let element = d3.select(nodes[i]);\n\n                element.append("rect")\n                    .attr("width", 10)\n                    .attr("height", 10)\n                    .attr("rx", 2)\n                    .attr("ry", 2)\n                    .attr("y", -10)\n                    .style("fill", d => colourScale(d, buckets));\n\n                element.append("text")\n                    .text(d => d)\n                    .attr("dx", 12)\n                    .style("font-size", fontSize + "px")\n                    .style("fill", _Colours__WEBPACK_IMPORTED_MODULE_1__["colours"].eighteen.darkGrey);\n\n                element.append("title")\n                    .text(d => d);\n\n                element.attr("transform", "translate(" + position + "," + position_height +")");\n                const positionDelta = boundings[d].width + 25;\n                position += positionDelta;\n\n                if (position >= maxWidth) {\n                    position = 0;\n                    position_height += 15;\n                    element.attr("transform", "translate(" + position + "," + position_height + ")");\n                    position += positionDelta;\n                }\n\n            })\n            .on("mouseover", (d, i, nodes) => {\n                element.selectAll(".series:not(.series-" + toColourKey(d) + ")")\n                    .interrupt("legend:highlight")\n                    .transition("legend:highlight")\n                    .style("opacity", 0.3);\n            })\n            .on("mouseout", (d, i, nodes) => {\n                element.selectAll(".series")\n                    .interrupt("legend:highlight")\n                    .transition("legend:highlight")\n                    .style("opacity", 1);\n            })\n            .style("opacity", 0)\n            .transition()\n            .duration(1000)\n            .style("opacity", 1);\n    })\n\n    let bb = legend.node().getBBox()\n    legend.attr("transform", "translate(" + ((width - bb.width)/2) + "," + (height - bb.height) + ")")\n    return bb.height\n}\n\n/**\n * Given a data point, this determines its colours.\n * @param d\n * @param individualColours\n * @param colourScale\n * @returns {*}\n */\nfunction getColour(d, individualColours, colourScale) {\n    return individualColours(d) || colourScale(d._colour);\n}\n\n/**\n * Figures out what buckets we may be using in our data set, based on\n * colour and size differentiation. This may have to be run for each\n * geom and merged.\n * @param data\n * @param colour    Fn to map a data point to a label e.g. \'First National Bank\'\n * @param size\n */\nfunction buckets(data, colour, individualColour, size) {\n    if (!data || !data.length) return { colours: new Set(), sizes: new Set()};\n\n    const colours = new Set(),  // these are the labels e.g. \'First National Bank\'\n        sizes = new Set(),\n        bucketColour = {};      // maps labels from colours to override colours e.g. \'First National Bank\': "#00acb6"\n\n    data.forEach(d => {\n        const c = colour(d)     // c is the label e.g. \'First National Bank\'\n        colours.add(c)\n        if (individualColour && individualColour(d, -1) !== -1) bucketColour[c] = individualColour(d)\n\n        sizes.add(size(d));\n    });\n\n    return { colours, sizes, bucketColour }\n}\n\nfunction toColourKey(colour) {\n    // TODO this is not internationalised, and may break on things like brand names.\n    colour = colour || "unknown-element";\n    return "colour-" + colour.toString().toLowerCase().replace(/\\s+/g, \'-\').replace(/[^a-z0-9]/g, \'\');\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvTGVnZW5kLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYjNqcy8uL3NyYy9MZWdlbmQuanM/OTIwNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKEMpIDIwMTMtMjAxNCwgMjAxOCBCcmFuZHNFeWUgKFBUWSkgTFREXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZiB0aGlzXG4vLyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmVcbi8vIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSxcbi8vICAgICBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvXG4vLyBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZ1xuLy8gY29uZGl0aW9uczpcbi8vXG4vLyAgICAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4vLyBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vICAgICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SIElNUExJRUQsXG4vLyAgICAgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEFcbi8vIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFRcbi8vIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRlxuLy8gQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFXG4vLyBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IHtnZXRCb3VuZGluZ3N9IGZyb20gXCIuL2hlbHBlcnNcIjtcbmltcG9ydCB7Y29sb3VycyBhcyBzY2hlbWF9IGZyb20gXCIuL0NvbG91cnNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUxlZ2VuZChlbGVtZW50KSB7XG4gICAgZWxlbWVudC5zZWxlY3RBbGwoXCIubGVnZW5kXCIpLnJlbW92ZSgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyTGVnZW5kKGVsZW1lbnQsIGdlb21CdWNrZXRzLCBjb2xvdXJTY2FsZSwgd2lkdGgsIGhlaWdodCwgbWluLCBvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0geyB9XG4gICAgbGV0IGZvbnRTaXplID0gb3B0aW9ucy5mb250U2l6ZSB8fCAxMlxuXG4gICAgbWluID0gbWluIHx8IDI7XG4gICAgcmVtb3ZlTGVnZW5kKGVsZW1lbnQpO1xuXG4gICAgLy8gT25seSBpZiB3ZSBoYXZlIG11bHRpcGxlIHNlcmllcy5cbiAgICBpZiAoIWdlb21CdWNrZXRzLmZpbmQoYiA9PiBiLmNvbG91cnMuc2l6ZSkpIHJldHVybiAwXG5cbiAgICBjb25zdCBsZWdlbmQgPSBlbGVtZW50LmFwcGVuZChcImdcIikuYXR0cihcImNsYXNzXCIsIFwibGVnZW5kXCIpO1xuXG4gICAgbGV0IHBvc2l0aW9uID0gMFxuICAgIGxldCBwb3NpdGlvbl9oZWlnaHQgPSAwXG4gICAgbGV0IG1heFdpZHRoID0gd2lkdGggLSA0MFxuXG4gICAgZ2VvbUJ1Y2tldHMuZm9yRWFjaChidWNrZXRzID0+IHtcbiAgICAgICAgbGV0IGdtID0gbGVnZW5kLmFwcGVuZChcImdcIikuYXR0cihcImNsYXNzXCIsIFwiZ2VvbWV0cnktbGVnZW5kXCIpXG4gICAgICAgIGNvbnN0IGNvbG91cnMgPSBBcnJheS5mcm9tKGJ1Y2tldHMuY29sb3Vycyk7XG4gICAgICAgIGlmIChjb2xvdXJzLmxlbmd0aCA8IG1pbikgcmV0dXJuIDA7XG5cbiAgICAgICAgY29uc3QgYm91bmRpbmdzID0gZ2V0Qm91bmRpbmdzKGVsZW1lbnQsIGNvbG91cnMpO1xuXG4gICAgICAgIGxldCBlbGVtZW50cyA9IGdtLnNlbGVjdEFsbChcIi5sZWdlbmQtZWxlbWVudFwiKS5kYXRhKGNvbG91cnMpO1xuXG4gICAgICAgIGVsZW1lbnRzLmVudGVyKClcbiAgICAgICAgICAgIC5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIChkLCBpKSA9PiBcImxlZ2VuZC1lbGVtZW50IHNlcmllcyBzZXJpZXMtXCIgKyB0b0NvbG91cktleShkKSlcbiAgICAgICAgICAgIC5zdHlsZShcImN1cnNvclwiLCBcImRlZmF1bHRcIilcbiAgICAgICAgICAgIC5lYWNoKChkLCBpLCBub2RlcykgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBlbGVtZW50ID0gZDMuc2VsZWN0KG5vZGVzW2ldKTtcblxuICAgICAgICAgICAgICAgIGVsZW1lbnQuYXBwZW5kKFwicmVjdFwiKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcIndpZHRoXCIsIDEwKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcImhlaWdodFwiLCAxMClcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJyeFwiLCAyKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcInJ5XCIsIDIpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFwieVwiLCAtMTApXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZShcImZpbGxcIiwgZCA9PiBjb2xvdXJTY2FsZShkLCBidWNrZXRzKSk7XG5cbiAgICAgICAgICAgICAgICBlbGVtZW50LmFwcGVuZChcInRleHRcIilcbiAgICAgICAgICAgICAgICAgICAgLnRleHQoZCA9PiBkKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcImR4XCIsIDEyKVxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJmb250LXNpemVcIiwgZm9udFNpemUgKyBcInB4XCIpXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZShcImZpbGxcIiwgc2NoZW1hLmVpZ2h0ZWVuLmRhcmtHcmV5KTtcblxuICAgICAgICAgICAgICAgIGVsZW1lbnQuYXBwZW5kKFwidGl0bGVcIilcbiAgICAgICAgICAgICAgICAgICAgLnRleHQoZCA9PiBkKTtcblxuICAgICAgICAgICAgICAgIGVsZW1lbnQuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIHBvc2l0aW9uICsgXCIsXCIgKyBwb3NpdGlvbl9oZWlnaHQgK1wiKVwiKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwb3NpdGlvbkRlbHRhID0gYm91bmRpbmdzW2RdLndpZHRoICsgMjU7XG4gICAgICAgICAgICAgICAgcG9zaXRpb24gKz0gcG9zaXRpb25EZWx0YTtcblxuICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA+PSBtYXhXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uX2hlaWdodCArPSAxNTtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgcG9zaXRpb24gKyBcIixcIiArIHBvc2l0aW9uX2hlaWdodCArIFwiKVwiKTtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gKz0gcG9zaXRpb25EZWx0YTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAub24oXCJtb3VzZW92ZXJcIiwgKGQsIGksIG5vZGVzKSA9PiB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5zZWxlY3RBbGwoXCIuc2VyaWVzOm5vdCguc2VyaWVzLVwiICsgdG9Db2xvdXJLZXkoZCkgKyBcIilcIilcbiAgICAgICAgICAgICAgICAgICAgLmludGVycnVwdChcImxlZ2VuZDpoaWdobGlnaHRcIilcbiAgICAgICAgICAgICAgICAgICAgLnRyYW5zaXRpb24oXCJsZWdlbmQ6aGlnaGxpZ2h0XCIpXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMC4zKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAub24oXCJtb3VzZW91dFwiLCAoZCwgaSwgbm9kZXMpID0+IHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnNlbGVjdEFsbChcIi5zZXJpZXNcIilcbiAgICAgICAgICAgICAgICAgICAgLmludGVycnVwdChcImxlZ2VuZDpoaWdobGlnaHRcIilcbiAgICAgICAgICAgICAgICAgICAgLnRyYW5zaXRpb24oXCJsZWdlbmQ6aGlnaGxpZ2h0XCIpXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAwKVxuICAgICAgICAgICAgLnRyYW5zaXRpb24oKVxuICAgICAgICAgICAgLmR1cmF0aW9uKDEwMDApXG4gICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDEpO1xuICAgIH0pXG5cbiAgICBsZXQgYmIgPSBsZWdlbmQubm9kZSgpLmdldEJCb3goKVxuICAgIGxlZ2VuZC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgKCh3aWR0aCAtIGJiLndpZHRoKS8yKSArIFwiLFwiICsgKGhlaWdodCAtIGJiLmhlaWdodCkgKyBcIilcIilcbiAgICByZXR1cm4gYmIuaGVpZ2h0XG59XG5cbi8qKlxuICogR2l2ZW4gYSBkYXRhIHBvaW50LCB0aGlzIGRldGVybWluZXMgaXRzIGNvbG91cnMuXG4gKiBAcGFyYW0gZFxuICogQHBhcmFtIGluZGl2aWR1YWxDb2xvdXJzXG4gKiBAcGFyYW0gY29sb3VyU2NhbGVcbiAqIEByZXR1cm5zIHsqfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29sb3VyKGQsIGluZGl2aWR1YWxDb2xvdXJzLCBjb2xvdXJTY2FsZSkge1xuICAgIHJldHVybiBpbmRpdmlkdWFsQ29sb3VycyhkKSB8fCBjb2xvdXJTY2FsZShkLl9jb2xvdXIpO1xufVxuXG4vKipcbiAqIEZpZ3VyZXMgb3V0IHdoYXQgYnVja2V0cyB3ZSBtYXkgYmUgdXNpbmcgaW4gb3VyIGRhdGEgc2V0LCBiYXNlZCBvblxuICogY29sb3VyIGFuZCBzaXplIGRpZmZlcmVudGlhdGlvbi4gVGhpcyBtYXkgaGF2ZSB0byBiZSBydW4gZm9yIGVhY2hcbiAqIGdlb20gYW5kIG1lcmdlZC5cbiAqIEBwYXJhbSBkYXRhXG4gKiBAcGFyYW0gY29sb3VyICAgIEZuIHRvIG1hcCBhIGRhdGEgcG9pbnQgdG8gYSBsYWJlbCBlLmcuICdGaXJzdCBOYXRpb25hbCBCYW5rJ1xuICogQHBhcmFtIHNpemVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ1Y2tldHMoZGF0YSwgY29sb3VyLCBpbmRpdmlkdWFsQ29sb3VyLCBzaXplKSB7XG4gICAgaWYgKCFkYXRhIHx8ICFkYXRhLmxlbmd0aCkgcmV0dXJuIHsgY29sb3VyczogbmV3IFNldCgpLCBzaXplczogbmV3IFNldCgpfTtcblxuICAgIGNvbnN0IGNvbG91cnMgPSBuZXcgU2V0KCksICAvLyB0aGVzZSBhcmUgdGhlIGxhYmVscyBlLmcuICdGaXJzdCBOYXRpb25hbCBCYW5rJ1xuICAgICAgICBzaXplcyA9IG5ldyBTZXQoKSxcbiAgICAgICAgYnVja2V0Q29sb3VyID0ge307ICAgICAgLy8gbWFwcyBsYWJlbHMgZnJvbSBjb2xvdXJzIHRvIG92ZXJyaWRlIGNvbG91cnMgZS5nLiAnRmlyc3QgTmF0aW9uYWwgQmFuayc6IFwiIzAwYWNiNlwiXG5cbiAgICBkYXRhLmZvckVhY2goZCA9PiB7XG4gICAgICAgIGNvbnN0IGMgPSBjb2xvdXIoZCkgICAgIC8vIGMgaXMgdGhlIGxhYmVsIGUuZy4gJ0ZpcnN0IE5hdGlvbmFsIEJhbmsnXG4gICAgICAgIGNvbG91cnMuYWRkKGMpXG4gICAgICAgIGlmIChpbmRpdmlkdWFsQ29sb3VyICYmIGluZGl2aWR1YWxDb2xvdXIoZCwgLTEpICE9PSAtMSkgYnVja2V0Q29sb3VyW2NdID0gaW5kaXZpZHVhbENvbG91cihkKVxuXG4gICAgICAgIHNpemVzLmFkZChzaXplKGQpKTtcbiAgICB9KTtcblxuICAgIHJldHVybiB7IGNvbG91cnMsIHNpemVzLCBidWNrZXRDb2xvdXIgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9Db2xvdXJLZXkoY29sb3VyKSB7XG4gICAgLy8gVE9ETyB0aGlzIGlzIG5vdCBpbnRlcm5hdGlvbmFsaXNlZCwgYW5kIG1heSBicmVhayBvbiB0aGluZ3MgbGlrZSBicmFuZCBuYW1lcy5cbiAgICBjb2xvdXIgPSBjb2xvdXIgfHwgXCJ1bmtub3duLWVsZW1lbnRcIjtcbiAgICByZXR1cm4gXCJjb2xvdXItXCIgKyBjb2xvdXIudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1xccysvZywgJy0nKS5yZXBsYWNlKC9bXmEtejAtOV0vZywgJycpO1xufSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/Legend.js\n')},"./src/LineChart.js":
/*!**************************!*\
  !*** ./src/LineChart.js ***!
  \**************************/
/*! exports provided: LineChart */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LineChart", function() { return LineChart; });\n/* harmony import */ var _Colours__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Colours */ "./src/Colours.js");\n/* harmony import */ var _Chart__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Chart */ "./src/Chart.js");\n// Copyright (C) 2013-2014, 2018 BrandsEye (PTY) LTD\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this\n// software and associated documentation files (the "Software"), to deal in the Software\n// without restriction, including without limitation the rights to use, copy, modify,\n//     merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following\n// conditions:\n//\n//     The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n//     INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n// CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n\n\nclass LineChart extends _Chart__WEBPACK_IMPORTED_MODULE_1__["Chart"] {\n\n    constructor() {\n        super();\n        this._xAxisTickFormat = d3.timeFormat("%B %d");\n    }\n\n    //------------------------------------------------------\n\n    data(data) {\n        if (!arguments.length) return this._data;\n        if (data && data[0].key === undefined) {\n            data = [\n                {\n                    key: "series 1",\n                    values: data\n                }\n            ];\n        }\n        this._data = data;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    element(element) {\n        if (!arguments.length) return this._element;\n        this._element = element;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    showLabels(show) {\n        if (!arguments.length) return this._show_labels;\n        this._show_labels = show;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    // todo dispatch\n    showLegend(show) {\n        if (!arguments.length) return this._show_legend;\n        this._show_legend = show;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    x(x) {\n        if (!arguments.length) return this._x;\n        this._x = x;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    y(y) {\n        if (!arguments.length) return this._y;\n        this._y = y;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    width(width) {\n        if (!arguments.length) return this._width;\n        this._width = width;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    height(height) {\n        if (!arguments.length) return this._height;\n        this._height = height;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    colours(colours) {\n        if (!arguments.length) return this._colours;\n        this._colours = colours;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    backgroundColour(colour) {\n        if (!arguments.length) return this._backgroundColour;\n        this._backgroundColour = colour || "#FFF"; // never set it to null.\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    tickFormat(format) {\n        if (!arguments.length) return this._tickFormat;\n        this._tickFormat = format;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    xAxisTickFormat(format) {\n        if (!arguments.length) return this._xAxisTickFormat;\n        this._xAxisTickFormat = format || (d => d.toString());\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    labelFormat(format) {\n        if (!arguments.length) return this._labelFormat;\n        this._labelFormat = format || (d => d.toString());\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    // todo missing\n    labelCompression(compression) {\n        if (!arguments.length) return this._compression;\n        this._compression = compression;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    //todo missing\n    dataAxisLabel(label) {\n        if (!arguments.length) return this._dataAxisLabel;\n        this._dataAxisLabel = label;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    tooltip(tooltip) {\n        if (!arguments.length) return this._tooltip;\n        this._tooltip = tooltip;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    forceY(force) {\n        if (!arguments.length) return this._forceY;\n        this._forceY = force;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n// todo missing\n    duration(duration) {\n        if (!arguments.length) return this._duration;\n        this._duration = duration;\n        return this;\n    }\n\n// todo missing\n    coarseness(coarseness) {\n        if (!arguments.length) return this._coarseness;\n        this._coarseness = coarseness;\n        return this;\n    }\n\n    // todo missing\n    padding(padding) {\n        if (!arguments.length) return this._padding;\n        this._padding = padding;\n        return this;\n    }\n\n    // todo missing\n    xAxisTooltips(tooltips) {\n        if (!arguments.length) return this._xAxisTooltips;\n        this._xAxisTooltips = tooltips;\n        return this;\n    }\n\n    xAxisOverride(override) {\n        if (!arguments.length) return this._xAxisOverride;\n        this._xAxisOverride = override;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    dispatch() {\n        return this._dispatch;\n    }\n\n    //------------------------------------------------------\n\n    render() {\n        if (!this._element) throw new Error("No element set for ColumnChart. See #element()");\n        if (!this._data) {\n            console.warn("No data set for ColumnChart. See #data()");\n            return;\n        }\n\n        const data = this.getTransformedData();\n        const keys = this.getKeys();\n\n        //------------------------------------------------\n        // Set up the SVG area\n\n        let topLevel = d3.select(this._element).select("svg");\n        if (topLevel.empty()) {\n            topLevel = d3.select(this._element).append("svg");\n        }\n\n        topLevel\n            .style("width", this._width + "px")\n            .style("height", this._height + "px");\n\n\n        // ---------------------------------\n        // Layout the showLegend.\n        //\n        // We do this now because we need to know how much space the legend\n        // takes up in order to finish calculating the margins.\n\n        const legendHeight = this.renderLegend();\n\n        //----------------------------------\n        // Calculate margins.\n\n        const margin = {top: 20, right: 20, bottom: 40, left: 40};\n        margin.bottom += legendHeight ? legendHeight + 20 : 0;\n\n        if (this._dataAxisLabel) margin.left += 20 + 12;\n        if (data) {\n            let maxLabelLength = 0;\n            data.forEach(d => {\n                d.data.forEach(d => {\n                    let length = this._xAxisTickFormat(this._x(d)).length;\n                    if (length > maxLabelLength) maxLabelLength = length;\n                })\n            });\n            margin.bottom += maxLabelLength * 2 + 10;    // space for axes labels.\n        }\n\n        const width = this._width - margin.left - margin.right,\n            height = this._height - margin.top - margin.bottom;\n\n        //----------------------------------\n        // Calculate scales and so on.\n\n\n        const x = d3.scaleTime()\n            .range([0, width]);\n\n        const y = d3.scaleLinear()\n            .range([height, 0])\n            .nice(5);\n        this._xscale = x;\n        this._yscale = y;\n\n        // Scale the range of the data in the domains\n\n        const allData = data.map(d => d.data).reduce((acc, val) => acc.concat(val));\n        x.domain(d3.extent(allData, d => d._x));\n        y.domain([Math.min(0, d3.min(allData, d => d._y)), d3.max(allData, d => d._y)]);\n\n        //------------------------------\n\n        let svg = topLevel.select(\'.main-group\');\n\n        if (svg.empty()) {\n            svg = topLevel\n                .append("g")\n                .attr("class", "main-group");\n        }\n\n        svg.attr("transform", "translate(" + margin.left + "," + margin.top + ")");\n\n        //---------------------------------\n        // append the lines\n        let lineGroup = svg.select(".lines");\n        lineGroup.selectAll("circle").remove();\n\n        let circle = false;\n        let lastMouse = null;\n        let lastMin = null;\n\n        if (lineGroup.empty()) {\n            lineGroup = svg\n                .append("g")\n                .attr("class", "lines")\n\n            lineGroup\n                .append("rect")\n                .style("opacity", "0")\n                .attr("width", "100%")\n                .attr("height", "100%");\n        }\n\n        lineGroup\n            .on("mousemove", (d, i, nodes) => { // Darken the bar on mouse over\n                const mouse = d3.mouse(nodes[i]);\n\n                const xval = x.invert(mouse[0]);\n                const yval = y.invert(mouse[1]);\n                // let min = this.getClosestPoint(xval, yval, this.getTransformedData()[0].data);\n\n                let mins = data.map(d => this.getClosestPoint(xval, yval, d.data));\n                mins.forEach(d => d._dist =  [x(d._x), y(d._y)])\n\n                mins = mins.filter(min => {\n                    const minScreenDist = Math.sqrt((mouse[0] - min._dist[0]) ** 2 + (mouse[1] - min._dist[1]) ** 2);\n                    min._min_screen = minScreenDist;\n                    return minScreenDist < 100;\n                });\n\n\n                if (!mins || !mins.length) {\n                    lastMouse = null;\n                    lineGroup.selectAll("circle").remove();\n                    return;\n                }\n\n                mins = mins.sort((lhs, rhs) => lhs._min_screen - rhs._min_screen);\n                let min = mins[0];\n\n                if (circle) {\n                    if (lastMin && min._x.getTime() === lastMin._x.getTime()) return;\n                    lineGroup.selectAll("circle").remove();\n                }\n\n                circle = true;\n                lastMouse = mouse;\n                lastMin = min;\n                lineGroup\n                    .append("circle")\n                        .attr("cx", x(min._x))\n                        .attr("cy", y(min._y))\n                        .attr("r", 10)\n                        .attr("fill", this.getSeriesColour(min._s_i))\n                        .style("opacity", 0.1)\n                    .on("mouseover", () => {\n                        this._dispatch.call("tooltipShow", this, {\n                            e: d3.event,\n                            point: min,\n                            series: data[min._s_i],\n                            seriesIndex: min._s_i,\n                            value: min._y\n                        })\n                    })\n                    .on("mouseout", (d, i, nodes) => { // bar is regular colour on mouse out.\n                        this._dispatch.call("tooltipHide", this);\n                    })\n                    .transition()\n                        .style("opacity", 0.5)\n\n            });\n\n        let lines = lineGroup.selectAll(\'.line\');\n        lines = lines.data(data);\n\n        lines.exit().remove();\n\n        const line = d3.line()\n            .x(d => x(d._x))\n            .y(d => y(d._y));\n\n        lines\n            .enter()\n            .append("path")\n                .attr("class", "line")\n                .attr("fill", "none")\n                .attr("stroke", (d, i) => this.getSeriesColour(i))\n                .attr("stroke-linejoin", "round")\n                .attr("stroke-linecap", "round")\n                .attr("stroke-width", 1.5)\n                .style("opacity", 0)\n\n            // .transition()\n            // .duration(this._duration)\n                .style("opacity", 1)\n                .attr("d", d => line(d.data));\n\n        lines\n            // .transition()\n            .attr("d", d => line(d.data));\n\n\n        // Adding new groups, and hence adding new bars to those groups.\n        // groups.enter()\n        //     .append("g")\n        //     .attr("class", "group")\n        //     .attr("transform", d => "translate(" + x(d.key) + ",0)")\n        //     .attr("width", x.bandwidth())\n        //     .attr("height", "100%")\n        //     .merge(groups)\n        //     .interrupt("groups:move")\n        //     .transition("groups:move")\n        //     .attr("transform", d => "translate(" + x(d.key) + ",0)")\n        //     .attr("width", x.bandwidth())\n        //     .each((s_d, s_i, nodes) => {\n        //         let group = d3.select(nodes[s_i])\n        //\n        //         let bars = group.selectAll(".bar")\n        //             .data(s_d.data);\n        //\n        //         bars.exit().remove();\n        //\n        //         bars.interrupt("bar:move")     // Animate the bars to their new position.\n        //             .transition("bar:move")\n        //             .attr("width", xGroup.bandwidth())\n        //             .attr("x", d => xGroup(d._key))\n        //             .attr("y", 0);\n        //\n        //         bars.enter()\n        //             .append("rect")\n        //             .attr("class", (d, i) => "bar series series-" + i)\n        //             .attr("x", d => xGroup(d._key))\n        //             .attr("y", 0)\n        //             .attr("width", xGroup.bandwidth())\n        //             .attr("height", 0)\n        //             .style("fill", (d, i) => this.getSeriesColour(i))\n        //             .style("cursor", "pointer")\n        //             .on("mouseover", (d, i, nodes) => { // Darken the bar on mouse over\n        //                 d3.select(nodes[i])\n        //                     .interrupt("hover:colour")\n        //                     .transition("hover:colour")\n        //                     .duration(400)\n        //                     .style("fill", d3.hcl(this.getSeriesColour(i)).darker())\n        //                 this._dispatch.call("tooltipShow", this, {\n        //                     e: d3.event,\n        //                     point: d,\n        //                     series: s_d,\n        //                     seriesIndex: s_i,\n        //                     value: d._y\n        //                 })\n        //             })\n        //             .on("mouseout", (d, i, nodes) => { // bar is regular colour on mouse out.\n        //                 d3.select(nodes[i])\n        //                     .interrupt("hover:colour")\n        //                     .transition("hover:colour")\n        //                     .duration(400)\n        //                     .style("fill", this.getSeriesColour(i));\n        //                 this._dispatch.call("tooltipHide", this);\n        //             })\n        //             .on("click auxclick", (d, i, nodes) => {\n        //                 this._dispatch.call("elementClick", this, {\n        //                     e: d3.event,\n        //                     point: d,\n        //                     series: d._series,\n        //                     seriesIndex: s_i,\n        //                     value: this._y(d)\n        //                 })\n        //             })\n        //             .merge(bars)\n        //             .interrupt("bar:growth")    // Animate bars growing.\n        //             .transition("bar:growth")\n        //             .delay((d) => {\n        //                 return this.calcBarGrowth(s_i, nodes.length);\n        //             })\n        //             .duration(this._duration)\n        //             .style("fill", (d, i) => this.getSeriesColour(i))\n        //             .attr("height", d => height - y(d._y));\n        //\n        //     })\n\n        // ---------------------------------\n        // Labels loaded after our first bar grows.\n        // if (this._show_labels) {\n        //     svg.transition("bar:growth")\n        //         .on("end", (d, i, nodes) => {\n        //             if (i < nodes.length - 1) return;\n        //             this.renderLabels(svg, data, x, xGroup, y);\n        //         })\n        // }\n\n        // ---------------------------------\n        // Draw the y axis data label.\n\n        if (this._dataAxisLabel) {\n            this.renderDataAxisLabel(height, margin);\n        }\n\n        // ---------------------------------\n        // Set the background colour\n\n        d3.select(this._element).select(".background").remove();\n        if (this._backgroundColour) {\n            d3.select(this._element).select("svg")\n                .append("rect")\n                .attr("class", "background")\n                .attr("width", "100%")\n                .attr("height", "100%")\n                .style("fill", this._backgroundColour)\n                .lower();\n        }\n\n        //---------------------------------\n        // add the Y gridlines\n        svg.call(this.grid, width, d3.axisLeft(y).ticks(5));\n\n        //---------------------------------\n        // axes\n        svg.call(this.xaxis, height, d3.axisBottom(x).tickSize(0).tickPadding(5).tickFormat(this._xAxisTickFormat)); //); //\n        svg.call(this.yaxis, d3.axisLeft(y).ticks(5).tickFormat(this._tickFormat));\n    }\n\n    //------------------------------------------------------\n\n    /*\n     * Returns an object with two functions, #show() and #hide(),\n     * to show and hide the labels.\n     */\n    labels() {\n        return {\n\n            show: () => {\n                if (this._element) {\n                    let selection = this._element,\n                        data = this.getTransformedData(),\n                        xscale = this._xscale,\n                        xgroup = this._xgroupscale,\n                        yscale = this._yscale;\n\n                    if (selection) selection = d3.select(this._element).select("svg").select("g");\n                    if (!selection.empty() && data && xscale && yscale && xgroup) {\n                        let labels = selection.select(\'.chart-labels\');\n                        if (!labels.empty()) return;\n                        labels.remove()\n                        this.renderLabels(selection, data, xscale, xgroup, yscale, false);\n                    }\n                }\n\n            },\n\n            hide: () => {\n                if (this._element) {\n                    d3.select(this._element)\n                        .select(\'.chart-labels\')\n                        .interrupt("labels")\n                        .interrupt("labels:fade")\n                        .transition("labels:fade")\n                        .style("opacity", 0)\n                        .on("end", (d, i, nodes) => {\n                            d3.select(nodes[i]).remove();\n                        })\n                }\n            }\n        }\n    }\n\n    //------------------------------------------------------\n\n    renderLabels(selection, data, xscale, xgroup, yscale, animate) {\n        animate = animate === undefined ? true : animate;\n        selection.selectAll(".chart-labels").remove();\n\n        let labels = selection.append("g")\n            .attr("class", "chart-labels")\n            // .selectAll(".chart-label")\n            .selectAll(".label-group")\n            .data(data)\n\n        let maxWidth = 0;     // For calculating the max width of text.\n        let fontSize = 12;    // Our initial font size.\n        const buffer = 5;     // Buffer space between words and the top of a bar.\n        const calcDy = (ypos) => ypos < 10 ? fontSize + buffer : -buffer;\n\n        labels.enter().each((series, s_i, s_nodes) => {\n            let group = d3.select(s_nodes[s_i])\n                .append("g")\n                .attr("class", "label-group")\n                .attr("transform", d => "translate(" + xscale(d.key) + ",0)")\n                .selectAll(".chart-label")\n                .data(series.data)\n                .enter()\n                .each((d, i, nodes) => {\n\n                    // Want to figure out if the label is too dark / light for the\n                    // bar.\n                    let invertedColor = d3.hcl(this.getSeriesColour(i));\n                    invertedColor.l += Math.min(invertedColor.l + 50, 100);\n                    let invert = d3.hcl(this.getSeriesColour(i)).l < 60;\n\n                    let ypos = yscale(d._y);\n                    let dy = calcDy(ypos);\n                    let text = d3.select(nodes[i])\n                        .append("text")\n                        .text(this._labelFormat(d._y))\n                        .attr("class", "chart-label")\n                        .attr("y", ypos)\n                        .attr("dx", animate ? -15 : 0)\n                        .attr("dy", dy)\n                        .style("opacity", 0)\n                        .style("pointer-events", "none")\n                        // .style("font-family", "Open Sans, sans-serif")\n                        // .style("font-weight", "normal")\n                        // .style("font-size", fontSize + "px")\n                        .style("fill", dy > 0 && invert ? invertedColor.toString() : _Colours__WEBPACK_IMPORTED_MODULE_0__["colours"].eighteen.darkGrey);\n\n                    // Set the x position, which is based on width.\n                    const width = text.node().getBBox().width;\n                    maxWidth = Math.max(width, maxWidth);\n                    text\n                        .attr("x", xgroup(d._key) + xgroup.bandwidth() / 2 - width / 2);\n\n                    text\n                        .transition("labels")\n                        .delay(() => animate ? this.calcBarGrowth(s_i, s_nodes.length) : 0) // Delay in lockstep with bar growth.\n                        .duration(this._duration)\n                        .attr("dx", 0)\n                        .style("opacity", 1)\n                })\n        })\n\n\n        // Figure out if we don\'t have enough space to show our labels.\n        // We then want to resize, if possible.\n        if (xgroup.bandwidth() < maxWidth * 1.05) {\n            let scale = maxWidth / xgroup.bandwidth() * 1.05;\n            fontSize = Math.floor(fontSize / scale);\n\n            if (fontSize < 8) {\n                // The labels are too small.\n                labels.enter().selectAll("text").remove();\n            } else {\n                labels.enter()\n                    .merge(labels)\n                    .selectAll("text")\n                    .style("font-size", fontSize + "px")\n                    .each((d, i, nodes) => {\n                        const text = d3.select(nodes[i]);\n                        const width = text.node().getBBox().width;\n                        text\n                            .attr("x", xgroup(d._key) + xgroup.bandwidth() / 2 - width / 2)\n                            .attr("dy", calcDy(d._y));\n                    })\n            }\n        }\n    }\n\n    //------------------------------------------------------\n\n    renderDataAxisLabel(height, margins) {\n        let svg = d3.select(this._element).select(\'svg\');\n        svg.selectAll(".data-labels").remove();\n\n        if (!this._dataAxisLabel) return;\n        let text = this._dataAxisLabel;\n        if (text.long) text = text.long;\n\n        let x = -(margins.top + height / 2);\n\n        let label = svg.append("g")\n            .attr("class", "data-labels")\n            .append("text")\n            .text(text)\n            .attr("transform", "rotate(-90 0,0) translate(" + x + ", 20)")\n            // .style("font-family", "Open Sans, sans-serif")\n            // .style("font-size", "12px")\n            // .style("font-style", "italic")\n            .style("fill", _Colours__WEBPACK_IMPORTED_MODULE_0__["colours"].eighteen.darkGrey);\n\n        let width = label.node().getBBox().width;\n        if (width >= height && this._dataAxisLabel.short) {\n            label.text(this._dataAxisLabel.short);\n            width = label.node().getBBox().width;\n        }\n\n        label.attr("dx", -width / 2);\n    }\n\n    //------------------------------------------------------\n\n    grid(selection, width, axis) {\n        selection.select(".grid").remove();\n\n        let grid = selection.append("g")\n            .attr("class", "grid")\n            .call(axis\n                .tickSize(-width)\n                .tickFormat("")\n            );\n\n        grid.selectAll("line")\n            .style("stroke", _Colours__WEBPACK_IMPORTED_MODULE_0__["colours"].eighteen.lightGrey);\n        grid.selectAll(".domain").remove();\n\n        grid\n            .lower() // Always ensure that this is earlier in the dom. Things must be drawn on top of it.\n            .style("opacity", 0)\n            .transition()\n            .delay(500)\n            .duration(500)\n            .style("opacity", 1);\n    }\n\n    //------------------------------------------------------\n\n    xaxis(selection, height, xaxis) {\n        selection.select(".x-axis").remove();\n        let axis = selection.append("g")\n            .attr("class", "x-axis")\n            .attr("transform", "translate(0," + height + ")")\n            .style("opacity", 0)\n            .call(xaxis);\n\n        axis.select(".domain").remove();\n\n        axis\n            .selectAll("text")\n            .style(\'text-anchor\', \'end\')\n            .attr(\'transform\', \'rotate(-30, 0,0)\');\n\n        axis\n            .transition()\n            .duration(1000)\n            .style("opacity", 1);\n    }\n\n    //------------------------------------------------------\n\n    yaxis(selection, axis) {\n        selection.select(".y-axis").remove();\n        let x = selection.append("g")\n            .attr("class", "y-axis")\n            .call(axis.tickSize(0).tickPadding(10))\n            .style("opacity", 0)\n            .transition()\n            .duration(1000)\n            .style("opacity", 1);\n\n        x.selectAll("text")\n            // .style("font-family", "Open Sans, sans-serif")\n            .style("fill", _Colours__WEBPACK_IMPORTED_MODULE_0__["colours"].eighteen.darkGrey)\n    }\n\n    //------------------------------------------------------\n\n    calcBarGrowth(i, max) {\n        if (max < 10) return i * this._BAR_GROWTH / 2;\n        if (max < 35) return i * this._BAR_GROWTH / 4;\n        return 1;\n    }\n\n    getSeriesColour(i) {\n        if (i < 0 || !this._colours) return _Colours__WEBPACK_IMPORTED_MODULE_0__["colours"].eighteen.midGrey;\n\n        i = i % this._colours.length;\n        return this._colours[i];\n    }\n\n    getSortedData() {\n        let data = this._data;\n        if (!data || !data.length) return [];\n\n        data = this._data.sort((lhs, rhs) => {\n            lhs = lhs.key.toLowerCase();\n            rhs = rhs.key.toLowerCase();\n\n            if (lhs === rhs) return 0;\n            if (lhs < rhs) return -1;\n            return 1;\n        });\n\n        return data;\n    }\n\n    getTransformedData() {\n        let data = this.getSortedData();\n        if (!data || !data.length) return [];\n\n        let results = [];\n\n        data.forEach((series, s_i) => {\n            let s = Object.assign({}, series);\n            results.push(s);\n\n            let data = [];\n            s.values.forEach((d) => {\n                data.push(Object.assign({\n                    _x: new Date(this._xAxisOverride ? this._xAxisOverride[this._x(d)] : this._x(d)),\n                    _series: series,\n                    _s_i: s_i,\n                    _key: series.key,\n                    _y: this._y(d)\n                }, d));\n            });\n\n            s.data = data;\n            delete s.values;\n        });\n\n        return results;\n    }\n\n    getKeys() {\n        let data = this._data;\n        if (!data || !data.length) return [];\n\n        return [...new Set(data.map(d => d.key))]\n    }\n\n    getClosestPoint(xval, yval, data) {\n        let calcDist = d => Math.sqrt(Math.abs(d._x - xval) ** 2 + (d._y - yval) ** 2);\n        let min = data[0];\n        let minDist = calcDist(min);\n\n        data.forEach(d => {\n            let dist = calcDist(d);\n            if (dist < minDist) {\n                minDist = dist;\n                min = d;\n            }\n        });\n\n        return min;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvTGluZUNoYXJ0LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYjNqcy8uL3NyYy9MaW5lQ2hhcnQuanM/ODk0ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKEMpIDIwMTMtMjAxNCwgMjAxOCBCcmFuZHNFeWUgKFBUWSkgTFREXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZiB0aGlzXG4vLyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmVcbi8vIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSxcbi8vICAgICBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvXG4vLyBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZ1xuLy8gY29uZGl0aW9uczpcbi8vXG4vLyAgICAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4vLyBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vICAgICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SIElNUExJRUQsXG4vLyAgICAgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEFcbi8vIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFRcbi8vIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRlxuLy8gQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFXG4vLyBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IHtjb2xvdXJzfSBmcm9tICcuL0NvbG91cnMnO1xuaW1wb3J0IHtDaGFydH0gZnJvbSAnLi9DaGFydCc7XG5cblxuZXhwb3J0IGNsYXNzIExpbmVDaGFydCBleHRlbmRzIENoYXJ0IHtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl94QXhpc1RpY2tGb3JtYXQgPSBkMy50aW1lRm9ybWF0KFwiJUIgJWRcIik7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGRhdGEoZGF0YSkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9kYXRhO1xuICAgICAgICBpZiAoZGF0YSAmJiBkYXRhWzBdLmtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBkYXRhID0gW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAga2V5OiBcInNlcmllcyAxXCIsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlczogZGF0YVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZGF0YSA9IGRhdGE7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBlbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fZWxlbWVudDtcbiAgICAgICAgdGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBzaG93TGFiZWxzKHNob3cpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fc2hvd19sYWJlbHM7XG4gICAgICAgIHRoaXMuX3Nob3dfbGFiZWxzID0gc2hvdztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8vIHRvZG8gZGlzcGF0Y2hcbiAgICBzaG93TGVnZW5kKHNob3cpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fc2hvd19sZWdlbmQ7XG4gICAgICAgIHRoaXMuX3Nob3dfbGVnZW5kID0gc2hvdztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHgoeCkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl94O1xuICAgICAgICB0aGlzLl94ID0geDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHkoeSkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl95O1xuICAgICAgICB0aGlzLl95ID0geTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHdpZHRoKHdpZHRoKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3dpZHRoO1xuICAgICAgICB0aGlzLl93aWR0aCA9IHdpZHRoO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgaGVpZ2h0KGhlaWdodCkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9oZWlnaHQ7XG4gICAgICAgIHRoaXMuX2hlaWdodCA9IGhlaWdodDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGNvbG91cnMoY29sb3Vycykge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9jb2xvdXJzO1xuICAgICAgICB0aGlzLl9jb2xvdXJzID0gY29sb3VycztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGJhY2tncm91bmRDb2xvdXIoY29sb3VyKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX2JhY2tncm91bmRDb2xvdXI7XG4gICAgICAgIHRoaXMuX2JhY2tncm91bmRDb2xvdXIgPSBjb2xvdXIgfHwgXCIjRkZGXCI7IC8vIG5ldmVyIHNldCBpdCB0byBudWxsLlxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgdGlja0Zvcm1hdChmb3JtYXQpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fdGlja0Zvcm1hdDtcbiAgICAgICAgdGhpcy5fdGlja0Zvcm1hdCA9IGZvcm1hdDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHhBeGlzVGlja0Zvcm1hdChmb3JtYXQpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5feEF4aXNUaWNrRm9ybWF0O1xuICAgICAgICB0aGlzLl94QXhpc1RpY2tGb3JtYXQgPSBmb3JtYXQgfHwgKGQgPT4gZC50b1N0cmluZygpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGxhYmVsRm9ybWF0KGZvcm1hdCkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9sYWJlbEZvcm1hdDtcbiAgICAgICAgdGhpcy5fbGFiZWxGb3JtYXQgPSBmb3JtYXQgfHwgKGQgPT4gZC50b1N0cmluZygpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8vIHRvZG8gbWlzc2luZ1xuICAgIGxhYmVsQ29tcHJlc3Npb24oY29tcHJlc3Npb24pIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fY29tcHJlc3Npb247XG4gICAgICAgIHRoaXMuX2NvbXByZXNzaW9uID0gY29tcHJlc3Npb247XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvL3RvZG8gbWlzc2luZ1xuICAgIGRhdGFBeGlzTGFiZWwobGFiZWwpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fZGF0YUF4aXNMYWJlbDtcbiAgICAgICAgdGhpcy5fZGF0YUF4aXNMYWJlbCA9IGxhYmVsO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgdG9vbHRpcCh0b29sdGlwKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3Rvb2x0aXA7XG4gICAgICAgIHRoaXMuX3Rvb2x0aXAgPSB0b29sdGlwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgZm9yY2VZKGZvcmNlKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX2ZvcmNlWTtcbiAgICAgICAgdGhpcy5fZm9yY2VZID0gZm9yY2U7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8vIHRvZG8gbWlzc2luZ1xuICAgIGR1cmF0aW9uKGR1cmF0aW9uKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX2R1cmF0aW9uO1xuICAgICAgICB0aGlzLl9kdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbi8vIHRvZG8gbWlzc2luZ1xuICAgIGNvYXJzZW5lc3MoY29hcnNlbmVzcykge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9jb2Fyc2VuZXNzO1xuICAgICAgICB0aGlzLl9jb2Fyc2VuZXNzID0gY29hcnNlbmVzcztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gdG9kbyBtaXNzaW5nXG4gICAgcGFkZGluZyhwYWRkaW5nKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3BhZGRpbmc7XG4gICAgICAgIHRoaXMuX3BhZGRpbmcgPSBwYWRkaW5nO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyB0b2RvIG1pc3NpbmdcbiAgICB4QXhpc1Rvb2x0aXBzKHRvb2x0aXBzKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3hBeGlzVG9vbHRpcHM7XG4gICAgICAgIHRoaXMuX3hBeGlzVG9vbHRpcHMgPSB0b29sdGlwcztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgeEF4aXNPdmVycmlkZShvdmVycmlkZSkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl94QXhpc092ZXJyaWRlO1xuICAgICAgICB0aGlzLl94QXhpc092ZXJyaWRlID0gb3ZlcnJpZGU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBkaXNwYXRjaCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc3BhdGNoO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGlmICghdGhpcy5fZWxlbWVudCkgdGhyb3cgbmV3IEVycm9yKFwiTm8gZWxlbWVudCBzZXQgZm9yIENvbHVtbkNoYXJ0LiBTZWUgI2VsZW1lbnQoKVwiKTtcbiAgICAgICAgaWYgKCF0aGlzLl9kYXRhKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJObyBkYXRhIHNldCBmb3IgQ29sdW1uQ2hhcnQuIFNlZSAjZGF0YSgpXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMuZ2V0VHJhbnNmb3JtZWREYXRhKCk7XG4gICAgICAgIGNvbnN0IGtleXMgPSB0aGlzLmdldEtleXMoKTtcblxuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBTZXQgdXAgdGhlIFNWRyBhcmVhXG5cbiAgICAgICAgbGV0IHRvcExldmVsID0gZDMuc2VsZWN0KHRoaXMuX2VsZW1lbnQpLnNlbGVjdChcInN2Z1wiKTtcbiAgICAgICAgaWYgKHRvcExldmVsLmVtcHR5KCkpIHtcbiAgICAgICAgICAgIHRvcExldmVsID0gZDMuc2VsZWN0KHRoaXMuX2VsZW1lbnQpLmFwcGVuZChcInN2Z1wiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRvcExldmVsXG4gICAgICAgICAgICAuc3R5bGUoXCJ3aWR0aFwiLCB0aGlzLl93aWR0aCArIFwicHhcIilcbiAgICAgICAgICAgIC5zdHlsZShcImhlaWdodFwiLCB0aGlzLl9oZWlnaHQgKyBcInB4XCIpO1xuXG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIExheW91dCB0aGUgc2hvd0xlZ2VuZC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gV2UgZG8gdGhpcyBub3cgYmVjYXVzZSB3ZSBuZWVkIHRvIGtub3cgaG93IG11Y2ggc3BhY2UgdGhlIGxlZ2VuZFxuICAgICAgICAvLyB0YWtlcyB1cCBpbiBvcmRlciB0byBmaW5pc2ggY2FsY3VsYXRpbmcgdGhlIG1hcmdpbnMuXG5cbiAgICAgICAgY29uc3QgbGVnZW5kSGVpZ2h0ID0gdGhpcy5yZW5kZXJMZWdlbmQoKTtcblxuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gQ2FsY3VsYXRlIG1hcmdpbnMuXG5cbiAgICAgICAgY29uc3QgbWFyZ2luID0ge3RvcDogMjAsIHJpZ2h0OiAyMCwgYm90dG9tOiA0MCwgbGVmdDogNDB9O1xuICAgICAgICBtYXJnaW4uYm90dG9tICs9IGxlZ2VuZEhlaWdodCA/IGxlZ2VuZEhlaWdodCArIDIwIDogMDtcblxuICAgICAgICBpZiAodGhpcy5fZGF0YUF4aXNMYWJlbCkgbWFyZ2luLmxlZnQgKz0gMjAgKyAxMjtcbiAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgIGxldCBtYXhMYWJlbExlbmd0aCA9IDA7XG4gICAgICAgICAgICBkYXRhLmZvckVhY2goZCA9PiB7XG4gICAgICAgICAgICAgICAgZC5kYXRhLmZvckVhY2goZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBsZW5ndGggPSB0aGlzLl94QXhpc1RpY2tGb3JtYXQodGhpcy5feChkKSkubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGVuZ3RoID4gbWF4TGFiZWxMZW5ndGgpIG1heExhYmVsTGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG1hcmdpbi5ib3R0b20gKz0gbWF4TGFiZWxMZW5ndGggKiAyICsgMTA7ICAgIC8vIHNwYWNlIGZvciBheGVzIGxhYmVscy5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHdpZHRoID0gdGhpcy5fd2lkdGggLSBtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodCxcbiAgICAgICAgICAgIGhlaWdodCA9IHRoaXMuX2hlaWdodCAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tO1xuXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBDYWxjdWxhdGUgc2NhbGVzIGFuZCBzbyBvbi5cblxuXG4gICAgICAgIGNvbnN0IHggPSBkMy5zY2FsZVRpbWUoKVxuICAgICAgICAgICAgLnJhbmdlKFswLCB3aWR0aF0pO1xuXG4gICAgICAgIGNvbnN0IHkgPSBkMy5zY2FsZUxpbmVhcigpXG4gICAgICAgICAgICAucmFuZ2UoW2hlaWdodCwgMF0pXG4gICAgICAgICAgICAubmljZSg1KTtcbiAgICAgICAgdGhpcy5feHNjYWxlID0geDtcbiAgICAgICAgdGhpcy5feXNjYWxlID0geTtcblxuICAgICAgICAvLyBTY2FsZSB0aGUgcmFuZ2Ugb2YgdGhlIGRhdGEgaW4gdGhlIGRvbWFpbnNcblxuICAgICAgICBjb25zdCBhbGxEYXRhID0gZGF0YS5tYXAoZCA9PiBkLmRhdGEpLnJlZHVjZSgoYWNjLCB2YWwpID0+IGFjYy5jb25jYXQodmFsKSk7XG4gICAgICAgIHguZG9tYWluKGQzLmV4dGVudChhbGxEYXRhLCBkID0+IGQuX3gpKTtcbiAgICAgICAgeS5kb21haW4oW01hdGgubWluKDAsIGQzLm1pbihhbGxEYXRhLCBkID0+IGQuX3kpKSwgZDMubWF4KGFsbERhdGEsIGQgPT4gZC5feSldKTtcblxuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgIGxldCBzdmcgPSB0b3BMZXZlbC5zZWxlY3QoJy5tYWluLWdyb3VwJyk7XG5cbiAgICAgICAgaWYgKHN2Zy5lbXB0eSgpKSB7XG4gICAgICAgICAgICBzdmcgPSB0b3BMZXZlbFxuICAgICAgICAgICAgICAgIC5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcIm1haW4tZ3JvdXBcIik7XG4gICAgICAgIH1cblxuICAgICAgICBzdmcuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIG1hcmdpbi5sZWZ0ICsgXCIsXCIgKyBtYXJnaW4udG9wICsgXCIpXCIpO1xuXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIGFwcGVuZCB0aGUgbGluZXNcbiAgICAgICAgbGV0IGxpbmVHcm91cCA9IHN2Zy5zZWxlY3QoXCIubGluZXNcIik7XG4gICAgICAgIGxpbmVHcm91cC5zZWxlY3RBbGwoXCJjaXJjbGVcIikucmVtb3ZlKCk7XG5cbiAgICAgICAgbGV0IGNpcmNsZSA9IGZhbHNlO1xuICAgICAgICBsZXQgbGFzdE1vdXNlID0gbnVsbDtcbiAgICAgICAgbGV0IGxhc3RNaW4gPSBudWxsO1xuXG4gICAgICAgIGlmIChsaW5lR3JvdXAuZW1wdHkoKSkge1xuICAgICAgICAgICAgbGluZUdyb3VwID0gc3ZnXG4gICAgICAgICAgICAgICAgLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwibGluZXNcIilcblxuICAgICAgICAgICAgbGluZUdyb3VwXG4gICAgICAgICAgICAgICAgLmFwcGVuZChcInJlY3RcIilcbiAgICAgICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMFwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwid2lkdGhcIiwgXCIxMDAlXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgXCIxMDAlXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGluZUdyb3VwXG4gICAgICAgICAgICAub24oXCJtb3VzZW1vdmVcIiwgKGQsIGksIG5vZGVzKSA9PiB7IC8vIERhcmtlbiB0aGUgYmFyIG9uIG1vdXNlIG92ZXJcbiAgICAgICAgICAgICAgICBjb25zdCBtb3VzZSA9IGQzLm1vdXNlKG5vZGVzW2ldKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHh2YWwgPSB4LmludmVydChtb3VzZVswXSk7XG4gICAgICAgICAgICAgICAgY29uc3QgeXZhbCA9IHkuaW52ZXJ0KG1vdXNlWzFdKTtcbiAgICAgICAgICAgICAgICAvLyBsZXQgbWluID0gdGhpcy5nZXRDbG9zZXN0UG9pbnQoeHZhbCwgeXZhbCwgdGhpcy5nZXRUcmFuc2Zvcm1lZERhdGEoKVswXS5kYXRhKTtcblxuICAgICAgICAgICAgICAgIGxldCBtaW5zID0gZGF0YS5tYXAoZCA9PiB0aGlzLmdldENsb3Nlc3RQb2ludCh4dmFsLCB5dmFsLCBkLmRhdGEpKTtcbiAgICAgICAgICAgICAgICBtaW5zLmZvckVhY2goZCA9PiBkLl9kaXN0ID0gIFt4KGQuX3gpLCB5KGQuX3kpXSlcblxuICAgICAgICAgICAgICAgIG1pbnMgPSBtaW5zLmZpbHRlcihtaW4gPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtaW5TY3JlZW5EaXN0ID0gTWF0aC5zcXJ0KChtb3VzZVswXSAtIG1pbi5fZGlzdFswXSkgKiogMiArIChtb3VzZVsxXSAtIG1pbi5fZGlzdFsxXSkgKiogMik7XG4gICAgICAgICAgICAgICAgICAgIG1pbi5fbWluX3NjcmVlbiA9IG1pblNjcmVlbkRpc3Q7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtaW5TY3JlZW5EaXN0IDwgMTAwO1xuICAgICAgICAgICAgICAgIH0pO1xuXG5cbiAgICAgICAgICAgICAgICBpZiAoIW1pbnMgfHwgIW1pbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RNb3VzZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVHcm91cC5zZWxlY3RBbGwoXCJjaXJjbGVcIikucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtaW5zID0gbWlucy5zb3J0KChsaHMsIHJocykgPT4gbGhzLl9taW5fc2NyZWVuIC0gcmhzLl9taW5fc2NyZWVuKTtcbiAgICAgICAgICAgICAgICBsZXQgbWluID0gbWluc1swXTtcblxuICAgICAgICAgICAgICAgIGlmIChjaXJjbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3RNaW4gJiYgbWluLl94LmdldFRpbWUoKSA9PT0gbGFzdE1pbi5feC5nZXRUaW1lKCkpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgbGluZUdyb3VwLnNlbGVjdEFsbChcImNpcmNsZVwiKS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjaXJjbGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGxhc3RNb3VzZSA9IG1vdXNlO1xuICAgICAgICAgICAgICAgIGxhc3RNaW4gPSBtaW47XG4gICAgICAgICAgICAgICAgbGluZUdyb3VwXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoXCJjaXJjbGVcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiY3hcIiwgeChtaW4uX3gpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJjeVwiLCB5KG1pbi5feSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcInJcIiwgMTApXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcImZpbGxcIiwgdGhpcy5nZXRTZXJpZXNDb2xvdXIobWluLl9zX2kpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAwLjEpXG4gICAgICAgICAgICAgICAgICAgIC5vbihcIm1vdXNlb3ZlclwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXNwYXRjaC5jYWxsKFwidG9vbHRpcFNob3dcIiwgdGhpcywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGU6IGQzLmV2ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50OiBtaW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzOiBkYXRhW21pbi5fc19pXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXNJbmRleDogbWluLl9zX2ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG1pbi5feVxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLm9uKFwibW91c2VvdXRcIiwgKGQsIGksIG5vZGVzKSA9PiB7IC8vIGJhciBpcyByZWd1bGFyIGNvbG91ciBvbiBtb3VzZSBvdXQuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXNwYXRjaC5jYWxsKFwidG9vbHRpcEhpZGVcIiwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMC41KVxuXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICBsZXQgbGluZXMgPSBsaW5lR3JvdXAuc2VsZWN0QWxsKCcubGluZScpO1xuICAgICAgICBsaW5lcyA9IGxpbmVzLmRhdGEoZGF0YSk7XG5cbiAgICAgICAgbGluZXMuZXhpdCgpLnJlbW92ZSgpO1xuXG4gICAgICAgIGNvbnN0IGxpbmUgPSBkMy5saW5lKClcbiAgICAgICAgICAgIC54KGQgPT4geChkLl94KSlcbiAgICAgICAgICAgIC55KGQgPT4geShkLl95KSk7XG5cbiAgICAgICAgbGluZXNcbiAgICAgICAgICAgIC5lbnRlcigpXG4gICAgICAgICAgICAuYXBwZW5kKFwicGF0aFwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJsaW5lXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJmaWxsXCIsIFwibm9uZVwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwic3Ryb2tlXCIsIChkLCBpKSA9PiB0aGlzLmdldFNlcmllc0NvbG91cihpKSlcbiAgICAgICAgICAgICAgICAuYXR0cihcInN0cm9rZS1saW5lam9pblwiLCBcInJvdW5kXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJzdHJva2UtbGluZWNhcFwiLCBcInJvdW5kXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJzdHJva2Utd2lkdGhcIiwgMS41KVxuICAgICAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMClcblxuICAgICAgICAgICAgLy8gLnRyYW5zaXRpb24oKVxuICAgICAgICAgICAgLy8gLmR1cmF0aW9uKHRoaXMuX2R1cmF0aW9uKVxuICAgICAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMSlcbiAgICAgICAgICAgICAgICAuYXR0cihcImRcIiwgZCA9PiBsaW5lKGQuZGF0YSkpO1xuXG4gICAgICAgIGxpbmVzXG4gICAgICAgICAgICAvLyAudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAuYXR0cihcImRcIiwgZCA9PiBsaW5lKGQuZGF0YSkpO1xuXG5cbiAgICAgICAgLy8gQWRkaW5nIG5ldyBncm91cHMsIGFuZCBoZW5jZSBhZGRpbmcgbmV3IGJhcnMgdG8gdGhvc2UgZ3JvdXBzLlxuICAgICAgICAvLyBncm91cHMuZW50ZXIoKVxuICAgICAgICAvLyAgICAgLmFwcGVuZChcImdcIilcbiAgICAgICAgLy8gICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJncm91cFwiKVxuICAgICAgICAvLyAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgZCA9PiBcInRyYW5zbGF0ZShcIiArIHgoZC5rZXkpICsgXCIsMClcIilcbiAgICAgICAgLy8gICAgIC5hdHRyKFwid2lkdGhcIiwgeC5iYW5kd2lkdGgoKSlcbiAgICAgICAgLy8gICAgIC5hdHRyKFwiaGVpZ2h0XCIsIFwiMTAwJVwiKVxuICAgICAgICAvLyAgICAgLm1lcmdlKGdyb3VwcylcbiAgICAgICAgLy8gICAgIC5pbnRlcnJ1cHQoXCJncm91cHM6bW92ZVwiKVxuICAgICAgICAvLyAgICAgLnRyYW5zaXRpb24oXCJncm91cHM6bW92ZVwiKVxuICAgICAgICAvLyAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgZCA9PiBcInRyYW5zbGF0ZShcIiArIHgoZC5rZXkpICsgXCIsMClcIilcbiAgICAgICAgLy8gICAgIC5hdHRyKFwid2lkdGhcIiwgeC5iYW5kd2lkdGgoKSlcbiAgICAgICAgLy8gICAgIC5lYWNoKChzX2QsIHNfaSwgbm9kZXMpID0+IHtcbiAgICAgICAgLy8gICAgICAgICBsZXQgZ3JvdXAgPSBkMy5zZWxlY3Qobm9kZXNbc19pXSlcbiAgICAgICAgLy9cbiAgICAgICAgLy8gICAgICAgICBsZXQgYmFycyA9IGdyb3VwLnNlbGVjdEFsbChcIi5iYXJcIilcbiAgICAgICAgLy8gICAgICAgICAgICAgLmRhdGEoc19kLmRhdGEpO1xuICAgICAgICAvL1xuICAgICAgICAvLyAgICAgICAgIGJhcnMuZXhpdCgpLnJlbW92ZSgpO1xuICAgICAgICAvL1xuICAgICAgICAvLyAgICAgICAgIGJhcnMuaW50ZXJydXB0KFwiYmFyOm1vdmVcIikgICAgIC8vIEFuaW1hdGUgdGhlIGJhcnMgdG8gdGhlaXIgbmV3IHBvc2l0aW9uLlxuICAgICAgICAvLyAgICAgICAgICAgICAudHJhbnNpdGlvbihcImJhcjptb3ZlXCIpXG4gICAgICAgIC8vICAgICAgICAgICAgIC5hdHRyKFwid2lkdGhcIiwgeEdyb3VwLmJhbmR3aWR0aCgpKVxuICAgICAgICAvLyAgICAgICAgICAgICAuYXR0cihcInhcIiwgZCA9PiB4R3JvdXAoZC5fa2V5KSlcbiAgICAgICAgLy8gICAgICAgICAgICAgLmF0dHIoXCJ5XCIsIDApO1xuICAgICAgICAvL1xuICAgICAgICAvLyAgICAgICAgIGJhcnMuZW50ZXIoKVxuICAgICAgICAvLyAgICAgICAgICAgICAuYXBwZW5kKFwicmVjdFwiKVxuICAgICAgICAvLyAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIChkLCBpKSA9PiBcImJhciBzZXJpZXMgc2VyaWVzLVwiICsgaSlcbiAgICAgICAgLy8gICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIGQgPT4geEdyb3VwKGQuX2tleSkpXG4gICAgICAgIC8vICAgICAgICAgICAgIC5hdHRyKFwieVwiLCAwKVxuICAgICAgICAvLyAgICAgICAgICAgICAuYXR0cihcIndpZHRoXCIsIHhHcm91cC5iYW5kd2lkdGgoKSlcbiAgICAgICAgLy8gICAgICAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgMClcbiAgICAgICAgLy8gICAgICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCAoZCwgaSkgPT4gdGhpcy5nZXRTZXJpZXNDb2xvdXIoaSkpXG4gICAgICAgIC8vICAgICAgICAgICAgIC5zdHlsZShcImN1cnNvclwiLCBcInBvaW50ZXJcIilcbiAgICAgICAgLy8gICAgICAgICAgICAgLm9uKFwibW91c2VvdmVyXCIsIChkLCBpLCBub2RlcykgPT4geyAvLyBEYXJrZW4gdGhlIGJhciBvbiBtb3VzZSBvdmVyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICBkMy5zZWxlY3Qobm9kZXNbaV0pXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgLmludGVycnVwdChcImhvdmVyOmNvbG91clwiKVxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKFwiaG92ZXI6Y29sb3VyXCIpXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKDQwMClcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIGQzLmhjbCh0aGlzLmdldFNlcmllc0NvbG91cihpKSkuZGFya2VyKCkpXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICB0aGlzLl9kaXNwYXRjaC5jYWxsKFwidG9vbHRpcFNob3dcIiwgdGhpcywge1xuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgIGU6IGQzLmV2ZW50LFxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgIHBvaW50OiBkLFxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgIHNlcmllczogc19kLFxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgIHNlcmllc0luZGV4OiBzX2ksXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGQuX3lcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgIH0pXG4gICAgICAgIC8vICAgICAgICAgICAgIH0pXG4gICAgICAgIC8vICAgICAgICAgICAgIC5vbihcIm1vdXNlb3V0XCIsIChkLCBpLCBub2RlcykgPT4geyAvLyBiYXIgaXMgcmVndWxhciBjb2xvdXIgb24gbW91c2Ugb3V0LlxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgZDMuc2VsZWN0KG5vZGVzW2ldKVxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgIC5pbnRlcnJ1cHQoXCJob3Zlcjpjb2xvdXJcIilcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAudHJhbnNpdGlvbihcImhvdmVyOmNvbG91clwiKVxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbig0MDApXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCB0aGlzLmdldFNlcmllc0NvbG91cihpKSk7XG4gICAgICAgIC8vICAgICAgICAgICAgICAgICB0aGlzLl9kaXNwYXRjaC5jYWxsKFwidG9vbHRpcEhpZGVcIiwgdGhpcyk7XG4gICAgICAgIC8vICAgICAgICAgICAgIH0pXG4gICAgICAgIC8vICAgICAgICAgICAgIC5vbihcImNsaWNrIGF1eGNsaWNrXCIsIChkLCBpLCBub2RlcykgPT4ge1xuICAgICAgICAvLyAgICAgICAgICAgICAgICAgdGhpcy5fZGlzcGF0Y2guY2FsbChcImVsZW1lbnRDbGlja1wiLCB0aGlzLCB7XG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgZTogZDMuZXZlbnQsXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgcG9pbnQ6IGQsXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgc2VyaWVzOiBkLl9zZXJpZXMsXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgc2VyaWVzSW5kZXg6IHNfaSxcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy5feShkKVxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgLy8gICAgICAgICAgICAgfSlcbiAgICAgICAgLy8gICAgICAgICAgICAgLm1lcmdlKGJhcnMpXG4gICAgICAgIC8vICAgICAgICAgICAgIC5pbnRlcnJ1cHQoXCJiYXI6Z3Jvd3RoXCIpICAgIC8vIEFuaW1hdGUgYmFycyBncm93aW5nLlxuICAgICAgICAvLyAgICAgICAgICAgICAudHJhbnNpdGlvbihcImJhcjpncm93dGhcIilcbiAgICAgICAgLy8gICAgICAgICAgICAgLmRlbGF5KChkKSA9PiB7XG4gICAgICAgIC8vICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jYWxjQmFyR3Jvd3RoKHNfaSwgbm9kZXMubGVuZ3RoKTtcbiAgICAgICAgLy8gICAgICAgICAgICAgfSlcbiAgICAgICAgLy8gICAgICAgICAgICAgLmR1cmF0aW9uKHRoaXMuX2R1cmF0aW9uKVxuICAgICAgICAvLyAgICAgICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIChkLCBpKSA9PiB0aGlzLmdldFNlcmllc0NvbG91cihpKSlcbiAgICAgICAgLy8gICAgICAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgZCA9PiBoZWlnaHQgLSB5KGQuX3kpKTtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gICAgIH0pXG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIExhYmVscyBsb2FkZWQgYWZ0ZXIgb3VyIGZpcnN0IGJhciBncm93cy5cbiAgICAgICAgLy8gaWYgKHRoaXMuX3Nob3dfbGFiZWxzKSB7XG4gICAgICAgIC8vICAgICBzdmcudHJhbnNpdGlvbihcImJhcjpncm93dGhcIilcbiAgICAgICAgLy8gICAgICAgICAub24oXCJlbmRcIiwgKGQsIGksIG5vZGVzKSA9PiB7XG4gICAgICAgIC8vICAgICAgICAgICAgIGlmIChpIDwgbm9kZXMubGVuZ3RoIC0gMSkgcmV0dXJuO1xuICAgICAgICAvLyAgICAgICAgICAgICB0aGlzLnJlbmRlckxhYmVscyhzdmcsIGRhdGEsIHgsIHhHcm91cCwgeSk7XG4gICAgICAgIC8vICAgICAgICAgfSlcbiAgICAgICAgLy8gfVxuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBEcmF3IHRoZSB5IGF4aXMgZGF0YSBsYWJlbC5cblxuICAgICAgICBpZiAodGhpcy5fZGF0YUF4aXNMYWJlbCkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJEYXRhQXhpc0xhYmVsKGhlaWdodCwgbWFyZ2luKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBTZXQgdGhlIGJhY2tncm91bmQgY29sb3VyXG5cbiAgICAgICAgZDMuc2VsZWN0KHRoaXMuX2VsZW1lbnQpLnNlbGVjdChcIi5iYWNrZ3JvdW5kXCIpLnJlbW92ZSgpO1xuICAgICAgICBpZiAodGhpcy5fYmFja2dyb3VuZENvbG91cikge1xuICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMuX2VsZW1lbnQpLnNlbGVjdChcInN2Z1wiKVxuICAgICAgICAgICAgICAgIC5hcHBlbmQoXCJyZWN0XCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImJhY2tncm91bmRcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcIndpZHRoXCIsIFwiMTAwJVwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIFwiMTAwJVwiKVxuICAgICAgICAgICAgICAgIC5zdHlsZShcImZpbGxcIiwgdGhpcy5fYmFja2dyb3VuZENvbG91cilcbiAgICAgICAgICAgICAgICAubG93ZXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIGFkZCB0aGUgWSBncmlkbGluZXNcbiAgICAgICAgc3ZnLmNhbGwodGhpcy5ncmlkLCB3aWR0aCwgZDMuYXhpc0xlZnQoeSkudGlja3MoNSkpO1xuXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIGF4ZXNcbiAgICAgICAgc3ZnLmNhbGwodGhpcy54YXhpcywgaGVpZ2h0LCBkMy5heGlzQm90dG9tKHgpLnRpY2tTaXplKDApLnRpY2tQYWRkaW5nKDUpLnRpY2tGb3JtYXQodGhpcy5feEF4aXNUaWNrRm9ybWF0KSk7IC8vKTsgLy9cbiAgICAgICAgc3ZnLmNhbGwodGhpcy55YXhpcywgZDMuYXhpc0xlZnQoeSkudGlja3MoNSkudGlja0Zvcm1hdCh0aGlzLl90aWNrRm9ybWF0KSk7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8qXG4gICAgICogUmV0dXJucyBhbiBvYmplY3Qgd2l0aCB0d28gZnVuY3Rpb25zLCAjc2hvdygpIGFuZCAjaGlkZSgpLFxuICAgICAqIHRvIHNob3cgYW5kIGhpZGUgdGhlIGxhYmVscy5cbiAgICAgKi9cbiAgICBsYWJlbHMoKSB7XG4gICAgICAgIHJldHVybiB7XG5cbiAgICAgICAgICAgIHNob3c6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgc2VsZWN0aW9uID0gdGhpcy5fZWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSB0aGlzLmdldFRyYW5zZm9ybWVkRGF0YSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgeHNjYWxlID0gdGhpcy5feHNjYWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgeGdyb3VwID0gdGhpcy5feGdyb3Vwc2NhbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB5c2NhbGUgPSB0aGlzLl95c2NhbGU7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvbikgc2VsZWN0aW9uID0gZDMuc2VsZWN0KHRoaXMuX2VsZW1lbnQpLnNlbGVjdChcInN2Z1wiKS5zZWxlY3QoXCJnXCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNlbGVjdGlvbi5lbXB0eSgpICYmIGRhdGEgJiYgeHNjYWxlICYmIHlzY2FsZSAmJiB4Z3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBsYWJlbHMgPSBzZWxlY3Rpb24uc2VsZWN0KCcuY2hhcnQtbGFiZWxzJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWxhYmVscy5lbXB0eSgpKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbHMucmVtb3ZlKClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyTGFiZWxzKHNlbGVjdGlvbiwgZGF0YSwgeHNjYWxlLCB4Z3JvdXAsIHlzY2FsZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBoaWRlOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2VsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMuX2VsZW1lbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc2VsZWN0KCcuY2hhcnQtbGFiZWxzJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5pbnRlcnJ1cHQoXCJsYWJlbHNcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5pbnRlcnJ1cHQoXCJsYWJlbHM6ZmFkZVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRyYW5zaXRpb24oXCJsYWJlbHM6ZmFkZVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm9uKFwiZW5kXCIsIChkLCBpLCBub2RlcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQzLnNlbGVjdChub2Rlc1tpXSkucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICByZW5kZXJMYWJlbHMoc2VsZWN0aW9uLCBkYXRhLCB4c2NhbGUsIHhncm91cCwgeXNjYWxlLCBhbmltYXRlKSB7XG4gICAgICAgIGFuaW1hdGUgPSBhbmltYXRlID09PSB1bmRlZmluZWQgPyB0cnVlIDogYW5pbWF0ZTtcbiAgICAgICAgc2VsZWN0aW9uLnNlbGVjdEFsbChcIi5jaGFydC1sYWJlbHNcIikucmVtb3ZlKCk7XG5cbiAgICAgICAgbGV0IGxhYmVscyA9IHNlbGVjdGlvbi5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwiY2hhcnQtbGFiZWxzXCIpXG4gICAgICAgICAgICAvLyAuc2VsZWN0QWxsKFwiLmNoYXJ0LWxhYmVsXCIpXG4gICAgICAgICAgICAuc2VsZWN0QWxsKFwiLmxhYmVsLWdyb3VwXCIpXG4gICAgICAgICAgICAuZGF0YShkYXRhKVxuXG4gICAgICAgIGxldCBtYXhXaWR0aCA9IDA7ICAgICAvLyBGb3IgY2FsY3VsYXRpbmcgdGhlIG1heCB3aWR0aCBvZiB0ZXh0LlxuICAgICAgICBsZXQgZm9udFNpemUgPSAxMjsgICAgLy8gT3VyIGluaXRpYWwgZm9udCBzaXplLlxuICAgICAgICBjb25zdCBidWZmZXIgPSA1OyAgICAgLy8gQnVmZmVyIHNwYWNlIGJldHdlZW4gd29yZHMgYW5kIHRoZSB0b3Agb2YgYSBiYXIuXG4gICAgICAgIGNvbnN0IGNhbGNEeSA9ICh5cG9zKSA9PiB5cG9zIDwgMTAgPyBmb250U2l6ZSArIGJ1ZmZlciA6IC1idWZmZXI7XG5cbiAgICAgICAgbGFiZWxzLmVudGVyKCkuZWFjaCgoc2VyaWVzLCBzX2ksIHNfbm9kZXMpID0+IHtcbiAgICAgICAgICAgIGxldCBncm91cCA9IGQzLnNlbGVjdChzX25vZGVzW3NfaV0pXG4gICAgICAgICAgICAgICAgLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwibGFiZWwtZ3JvdXBcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBkID0+IFwidHJhbnNsYXRlKFwiICsgeHNjYWxlKGQua2V5KSArIFwiLDApXCIpXG4gICAgICAgICAgICAgICAgLnNlbGVjdEFsbChcIi5jaGFydC1sYWJlbFwiKVxuICAgICAgICAgICAgICAgIC5kYXRhKHNlcmllcy5kYXRhKVxuICAgICAgICAgICAgICAgIC5lbnRlcigpXG4gICAgICAgICAgICAgICAgLmVhY2goKGQsIGksIG5vZGVzKSA9PiB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gV2FudCB0byBmaWd1cmUgb3V0IGlmIHRoZSBsYWJlbCBpcyB0b28gZGFyayAvIGxpZ2h0IGZvciB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gYmFyLlxuICAgICAgICAgICAgICAgICAgICBsZXQgaW52ZXJ0ZWRDb2xvciA9IGQzLmhjbCh0aGlzLmdldFNlcmllc0NvbG91cihpKSk7XG4gICAgICAgICAgICAgICAgICAgIGludmVydGVkQ29sb3IubCArPSBNYXRoLm1pbihpbnZlcnRlZENvbG9yLmwgKyA1MCwgMTAwKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGludmVydCA9IGQzLmhjbCh0aGlzLmdldFNlcmllc0NvbG91cihpKSkubCA8IDYwO1xuXG4gICAgICAgICAgICAgICAgICAgIGxldCB5cG9zID0geXNjYWxlKGQuX3kpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZHkgPSBjYWxjRHkoeXBvcyk7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0ZXh0ID0gZDMuc2VsZWN0KG5vZGVzW2ldKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC50ZXh0KHRoaXMuX2xhYmVsRm9ybWF0KGQuX3kpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImNoYXJ0LWxhYmVsXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcInlcIiwgeXBvcylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiZHhcIiwgYW5pbWF0ZSA/IC0xNSA6IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcImR5XCIsIGR5KVxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwicG9pbnRlci1ldmVudHNcIiwgXCJub25lXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAuc3R5bGUoXCJmb250LWZhbWlseVwiLCBcIk9wZW4gU2Fucywgc2Fucy1zZXJpZlwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gLnN0eWxlKFwiZm9udC13ZWlnaHRcIiwgXCJub3JtYWxcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIC5zdHlsZShcImZvbnQtc2l6ZVwiLCBmb250U2l6ZSArIFwicHhcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcImZpbGxcIiwgZHkgPiAwICYmIGludmVydCA/IGludmVydGVkQ29sb3IudG9TdHJpbmcoKSA6IGNvbG91cnMuZWlnaHRlZW4uZGFya0dyZXkpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFNldCB0aGUgeCBwb3NpdGlvbiwgd2hpY2ggaXMgYmFzZWQgb24gd2lkdGguXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gdGV4dC5ub2RlKCkuZ2V0QkJveCgpLndpZHRoO1xuICAgICAgICAgICAgICAgICAgICBtYXhXaWR0aCA9IE1hdGgubWF4KHdpZHRoLCBtYXhXaWR0aCk7XG4gICAgICAgICAgICAgICAgICAgIHRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwieFwiLCB4Z3JvdXAoZC5fa2V5KSArIHhncm91cC5iYW5kd2lkdGgoKSAvIDIgLSB3aWR0aCAvIDIpO1xuXG4gICAgICAgICAgICAgICAgICAgIHRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKFwibGFiZWxzXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAuZGVsYXkoKCkgPT4gYW5pbWF0ZSA/IHRoaXMuY2FsY0Jhckdyb3d0aChzX2ksIHNfbm9kZXMubGVuZ3RoKSA6IDApIC8vIERlbGF5IGluIGxvY2tzdGVwIHdpdGggYmFyIGdyb3d0aC5cbiAgICAgICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbih0aGlzLl9kdXJhdGlvbilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiZHhcIiwgMClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMSlcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICB9KVxuXG5cbiAgICAgICAgLy8gRmlndXJlIG91dCBpZiB3ZSBkb24ndCBoYXZlIGVub3VnaCBzcGFjZSB0byBzaG93IG91ciBsYWJlbHMuXG4gICAgICAgIC8vIFdlIHRoZW4gd2FudCB0byByZXNpemUsIGlmIHBvc3NpYmxlLlxuICAgICAgICBpZiAoeGdyb3VwLmJhbmR3aWR0aCgpIDwgbWF4V2lkdGggKiAxLjA1KSB7XG4gICAgICAgICAgICBsZXQgc2NhbGUgPSBtYXhXaWR0aCAvIHhncm91cC5iYW5kd2lkdGgoKSAqIDEuMDU7XG4gICAgICAgICAgICBmb250U2l6ZSA9IE1hdGguZmxvb3IoZm9udFNpemUgLyBzY2FsZSk7XG5cbiAgICAgICAgICAgIGlmIChmb250U2l6ZSA8IDgpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgbGFiZWxzIGFyZSB0b28gc21hbGwuXG4gICAgICAgICAgICAgICAgbGFiZWxzLmVudGVyKCkuc2VsZWN0QWxsKFwidGV4dFwiKS5yZW1vdmUoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGFiZWxzLmVudGVyKClcbiAgICAgICAgICAgICAgICAgICAgLm1lcmdlKGxhYmVscylcbiAgICAgICAgICAgICAgICAgICAgLnNlbGVjdEFsbChcInRleHRcIilcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwiZm9udC1zaXplXCIsIGZvbnRTaXplICsgXCJweFwiKVxuICAgICAgICAgICAgICAgICAgICAuZWFjaCgoZCwgaSwgbm9kZXMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRleHQgPSBkMy5zZWxlY3Qobm9kZXNbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgd2lkdGggPSB0ZXh0Lm5vZGUoKS5nZXRCQm94KCkud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIHhncm91cChkLl9rZXkpICsgeGdyb3VwLmJhbmR3aWR0aCgpIC8gMiAtIHdpZHRoIC8gMilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcImR5XCIsIGNhbGNEeShkLl95KSk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgcmVuZGVyRGF0YUF4aXNMYWJlbChoZWlnaHQsIG1hcmdpbnMpIHtcbiAgICAgICAgbGV0IHN2ZyA9IGQzLnNlbGVjdCh0aGlzLl9lbGVtZW50KS5zZWxlY3QoJ3N2ZycpO1xuICAgICAgICBzdmcuc2VsZWN0QWxsKFwiLmRhdGEtbGFiZWxzXCIpLnJlbW92ZSgpO1xuXG4gICAgICAgIGlmICghdGhpcy5fZGF0YUF4aXNMYWJlbCkgcmV0dXJuO1xuICAgICAgICBsZXQgdGV4dCA9IHRoaXMuX2RhdGFBeGlzTGFiZWw7XG4gICAgICAgIGlmICh0ZXh0LmxvbmcpIHRleHQgPSB0ZXh0Lmxvbmc7XG5cbiAgICAgICAgbGV0IHggPSAtKG1hcmdpbnMudG9wICsgaGVpZ2h0IC8gMik7XG5cbiAgICAgICAgbGV0IGxhYmVsID0gc3ZnLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJkYXRhLWxhYmVsc1wiKVxuICAgICAgICAgICAgLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgICAgIC50ZXh0KHRleHQpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInJvdGF0ZSgtOTAgMCwwKSB0cmFuc2xhdGUoXCIgKyB4ICsgXCIsIDIwKVwiKVxuICAgICAgICAgICAgLy8gLnN0eWxlKFwiZm9udC1mYW1pbHlcIiwgXCJPcGVuIFNhbnMsIHNhbnMtc2VyaWZcIilcbiAgICAgICAgICAgIC8vIC5zdHlsZShcImZvbnQtc2l6ZVwiLCBcIjEycHhcIilcbiAgICAgICAgICAgIC8vIC5zdHlsZShcImZvbnQtc3R5bGVcIiwgXCJpdGFsaWNcIilcbiAgICAgICAgICAgIC5zdHlsZShcImZpbGxcIiwgY29sb3Vycy5laWdodGVlbi5kYXJrR3JleSk7XG5cbiAgICAgICAgbGV0IHdpZHRoID0gbGFiZWwubm9kZSgpLmdldEJCb3goKS53aWR0aDtcbiAgICAgICAgaWYgKHdpZHRoID49IGhlaWdodCAmJiB0aGlzLl9kYXRhQXhpc0xhYmVsLnNob3J0KSB7XG4gICAgICAgICAgICBsYWJlbC50ZXh0KHRoaXMuX2RhdGFBeGlzTGFiZWwuc2hvcnQpO1xuICAgICAgICAgICAgd2lkdGggPSBsYWJlbC5ub2RlKCkuZ2V0QkJveCgpLndpZHRoO1xuICAgICAgICB9XG5cbiAgICAgICAgbGFiZWwuYXR0cihcImR4XCIsIC13aWR0aCAvIDIpO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBncmlkKHNlbGVjdGlvbiwgd2lkdGgsIGF4aXMpIHtcbiAgICAgICAgc2VsZWN0aW9uLnNlbGVjdChcIi5ncmlkXCIpLnJlbW92ZSgpO1xuXG4gICAgICAgIGxldCBncmlkID0gc2VsZWN0aW9uLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJncmlkXCIpXG4gICAgICAgICAgICAuY2FsbChheGlzXG4gICAgICAgICAgICAgICAgLnRpY2tTaXplKC13aWR0aClcbiAgICAgICAgICAgICAgICAudGlja0Zvcm1hdChcIlwiKVxuICAgICAgICAgICAgKTtcblxuICAgICAgICBncmlkLnNlbGVjdEFsbChcImxpbmVcIilcbiAgICAgICAgICAgIC5zdHlsZShcInN0cm9rZVwiLCBjb2xvdXJzLmVpZ2h0ZWVuLmxpZ2h0R3JleSk7XG4gICAgICAgIGdyaWQuc2VsZWN0QWxsKFwiLmRvbWFpblwiKS5yZW1vdmUoKTtcblxuICAgICAgICBncmlkXG4gICAgICAgICAgICAubG93ZXIoKSAvLyBBbHdheXMgZW5zdXJlIHRoYXQgdGhpcyBpcyBlYXJsaWVyIGluIHRoZSBkb20uIFRoaW5ncyBtdXN0IGJlIGRyYXduIG9uIHRvcCBvZiBpdC5cbiAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMClcbiAgICAgICAgICAgIC50cmFuc2l0aW9uKClcbiAgICAgICAgICAgIC5kZWxheSg1MDApXG4gICAgICAgICAgICAuZHVyYXRpb24oNTAwKVxuICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAxKTtcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgeGF4aXMoc2VsZWN0aW9uLCBoZWlnaHQsIHhheGlzKSB7XG4gICAgICAgIHNlbGVjdGlvbi5zZWxlY3QoXCIueC1heGlzXCIpLnJlbW92ZSgpO1xuICAgICAgICBsZXQgYXhpcyA9IHNlbGVjdGlvbi5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwieC1heGlzXCIpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZSgwLFwiICsgaGVpZ2h0ICsgXCIpXCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDApXG4gICAgICAgICAgICAuY2FsbCh4YXhpcyk7XG5cbiAgICAgICAgYXhpcy5zZWxlY3QoXCIuZG9tYWluXCIpLnJlbW92ZSgpO1xuXG4gICAgICAgIGF4aXNcbiAgICAgICAgICAgIC5zZWxlY3RBbGwoXCJ0ZXh0XCIpXG4gICAgICAgICAgICAuc3R5bGUoJ3RleHQtYW5jaG9yJywgJ2VuZCcpXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3JvdGF0ZSgtMzAsIDAsMCknKTtcblxuICAgICAgICBheGlzXG4gICAgICAgICAgICAudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAuZHVyYXRpb24oMTAwMClcbiAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMSk7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHlheGlzKHNlbGVjdGlvbiwgYXhpcykge1xuICAgICAgICBzZWxlY3Rpb24uc2VsZWN0KFwiLnktYXhpc1wiKS5yZW1vdmUoKTtcbiAgICAgICAgbGV0IHggPSBzZWxlY3Rpb24uYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcInktYXhpc1wiKVxuICAgICAgICAgICAgLmNhbGwoYXhpcy50aWNrU2l6ZSgwKS50aWNrUGFkZGluZygxMCkpXG4gICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDApXG4gICAgICAgICAgICAudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAuZHVyYXRpb24oMTAwMClcbiAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMSk7XG5cbiAgICAgICAgeC5zZWxlY3RBbGwoXCJ0ZXh0XCIpXG4gICAgICAgICAgICAvLyAuc3R5bGUoXCJmb250LWZhbWlseVwiLCBcIk9wZW4gU2Fucywgc2Fucy1zZXJpZlwiKVxuICAgICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBjb2xvdXJzLmVpZ2h0ZWVuLmRhcmtHcmV5KVxuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBjYWxjQmFyR3Jvd3RoKGksIG1heCkge1xuICAgICAgICBpZiAobWF4IDwgMTApIHJldHVybiBpICogdGhpcy5fQkFSX0dST1dUSCAvIDI7XG4gICAgICAgIGlmIChtYXggPCAzNSkgcmV0dXJuIGkgKiB0aGlzLl9CQVJfR1JPV1RIIC8gNDtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuXG4gICAgZ2V0U2VyaWVzQ29sb3VyKGkpIHtcbiAgICAgICAgaWYgKGkgPCAwIHx8ICF0aGlzLl9jb2xvdXJzKSByZXR1cm4gY29sb3Vycy5laWdodGVlbi5taWRHcmV5O1xuXG4gICAgICAgIGkgPSBpICUgdGhpcy5fY29sb3Vycy5sZW5ndGg7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb2xvdXJzW2ldO1xuICAgIH1cblxuICAgIGdldFNvcnRlZERhdGEoKSB7XG4gICAgICAgIGxldCBkYXRhID0gdGhpcy5fZGF0YTtcbiAgICAgICAgaWYgKCFkYXRhIHx8ICFkYXRhLmxlbmd0aCkgcmV0dXJuIFtdO1xuXG4gICAgICAgIGRhdGEgPSB0aGlzLl9kYXRhLnNvcnQoKGxocywgcmhzKSA9PiB7XG4gICAgICAgICAgICBsaHMgPSBsaHMua2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICByaHMgPSByaHMua2V5LnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgICAgIGlmIChsaHMgPT09IHJocykgcmV0dXJuIDA7XG4gICAgICAgICAgICBpZiAobGhzIDwgcmhzKSByZXR1cm4gLTE7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgZ2V0VHJhbnNmb3JtZWREYXRhKCkge1xuICAgICAgICBsZXQgZGF0YSA9IHRoaXMuZ2V0U29ydGVkRGF0YSgpO1xuICAgICAgICBpZiAoIWRhdGEgfHwgIWRhdGEubGVuZ3RoKSByZXR1cm4gW107XG5cbiAgICAgICAgbGV0IHJlc3VsdHMgPSBbXTtcblxuICAgICAgICBkYXRhLmZvckVhY2goKHNlcmllcywgc19pKSA9PiB7XG4gICAgICAgICAgICBsZXQgcyA9IE9iamVjdC5hc3NpZ24oe30sIHNlcmllcyk7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2gocyk7XG5cbiAgICAgICAgICAgIGxldCBkYXRhID0gW107XG4gICAgICAgICAgICBzLnZhbHVlcy5mb3JFYWNoKChkKSA9PiB7XG4gICAgICAgICAgICAgICAgZGF0YS5wdXNoKE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgICAgICAgICBfeDogbmV3IERhdGUodGhpcy5feEF4aXNPdmVycmlkZSA/IHRoaXMuX3hBeGlzT3ZlcnJpZGVbdGhpcy5feChkKV0gOiB0aGlzLl94KGQpKSxcbiAgICAgICAgICAgICAgICAgICAgX3Nlcmllczogc2VyaWVzLFxuICAgICAgICAgICAgICAgICAgICBfc19pOiBzX2ksXG4gICAgICAgICAgICAgICAgICAgIF9rZXk6IHNlcmllcy5rZXksXG4gICAgICAgICAgICAgICAgICAgIF95OiB0aGlzLl95KGQpXG4gICAgICAgICAgICAgICAgfSwgZCkpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHMuZGF0YSA9IGRhdGE7XG4gICAgICAgICAgICBkZWxldGUgcy52YWx1ZXM7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cblxuICAgIGdldEtleXMoKSB7XG4gICAgICAgIGxldCBkYXRhID0gdGhpcy5fZGF0YTtcbiAgICAgICAgaWYgKCFkYXRhIHx8ICFkYXRhLmxlbmd0aCkgcmV0dXJuIFtdO1xuXG4gICAgICAgIHJldHVybiBbLi4ubmV3IFNldChkYXRhLm1hcChkID0+IGQua2V5KSldXG4gICAgfVxuXG4gICAgZ2V0Q2xvc2VzdFBvaW50KHh2YWwsIHl2YWwsIGRhdGEpIHtcbiAgICAgICAgbGV0IGNhbGNEaXN0ID0gZCA9PiBNYXRoLnNxcnQoTWF0aC5hYnMoZC5feCAtIHh2YWwpICoqIDIgKyAoZC5feSAtIHl2YWwpICoqIDIpO1xuICAgICAgICBsZXQgbWluID0gZGF0YVswXTtcbiAgICAgICAgbGV0IG1pbkRpc3QgPSBjYWxjRGlzdChtaW4pO1xuXG4gICAgICAgIGRhdGEuZm9yRWFjaChkID0+IHtcbiAgICAgICAgICAgIGxldCBkaXN0ID0gY2FsY0Rpc3QoZCk7XG4gICAgICAgICAgICBpZiAoZGlzdCA8IG1pbkRpc3QpIHtcbiAgICAgICAgICAgICAgICBtaW5EaXN0ID0gZGlzdDtcbiAgICAgICAgICAgICAgICBtaW4gPSBkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gbWluO1xuICAgIH1cbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/LineChart.js\n')},"./src/PieChart.js":
/*!*************************!*\
  !*** ./src/PieChart.js ***!
  \*************************/
/*! exports provided: PieChart */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PieChart", function() { return PieChart; });\n/* harmony import */ var _Colours__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Colours */ "./src/Colours.js");\n/* harmony import */ var _Chart__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Chart */ "./src/Chart.js");\n// Copyright (C) 2013-2014, 2018 BrandsEye (PTY) LTD\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this\n// software and associated documentation files (the "Software"), to deal in the Software\n// without restriction, including without limitation the rights to use, copy, modify,\n//     merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following\n// conditions:\n//\n//     The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n//     INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n// CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n\nclass PieChart extends _Chart__WEBPACK_IMPORTED_MODULE_1__["Chart"] {\n    constructor() {\n        super();\n        this._colours = ["#98abc5", "#8a89a6", "#7b6888", "#6b486b", "#a05d56", "#d0743c", "#ff8c00"];\n    }\n\n    //------------------------------------------------------\n\n    data(data) {\n        if (!arguments.length) return this._data;\n        if (data && data[0].key === undefined) {\n            data = [\n                {\n                    key: "series 1",\n                    values: data\n                }\n            ];\n        }\n        this._data = data;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    element(element) {\n        if (!arguments.length) return this._element;\n        this._element = element;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    showLabels(show) {\n        if (!arguments.length) return this._show_labels;\n        this._show_labels = show;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    // todo dispatch\n    showLegend(show) {\n        if (!arguments.length) return this._show_legend;\n        this._show_legend = show;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    x(x) {\n        if (!arguments.length) return this._x;\n        this._x = x;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    y(y) {\n        if (!arguments.length) return this._y;\n        this._y = y;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    width(width) {\n        if (!arguments.length) return this._width;\n        this._width = width;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    height(height) {\n        if (!arguments.length) return this._height;\n        this._height = height;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    colours(colours) {\n        if (!arguments.length) return this._colours;\n        this._colours = colours;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    backgroundColour(colour) {\n        if (!arguments.length) return this._backgroundColour;\n        this._backgroundColour = colour || "#FFF"; // never set it to null.\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    tickFormat(format) {\n        if (!arguments.length) return this._tickFormat;\n        this._tickFormat = format;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    xAxisTickFormat(format) {\n        if (!arguments.length) return this._xAxisTickFormat;\n        this._xAxisTickFormat = format || (d => d.toString());\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    labelFormat(format) {\n        if (!arguments.length) return this._labelFormat;\n        this._labelFormat = format || (d => d.toString());\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    // todo missing\n    labelCompression(compression) {\n        if (!arguments.length) return this._compression;\n        this._compression = compression;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    //todo missing\n    dataAxisLabel(label) {\n        if (!arguments.length) return this._dataAxisLabel;\n        this._dataAxisLabel = label;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    tooltip(tooltip) {\n        if (!arguments.length) return this._tooltip;\n        this._tooltip = tooltip;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    forceY(force) {\n        if (!arguments.length) return this._forceY;\n        this._forceY = force;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n// todo missing\n    duration(duration) {\n        if (!arguments.length) return this._duration;\n        this._duration = duration;\n        return this;\n    }\n\n// todo missing\n    coarseness(coarseness) {\n        if (!arguments.length) return this._coarseness;\n        this._coarseness = coarseness;\n        return this;\n    }\n\n    // todo missing\n    padding(padding) {\n        if (!arguments.length) return this._padding;\n        this._padding = padding;\n        return this;\n    }\n\n    // todo missing\n    xAxisTooltips(tooltips) {\n        if (!arguments.length) return this._xAxisTooltips;\n        this._xAxisTooltips = tooltips;\n        return this;\n    }\n\n    xAxisOverride(override) {\n        if (!arguments.length) return this._xAxisOverride;\n        this._xAxisOverride = override;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    dispatch() {\n        return this._dispatch;\n    }\n\n    //------------------------------------------------------\n\n    render() {\n        if (!this._element) throw new Error("No element set for ColumnChart. See #element()");\n        if (!this._data) {\n            console.warn("No data set for ColumnChart. See #data()");\n            return;\n        }\n\n        const data = this.getTransformedData();\n\n        //------------------------------------------------\n        // Set up the SVG area\n\n        let topLevel = d3.select(this._element).select("svg");\n        if (topLevel.empty()) topLevel = d3.select(this._element).append("svg");\n\n        topLevel\n            .style("width", this._width + "px")\n            .style("height", this._height + "px");\n\n        // ---------------------------------\n        // Layout the showLegend.\n        //\n        // We do this now because we need to know how much space the legend\n        // takes up in order to finish calculating the margins.\n\n        const legendHeight = this.renderLegend(topLevel, data, 0, this._width, this._height, d => d._key);\n\n        //----------------------------------\n        // Calculate margins.\n\n        const margin = {top: 20, right: 20, bottom: 40, left: 40};\n        margin.bottom += legendHeight ? legendHeight + 20 : 0;\n\n        // if (this._dataAxisLabel) margin.left += 20 + 12;\n        // if (data) {\n        //     let maxLabelLength = 0;\n        //     data.forEach(d => {\n        //         d.data.forEach(d => {\n        //             let length = this._xAxisTickFormat(this._x(d)).length;\n        //             if (length > maxLabelLength) maxLabelLength = length;\n        //         })\n        //     });\n        //     margin.bottom += maxLabelLength * 2 + 10;    // space for axes labels.\n        // }\n\n        const width = this._width - margin.left - margin.right,\n              height = this._height - margin.top - margin.bottom;\n        const radius = Math.min(width, height) / 2;\n        this._radius = radius;\n\n        //----------------------------------\n        // Calculate scales and so on.\n\n        let colour = d3.scaleOrdinal(["#98abc5", "#8a89a6", "#7b6888", "#6b486b", "#a05d56", "#d0743c", "#ff8c00"]);\n\n        //------------------------------\n\n        let svg = topLevel.select(\'.main-group\');\n\n        if (svg.empty()) {\n            svg = topLevel\n                .append("g")\n                .attr("class", "main-group");\n        }\n\n        svg.attr("transform", "translate(" + (margin.left + width / 2) + "," + (margin.top + height / 2) + ")");\n\n        //---------------------------------\n        // Get rid of current labels.\n        svg.select(".chart-labels")\n            .remove();\n\n        //---------------------------------\n        // append the arcs for the pie chart\n\n        let pie = d3.pie()\n            .sort(null)\n            .value(d => d._y);\n        this._pie = pie;\n\n        let path = d3.arc()\n            .outerRadius(radius - 10)\n            .innerRadius(0);\n\n        let arcs = svg.select(".slices").selectAll(\'.arc\');\n\n        if (arcs.empty()) {\n            arcs = svg\n                .append("g")\n                .attr("class", "slices")\n                .selectAll(".arc");\n        }\n\n        let pieData = pie(data);\n        arcs = arcs.data(pieData);\n        arcs.exit().remove();\n\n        function arcTween(d, i) {\n            this._current = this._current || (i <= 0 ? { startAngle: 0, endAngle: 0} : pieData[i - 1]);\n            let interpolator = d3.interpolate(this._current, d);\n            this._current = interpolator(0);\n\n            return function(t) {\n                return path(interpolator(t))\n            }\n        }\n\n        arcs.enter()\n            .append("path")\n                .attr("class", (d, i) => "arc " + "series series-" + i)\n                .style("cursor", "pointer")\n            .on("mouseover", (d, i, nodes) => { // Darken the pie on mouse over\n                // We want to shift the pie out a bit on mouseover.\n                // So we want to find the direction to move the pie in.\n                // We can just ask the path helper to give us the centroid,\n                // normalise it, and that is the direction to move in.\n                const centre = path.centroid(d);\n                const norm = Math.sqrt(centre[0] ** 2 + centre[1] ** 2);\n                centre[0] = centre[0] / norm;\n                centre[1] = centre[1] / norm;\n\n                d3.select(nodes[i])\n                    .interrupt("hover:colour")\n                    .transition("hover:colour")\n                    .duration(300)\n                        .attr("transform", "translate(" + (centre[0] * 10) + "," + (centre[1] * 10) + "), scale(1.1)")\n                        .style("fill", d3.hcl(this.getSeriesColour(i)).darker());\n                this._dispatch.call("tooltipShow", this, {\n                    e: d3.event,\n                    point: d.data,\n                    series: d.data._series,\n                    seriesIndex: d.data._s_i,\n                    value: d.data._y\n                })\n            })\n            .on("mouseout", (d, i, nodes) => { // pie is regular colour on mouse out.\n                d3.select(nodes[i])\n                    .interrupt("hover:colour")\n                    .transition("hover:colour")\n                    .duration(300)\n                        .attr("transform", "translate(0,0)")\n                        .style("fill", this.getSeriesColour(i));\n                this._dispatch.call("tooltipHide", this);\n            })\n            .on("click auxclick", (d, i, nodes) => {\n                this._dispatch.call("elementClick", this, {\n                    e: d3.event,\n                    point: d.data,\n                    series: d.data._series,\n                    seriesIndex: d.data._s_i,\n                    value: d.data._y\n                })\n            })\n            .merge(arcs)\n            .transition()\n                .attrTween("d", arcTween)\n                .attr("fill", (d, i) => this.getSeriesColour(i) );\n\n        // arcs.append("text")\n        //     .attr("transform", function(d) { return "translate(" + label.centroid(d) + ")"; })\n        //     .attr("dy", "0.35em")\n        //     .text(d => {console.log("d is", d); return d.data._y; });\n\n\n        // ---------------------------------\n        // Labels loaded after our first bar grows.\n        if (this._show_labels) {\n            svg.transition("bar:growth")\n                .on("end", (d, i, nodes) => {\n                    if (i < nodes.length - 1) return;\n                    this.renderLabels(svg, data);\n                })\n        }\n\n        // ---------------------------------\n        // Set the background colour\n\n        d3.select(this._element).select(".background").remove();\n        if (this._backgroundColour) {\n            d3.select(this._element).select("svg")\n                .append("rect")\n                    .attr("class", "background")\n                    .attr("width", "100%")\n                    .attr("height", "100%")\n                    .style("fill", this._backgroundColour)\n                .lower();\n        }\n\n    }\n\n    //------------------------------------------------------\n\n    /*\n     * Returns an object with two functions, #show() and #hide(),\n     * to show and hide the labels.\n     */\n    labels() {\n        return {\n\n            show: () => {\n                if (this._element) {\n                    let selection = this._element,\n                        data = this.getTransformedData();\n\n                    if (selection) selection = d3.select(this._element).select("svg").select(".main-group");\n                    if (!selection.empty() && data) {\n                        let labels = selection.select(\'.chart-labels\');\n                        if (!labels.empty()) return;\n                        labels.remove();\n                        this.renderLabels(selection, data);\n                    }\n                }\n\n            },\n\n            hide: () => {\n                if (this._element) {\n                    d3.select(this._element)\n                        .select(\'.chart-labels\')\n                        .interrupt("labels")\n                        .interrupt("labels:fade")\n                        .transition("labels:fade")\n                        .style("opacity", 0)\n                        .on("end", (d, i, nodes) => {\n                            d3.select(nodes[i]).remove();\n                        })\n                }\n            }\n        }\n    }\n\n    //------------------------------------------------------\n\n    renderLabels(selection, data, animate) {\n        selection.selectAll(".chart-labels").remove();\n\n        const radius = this._radius + 15;\n\n        let arc = d3.arc()\n            .outerRadius(radius)\n            .innerRadius(radius);\n\n        let labels = selection.append("g")\n            .attr("class", "chart-labels")\n            .selectAll(".label-group")\n            .data(this._pie(data));\n\n        labels.enter()\n            .each((d, i, nodes) => {\n                const centroid = arc.centroid(d);\n                const radians = d.endAngle - d.startAngle;\n                const arcLength = radians * radius;\n\n                let label = d3.select(nodes[i])\n                    .append("text")\n                    .text(d => this._labelFormat(d.data._y))\n                        // .style("font-family", "Open Sans, sans-serif")\n                        // .style("font-size", "12px")\n                        .style("fill", _Colours__WEBPACK_IMPORTED_MODULE_0__["colours"].eighteen.darkGrey)\n                        .style("opacity", 0)\n                        .attr("transform", "translate(" + centroid + ")");\n\n                const bounding = label.node().getBBox();\n                if (bounding.width < arcLength) {\n                    // label.attr("dx", (bounding.width / 2) * (direction[0] < 0 ? -1 : 1));\n                    // label.attr("dy", (bounding.height / 2) * (direction[1] < 0 ? -1 : 1));\n                    label.attr("dx", -(bounding.width / 2));\n                    label.attr("dy", (bounding.height / 2));\n\n                    label\n                        .transition()\n                        .duration(this._duration)\n                        .style("opacity", 1)\n                }\n\n            })\n    }\n\n    //------------------------------------------------------\n\n    getSeriesColour(i) {\n        if (i < 0 || !this._colours) return _Colours__WEBPACK_IMPORTED_MODULE_0__["colours"].eighteen.midGrey;\n\n        i = i % this._colours.length;\n        return this._colours[i];\n    }\n\n    getSortedData() {\n        let data = this._data;\n        if (!data || !data.length) return [];\n\n        data = this._data.sort((lhs, rhs) => {\n            lhs = lhs.key.toLowerCase();\n            rhs = rhs.key.toLowerCase();\n\n            if (lhs === rhs) return 0;\n            if (lhs < rhs) return -1;\n            return 1;\n        });\n\n        return data;\n    }\n\n    getTransformedData() {\n        let data = this.getSortedData();\n        if (!data || !data.length) return [];\n\n        let results = [];\n\n        let series = data[0];\n        series.values.forEach((d, d_i) => {\n\n            results.push(Object.assign({\n                _y: this._y(d),\n                _series_key: series.key,\n                _s_i: 0,\n                _series: series,\n                _key: this._xAxisOverride ? this._xAxisOverride[this._x(d)] : this._x(d)\n            }, d));\n        });\n\n        return results;\n    }\n\n    getKeys() {\n        let data = this._data;\n        if (!data || !data.length) return [];\n\n        return [...new Set(data.map(d => d.key))]\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvUGllQ2hhcnQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9iM2pzLy4vc3JjL1BpZUNoYXJ0LmpzPzczZGQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChDKSAyMDEzLTIwMTQsIDIwMTggQnJhbmRzRXllIChQVFkpIExURFxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpc1xuLy8gc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlXG4vLyB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksXG4vLyAgICAgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0b1xuLy8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcbi8vIGNvbmRpdGlvbnM6XG4vL1xuLy8gICAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuLy8gY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyAgICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUiBJTVBMSUVELFxuLy8gICAgIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBXG4vLyBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUXG4vLyBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0Zcbi8vIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRVxuLy8gT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCB7Y29sb3Vyc30gZnJvbSAnLi9Db2xvdXJzJztcbmltcG9ydCB7Q2hhcnR9IGZyb20gJy4vQ2hhcnQnO1xuXG5leHBvcnQgY2xhc3MgUGllQ2hhcnQgZXh0ZW5kcyBDaGFydCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX2NvbG91cnMgPSBbXCIjOThhYmM1XCIsIFwiIzhhODlhNlwiLCBcIiM3YjY4ODhcIiwgXCIjNmI0ODZiXCIsIFwiI2EwNWQ1NlwiLCBcIiNkMDc0M2NcIiwgXCIjZmY4YzAwXCJdO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBkYXRhKGRhdGEpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fZGF0YTtcbiAgICAgICAgaWYgKGRhdGEgJiYgZGF0YVswXS5rZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZGF0YSA9IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGtleTogXCJzZXJpZXMgMVwiLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZXM6IGRhdGFcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgZWxlbWVudChlbGVtZW50KSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX2VsZW1lbnQ7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgc2hvd0xhYmVscyhzaG93KSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3Nob3dfbGFiZWxzO1xuICAgICAgICB0aGlzLl9zaG93X2xhYmVscyA9IHNob3c7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvLyB0b2RvIGRpc3BhdGNoXG4gICAgc2hvd0xlZ2VuZChzaG93KSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3Nob3dfbGVnZW5kO1xuICAgICAgICB0aGlzLl9zaG93X2xlZ2VuZCA9IHNob3c7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB4KHgpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5feDtcbiAgICAgICAgdGhpcy5feCA9IHg7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB5KHkpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5feTtcbiAgICAgICAgdGhpcy5feSA9IHk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB3aWR0aCh3aWR0aCkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl93aWR0aDtcbiAgICAgICAgdGhpcy5fd2lkdGggPSB3aWR0aDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGhlaWdodChoZWlnaHQpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5faGVpZ2h0O1xuICAgICAgICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBjb2xvdXJzKGNvbG91cnMpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fY29sb3VycztcbiAgICAgICAgdGhpcy5fY29sb3VycyA9IGNvbG91cnM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBiYWNrZ3JvdW5kQ29sb3VyKGNvbG91cikge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9iYWNrZ3JvdW5kQ29sb3VyO1xuICAgICAgICB0aGlzLl9iYWNrZ3JvdW5kQ29sb3VyID0gY29sb3VyIHx8IFwiI0ZGRlwiOyAvLyBuZXZlciBzZXQgaXQgdG8gbnVsbC5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHRpY2tGb3JtYXQoZm9ybWF0KSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3RpY2tGb3JtYXQ7XG4gICAgICAgIHRoaXMuX3RpY2tGb3JtYXQgPSBmb3JtYXQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB4QXhpc1RpY2tGb3JtYXQoZm9ybWF0KSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3hBeGlzVGlja0Zvcm1hdDtcbiAgICAgICAgdGhpcy5feEF4aXNUaWNrRm9ybWF0ID0gZm9ybWF0IHx8IChkID0+IGQudG9TdHJpbmcoKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBsYWJlbEZvcm1hdChmb3JtYXQpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fbGFiZWxGb3JtYXQ7XG4gICAgICAgIHRoaXMuX2xhYmVsRm9ybWF0ID0gZm9ybWF0IHx8IChkID0+IGQudG9TdHJpbmcoKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvLyB0b2RvIG1pc3NpbmdcbiAgICBsYWJlbENvbXByZXNzaW9uKGNvbXByZXNzaW9uKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX2NvbXByZXNzaW9uO1xuICAgICAgICB0aGlzLl9jb21wcmVzc2lvbiA9IGNvbXByZXNzaW9uO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLy90b2RvIG1pc3NpbmdcbiAgICBkYXRhQXhpc0xhYmVsKGxhYmVsKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX2RhdGFBeGlzTGFiZWw7XG4gICAgICAgIHRoaXMuX2RhdGFBeGlzTGFiZWwgPSBsYWJlbDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHRvb2x0aXAodG9vbHRpcCkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl90b29sdGlwO1xuICAgICAgICB0aGlzLl90b29sdGlwID0gdG9vbHRpcDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGZvcmNlWShmb3JjZSkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9mb3JjZVk7XG4gICAgICAgIHRoaXMuX2ZvcmNlWSA9IGZvcmNlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vLyB0b2RvIG1pc3NpbmdcbiAgICBkdXJhdGlvbihkdXJhdGlvbikge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9kdXJhdGlvbjtcbiAgICAgICAgdGhpcy5fZHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4vLyB0b2RvIG1pc3NpbmdcbiAgICBjb2Fyc2VuZXNzKGNvYXJzZW5lc3MpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fY29hcnNlbmVzcztcbiAgICAgICAgdGhpcy5fY29hcnNlbmVzcyA9IGNvYXJzZW5lc3M7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIHRvZG8gbWlzc2luZ1xuICAgIHBhZGRpbmcocGFkZGluZykge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9wYWRkaW5nO1xuICAgICAgICB0aGlzLl9wYWRkaW5nID0gcGFkZGluZztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gdG9kbyBtaXNzaW5nXG4gICAgeEF4aXNUb29sdGlwcyh0b29sdGlwcykge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl94QXhpc1Rvb2x0aXBzO1xuICAgICAgICB0aGlzLl94QXhpc1Rvb2x0aXBzID0gdG9vbHRpcHM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHhBeGlzT3ZlcnJpZGUob3ZlcnJpZGUpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5feEF4aXNPdmVycmlkZTtcbiAgICAgICAgdGhpcy5feEF4aXNPdmVycmlkZSA9IG92ZXJyaWRlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgZGlzcGF0Y2goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaXNwYXRjaDtcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2VsZW1lbnQpIHRocm93IG5ldyBFcnJvcihcIk5vIGVsZW1lbnQgc2V0IGZvciBDb2x1bW5DaGFydC4gU2VlICNlbGVtZW50KClcIik7XG4gICAgICAgIGlmICghdGhpcy5fZGF0YSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiTm8gZGF0YSBzZXQgZm9yIENvbHVtbkNoYXJ0LiBTZWUgI2RhdGEoKVwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLmdldFRyYW5zZm9ybWVkRGF0YSgpO1xuXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIFNldCB1cCB0aGUgU1ZHIGFyZWFcblxuICAgICAgICBsZXQgdG9wTGV2ZWwgPSBkMy5zZWxlY3QodGhpcy5fZWxlbWVudCkuc2VsZWN0KFwic3ZnXCIpO1xuICAgICAgICBpZiAodG9wTGV2ZWwuZW1wdHkoKSkgdG9wTGV2ZWwgPSBkMy5zZWxlY3QodGhpcy5fZWxlbWVudCkuYXBwZW5kKFwic3ZnXCIpO1xuXG4gICAgICAgIHRvcExldmVsXG4gICAgICAgICAgICAuc3R5bGUoXCJ3aWR0aFwiLCB0aGlzLl93aWR0aCArIFwicHhcIilcbiAgICAgICAgICAgIC5zdHlsZShcImhlaWdodFwiLCB0aGlzLl9oZWlnaHQgKyBcInB4XCIpO1xuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBMYXlvdXQgdGhlIHNob3dMZWdlbmQuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFdlIGRvIHRoaXMgbm93IGJlY2F1c2Ugd2UgbmVlZCB0byBrbm93IGhvdyBtdWNoIHNwYWNlIHRoZSBsZWdlbmRcbiAgICAgICAgLy8gdGFrZXMgdXAgaW4gb3JkZXIgdG8gZmluaXNoIGNhbGN1bGF0aW5nIHRoZSBtYXJnaW5zLlxuXG4gICAgICAgIGNvbnN0IGxlZ2VuZEhlaWdodCA9IHRoaXMucmVuZGVyTGVnZW5kKHRvcExldmVsLCBkYXRhLCAwLCB0aGlzLl93aWR0aCwgdGhpcy5faGVpZ2h0LCBkID0+IGQuX2tleSk7XG5cbiAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIENhbGN1bGF0ZSBtYXJnaW5zLlxuXG4gICAgICAgIGNvbnN0IG1hcmdpbiA9IHt0b3A6IDIwLCByaWdodDogMjAsIGJvdHRvbTogNDAsIGxlZnQ6IDQwfTtcbiAgICAgICAgbWFyZ2luLmJvdHRvbSArPSBsZWdlbmRIZWlnaHQgPyBsZWdlbmRIZWlnaHQgKyAyMCA6IDA7XG5cbiAgICAgICAgLy8gaWYgKHRoaXMuX2RhdGFBeGlzTGFiZWwpIG1hcmdpbi5sZWZ0ICs9IDIwICsgMTI7XG4gICAgICAgIC8vIGlmIChkYXRhKSB7XG4gICAgICAgIC8vICAgICBsZXQgbWF4TGFiZWxMZW5ndGggPSAwO1xuICAgICAgICAvLyAgICAgZGF0YS5mb3JFYWNoKGQgPT4ge1xuICAgICAgICAvLyAgICAgICAgIGQuZGF0YS5mb3JFYWNoKGQgPT4ge1xuICAgICAgICAvLyAgICAgICAgICAgICBsZXQgbGVuZ3RoID0gdGhpcy5feEF4aXNUaWNrRm9ybWF0KHRoaXMuX3goZCkpLmxlbmd0aDtcbiAgICAgICAgLy8gICAgICAgICAgICAgaWYgKGxlbmd0aCA+IG1heExhYmVsTGVuZ3RoKSBtYXhMYWJlbExlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgLy8gICAgICAgICB9KVxuICAgICAgICAvLyAgICAgfSk7XG4gICAgICAgIC8vICAgICBtYXJnaW4uYm90dG9tICs9IG1heExhYmVsTGVuZ3RoICogMiArIDEwOyAgICAvLyBzcGFjZSBmb3IgYXhlcyBsYWJlbHMuXG4gICAgICAgIC8vIH1cblxuICAgICAgICBjb25zdCB3aWR0aCA9IHRoaXMuX3dpZHRoIC0gbWFyZ2luLmxlZnQgLSBtYXJnaW4ucmlnaHQsXG4gICAgICAgICAgICAgIGhlaWdodCA9IHRoaXMuX2hlaWdodCAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tO1xuICAgICAgICBjb25zdCByYWRpdXMgPSBNYXRoLm1pbih3aWR0aCwgaGVpZ2h0KSAvIDI7XG4gICAgICAgIHRoaXMuX3JhZGl1cyA9IHJhZGl1cztcblxuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHNjYWxlcyBhbmQgc28gb24uXG5cbiAgICAgICAgbGV0IGNvbG91ciA9IGQzLnNjYWxlT3JkaW5hbChbXCIjOThhYmM1XCIsIFwiIzhhODlhNlwiLCBcIiM3YjY4ODhcIiwgXCIjNmI0ODZiXCIsIFwiI2EwNWQ1NlwiLCBcIiNkMDc0M2NcIiwgXCIjZmY4YzAwXCJdKTtcblxuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgIGxldCBzdmcgPSB0b3BMZXZlbC5zZWxlY3QoJy5tYWluLWdyb3VwJyk7XG5cbiAgICAgICAgaWYgKHN2Zy5lbXB0eSgpKSB7XG4gICAgICAgICAgICBzdmcgPSB0b3BMZXZlbFxuICAgICAgICAgICAgICAgIC5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcIm1haW4tZ3JvdXBcIik7XG4gICAgICAgIH1cblxuICAgICAgICBzdmcuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIChtYXJnaW4ubGVmdCArIHdpZHRoIC8gMikgKyBcIixcIiArIChtYXJnaW4udG9wICsgaGVpZ2h0IC8gMikgKyBcIilcIik7XG5cbiAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gR2V0IHJpZCBvZiBjdXJyZW50IGxhYmVscy5cbiAgICAgICAgc3ZnLnNlbGVjdChcIi5jaGFydC1sYWJlbHNcIilcbiAgICAgICAgICAgIC5yZW1vdmUoKTtcblxuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBhcHBlbmQgdGhlIGFyY3MgZm9yIHRoZSBwaWUgY2hhcnRcblxuICAgICAgICBsZXQgcGllID0gZDMucGllKClcbiAgICAgICAgICAgIC5zb3J0KG51bGwpXG4gICAgICAgICAgICAudmFsdWUoZCA9PiBkLl95KTtcbiAgICAgICAgdGhpcy5fcGllID0gcGllO1xuXG4gICAgICAgIGxldCBwYXRoID0gZDMuYXJjKClcbiAgICAgICAgICAgIC5vdXRlclJhZGl1cyhyYWRpdXMgLSAxMClcbiAgICAgICAgICAgIC5pbm5lclJhZGl1cygwKTtcblxuICAgICAgICBsZXQgYXJjcyA9IHN2Zy5zZWxlY3QoXCIuc2xpY2VzXCIpLnNlbGVjdEFsbCgnLmFyYycpO1xuXG4gICAgICAgIGlmIChhcmNzLmVtcHR5KCkpIHtcbiAgICAgICAgICAgIGFyY3MgPSBzdmdcbiAgICAgICAgICAgICAgICAuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJzbGljZXNcIilcbiAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKFwiLmFyY1wiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBwaWVEYXRhID0gcGllKGRhdGEpO1xuICAgICAgICBhcmNzID0gYXJjcy5kYXRhKHBpZURhdGEpO1xuICAgICAgICBhcmNzLmV4aXQoKS5yZW1vdmUoKTtcblxuICAgICAgICBmdW5jdGlvbiBhcmNUd2VlbihkLCBpKSB7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50ID0gdGhpcy5fY3VycmVudCB8fCAoaSA8PSAwID8geyBzdGFydEFuZ2xlOiAwLCBlbmRBbmdsZTogMH0gOiBwaWVEYXRhW2kgLSAxXSk7XG4gICAgICAgICAgICBsZXQgaW50ZXJwb2xhdG9yID0gZDMuaW50ZXJwb2xhdGUodGhpcy5fY3VycmVudCwgZCk7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50ID0gaW50ZXJwb2xhdG9yKDApO1xuXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXRoKGludGVycG9sYXRvcih0KSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGFyY3MuZW50ZXIoKVxuICAgICAgICAgICAgLmFwcGVuZChcInBhdGhcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIChkLCBpKSA9PiBcImFyYyBcIiArIFwic2VyaWVzIHNlcmllcy1cIiArIGkpXG4gICAgICAgICAgICAgICAgLnN0eWxlKFwiY3Vyc29yXCIsIFwicG9pbnRlclwiKVxuICAgICAgICAgICAgLm9uKFwibW91c2VvdmVyXCIsIChkLCBpLCBub2RlcykgPT4geyAvLyBEYXJrZW4gdGhlIHBpZSBvbiBtb3VzZSBvdmVyXG4gICAgICAgICAgICAgICAgLy8gV2Ugd2FudCB0byBzaGlmdCB0aGUgcGllIG91dCBhIGJpdCBvbiBtb3VzZW92ZXIuXG4gICAgICAgICAgICAgICAgLy8gU28gd2Ugd2FudCB0byBmaW5kIHRoZSBkaXJlY3Rpb24gdG8gbW92ZSB0aGUgcGllIGluLlxuICAgICAgICAgICAgICAgIC8vIFdlIGNhbiBqdXN0IGFzayB0aGUgcGF0aCBoZWxwZXIgdG8gZ2l2ZSB1cyB0aGUgY2VudHJvaWQsXG4gICAgICAgICAgICAgICAgLy8gbm9ybWFsaXNlIGl0LCBhbmQgdGhhdCBpcyB0aGUgZGlyZWN0aW9uIHRvIG1vdmUgaW4uXG4gICAgICAgICAgICAgICAgY29uc3QgY2VudHJlID0gcGF0aC5jZW50cm9pZChkKTtcbiAgICAgICAgICAgICAgICBjb25zdCBub3JtID0gTWF0aC5zcXJ0KGNlbnRyZVswXSAqKiAyICsgY2VudHJlWzFdICoqIDIpO1xuICAgICAgICAgICAgICAgIGNlbnRyZVswXSA9IGNlbnRyZVswXSAvIG5vcm07XG4gICAgICAgICAgICAgICAgY2VudHJlWzFdID0gY2VudHJlWzFdIC8gbm9ybTtcblxuICAgICAgICAgICAgICAgIGQzLnNlbGVjdChub2Rlc1tpXSlcbiAgICAgICAgICAgICAgICAgICAgLmludGVycnVwdChcImhvdmVyOmNvbG91clwiKVxuICAgICAgICAgICAgICAgICAgICAudHJhbnNpdGlvbihcImhvdmVyOmNvbG91clwiKVxuICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24oMzAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyAoY2VudHJlWzBdICogMTApICsgXCIsXCIgKyAoY2VudHJlWzFdICogMTApICsgXCIpLCBzY2FsZSgxLjEpXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIGQzLmhjbCh0aGlzLmdldFNlcmllc0NvbG91cihpKSkuZGFya2VyKCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3BhdGNoLmNhbGwoXCJ0b29sdGlwU2hvd1wiLCB0aGlzLCB7XG4gICAgICAgICAgICAgICAgICAgIGU6IGQzLmV2ZW50LFxuICAgICAgICAgICAgICAgICAgICBwb2ludDogZC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICBzZXJpZXM6IGQuZGF0YS5fc2VyaWVzLFxuICAgICAgICAgICAgICAgICAgICBzZXJpZXNJbmRleDogZC5kYXRhLl9zX2ksXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBkLmRhdGEuX3lcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbihcIm1vdXNlb3V0XCIsIChkLCBpLCBub2RlcykgPT4geyAvLyBwaWUgaXMgcmVndWxhciBjb2xvdXIgb24gbW91c2Ugb3V0LlxuICAgICAgICAgICAgICAgIGQzLnNlbGVjdChub2Rlc1tpXSlcbiAgICAgICAgICAgICAgICAgICAgLmludGVycnVwdChcImhvdmVyOmNvbG91clwiKVxuICAgICAgICAgICAgICAgICAgICAudHJhbnNpdGlvbihcImhvdmVyOmNvbG91clwiKVxuICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24oMzAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoMCwwKVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCB0aGlzLmdldFNlcmllc0NvbG91cihpKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGlzcGF0Y2guY2FsbChcInRvb2x0aXBIaWRlXCIsIHRoaXMpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbihcImNsaWNrIGF1eGNsaWNrXCIsIChkLCBpLCBub2RlcykgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3BhdGNoLmNhbGwoXCJlbGVtZW50Q2xpY2tcIiwgdGhpcywge1xuICAgICAgICAgICAgICAgICAgICBlOiBkMy5ldmVudCxcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQ6IGQuZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgc2VyaWVzOiBkLmRhdGEuX3NlcmllcyxcbiAgICAgICAgICAgICAgICAgICAgc2VyaWVzSW5kZXg6IGQuZGF0YS5fc19pLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZC5kYXRhLl95XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAubWVyZ2UoYXJjcylcbiAgICAgICAgICAgIC50cmFuc2l0aW9uKClcbiAgICAgICAgICAgICAgICAuYXR0clR3ZWVuKFwiZFwiLCBhcmNUd2VlbilcbiAgICAgICAgICAgICAgICAuYXR0cihcImZpbGxcIiwgKGQsIGkpID0+IHRoaXMuZ2V0U2VyaWVzQ29sb3VyKGkpICk7XG5cbiAgICAgICAgLy8gYXJjcy5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgICAgIC8vICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBmdW5jdGlvbihkKSB7IHJldHVybiBcInRyYW5zbGF0ZShcIiArIGxhYmVsLmNlbnRyb2lkKGQpICsgXCIpXCI7IH0pXG4gICAgICAgIC8vICAgICAuYXR0cihcImR5XCIsIFwiMC4zNWVtXCIpXG4gICAgICAgIC8vICAgICAudGV4dChkID0+IHtjb25zb2xlLmxvZyhcImQgaXNcIiwgZCk7IHJldHVybiBkLmRhdGEuX3k7IH0pO1xuXG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIExhYmVscyBsb2FkZWQgYWZ0ZXIgb3VyIGZpcnN0IGJhciBncm93cy5cbiAgICAgICAgaWYgKHRoaXMuX3Nob3dfbGFiZWxzKSB7XG4gICAgICAgICAgICBzdmcudHJhbnNpdGlvbihcImJhcjpncm93dGhcIilcbiAgICAgICAgICAgICAgICAub24oXCJlbmRcIiwgKGQsIGksIG5vZGVzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpIDwgbm9kZXMubGVuZ3RoIC0gMSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckxhYmVscyhzdmcsIGRhdGEpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gU2V0IHRoZSBiYWNrZ3JvdW5kIGNvbG91clxuXG4gICAgICAgIGQzLnNlbGVjdCh0aGlzLl9lbGVtZW50KS5zZWxlY3QoXCIuYmFja2dyb3VuZFwiKS5yZW1vdmUoKTtcbiAgICAgICAgaWYgKHRoaXMuX2JhY2tncm91bmRDb2xvdXIpIHtcbiAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzLl9lbGVtZW50KS5zZWxlY3QoXCJzdmdcIilcbiAgICAgICAgICAgICAgICAuYXBwZW5kKFwicmVjdFwiKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwiYmFja2dyb3VuZFwiKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcIndpZHRoXCIsIFwiMTAwJVwiKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcImhlaWdodFwiLCBcIjEwMCVcIilcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCB0aGlzLl9iYWNrZ3JvdW5kQ29sb3VyKVxuICAgICAgICAgICAgICAgIC5sb3dlcigpO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLypcbiAgICAgKiBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIHR3byBmdW5jdGlvbnMsICNzaG93KCkgYW5kICNoaWRlKCksXG4gICAgICogdG8gc2hvdyBhbmQgaGlkZSB0aGUgbGFiZWxzLlxuICAgICAqL1xuICAgIGxhYmVscygpIHtcbiAgICAgICAgcmV0dXJuIHtcblxuICAgICAgICAgICAgc2hvdzogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9lbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzZWxlY3Rpb24gPSB0aGlzLl9lbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHRoaXMuZ2V0VHJhbnNmb3JtZWREYXRhKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvbikgc2VsZWN0aW9uID0gZDMuc2VsZWN0KHRoaXMuX2VsZW1lbnQpLnNlbGVjdChcInN2Z1wiKS5zZWxlY3QoXCIubWFpbi1ncm91cFwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzZWxlY3Rpb24uZW1wdHkoKSAmJiBkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbGFiZWxzID0gc2VsZWN0aW9uLnNlbGVjdCgnLmNoYXJ0LWxhYmVscycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFsYWJlbHMuZW1wdHkoKSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWxzLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJMYWJlbHMoc2VsZWN0aW9uLCBkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgaGlkZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9lbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzLl9lbGVtZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgLnNlbGVjdCgnLmNoYXJ0LWxhYmVscycpXG4gICAgICAgICAgICAgICAgICAgICAgICAuaW50ZXJydXB0KFwibGFiZWxzXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAuaW50ZXJydXB0KFwibGFiZWxzOmZhZGVcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKFwibGFiZWxzOmZhZGVcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5vbihcImVuZFwiLCAoZCwgaSwgbm9kZXMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkMy5zZWxlY3Qobm9kZXNbaV0pLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgcmVuZGVyTGFiZWxzKHNlbGVjdGlvbiwgZGF0YSwgYW5pbWF0ZSkge1xuICAgICAgICBzZWxlY3Rpb24uc2VsZWN0QWxsKFwiLmNoYXJ0LWxhYmVsc1wiKS5yZW1vdmUoKTtcblxuICAgICAgICBjb25zdCByYWRpdXMgPSB0aGlzLl9yYWRpdXMgKyAxNTtcblxuICAgICAgICBsZXQgYXJjID0gZDMuYXJjKClcbiAgICAgICAgICAgIC5vdXRlclJhZGl1cyhyYWRpdXMpXG4gICAgICAgICAgICAuaW5uZXJSYWRpdXMocmFkaXVzKTtcblxuICAgICAgICBsZXQgbGFiZWxzID0gc2VsZWN0aW9uLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJjaGFydC1sYWJlbHNcIilcbiAgICAgICAgICAgIC5zZWxlY3RBbGwoXCIubGFiZWwtZ3JvdXBcIilcbiAgICAgICAgICAgIC5kYXRhKHRoaXMuX3BpZShkYXRhKSk7XG5cbiAgICAgICAgbGFiZWxzLmVudGVyKClcbiAgICAgICAgICAgIC5lYWNoKChkLCBpLCBub2RlcykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNlbnRyb2lkID0gYXJjLmNlbnRyb2lkKGQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJhZGlhbnMgPSBkLmVuZEFuZ2xlIC0gZC5zdGFydEFuZ2xlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFyY0xlbmd0aCA9IHJhZGlhbnMgKiByYWRpdXM7XG5cbiAgICAgICAgICAgICAgICBsZXQgbGFiZWwgPSBkMy5zZWxlY3Qobm9kZXNbaV0pXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgICAgICAgICAgICAgICAgIC50ZXh0KGQgPT4gdGhpcy5fbGFiZWxGb3JtYXQoZC5kYXRhLl95KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIC5zdHlsZShcImZvbnQtZmFtaWx5XCIsIFwiT3BlbiBTYW5zLCBzYW5zLXNlcmlmXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAuc3R5bGUoXCJmb250LXNpemVcIiwgXCIxMnB4XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIGNvbG91cnMuZWlnaHRlZW4uZGFya0dyZXkpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDApXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIGNlbnRyb2lkICsgXCIpXCIpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgYm91bmRpbmcgPSBsYWJlbC5ub2RlKCkuZ2V0QkJveCgpO1xuICAgICAgICAgICAgICAgIGlmIChib3VuZGluZy53aWR0aCA8IGFyY0xlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBsYWJlbC5hdHRyKFwiZHhcIiwgKGJvdW5kaW5nLndpZHRoIC8gMikgKiAoZGlyZWN0aW9uWzBdIDwgMCA/IC0xIDogMSkpO1xuICAgICAgICAgICAgICAgICAgICAvLyBsYWJlbC5hdHRyKFwiZHlcIiwgKGJvdW5kaW5nLmhlaWdodCAvIDIpICogKGRpcmVjdGlvblsxXSA8IDAgPyAtMSA6IDEpKTtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWwuYXR0cihcImR4XCIsIC0oYm91bmRpbmcud2lkdGggLyAyKSk7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsLmF0dHIoXCJkeVwiLCAoYm91bmRpbmcuaGVpZ2h0IC8gMikpO1xuXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsXG4gICAgICAgICAgICAgICAgICAgICAgICAudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24odGhpcy5fZHVyYXRpb24pXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDEpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9KVxuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBnZXRTZXJpZXNDb2xvdXIoaSkge1xuICAgICAgICBpZiAoaSA8IDAgfHwgIXRoaXMuX2NvbG91cnMpIHJldHVybiBjb2xvdXJzLmVpZ2h0ZWVuLm1pZEdyZXk7XG5cbiAgICAgICAgaSA9IGkgJSB0aGlzLl9jb2xvdXJzLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbG91cnNbaV07XG4gICAgfVxuXG4gICAgZ2V0U29ydGVkRGF0YSgpIHtcbiAgICAgICAgbGV0IGRhdGEgPSB0aGlzLl9kYXRhO1xuICAgICAgICBpZiAoIWRhdGEgfHwgIWRhdGEubGVuZ3RoKSByZXR1cm4gW107XG5cbiAgICAgICAgZGF0YSA9IHRoaXMuX2RhdGEuc29ydCgobGhzLCByaHMpID0+IHtcbiAgICAgICAgICAgIGxocyA9IGxocy5rZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIHJocyA9IHJocy5rZXkudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICAgICAgaWYgKGxocyA9PT0gcmhzKSByZXR1cm4gMDtcbiAgICAgICAgICAgIGlmIChsaHMgPCByaHMpIHJldHVybiAtMTtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICBnZXRUcmFuc2Zvcm1lZERhdGEoKSB7XG4gICAgICAgIGxldCBkYXRhID0gdGhpcy5nZXRTb3J0ZWREYXRhKCk7XG4gICAgICAgIGlmICghZGF0YSB8fCAhZGF0YS5sZW5ndGgpIHJldHVybiBbXTtcblxuICAgICAgICBsZXQgcmVzdWx0cyA9IFtdO1xuXG4gICAgICAgIGxldCBzZXJpZXMgPSBkYXRhWzBdO1xuICAgICAgICBzZXJpZXMudmFsdWVzLmZvckVhY2goKGQsIGRfaSkgPT4ge1xuXG4gICAgICAgICAgICByZXN1bHRzLnB1c2goT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICAgICAgX3k6IHRoaXMuX3koZCksXG4gICAgICAgICAgICAgICAgX3Nlcmllc19rZXk6IHNlcmllcy5rZXksXG4gICAgICAgICAgICAgICAgX3NfaTogMCxcbiAgICAgICAgICAgICAgICBfc2VyaWVzOiBzZXJpZXMsXG4gICAgICAgICAgICAgICAgX2tleTogdGhpcy5feEF4aXNPdmVycmlkZSA/IHRoaXMuX3hBeGlzT3ZlcnJpZGVbdGhpcy5feChkKV0gOiB0aGlzLl94KGQpXG4gICAgICAgICAgICB9LCBkKSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cblxuICAgIGdldEtleXMoKSB7XG4gICAgICAgIGxldCBkYXRhID0gdGhpcy5fZGF0YTtcbiAgICAgICAgaWYgKCFkYXRhIHx8ICFkYXRhLmxlbmd0aCkgcmV0dXJuIFtdO1xuXG4gICAgICAgIHJldHVybiBbLi4ubmV3IFNldChkYXRhLm1hcChkID0+IGQua2V5KSldXG4gICAgfVxufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/PieChart.js\n')},"./src/Statistics.js":
/*!***************************!*\
  !*** ./src/Statistics.js ***!
  \***************************/
/*! exports provided: freedmanDiaconis */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "freedmanDiaconis", function() { return freedmanDiaconis; });\n/* harmony import */ var compute_iqr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! compute-iqr */ "./node_modules/compute-iqr/lib/index.js");\n/* harmony import */ var compute_iqr__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(compute_iqr__WEBPACK_IMPORTED_MODULE_0__);\n// Copyright (C) 2013-2014, 2018 BrandsEye (PTY) LTD\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this\n// software and associated documentation files (the "Software"), to deal in the Software\n// without restriction, including without limitation the rights to use, copy, modify,\n//     merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following\n// conditions:\n//\n//     The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n//     INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n// CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n\n/**\n * Calculates the number of buckets to split a real value domain\n * in to when calculating a histogram.\n *\n * https://en.wikipedia.org/wiki/Histogram\n *\n * @return {number}\n */\nfunction freedmanDiaconis(data) {\n    return 2 * compute_iqr__WEBPACK_IMPORTED_MODULE_0___default()(data) / Math.pow(data.length, 1/3);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvU3RhdGlzdGljcy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2IzanMvLi9zcmMvU3RhdGlzdGljcy5qcz9kNThlIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoQykgMjAxMy0yMDE0LCAyMDE4IEJyYW5kc0V5ZSAoUFRZKSBMVERcbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXNcbi8vIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZVxuLy8gd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LFxuLy8gICAgIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG9cbi8vIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nXG4vLyBjb25kaXRpb25zOlxuLy9cbi8vICAgICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbi8vIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gICAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1IgSU1QTElFRCxcbi8vICAgICBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQVxuLy8gUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxuLy8gSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GXG4vLyBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkVcbi8vIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5pbXBvcnQgaXFyIGZyb20gJ2NvbXB1dGUtaXFyJztcblxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIG51bWJlciBvZiBidWNrZXRzIHRvIHNwbGl0IGEgcmVhbCB2YWx1ZSBkb21haW5cbiAqIGluIHRvIHdoZW4gY2FsY3VsYXRpbmcgYSBoaXN0b2dyYW0uXG4gKlxuICogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSGlzdG9ncmFtXG4gKlxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJlZWRtYW5EaWFjb25pcyhkYXRhKSB7XG4gICAgcmV0dXJuIDIgKiBpcXIoZGF0YSkgLyBNYXRoLnBvdyhkYXRhLmxlbmd0aCwgMS8zKTtcbn0iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/Statistics.js\n')},"./src/Strings.js":
/*!************************!*\
  !*** ./src/Strings.js ***!
  \************************/
/*! exports provided: restrictLength */function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"restrictLength\", function() { return restrictLength; });\n// Copyright (C) 2013-2014, 2018 BrandsEye (PTY) LTD\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this\n// software and associated documentation files (the \"Software\"), to deal in the Software\n// without restriction, including without limitation the rights to use, copy, modify,\n//     merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following\n// conditions:\n//\n//     The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n//     INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n// CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n/**\n * Limits the length of a string, and places ellipses if this happens.\n * @param text\n * @param length\n * @returns {*}\n */\nfunction restrictLength(text, length) {\n    if (!text) return text;\n    text = \"\" + text;\n    if (text.length <= length) return text;\n\n    var result = [];\n    var word = [];\n    for (let i = 0; i < length - 1; i++) {\n        var character = text.charAt(i);\n        if (character === ' ' || character === '\\n') {\n            if (result.length === 0) result = result.concat(word);\n            else {\n                result.push(' ');\n                result = result.concat(word);\n            }\n            word = [];\n        } else {\n            word.push(character)\n        }\n    }\n\n    if (text.length !== 0 && result.length === 0) result = text; // Can happen if the string is a single word longer than length.\n    else result.push('');\n\n    if (result.length > length) {\n        return result.substring(0, length - 1) + '';\n    }\n\n    return result.join('');\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvU3RyaW5ncy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2IzanMvLi9zcmMvU3RyaW5ncy5qcz8xMTZhIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoQykgMjAxMy0yMDE0LCAyMDE4IEJyYW5kc0V5ZSAoUFRZKSBMVERcbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXNcbi8vIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZVxuLy8gd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LFxuLy8gICAgIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG9cbi8vIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nXG4vLyBjb25kaXRpb25zOlxuLy9cbi8vICAgICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbi8vIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gICAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1IgSU1QTElFRCxcbi8vICAgICBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQVxuLy8gUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxuLy8gSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GXG4vLyBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkVcbi8vIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vKipcbiAqIExpbWl0cyB0aGUgbGVuZ3RoIG9mIGEgc3RyaW5nLCBhbmQgcGxhY2VzIGVsbGlwc2VzIGlmIHRoaXMgaGFwcGVucy5cbiAqIEBwYXJhbSB0ZXh0XG4gKiBAcGFyYW0gbGVuZ3RoXG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc3RyaWN0TGVuZ3RoKHRleHQsIGxlbmd0aCkge1xuICAgIGlmICghdGV4dCkgcmV0dXJuIHRleHQ7XG4gICAgdGV4dCA9IFwiXCIgKyB0ZXh0O1xuICAgIGlmICh0ZXh0Lmxlbmd0aCA8PSBsZW5ndGgpIHJldHVybiB0ZXh0O1xuXG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciB3b3JkID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgdmFyIGNoYXJhY3RlciA9IHRleHQuY2hhckF0KGkpO1xuICAgICAgICBpZiAoY2hhcmFjdGVyID09PSAnICcgfHwgY2hhcmFjdGVyID09PSAnXFxuJykge1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPT09IDApIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQod29yZCk7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnICcpO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQod29yZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3b3JkID0gW107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3b3JkLnB1c2goY2hhcmFjdGVyKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRleHQubGVuZ3RoICE9PSAwICYmIHJlc3VsdC5sZW5ndGggPT09IDApIHJlc3VsdCA9IHRleHQ7IC8vIENhbiBoYXBwZW4gaWYgdGhlIHN0cmluZyBpcyBhIHNpbmdsZSB3b3JkIGxvbmdlciB0aGFuIGxlbmd0aC5cbiAgICBlbHNlIHJlc3VsdC5wdXNoKCfigKYnKTtcblxuICAgIGlmIChyZXN1bHQubGVuZ3RoID4gbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQuc3Vic3RyaW5nKDAsIGxlbmd0aCAtIDEpICsgJ+KApic7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdC5qb2luKCcnKTtcbn0iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/Strings.js\n")},"./src/chart/Axes.js":
/*!***************************!*\
  !*** ./src/chart/Axes.js ***!
  \***************************/
/*! exports provided: xaxis, yaxis, yGrid, xGrid, yAxisLabel, xAxisLabel */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "xaxis", function() { return xaxis; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "yaxis", function() { return yaxis; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "yGrid", function() { return yGrid; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "xGrid", function() { return xGrid; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "yAxisLabel", function() { return yAxisLabel; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "xAxisLabel", function() { return xAxisLabel; });\n/* harmony import */ var _Colours__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Colours */ "./src/Colours.js");\n// Copyright (C) 2013-2014, 2018 BrandsEye (PTY) LTD\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this\n// software and associated documentation files (the "Software"), to deal in the Software\n// without restriction, including without limitation the rights to use, copy, modify,\n//     merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following\n// conditions:\n//\n//     The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n//     INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n// CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nconst AXIS_ANIMATION_DURATION = 1000;\nconst AXIS_DELAY = 250;\n\nfunction ensureOptions(o) {\n    return Object.assign({\n        fontSize: 12,\n        gridLineOpacity: 0.2\n    }, o)\n}\n\nfunction getMaxWidth(sel) {\n    let max = 0\n    sel.nodes().forEach(node => max = Math.max(max, node.getBBox().width))\n    return max\n}\n\nfunction removeOverlappingXTicks(axis, labelWidth) {\n    let a = axis.selectAll("g.tick").nodes()\n    if (!a.length) return\n    let px = a[0].getBoundingClientRect().x + labelWidth\n    for (let i = 1; i < a.length; i++) {\n        let node = a[i]\n        let x = node.getBoundingClientRect().x\n        if (x < px) node.parentNode.removeChild(node)\n        else px = x + labelWidth // there is space for the label\n    }\n}\n\nfunction adjustFirstXTickLabel(axis) {\n    // move the first tick label right if it extends too far to the left as it might overlap the y-axis zero\n    let tick = axis.select("g.tick")\n    if (tick.empty()) return\n    let t = tick.attr("transform")  // e.g. translate(8.327586206896552,0)\n    let i = t.indexOf(\'(\')\n    let j = t.indexOf(\',\', i + 1)\n    let x = parseFloat(t.substring(i + 1, j))\n    let text = tick.select("text")\n    x -= text.node().getComputedTextLength() / 2\n    if (x < -8) text.attr("x", Math.abs(x + 6))\n}\n\nfunction xaxis(selection, height, width, axisObject, importance, options) {\n    options = ensureOptions(options)\n    let { fontSize, gridLineOpacity } = options\n\n    selection.select(".x-axis").remove();\n    let axis = selection.append("g").attr("class", "x-axis").style("opacity", 0).call(axisObject)\n\n    axis.select(".domain").remove();\n\n    const regularText = d3.hcl(_Colours__WEBPACK_IMPORTED_MODULE_0__["colours"].eighteen.darkGrey).brighter();\n\n    let text = axis.selectAll("text")\n    text.style("font-size", fontSize + "px")\n        .style("fill", regularText)\n\n    let tv = axisObject.tickValues()\n    if (tv) width *= axisObject.scale().domain().length / (tv.length + 1)\n\n    let labelWidth = getMaxWidth(text) + 4\n    if (labelWidth > width) {\n        if (options.xLabelAngle !== 0) {\n            const bad = labelWidth >= width * 2;\n            const angle = bad ? -90 : -30;\n            const x = bad ? -(fontSize * 0.78) : 0;\n            const y = bad ? 5 : 2;\n\n            text.style(\'text-anchor\', \'end\')\n                .attr("transform", () => "translate(" + x + "," + y + ") rotate(" + angle + " 0,0)")\n\n            labelWidth = fontSize * 1.2  // getBoundingClientRect doesn\'t seem to consider the rotation?\n        } else {\n            if (!options.hideYAxisMin) adjustFirstXTickLabel(axis)\n        }\n        if (options.hideXAxisMin) axis.select("text").remove()\n        if (labelWidth > width) removeOverlappingXTicks(axis, labelWidth)\n    } else {\n        if (!options.hideYAxisMin) adjustFirstXTickLabel(axis)\n        if (options.hideXAxisMin) axis.select("text").remove()\n        if (tv) removeOverlappingXTicks(axis, labelWidth) // ticks might not be evenly spaced\n    }\n\n    axis.selectAll("line").style("opacity", gridLineOpacity)\n\n    let tickSize = axisObject.tickSize();\n    if (tickSize && options.axisBox) {\n        let x = axisObject.scale().range()[1]\n        axis.append("line").attr("x1", x).attr("x2", x).attr("y2", tickSize)\n            .attr("opacity", gridLineOpacity).attr("stroke", "currentColor")\n    }\n\n    axis.transition().duration(AXIS_ANIMATION_DURATION).delay(AXIS_DELAY).style("opacity", 1)\n\n    return axis.node().getBBox().height;\n}\n\nfunction removeOverlappingYTicks(axis, labelHeight) {\n    let a = axis.selectAll("g.tick").nodes()\n    if (!a.length) return\n    let py = a[0].getBoundingClientRect().y - labelHeight\n    for (let i = 1; i < a.length; i++) {\n        let node = a[i]\n        let y = node.getBoundingClientRect().y\n        if (y > py) node.parentNode.removeChild(node)\n        else py = y - labelHeight // there is space for the label\n    }\n}\n\nfunction yaxis(selection, axis, options) {\n    options = ensureOptions(options)\n    let { fontSize, gridLineOpacity } = ensureOptions(options)\n\n    selection.select(".y-axis").remove();\n    let y = selection.append("g")\n                     .attr("class", "y-axis")\n                     .call(axis)\n                     .style("opacity", 0)\n    y.select(".domain").remove() // this doubles up on the 0 tick line making it darker so nuke it\n\n    if (options.axisBox) y.append("line").attr("y2", axis.scale().range()[0]).attr("stroke", "currentColor")\n\n    let tickSize = axis.tickSize()\n    if (tickSize && options.axisBox) y.append("line").attr("x2", -tickSize).attr("stroke", "currentColor")\n\n    if (options.hideYAxisMin) y.select("text").remove()\n\n    y.selectAll("text").style("font-size", fontSize + "px").style("fill", d3.hcl(_Colours__WEBPACK_IMPORTED_MODULE_0__["colours"].eighteen.darkGrey).brighter());\n    y.selectAll("path").style("opacity", gridLineOpacity)\n    y.selectAll("line").style("opacity", gridLineOpacity)\n\n    if (!axis.scale().bandwidth) removeOverlappingYTicks(y, fontSize * 1.2)\n\n    y.transition()\n        .duration(AXIS_ANIMATION_DURATION)\n        .delay(AXIS_DELAY)\n        .style("opacity", 1);\n\n    return y.node().getBBox().width + 20;\n}\n\nfunction yGrid(selection, width, show, axis) {\n    selection.select(".yGrid").remove();\n\n    if (!show) return;\n\n    let grid = selection.append("g")\n                        .attr("class", "yGrid")\n                        .call(axis\n                            .tickSize(-width)\n                            .tickFormat("")\n                        );\n\n    grid.selectAll("line")\n        .style("stroke", _Colours__WEBPACK_IMPORTED_MODULE_0__["colours"].eighteen.lightGrey);\n    grid.selectAll(".domain").remove();\n\n    grid\n        .lower() // Always ensure that this is earlier in the dom. Things must be drawn on top of it.\n        .style("opacity", 0)\n        .transition()\n        .delay(AXIS_DELAY)\n        .duration(AXIS_ANIMATION_DURATION)\n        .style("opacity", 1);\n}\n\nfunction xGrid(selection, height, show, axis) {\n    selection.select(".xGrid").remove();\n\n    if (!show) return;\n\n    let grid = selection.append("g")\n                        .attr("class", "xGrid")\n                        .call(axis\n                            .tickSize(height)\n                            .tickFormat("")\n                        );\n\n    grid.selectAll("line")\n        .style("stroke", _Colours__WEBPACK_IMPORTED_MODULE_0__["colours"].eighteen.lightGrey);\n    grid.selectAll(".domain").remove();\n\n    grid\n        .lower()\n        .style("opacity", 0)\n        .transition()\n        .delay(AXIS_DELAY)\n        .duration(AXIS_ANIMATION_DURATION)\n        .style("opacity", 1);\n}\n\nfunction yAxisLabel(element, height, margins, label, options, y2x) {\n    let { fontSize } = ensureOptions(options)\n\n    let cls = y2x ? "y2-axis-label" : "y-axis-label"\n    element.selectAll("." + cls).remove();\n\n    if (!label) return;\n    let text = label;\n    if (text.long) text = text.long;\n\n    let x = y2x || 20\n    let y = -(margins.top + height / 2)\n\n    let labelElement = element.append("g")\n        .attr("class", cls)\n        .append("text")\n        .style("font-size", fontSize + "px")\n        .text(text)\n        .attr("transform", "rotate(-90 0,0) translate(" + y + "," + x + ")")\n        .style("fill", d3.hcl(_Colours__WEBPACK_IMPORTED_MODULE_0__["colours"].eighteen.darkGrey).brighter());\n\n    let width = labelElement.node().getBBox().width;\n    if (width >= height && label.short) {\n        labelElement.text(label.short);\n        width = labelElement.node().getBBox().width;\n    }\n\n    labelElement.attr("dx", -width / 2)\n                .style("opacity", 0)\n                .transition()\n                .delay(AXIS_DELAY)\n                .duration(AXIS_ANIMATION_DURATION)\n                .style("opacity", 1)\n}\n\nfunction xAxisLabel(element, width, height, margins, label, options) {\n    let { fontSize } = ensureOptions(options)\n\n    element.selectAll(".x-axis-label").remove();\n\n    if (!label) return;\n    let text = label;\n    if (text.long) text = text.long;\n\n    let x = margins.left + width / 2;\n    let y = margins.top + height + 40;\n\n    let labelElement = element.append("g")\n        .attr("class", "x-axis-label")\n        .append("text")\n        .style("font-size", fontSize + "px")\n        .text(text)\n        .attr("transform", "translate(" + x + ", " + y + ")")\n        .style("fill", d3.hcl(_Colours__WEBPACK_IMPORTED_MODULE_0__["colours"].eighteen.darkGrey).brighter());\n\n    let textWidth = labelElement.node().getBBox().width;\n    if (textWidth >= height && label.short) {\n        labelElement.text(label.short);\n        textWidth = labelElement.node().getBBox().width;\n    }\n\n    labelElement.attr("dx", -textWidth / 2)\n                .style("opacity", 0)\n                .transition()\n                .delay(AXIS_DELAY)\n                .duration(AXIS_ANIMATION_DURATION)\n                .style("opacity", 1)\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY2hhcnQvQXhlcy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2IzanMvLi9zcmMvY2hhcnQvQXhlcy5qcz9iNDYxIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoQykgMjAxMy0yMDE0LCAyMDE4IEJyYW5kc0V5ZSAoUFRZKSBMVERcbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXNcbi8vIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZVxuLy8gd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LFxuLy8gICAgIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG9cbi8vIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nXG4vLyBjb25kaXRpb25zOlxuLy9cbi8vICAgICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbi8vIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gICAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1IgSU1QTElFRCxcbi8vICAgICBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQVxuLy8gUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxuLy8gSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GXG4vLyBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkVcbi8vIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5pbXBvcnQge2NvbG91cnN9IGZyb20gXCIuLi9Db2xvdXJzXCI7XG5cbmNvbnN0IEFYSVNfQU5JTUFUSU9OX0RVUkFUSU9OID0gMTAwMDtcbmNvbnN0IEFYSVNfREVMQVkgPSAyNTA7XG5cbmZ1bmN0aW9uIGVuc3VyZU9wdGlvbnMobykge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgZm9udFNpemU6IDEyLFxuICAgICAgICBncmlkTGluZU9wYWNpdHk6IDAuMlxuICAgIH0sIG8pXG59XG5cbmZ1bmN0aW9uIGdldE1heFdpZHRoKHNlbCkge1xuICAgIGxldCBtYXggPSAwXG4gICAgc2VsLm5vZGVzKCkuZm9yRWFjaChub2RlID0+IG1heCA9IE1hdGgubWF4KG1heCwgbm9kZS5nZXRCQm94KCkud2lkdGgpKVxuICAgIHJldHVybiBtYXhcbn1cblxuZnVuY3Rpb24gcmVtb3ZlT3ZlcmxhcHBpbmdYVGlja3MoYXhpcywgbGFiZWxXaWR0aCkge1xuICAgIGxldCBhID0gYXhpcy5zZWxlY3RBbGwoXCJnLnRpY2tcIikubm9kZXMoKVxuICAgIGlmICghYS5sZW5ndGgpIHJldHVyblxuICAgIGxldCBweCA9IGFbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkueCArIGxhYmVsV2lkdGhcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IG5vZGUgPSBhW2ldXG4gICAgICAgIGxldCB4ID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS54XG4gICAgICAgIGlmICh4IDwgcHgpIG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKVxuICAgICAgICBlbHNlIHB4ID0geCArIGxhYmVsV2lkdGggLy8gdGhlcmUgaXMgc3BhY2UgZm9yIHRoZSBsYWJlbFxuICAgIH1cbn1cblxuZnVuY3Rpb24gYWRqdXN0Rmlyc3RYVGlja0xhYmVsKGF4aXMpIHtcbiAgICAvLyBtb3ZlIHRoZSBmaXJzdCB0aWNrIGxhYmVsIHJpZ2h0IGlmIGl0IGV4dGVuZHMgdG9vIGZhciB0byB0aGUgbGVmdCBhcyBpdCBtaWdodCBvdmVybGFwIHRoZSB5LWF4aXMgemVyb1xuICAgIGxldCB0aWNrID0gYXhpcy5zZWxlY3QoXCJnLnRpY2tcIilcbiAgICBpZiAodGljay5lbXB0eSgpKSByZXR1cm5cbiAgICBsZXQgdCA9IHRpY2suYXR0cihcInRyYW5zZm9ybVwiKSAgLy8gZS5nLiB0cmFuc2xhdGUoOC4zMjc1ODYyMDY4OTY1NTIsMClcbiAgICBsZXQgaSA9IHQuaW5kZXhPZignKCcpXG4gICAgbGV0IGogPSB0LmluZGV4T2YoJywnLCBpICsgMSlcbiAgICBsZXQgeCA9IHBhcnNlRmxvYXQodC5zdWJzdHJpbmcoaSArIDEsIGopKVxuICAgIGxldCB0ZXh0ID0gdGljay5zZWxlY3QoXCJ0ZXh0XCIpXG4gICAgeCAtPSB0ZXh0Lm5vZGUoKS5nZXRDb21wdXRlZFRleHRMZW5ndGgoKSAvIDJcbiAgICBpZiAoeCA8IC04KSB0ZXh0LmF0dHIoXCJ4XCIsIE1hdGguYWJzKHggKyA2KSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHhheGlzKHNlbGVjdGlvbiwgaGVpZ2h0LCB3aWR0aCwgYXhpc09iamVjdCwgaW1wb3J0YW5jZSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBlbnN1cmVPcHRpb25zKG9wdGlvbnMpXG4gICAgbGV0IHsgZm9udFNpemUsIGdyaWRMaW5lT3BhY2l0eSB9ID0gb3B0aW9uc1xuXG4gICAgc2VsZWN0aW9uLnNlbGVjdChcIi54LWF4aXNcIikucmVtb3ZlKCk7XG4gICAgbGV0IGF4aXMgPSBzZWxlY3Rpb24uYXBwZW5kKFwiZ1wiKS5hdHRyKFwiY2xhc3NcIiwgXCJ4LWF4aXNcIikuc3R5bGUoXCJvcGFjaXR5XCIsIDApLmNhbGwoYXhpc09iamVjdClcblxuICAgIGF4aXMuc2VsZWN0KFwiLmRvbWFpblwiKS5yZW1vdmUoKTtcblxuICAgIGNvbnN0IHJlZ3VsYXJUZXh0ID0gZDMuaGNsKGNvbG91cnMuZWlnaHRlZW4uZGFya0dyZXkpLmJyaWdodGVyKCk7XG5cbiAgICBsZXQgdGV4dCA9IGF4aXMuc2VsZWN0QWxsKFwidGV4dFwiKVxuICAgIHRleHQuc3R5bGUoXCJmb250LXNpemVcIiwgZm9udFNpemUgKyBcInB4XCIpXG4gICAgICAgIC5zdHlsZShcImZpbGxcIiwgcmVndWxhclRleHQpXG5cbiAgICBsZXQgdHYgPSBheGlzT2JqZWN0LnRpY2tWYWx1ZXMoKVxuICAgIGlmICh0dikgd2lkdGggKj0gYXhpc09iamVjdC5zY2FsZSgpLmRvbWFpbigpLmxlbmd0aCAvICh0di5sZW5ndGggKyAxKVxuXG4gICAgbGV0IGxhYmVsV2lkdGggPSBnZXRNYXhXaWR0aCh0ZXh0KSArIDRcbiAgICBpZiAobGFiZWxXaWR0aCA+IHdpZHRoKSB7XG4gICAgICAgIGlmIChvcHRpb25zLnhMYWJlbEFuZ2xlICE9PSAwKSB7XG4gICAgICAgICAgICBjb25zdCBiYWQgPSBsYWJlbFdpZHRoID49IHdpZHRoICogMjtcbiAgICAgICAgICAgIGNvbnN0IGFuZ2xlID0gYmFkID8gLTkwIDogLTMwO1xuICAgICAgICAgICAgY29uc3QgeCA9IGJhZCA/IC0oZm9udFNpemUgKiAwLjc4KSA6IDA7XG4gICAgICAgICAgICBjb25zdCB5ID0gYmFkID8gNSA6IDI7XG5cbiAgICAgICAgICAgIHRleHQuc3R5bGUoJ3RleHQtYW5jaG9yJywgJ2VuZCcpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgKCkgPT4gXCJ0cmFuc2xhdGUoXCIgKyB4ICsgXCIsXCIgKyB5ICsgXCIpIHJvdGF0ZShcIiArIGFuZ2xlICsgXCIgMCwwKVwiKVxuXG4gICAgICAgICAgICBsYWJlbFdpZHRoID0gZm9udFNpemUgKiAxLjIgIC8vIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBkb2Vzbid0IHNlZW0gdG8gY29uc2lkZXIgdGhlIHJvdGF0aW9uP1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zLmhpZGVZQXhpc01pbikgYWRqdXN0Rmlyc3RYVGlja0xhYmVsKGF4aXMpXG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuaGlkZVhBeGlzTWluKSBheGlzLnNlbGVjdChcInRleHRcIikucmVtb3ZlKClcbiAgICAgICAgaWYgKGxhYmVsV2lkdGggPiB3aWR0aCkgcmVtb3ZlT3ZlcmxhcHBpbmdYVGlja3MoYXhpcywgbGFiZWxXaWR0aClcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIW9wdGlvbnMuaGlkZVlBeGlzTWluKSBhZGp1c3RGaXJzdFhUaWNrTGFiZWwoYXhpcylcbiAgICAgICAgaWYgKG9wdGlvbnMuaGlkZVhBeGlzTWluKSBheGlzLnNlbGVjdChcInRleHRcIikucmVtb3ZlKClcbiAgICAgICAgaWYgKHR2KSByZW1vdmVPdmVybGFwcGluZ1hUaWNrcyhheGlzLCBsYWJlbFdpZHRoKSAvLyB0aWNrcyBtaWdodCBub3QgYmUgZXZlbmx5IHNwYWNlZFxuICAgIH1cblxuICAgIGF4aXMuc2VsZWN0QWxsKFwibGluZVwiKS5zdHlsZShcIm9wYWNpdHlcIiwgZ3JpZExpbmVPcGFjaXR5KVxuXG4gICAgbGV0IHRpY2tTaXplID0gYXhpc09iamVjdC50aWNrU2l6ZSgpO1xuICAgIGlmICh0aWNrU2l6ZSAmJiBvcHRpb25zLmF4aXNCb3gpIHtcbiAgICAgICAgbGV0IHggPSBheGlzT2JqZWN0LnNjYWxlKCkucmFuZ2UoKVsxXVxuICAgICAgICBheGlzLmFwcGVuZChcImxpbmVcIikuYXR0cihcIngxXCIsIHgpLmF0dHIoXCJ4MlwiLCB4KS5hdHRyKFwieTJcIiwgdGlja1NpemUpXG4gICAgICAgICAgICAuYXR0cihcIm9wYWNpdHlcIiwgZ3JpZExpbmVPcGFjaXR5KS5hdHRyKFwic3Ryb2tlXCIsIFwiY3VycmVudENvbG9yXCIpXG4gICAgfVxuXG4gICAgYXhpcy50cmFuc2l0aW9uKCkuZHVyYXRpb24oQVhJU19BTklNQVRJT05fRFVSQVRJT04pLmRlbGF5KEFYSVNfREVMQVkpLnN0eWxlKFwib3BhY2l0eVwiLCAxKVxuXG4gICAgcmV0dXJuIGF4aXMubm9kZSgpLmdldEJCb3goKS5oZWlnaHQ7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZU92ZXJsYXBwaW5nWVRpY2tzKGF4aXMsIGxhYmVsSGVpZ2h0KSB7XG4gICAgbGV0IGEgPSBheGlzLnNlbGVjdEFsbChcImcudGlja1wiKS5ub2RlcygpXG4gICAgaWYgKCFhLmxlbmd0aCkgcmV0dXJuXG4gICAgbGV0IHB5ID0gYVswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS55IC0gbGFiZWxIZWlnaHRcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IG5vZGUgPSBhW2ldXG4gICAgICAgIGxldCB5ID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS55XG4gICAgICAgIGlmICh5ID4gcHkpIG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKVxuICAgICAgICBlbHNlIHB5ID0geSAtIGxhYmVsSGVpZ2h0IC8vIHRoZXJlIGlzIHNwYWNlIGZvciB0aGUgbGFiZWxcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB5YXhpcyhzZWxlY3Rpb24sIGF4aXMsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gZW5zdXJlT3B0aW9ucyhvcHRpb25zKVxuICAgIGxldCB7IGZvbnRTaXplLCBncmlkTGluZU9wYWNpdHkgfSA9IGVuc3VyZU9wdGlvbnMob3B0aW9ucylcblxuICAgIHNlbGVjdGlvbi5zZWxlY3QoXCIueS1heGlzXCIpLnJlbW92ZSgpO1xuICAgIGxldCB5ID0gc2VsZWN0aW9uLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJ5LWF4aXNcIilcbiAgICAgICAgICAgICAgICAgICAgIC5jYWxsKGF4aXMpXG4gICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDApXG4gICAgeS5zZWxlY3QoXCIuZG9tYWluXCIpLnJlbW92ZSgpIC8vIHRoaXMgZG91YmxlcyB1cCBvbiB0aGUgMCB0aWNrIGxpbmUgbWFraW5nIGl0IGRhcmtlciBzbyBudWtlIGl0XG5cbiAgICBpZiAob3B0aW9ucy5heGlzQm94KSB5LmFwcGVuZChcImxpbmVcIikuYXR0cihcInkyXCIsIGF4aXMuc2NhbGUoKS5yYW5nZSgpWzBdKS5hdHRyKFwic3Ryb2tlXCIsIFwiY3VycmVudENvbG9yXCIpXG5cbiAgICBsZXQgdGlja1NpemUgPSBheGlzLnRpY2tTaXplKClcbiAgICBpZiAodGlja1NpemUgJiYgb3B0aW9ucy5heGlzQm94KSB5LmFwcGVuZChcImxpbmVcIikuYXR0cihcIngyXCIsIC10aWNrU2l6ZSkuYXR0cihcInN0cm9rZVwiLCBcImN1cnJlbnRDb2xvclwiKVxuXG4gICAgaWYgKG9wdGlvbnMuaGlkZVlBeGlzTWluKSB5LnNlbGVjdChcInRleHRcIikucmVtb3ZlKClcblxuICAgIHkuc2VsZWN0QWxsKFwidGV4dFwiKS5zdHlsZShcImZvbnQtc2l6ZVwiLCBmb250U2l6ZSArIFwicHhcIikuc3R5bGUoXCJmaWxsXCIsIGQzLmhjbChjb2xvdXJzLmVpZ2h0ZWVuLmRhcmtHcmV5KS5icmlnaHRlcigpKTtcbiAgICB5LnNlbGVjdEFsbChcInBhdGhcIikuc3R5bGUoXCJvcGFjaXR5XCIsIGdyaWRMaW5lT3BhY2l0eSlcbiAgICB5LnNlbGVjdEFsbChcImxpbmVcIikuc3R5bGUoXCJvcGFjaXR5XCIsIGdyaWRMaW5lT3BhY2l0eSlcblxuICAgIGlmICghYXhpcy5zY2FsZSgpLmJhbmR3aWR0aCkgcmVtb3ZlT3ZlcmxhcHBpbmdZVGlja3MoeSwgZm9udFNpemUgKiAxLjIpXG5cbiAgICB5LnRyYW5zaXRpb24oKVxuICAgICAgICAuZHVyYXRpb24oQVhJU19BTklNQVRJT05fRFVSQVRJT04pXG4gICAgICAgIC5kZWxheShBWElTX0RFTEFZKVxuICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDEpO1xuXG4gICAgcmV0dXJuIHkubm9kZSgpLmdldEJCb3goKS53aWR0aCArIDIwO1xufVxuXG5leHBvcnQgZnVuY3Rpb24geUdyaWQoc2VsZWN0aW9uLCB3aWR0aCwgc2hvdywgYXhpcykge1xuICAgIHNlbGVjdGlvbi5zZWxlY3QoXCIueUdyaWRcIikucmVtb3ZlKCk7XG5cbiAgICBpZiAoIXNob3cpIHJldHVybjtcblxuICAgIGxldCBncmlkID0gc2VsZWN0aW9uLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJ5R3JpZFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNhbGwoYXhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aWNrU2l6ZSgtd2lkdGgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRpY2tGb3JtYXQoXCJcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICBncmlkLnNlbGVjdEFsbChcImxpbmVcIilcbiAgICAgICAgLnN0eWxlKFwic3Ryb2tlXCIsIGNvbG91cnMuZWlnaHRlZW4ubGlnaHRHcmV5KTtcbiAgICBncmlkLnNlbGVjdEFsbChcIi5kb21haW5cIikucmVtb3ZlKCk7XG5cbiAgICBncmlkXG4gICAgICAgIC5sb3dlcigpIC8vIEFsd2F5cyBlbnN1cmUgdGhhdCB0aGlzIGlzIGVhcmxpZXIgaW4gdGhlIGRvbS4gVGhpbmdzIG11c3QgYmUgZHJhd24gb24gdG9wIG9mIGl0LlxuICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDApXG4gICAgICAgIC50cmFuc2l0aW9uKClcbiAgICAgICAgLmRlbGF5KEFYSVNfREVMQVkpXG4gICAgICAgIC5kdXJhdGlvbihBWElTX0FOSU1BVElPTl9EVVJBVElPTilcbiAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAxKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHhHcmlkKHNlbGVjdGlvbiwgaGVpZ2h0LCBzaG93LCBheGlzKSB7XG4gICAgc2VsZWN0aW9uLnNlbGVjdChcIi54R3JpZFwiKS5yZW1vdmUoKTtcblxuICAgIGlmICghc2hvdykgcmV0dXJuO1xuXG4gICAgbGV0IGdyaWQgPSBzZWxlY3Rpb24uYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcInhHcmlkXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAuY2FsbChheGlzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRpY2tTaXplKGhlaWdodClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGlja0Zvcm1hdChcIlwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgIGdyaWQuc2VsZWN0QWxsKFwibGluZVwiKVxuICAgICAgICAuc3R5bGUoXCJzdHJva2VcIiwgY29sb3Vycy5laWdodGVlbi5saWdodEdyZXkpO1xuICAgIGdyaWQuc2VsZWN0QWxsKFwiLmRvbWFpblwiKS5yZW1vdmUoKTtcblxuICAgIGdyaWRcbiAgICAgICAgLmxvd2VyKClcbiAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAwKVxuICAgICAgICAudHJhbnNpdGlvbigpXG4gICAgICAgIC5kZWxheShBWElTX0RFTEFZKVxuICAgICAgICAuZHVyYXRpb24oQVhJU19BTklNQVRJT05fRFVSQVRJT04pXG4gICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB5QXhpc0xhYmVsKGVsZW1lbnQsIGhlaWdodCwgbWFyZ2lucywgbGFiZWwsIG9wdGlvbnMsIHkyeCkge1xuICAgIGxldCB7IGZvbnRTaXplIH0gPSBlbnN1cmVPcHRpb25zKG9wdGlvbnMpXG5cbiAgICBsZXQgY2xzID0geTJ4ID8gXCJ5Mi1heGlzLWxhYmVsXCIgOiBcInktYXhpcy1sYWJlbFwiXG4gICAgZWxlbWVudC5zZWxlY3RBbGwoXCIuXCIgKyBjbHMpLnJlbW92ZSgpO1xuXG4gICAgaWYgKCFsYWJlbCkgcmV0dXJuO1xuICAgIGxldCB0ZXh0ID0gbGFiZWw7XG4gICAgaWYgKHRleHQubG9uZykgdGV4dCA9IHRleHQubG9uZztcblxuICAgIGxldCB4ID0geTJ4IHx8IDIwXG4gICAgbGV0IHkgPSAtKG1hcmdpbnMudG9wICsgaGVpZ2h0IC8gMilcblxuICAgIGxldCBsYWJlbEVsZW1lbnQgPSBlbGVtZW50LmFwcGVuZChcImdcIilcbiAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBjbHMpXG4gICAgICAgIC5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgICAgIC5zdHlsZShcImZvbnQtc2l6ZVwiLCBmb250U2l6ZSArIFwicHhcIilcbiAgICAgICAgLnRleHQodGV4dClcbiAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJyb3RhdGUoLTkwIDAsMCkgdHJhbnNsYXRlKFwiICsgeSArIFwiLFwiICsgeCArIFwiKVwiKVxuICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIGQzLmhjbChjb2xvdXJzLmVpZ2h0ZWVuLmRhcmtHcmV5KS5icmlnaHRlcigpKTtcblxuICAgIGxldCB3aWR0aCA9IGxhYmVsRWxlbWVudC5ub2RlKCkuZ2V0QkJveCgpLndpZHRoO1xuICAgIGlmICh3aWR0aCA+PSBoZWlnaHQgJiYgbGFiZWwuc2hvcnQpIHtcbiAgICAgICAgbGFiZWxFbGVtZW50LnRleHQobGFiZWwuc2hvcnQpO1xuICAgICAgICB3aWR0aCA9IGxhYmVsRWxlbWVudC5ub2RlKCkuZ2V0QkJveCgpLndpZHRoO1xuICAgIH1cblxuICAgIGxhYmVsRWxlbWVudC5hdHRyKFwiZHhcIiwgLXdpZHRoIC8gMilcbiAgICAgICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDApXG4gICAgICAgICAgICAgICAgLnRyYW5zaXRpb24oKVxuICAgICAgICAgICAgICAgIC5kZWxheShBWElTX0RFTEFZKVxuICAgICAgICAgICAgICAgIC5kdXJhdGlvbihBWElTX0FOSU1BVElPTl9EVVJBVElPTilcbiAgICAgICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDEpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB4QXhpc0xhYmVsKGVsZW1lbnQsIHdpZHRoLCBoZWlnaHQsIG1hcmdpbnMsIGxhYmVsLCBvcHRpb25zKSB7XG4gICAgbGV0IHsgZm9udFNpemUgfSA9IGVuc3VyZU9wdGlvbnMob3B0aW9ucylcblxuICAgIGVsZW1lbnQuc2VsZWN0QWxsKFwiLngtYXhpcy1sYWJlbFwiKS5yZW1vdmUoKTtcblxuICAgIGlmICghbGFiZWwpIHJldHVybjtcbiAgICBsZXQgdGV4dCA9IGxhYmVsO1xuICAgIGlmICh0ZXh0LmxvbmcpIHRleHQgPSB0ZXh0Lmxvbmc7XG5cbiAgICBsZXQgeCA9IG1hcmdpbnMubGVmdCArIHdpZHRoIC8gMjtcbiAgICBsZXQgeSA9IG1hcmdpbnMudG9wICsgaGVpZ2h0ICsgNDA7XG5cbiAgICBsZXQgbGFiZWxFbGVtZW50ID0gZWxlbWVudC5hcHBlbmQoXCJnXCIpXG4gICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJ4LWF4aXMtbGFiZWxcIilcbiAgICAgICAgLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgLnN0eWxlKFwiZm9udC1zaXplXCIsIGZvbnRTaXplICsgXCJweFwiKVxuICAgICAgICAudGV4dCh0ZXh0KVxuICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIHggKyBcIiwgXCIgKyB5ICsgXCIpXCIpXG4gICAgICAgIC5zdHlsZShcImZpbGxcIiwgZDMuaGNsKGNvbG91cnMuZWlnaHRlZW4uZGFya0dyZXkpLmJyaWdodGVyKCkpO1xuXG4gICAgbGV0IHRleHRXaWR0aCA9IGxhYmVsRWxlbWVudC5ub2RlKCkuZ2V0QkJveCgpLndpZHRoO1xuICAgIGlmICh0ZXh0V2lkdGggPj0gaGVpZ2h0ICYmIGxhYmVsLnNob3J0KSB7XG4gICAgICAgIGxhYmVsRWxlbWVudC50ZXh0KGxhYmVsLnNob3J0KTtcbiAgICAgICAgdGV4dFdpZHRoID0gbGFiZWxFbGVtZW50Lm5vZGUoKS5nZXRCQm94KCkud2lkdGg7XG4gICAgfVxuXG4gICAgbGFiZWxFbGVtZW50LmF0dHIoXCJkeFwiLCAtdGV4dFdpZHRoIC8gMilcbiAgICAgICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDApXG4gICAgICAgICAgICAgICAgLnRyYW5zaXRpb24oKVxuICAgICAgICAgICAgICAgIC5kZWxheShBWElTX0RFTEFZKVxuICAgICAgICAgICAgICAgIC5kdXJhdGlvbihBWElTX0FOSU1BVElPTl9EVVJBVElPTilcbiAgICAgICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDEpXG59Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/chart/Axes.js\n')},"./src/chart/BarChart.js":
/*!*******************************!*\
  !*** ./src/chart/BarChart.js ***!
  \*******************************/
/*! exports provided: barChart */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "barChart", function() { return barChart; });\n/* harmony import */ var _Geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Geometry */ "./src/chart/Geometry.js");\n/* harmony import */ var _Colours__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Colours */ "./src/Colours.js");\n/* harmony import */ var _Legend__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Legend */ "./src/Legend.js");\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../helpers */ "./src/helpers.js");\n// Copyright (C) 2013-2014, 2018 BrandsEye (PTY) LTD\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this\n// software and associated documentation files (the "Software"), to deal in the Software\n// without restriction, including without limitation the rights to use, copy, modify,\n//     merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following\n// conditions:\n//\n//     The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n//     INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n// CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n\n\n\n\nclass BarHistogram extends _Geometry__WEBPACK_IMPORTED_MODULE_0__["Geometry"] {\n\n    constructor(name, padding) {\n        super(name || "BAR_HISTOGRAM");\n        this._BAR_GROWTH = 100;\n        this._padding = padding || 0;\n    }\n\n    /**\n     * Set the padding between bar groups. 0 padding is a standard histogram.\n     */\n    padding(padding) {\n        if (arguments.length === 0) return this._padding;\n        this._padding = padding;\n        return this;\n    }\n\n    render() {\n        const element = this._element;\n        const data = this.prepareData(null, true);\n        const allData = this.prepareData(null, false);\n        const width = this._width,\n              height = this._height;\n\n        element.classed("histogram", true);\n        element.style("opacity", this._opacity === null ? 1.0 : this._opacity)\n\n        const x = this.getD3XScale(allData, width);\n        const y = this.getD3YScale(data, height);\n        const usingX2 = !!this._x2_getter   // bars extend from d._x to d._x2\n        const yGroup = this.getD3GroupScale(data, y);\n        const colours = this.d3ColourScale();\n\n        // render gradient to match the scale if needed\n        let gradientId\n        if (this._gradient_fn) {\n            element.select("g.gradient").remove()\n            this.gradientId = gradientId = this._gradient_fn(element.append("g").attr("class", "gradient"), x, this)\n        }\n\n        let groups = element.select(".bars").selectAll(\'.group\');\n\n        //----------------------------------------------\n        // Get rid of current labels\n\n        element.select(".chart-labels")\n               .remove();\n\n        //----------------------------------------------\n\n        if (groups.empty()) {\n            groups = element\n                .append("g")\n                .attr("class", "bars")\n                .selectAll(".group");\n        }\n\n        // Ensure that we\'re always using the correct height.\n        element.select(".bars")\n               .attr("transform", "translate(0,0)");\n\n        groups = groups.data(data, d => d._key);\n\n        groups.exit().remove();\n\n        const fillFn = d => gradientId ? "url(#" + gradientId + ")" : this.getD3Colour(d)\n\n        groups.enter()\n              .append("g")\n              .attr("class", "group")\n              .attr("transform", d => "translate(0," + y(d._key) +")")\n              .attr("width", "100%")\n              .attr("height", y.bandwidth())\n              .merge(groups)\n              .interrupt("groups:move")\n              .transition("groups:move")\n              .attr("transform", d => "translate(0," + y(d._key) +")")\n              .attr("height", y.bandwidth())\n              .each((s_d, s_i, nodes) => {\n                  let group = d3.select(nodes[s_i]);\n\n                  let bars = group.selectAll(".bar")\n                                  .data(s_d.data, d => d._y);\n\n                  bars.exit().remove();\n\n                  bars.interrupt("bar:move")     // Animate the bars to their new position.\n                      .transition("bar:move")\n                      .attr("width", d => (Math.abs(x(0) - x(d._x))))\n                      .attr("y", d => yGroup(d._key));\n\n                  bars.enter()\n                      .append("rect")\n                      .attr("y", d => yGroup(d._key))\n                      // .attr("y", d => height - y(Math.min(0, d._y)))\n                      .attr("x", x(0))\n                      .attr("width", 0)\n                      .attr("height", yGroup.bandwidth())\n                      .style("cursor", "pointer")\n                      .on("contextmenu", () => d3.event.preventDefault()) // No right click.\n                      .merge(bars)\n                      .style("fill", fillFn)\n                      .style("stroke", d => d3.hcl(this.getD3Colour(d)).darker())\n                      .style("stroke-width", this.strokeWidth())\n                      .attr("class", d => "bar series series-" + Object(_Legend__WEBPACK_IMPORTED_MODULE_2__["toColourKey"])(d._colour))\n                      .on("click auxclick", (d, i, nodes) => {\n                          this._dispatch.call("elementClick", this, {\n                              e: d3.event,\n                              point: d,\n                              series: d._series,\n                              seriesIndex: s_i,\n                              value: d._y\n                          })\n                      })\n                      .on("mouseover", (d, i, nodes) => { // Darken the bar on mouse over\n                          let sel = d3.select(nodes[i])\n                            .interrupt("hover:colour")\n                            .transition("hover:colour")\n                            .duration(150)\n                          if (gradientId) sel.style("opacity", "0.5")\n                          else sel.style("fill", d3.hcl(this.getD3Colour(d)).darker())\n                          this._dispatch.call("tooltipShow", this, {\n                              e: d3.event,\n                              point: d,\n                              series: s_d,\n                              seriesIndex: s_i,\n                              value: d._y\n                          })\n                      })\n                      .on("mouseout", (d, i, nodes) => { // bar is regular colour on mouse out.\n                          let sel = d3.select(nodes[i])\n                              .interrupt("hover:colour")\n                              .transition("hover:colour")\n                              .duration(100)\n                          if (gradientId) sel.style("opacity", "1.0")\n                          else sel.style("fill", d => this.getD3Colour(d))\n                          this._dispatch.call("tooltipHide", this);\n                      })\n                      .interrupt("bar:growth")    // Animate bars growing.\n                      .transition("bar:growth")\n                      .delay(() => this.calcBarGrowth(s_i, nodes.length))\n                      .style("fill", fillFn)\n                      .style("stroke", d => d3.hcl(this.getD3Colour(d)).darker())\n                      .attr("x", d => x(Math.min(0, d._x)))\n                      .attr("height", yGroup.bandwidth())\n                      .attr("width", d => Math.abs((usingX2 ? x(d._x2) : x(0)) - x(d._x)));\n              });\n\n        // Labels loaded after our last bar grows.\n        if (this.showLabels()) {\n            element.transition("bar:growth")\n                   .on("end", (d, i, nodes) => {\n                       if (i < nodes.length - 1) return;\n                       this.renderLabels(element, data, x, yGroup, y, colours);\n                   })\n        }\n    }\n\n    calcBarGrowth(i, max) {\n        if (max < 10) return i * this._BAR_GROWTH / 2;\n        if (max < 35) return i * this._BAR_GROWTH / 4;\n        return 1;\n    }\n\n    prepareData(data, faceted) {\n        data = _Geometry__WEBPACK_IMPORTED_MODULE_0__["Geometry"].prototype.prepareData.call(this, data, faceted);\n\n        const sortOrder = {};\n        this.yValues().forEach((d, i) => {\n            sortOrder[d] = sortOrder[d] || ("" + i);\n        });\n\n        let results = {};\n\n        // We want to calculate what bucket each bit of data belongs to.\n        const buckets = this.scaleY()\n                            .buckets(Object\n                                .values(data)\n                                .map(d => d.data)\n                                .reduce((acc, cur) => acc.concat(cur))\n                                .map(d => d._y));\n\n        // Sort data in to their appropriate buckets. This may be\n        // specific date buckets, or general buckets for continuous data.\n        Object.keys(data).forEach(key => {\n            let values = data[key].data;\n            values.forEach(d => {\n                d._bucket = buckets.bucket(d._y);\n                let bucket = results[d._bucket] || { _key: d._bucket, data: [] };\n                bucket.data.push(d);\n                results[d._bucket] = bucket;\n            })\n        });\n\n        return buckets.consolidateBuckets(Object.values(results))\n                      .sort((lhs, rhs) => {\n                          return sortOrder["" + lhs._key] - sortOrder["" + rhs._key];\n                      });\n    }\n\n    getKeys(data) {\n        if (!data || !data.length) return [];\n\n        let keys = new Set();\n\n        // todo calculate buckets\n        Object.keys(data).forEach(key => {\n            let values = data[key].data;\n            values.forEach(d => keys.add(d._key))\n        });\n\n\n        return [...keys]\n    }\n\n    getD3XScale(data, width) {\n        data = (data || this.prepareData(null, false)).map(d => d.data).reduce((acc, val) => acc.concat(val));\n        width = width || this.width();\n\n        let extent = d3.extent(data, d => d._x)\n        if (this._x2_getter) {\n            let e2 = d3.extent(data, d => d._x2)\n            extent[0] = Math.min(extent[0], e2[0])\n            extent[1] = Math.max(extent[1], e2[1])\n        }\n\n        const max = Math.max(extent[1], this._axis_max_value || 0)\n        const min = Math.min(this._axis_min_value || 0, extent[0])\n        return d3.scaleLinear().rangeRound([0, width]).nice().domain([min, max])\n    }\n\n    getD3YScale(data, height) {\n        data = data || this.prepareData(null, true);\n        height = height || this.height();\n\n        return d3.scaleBand()\n                 .rangeRound([0, height])\n                 .padding((data[0].data.length > 1 ? 0.2 : 0) + this._padding)\n                 .domain(data.map(d => d._key));\n    }\n\n    getD3GroupScale(data, yscale) {\n        return d3.scaleBand()\n                 .padding(0)\n                 .domain(this.getKeys(data))\n                 .rangeRound([0, yscale.bandwidth()]);\n    }\n\n    renderLabels(selection, data, xscale, yGroup, yscale, colourScale, animate) {\n        animate = animate === undefined ? true : animate;\n        selection.selectAll(".chart-labels").remove();\n\n        let labels = selection.append("g")\n                              .attr("class", "chart-labels")\n                              .selectAll(".label-group")\n                              .data(data);\n\n        let maxHeight = 0;    // For calculating the max height of text.\n        let maxWidth = 0;     // For calculating the max width of the text.\n        let fontSize = this._font_size;    // Our initial font size.\n        const buffer = 5;     // Buffer space between words and the top of a bar.\n\n        // Want to figure out if the label is too dark / light for the\n        // bar.\n        const getInvertedColor = d => {\n            let invertedColor = d3.hcl(this.getD3Colour(d));\n            invertedColor.l += Math.min(invertedColor.l + 50, 100);\n            return invertedColor;\n        };\n        const shouldInvert = d => d3.hcl(this.getD3Colour(d)).l < 60;\n        const fillColour = d3.hcl(_Colours__WEBPACK_IMPORTED_MODULE_1__["colours"].eighteen.darkGrey).brighter();\n        const lighterFillColour = d3.hcl(_Colours__WEBPACK_IMPORTED_MODULE_1__["colours"].eighteen.midGrey);\n        const findColour = (d, onBar, labelText) => {\n            return onBar && shouldInvert(d)\n                ? getInvertedColor(d).toString()\n                : (Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["labelIsZero"])(labelText)\n                    ? lighterFillColour\n                    : (onBar ? d3.hcl(fillColour).darker() : fillColour));\n        };\n\n        labels.enter().each((series, s_i, s_nodes) => {\n            // We want to determine which groups may have missing values, and provide them.\n            const requiredGroups = {};\n            yGroup.domain().map(_Geometry__WEBPACK_IMPORTED_MODULE_0__["fromKey"]).forEach(d => {\n                requiredGroups[d._colour] = d;\n            });\n\n            series.data.forEach(d => {\n                delete requiredGroups[d._colour]\n            });\n\n            const missingGroups = Object.values(requiredGroups);\n            missingGroups.forEach(d => {\n                d._x = series._key;\n                d._y = 0;\n            });\n\n            d3.select(s_nodes[s_i])\n              .append("g")\n              .attr("class", "label-group")\n              .attr("transform", d => "translate(0," + yscale(d._key) + ")")\n              .selectAll(".chart-label")\n              .data(series.data.concat(Object.values(missingGroups)))\n              .enter()\n              .each((d, i, nodes) => {\n                  const labelText = this.formatLabel()(d._x, d);\n                  let ypos = yGroup(d._key) + yGroup.bandwidth() / 2;\n                  let xpos = xscale(d._x);\n                  let text = d3.select(nodes[i])\n                        .append("text")\n                        .style("font-size", fontSize + "px")\n                        .text(labelText)\n                        .attr("class", d => "chart-label series series-" + Object(_Legend__WEBPACK_IMPORTED_MODULE_2__["toColourKey"])(d._colour))\n                        .attr("dx", (animate ? -15 : 0))\n                        .style("opacity", 0)\n                        .style("pointer-events", "none");\n\n                  // Set the x position, which is based on width.\n                  const bb = text.node().getBBox();\n                  const height = bb.height;\n                  const width = bb.width;\n\n                  let effectiveBuffer = buffer;\n                  if (xpos + width >= this._width) {\n                      xpos = Math.max(0, xpos - width);\n                      effectiveBuffer = -buffer;\n                  }\n\n                  maxHeight = Math.max(height, maxHeight);\n                  text\n                      .attr("y", ypos + height / 3) // use a third of the height rather than half because it looks better.\n                      .attr("x", xpos)\n                      .style("fill", d => findColour(d, effectiveBuffer < 0, labelText));\n\n                  text\n                      .transition("labels")\n                      .delay(() => animate ? this.calcBarGrowth(s_i, s_nodes.length) : 0) // Delay in lockstep with bar growth.\n                      .attr("dx", effectiveBuffer)\n                      .style("opacity", 1)\n              });\n\n            if (maxWidth > xscale.range()[1]) {\n                selection.selectAll(".chart-labels").remove();\n            }\n        });\n\n\n        // Figure out if we don\'t have enough space to show our labels.\n        // We then want to resize, if possible.\n        if (yGroup.bandwidth() < maxHeight * 1.10) {\n            let scale = maxHeight / yGroup.bandwidth() * 1.10;\n            fontSize = Math.floor(fontSize / scale);\n\n            if (fontSize < 8) {\n                // The labels are too small.\n                labels.enter().selectAll("text").remove();\n            } else {\n                labels.enter()\n                      .merge(labels)\n                      .selectAll("text")\n                      .style("font-size", fontSize + "px")\n                      .each((d, i, nodes) => {\n                          const text = d3.select(nodes[i]);\n                          const width = text.node().getBBox().width;\n\n                          let xpos = xscale(d._x);\n                          let effectiveBuffer = buffer;\n                          if (xpos + width >= this._width) {\n                              xpos = Math.max(0, xpos - width);\n                              effectiveBuffer = -buffer;\n                          }\n\n                          text\n                              .attr("x", xpos)\n                              .style("fill", d => findColour(d, effectiveBuffer < 0, text.text())) // todo\n                              .attr("dx", effectiveBuffer); // todo\n                      })\n            }\n        }\n    }\n\n\n    immediatelyRenderLabels(show) {\n        const element = this.element();\n        if (!element) return;\n\n        if (!show) { // Hides the labels\n            element\n                .select(\'.chart-labels\')\n                .interrupt("labels")\n                .interrupt("labels:fade")\n                .transition("labels:fade")\n                .style("opacity", 0)\n                .on("end", (d, i, nodes) => {\n                    d3.select(nodes[i]).remove();\n                })\n        } else {\n            let labels = element.select(\'.chart-labels\');\n            if (!labels.empty()) return;\n\n            const data = this.prepareData(null, true);\n            const allData = this.prepareData(null, false);\n\n            const yscale = this.getD3YScale(data),\n                  xscale = this.getD3XScale(data),\n                  xgroup = this.getD3GroupScale(data, yscale),\n                  colourScale = this.d3ColourScale();\n\n            labels.remove();\n            this.renderLabels(element, data, xscale, xgroup, yscale, colourScale, false);\n        }\n\n    }\n\n\n}\n\n\nfunction barChart() {\n    return new BarHistogram("BAR_CHART", 0.1);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY2hhcnQvQmFyQ2hhcnQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9iM2pzLy4vc3JjL2NoYXJ0L0JhckNoYXJ0LmpzPzM3MDMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChDKSAyMDEzLTIwMTQsIDIwMTggQnJhbmRzRXllIChQVFkpIExURFxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpc1xuLy8gc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlXG4vLyB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksXG4vLyAgICAgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0b1xuLy8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcbi8vIGNvbmRpdGlvbnM6XG4vL1xuLy8gICAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuLy8gY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyAgICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUiBJTVBMSUVELFxuLy8gICAgIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBXG4vLyBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUXG4vLyBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0Zcbi8vIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRVxuLy8gT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCB7IEdlb21ldHJ5LCBmcm9tS2V5IH0gZnJvbSAnLi9HZW9tZXRyeSc7XG5pbXBvcnQgeyBjb2xvdXJzIH0gZnJvbSBcIi4uL0NvbG91cnNcIjtcbmltcG9ydCB7IHRvQ29sb3VyS2V5IH0gZnJvbSBcIi4uL0xlZ2VuZFwiO1xuaW1wb3J0IHsgbGFiZWxJc1plcm8gfSBmcm9tIFwiLi4vaGVscGVyc1wiO1xuXG5cbmNsYXNzIEJhckhpc3RvZ3JhbSBleHRlbmRzIEdlb21ldHJ5IHtcblxuICAgIGNvbnN0cnVjdG9yKG5hbWUsIHBhZGRpbmcpIHtcbiAgICAgICAgc3VwZXIobmFtZSB8fCBcIkJBUl9ISVNUT0dSQU1cIik7XG4gICAgICAgIHRoaXMuX0JBUl9HUk9XVEggPSAxMDA7XG4gICAgICAgIHRoaXMuX3BhZGRpbmcgPSBwYWRkaW5nIHx8IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBwYWRkaW5nIGJldHdlZW4gYmFyIGdyb3Vwcy4gMCBwYWRkaW5nIGlzIGEgc3RhbmRhcmQgaGlzdG9ncmFtLlxuICAgICAqL1xuICAgIHBhZGRpbmcocGFkZGluZykge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX3BhZGRpbmc7XG4gICAgICAgIHRoaXMuX3BhZGRpbmcgPSBwYWRkaW5nO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLl9lbGVtZW50O1xuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5wcmVwYXJlRGF0YShudWxsLCB0cnVlKTtcbiAgICAgICAgY29uc3QgYWxsRGF0YSA9IHRoaXMucHJlcGFyZURhdGEobnVsbCwgZmFsc2UpO1xuICAgICAgICBjb25zdCB3aWR0aCA9IHRoaXMuX3dpZHRoLFxuICAgICAgICAgICAgICBoZWlnaHQgPSB0aGlzLl9oZWlnaHQ7XG5cbiAgICAgICAgZWxlbWVudC5jbGFzc2VkKFwiaGlzdG9ncmFtXCIsIHRydWUpO1xuICAgICAgICBlbGVtZW50LnN0eWxlKFwib3BhY2l0eVwiLCB0aGlzLl9vcGFjaXR5ID09PSBudWxsID8gMS4wIDogdGhpcy5fb3BhY2l0eSlcblxuICAgICAgICBjb25zdCB4ID0gdGhpcy5nZXREM1hTY2FsZShhbGxEYXRhLCB3aWR0aCk7XG4gICAgICAgIGNvbnN0IHkgPSB0aGlzLmdldEQzWVNjYWxlKGRhdGEsIGhlaWdodCk7XG4gICAgICAgIGNvbnN0IHVzaW5nWDIgPSAhIXRoaXMuX3gyX2dldHRlciAgIC8vIGJhcnMgZXh0ZW5kIGZyb20gZC5feCB0byBkLl94MlxuICAgICAgICBjb25zdCB5R3JvdXAgPSB0aGlzLmdldEQzR3JvdXBTY2FsZShkYXRhLCB5KTtcbiAgICAgICAgY29uc3QgY29sb3VycyA9IHRoaXMuZDNDb2xvdXJTY2FsZSgpO1xuXG4gICAgICAgIC8vIHJlbmRlciBncmFkaWVudCB0byBtYXRjaCB0aGUgc2NhbGUgaWYgbmVlZGVkXG4gICAgICAgIGxldCBncmFkaWVudElkXG4gICAgICAgIGlmICh0aGlzLl9ncmFkaWVudF9mbikge1xuICAgICAgICAgICAgZWxlbWVudC5zZWxlY3QoXCJnLmdyYWRpZW50XCIpLnJlbW92ZSgpXG4gICAgICAgICAgICB0aGlzLmdyYWRpZW50SWQgPSBncmFkaWVudElkID0gdGhpcy5fZ3JhZGllbnRfZm4oZWxlbWVudC5hcHBlbmQoXCJnXCIpLmF0dHIoXCJjbGFzc1wiLCBcImdyYWRpZW50XCIpLCB4LCB0aGlzKVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGdyb3VwcyA9IGVsZW1lbnQuc2VsZWN0KFwiLmJhcnNcIikuc2VsZWN0QWxsKCcuZ3JvdXAnKTtcblxuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gR2V0IHJpZCBvZiBjdXJyZW50IGxhYmVsc1xuXG4gICAgICAgIGVsZW1lbnQuc2VsZWN0KFwiLmNoYXJ0LWxhYmVsc1wiKVxuICAgICAgICAgICAgICAgLnJlbW92ZSgpO1xuXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgIGlmIChncm91cHMuZW1wdHkoKSkge1xuICAgICAgICAgICAgZ3JvdXBzID0gZWxlbWVudFxuICAgICAgICAgICAgICAgIC5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImJhcnNcIilcbiAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKFwiLmdyb3VwXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRW5zdXJlIHRoYXQgd2UncmUgYWx3YXlzIHVzaW5nIHRoZSBjb3JyZWN0IGhlaWdodC5cbiAgICAgICAgZWxlbWVudC5zZWxlY3QoXCIuYmFyc1wiKVxuICAgICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoMCwwKVwiKTtcblxuICAgICAgICBncm91cHMgPSBncm91cHMuZGF0YShkYXRhLCBkID0+IGQuX2tleSk7XG5cbiAgICAgICAgZ3JvdXBzLmV4aXQoKS5yZW1vdmUoKTtcblxuICAgICAgICBjb25zdCBmaWxsRm4gPSBkID0+IGdyYWRpZW50SWQgPyBcInVybCgjXCIgKyBncmFkaWVudElkICsgXCIpXCIgOiB0aGlzLmdldEQzQ29sb3VyKGQpXG5cbiAgICAgICAgZ3JvdXBzLmVudGVyKClcbiAgICAgICAgICAgICAgLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImdyb3VwXCIpXG4gICAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIGQgPT4gXCJ0cmFuc2xhdGUoMCxcIiArIHkoZC5fa2V5KSArXCIpXCIpXG4gICAgICAgICAgICAgIC5hdHRyKFwid2lkdGhcIiwgXCIxMDAlXCIpXG4gICAgICAgICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIHkuYmFuZHdpZHRoKCkpXG4gICAgICAgICAgICAgIC5tZXJnZShncm91cHMpXG4gICAgICAgICAgICAgIC5pbnRlcnJ1cHQoXCJncm91cHM6bW92ZVwiKVxuICAgICAgICAgICAgICAudHJhbnNpdGlvbihcImdyb3Vwczptb3ZlXCIpXG4gICAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIGQgPT4gXCJ0cmFuc2xhdGUoMCxcIiArIHkoZC5fa2V5KSArXCIpXCIpXG4gICAgICAgICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIHkuYmFuZHdpZHRoKCkpXG4gICAgICAgICAgICAgIC5lYWNoKChzX2QsIHNfaSwgbm9kZXMpID0+IHtcbiAgICAgICAgICAgICAgICAgIGxldCBncm91cCA9IGQzLnNlbGVjdChub2Rlc1tzX2ldKTtcblxuICAgICAgICAgICAgICAgICAgbGV0IGJhcnMgPSBncm91cC5zZWxlY3RBbGwoXCIuYmFyXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmRhdGEoc19kLmRhdGEsIGQgPT4gZC5feSk7XG5cbiAgICAgICAgICAgICAgICAgIGJhcnMuZXhpdCgpLnJlbW92ZSgpO1xuXG4gICAgICAgICAgICAgICAgICBiYXJzLmludGVycnVwdChcImJhcjptb3ZlXCIpICAgICAvLyBBbmltYXRlIHRoZSBiYXJzIHRvIHRoZWlyIG5ldyBwb3NpdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgICAudHJhbnNpdGlvbihcImJhcjptb3ZlXCIpXG4gICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCBkID0+IChNYXRoLmFicyh4KDApIC0geChkLl94KSkpKVxuICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwieVwiLCBkID0+IHlHcm91cChkLl9rZXkpKTtcblxuICAgICAgICAgICAgICAgICAgYmFycy5lbnRlcigpXG4gICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZChcInJlY3RcIilcbiAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcInlcIiwgZCA9PiB5R3JvdXAoZC5fa2V5KSlcbiAgICAgICAgICAgICAgICAgICAgICAvLyAuYXR0cihcInlcIiwgZCA9PiBoZWlnaHQgLSB5KE1hdGgubWluKDAsIGQuX3kpKSlcbiAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcInhcIiwgeCgwKSlcbiAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcIndpZHRoXCIsIDApXG4gICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgeUdyb3VwLmJhbmR3aWR0aCgpKVxuICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcImN1cnNvclwiLCBcInBvaW50ZXJcIilcbiAgICAgICAgICAgICAgICAgICAgICAub24oXCJjb250ZXh0bWVudVwiLCAoKSA9PiBkMy5ldmVudC5wcmV2ZW50RGVmYXVsdCgpKSAvLyBObyByaWdodCBjbGljay5cbiAgICAgICAgICAgICAgICAgICAgICAubWVyZ2UoYmFycylcbiAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIGZpbGxGbilcbiAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJzdHJva2VcIiwgZCA9PiBkMy5oY2wodGhpcy5nZXREM0NvbG91cihkKSkuZGFya2VyKCkpXG4gICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwic3Ryb2tlLXdpZHRoXCIsIHRoaXMuc3Ryb2tlV2lkdGgoKSlcbiAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIGQgPT4gXCJiYXIgc2VyaWVzIHNlcmllcy1cIiArIHRvQ29sb3VyS2V5KGQuX2NvbG91cikpXG4gICAgICAgICAgICAgICAgICAgICAgLm9uKFwiY2xpY2sgYXV4Y2xpY2tcIiwgKGQsIGksIG5vZGVzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3BhdGNoLmNhbGwoXCJlbGVtZW50Q2xpY2tcIiwgdGhpcywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZTogZDMuZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludDogZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllczogZC5fc2VyaWVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzSW5kZXg6IHNfaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBkLl95XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAub24oXCJtb3VzZW92ZXJcIiwgKGQsIGksIG5vZGVzKSA9PiB7IC8vIERhcmtlbiB0aGUgYmFyIG9uIG1vdXNlIG92ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHNlbCA9IGQzLnNlbGVjdChub2Rlc1tpXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuaW50ZXJydXB0KFwiaG92ZXI6Y29sb3VyXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRyYW5zaXRpb24oXCJob3Zlcjpjb2xvdXJcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24oMTUwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ3JhZGllbnRJZCkgc2VsLnN0eWxlKFwib3BhY2l0eVwiLCBcIjAuNVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHNlbC5zdHlsZShcImZpbGxcIiwgZDMuaGNsKHRoaXMuZ2V0RDNDb2xvdXIoZCkpLmRhcmtlcigpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXNwYXRjaC5jYWxsKFwidG9vbHRpcFNob3dcIiwgdGhpcywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZTogZDMuZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludDogZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllczogc19kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzSW5kZXg6IHNfaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBkLl95XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAub24oXCJtb3VzZW91dFwiLCAoZCwgaSwgbm9kZXMpID0+IHsgLy8gYmFyIGlzIHJlZ3VsYXIgY29sb3VyIG9uIG1vdXNlIG91dC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHNlbCA9IGQzLnNlbGVjdChub2Rlc1tpXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5pbnRlcnJ1cHQoXCJob3Zlcjpjb2xvdXJcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKFwiaG92ZXI6Y29sb3VyXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24oMTAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ3JhZGllbnRJZCkgc2VsLnN0eWxlKFwib3BhY2l0eVwiLCBcIjEuMFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHNlbC5zdHlsZShcImZpbGxcIiwgZCA9PiB0aGlzLmdldEQzQ29sb3VyKGQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXNwYXRjaC5jYWxsKFwidG9vbHRpcEhpZGVcIiwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAuaW50ZXJydXB0KFwiYmFyOmdyb3d0aFwiKSAgICAvLyBBbmltYXRlIGJhcnMgZ3Jvd2luZy5cbiAgICAgICAgICAgICAgICAgICAgICAudHJhbnNpdGlvbihcImJhcjpncm93dGhcIilcbiAgICAgICAgICAgICAgICAgICAgICAuZGVsYXkoKCkgPT4gdGhpcy5jYWxjQmFyR3Jvd3RoKHNfaSwgbm9kZXMubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIGZpbGxGbilcbiAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJzdHJva2VcIiwgZCA9PiBkMy5oY2wodGhpcy5nZXREM0NvbG91cihkKSkuZGFya2VyKCkpXG4gICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIGQgPT4geChNYXRoLm1pbigwLCBkLl94KSkpXG4gICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgeUdyb3VwLmJhbmR3aWR0aCgpKVxuICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwid2lkdGhcIiwgZCA9PiBNYXRoLmFicygodXNpbmdYMiA/IHgoZC5feDIpIDogeCgwKSkgLSB4KGQuX3gpKSk7XG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIC8vIExhYmVscyBsb2FkZWQgYWZ0ZXIgb3VyIGxhc3QgYmFyIGdyb3dzLlxuICAgICAgICBpZiAodGhpcy5zaG93TGFiZWxzKCkpIHtcbiAgICAgICAgICAgIGVsZW1lbnQudHJhbnNpdGlvbihcImJhcjpncm93dGhcIilcbiAgICAgICAgICAgICAgICAgICAub24oXCJlbmRcIiwgKGQsIGksIG5vZGVzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgIGlmIChpIDwgbm9kZXMubGVuZ3RoIC0gMSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckxhYmVscyhlbGVtZW50LCBkYXRhLCB4LCB5R3JvdXAsIHksIGNvbG91cnMpO1xuICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjYWxjQmFyR3Jvd3RoKGksIG1heCkge1xuICAgICAgICBpZiAobWF4IDwgMTApIHJldHVybiBpICogdGhpcy5fQkFSX0dST1dUSCAvIDI7XG4gICAgICAgIGlmIChtYXggPCAzNSkgcmV0dXJuIGkgKiB0aGlzLl9CQVJfR1JPV1RIIC8gNDtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuXG4gICAgcHJlcGFyZURhdGEoZGF0YSwgZmFjZXRlZCkge1xuICAgICAgICBkYXRhID0gR2VvbWV0cnkucHJvdG90eXBlLnByZXBhcmVEYXRhLmNhbGwodGhpcywgZGF0YSwgZmFjZXRlZCk7XG5cbiAgICAgICAgY29uc3Qgc29ydE9yZGVyID0ge307XG4gICAgICAgIHRoaXMueVZhbHVlcygpLmZvckVhY2goKGQsIGkpID0+IHtcbiAgICAgICAgICAgIHNvcnRPcmRlcltkXSA9IHNvcnRPcmRlcltkXSB8fCAoXCJcIiArIGkpO1xuICAgICAgICB9KTtcblxuICAgICAgICBsZXQgcmVzdWx0cyA9IHt9O1xuXG4gICAgICAgIC8vIFdlIHdhbnQgdG8gY2FsY3VsYXRlIHdoYXQgYnVja2V0IGVhY2ggYml0IG9mIGRhdGEgYmVsb25ncyB0by5cbiAgICAgICAgY29uc3QgYnVja2V0cyA9IHRoaXMuc2NhbGVZKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYnVja2V0cyhPYmplY3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnZhbHVlcyhkYXRhKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKGQgPT4gZC5kYXRhKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVkdWNlKChhY2MsIGN1cikgPT4gYWNjLmNvbmNhdChjdXIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKGQgPT4gZC5feSkpO1xuXG4gICAgICAgIC8vIFNvcnQgZGF0YSBpbiB0byB0aGVpciBhcHByb3ByaWF0ZSBidWNrZXRzLiBUaGlzIG1heSBiZVxuICAgICAgICAvLyBzcGVjaWZpYyBkYXRlIGJ1Y2tldHMsIG9yIGdlbmVyYWwgYnVja2V0cyBmb3IgY29udGludW91cyBkYXRhLlxuICAgICAgICBPYmplY3Qua2V5cyhkYXRhKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWVzID0gZGF0YVtrZXldLmRhdGE7XG4gICAgICAgICAgICB2YWx1ZXMuZm9yRWFjaChkID0+IHtcbiAgICAgICAgICAgICAgICBkLl9idWNrZXQgPSBidWNrZXRzLmJ1Y2tldChkLl95KTtcbiAgICAgICAgICAgICAgICBsZXQgYnVja2V0ID0gcmVzdWx0c1tkLl9idWNrZXRdIHx8IHsgX2tleTogZC5fYnVja2V0LCBkYXRhOiBbXSB9O1xuICAgICAgICAgICAgICAgIGJ1Y2tldC5kYXRhLnB1c2goZCk7XG4gICAgICAgICAgICAgICAgcmVzdWx0c1tkLl9idWNrZXRdID0gYnVja2V0O1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGJ1Y2tldHMuY29uc29saWRhdGVCdWNrZXRzKE9iamVjdC52YWx1ZXMocmVzdWx0cykpXG4gICAgICAgICAgICAgICAgICAgICAgLnNvcnQoKGxocywgcmhzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzb3J0T3JkZXJbXCJcIiArIGxocy5fa2V5XSAtIHNvcnRPcmRlcltcIlwiICsgcmhzLl9rZXldO1xuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgIH1cblxuICAgIGdldEtleXMoZGF0YSkge1xuICAgICAgICBpZiAoIWRhdGEgfHwgIWRhdGEubGVuZ3RoKSByZXR1cm4gW107XG5cbiAgICAgICAgbGV0IGtleXMgPSBuZXcgU2V0KCk7XG5cbiAgICAgICAgLy8gdG9kbyBjYWxjdWxhdGUgYnVja2V0c1xuICAgICAgICBPYmplY3Qua2V5cyhkYXRhKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWVzID0gZGF0YVtrZXldLmRhdGE7XG4gICAgICAgICAgICB2YWx1ZXMuZm9yRWFjaChkID0+IGtleXMuYWRkKGQuX2tleSkpXG4gICAgICAgIH0pO1xuXG5cbiAgICAgICAgcmV0dXJuIFsuLi5rZXlzXVxuICAgIH1cblxuICAgIGdldEQzWFNjYWxlKGRhdGEsIHdpZHRoKSB7XG4gICAgICAgIGRhdGEgPSAoZGF0YSB8fCB0aGlzLnByZXBhcmVEYXRhKG51bGwsIGZhbHNlKSkubWFwKGQgPT4gZC5kYXRhKS5yZWR1Y2UoKGFjYywgdmFsKSA9PiBhY2MuY29uY2F0KHZhbCkpO1xuICAgICAgICB3aWR0aCA9IHdpZHRoIHx8IHRoaXMud2lkdGgoKTtcblxuICAgICAgICBsZXQgZXh0ZW50ID0gZDMuZXh0ZW50KGRhdGEsIGQgPT4gZC5feClcbiAgICAgICAgaWYgKHRoaXMuX3gyX2dldHRlcikge1xuICAgICAgICAgICAgbGV0IGUyID0gZDMuZXh0ZW50KGRhdGEsIGQgPT4gZC5feDIpXG4gICAgICAgICAgICBleHRlbnRbMF0gPSBNYXRoLm1pbihleHRlbnRbMF0sIGUyWzBdKVxuICAgICAgICAgICAgZXh0ZW50WzFdID0gTWF0aC5tYXgoZXh0ZW50WzFdLCBlMlsxXSlcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG1heCA9IE1hdGgubWF4KGV4dGVudFsxXSwgdGhpcy5fYXhpc19tYXhfdmFsdWUgfHwgMClcbiAgICAgICAgY29uc3QgbWluID0gTWF0aC5taW4odGhpcy5fYXhpc19taW5fdmFsdWUgfHwgMCwgZXh0ZW50WzBdKVxuICAgICAgICByZXR1cm4gZDMuc2NhbGVMaW5lYXIoKS5yYW5nZVJvdW5kKFswLCB3aWR0aF0pLm5pY2UoKS5kb21haW4oW21pbiwgbWF4XSlcbiAgICB9XG5cbiAgICBnZXREM1lTY2FsZShkYXRhLCBoZWlnaHQpIHtcbiAgICAgICAgZGF0YSA9IGRhdGEgfHwgdGhpcy5wcmVwYXJlRGF0YShudWxsLCB0cnVlKTtcbiAgICAgICAgaGVpZ2h0ID0gaGVpZ2h0IHx8IHRoaXMuaGVpZ2h0KCk7XG5cbiAgICAgICAgcmV0dXJuIGQzLnNjYWxlQmFuZCgpXG4gICAgICAgICAgICAgICAgIC5yYW5nZVJvdW5kKFswLCBoZWlnaHRdKVxuICAgICAgICAgICAgICAgICAucGFkZGluZygoZGF0YVswXS5kYXRhLmxlbmd0aCA+IDEgPyAwLjIgOiAwKSArIHRoaXMuX3BhZGRpbmcpXG4gICAgICAgICAgICAgICAgIC5kb21haW4oZGF0YS5tYXAoZCA9PiBkLl9rZXkpKTtcbiAgICB9XG5cbiAgICBnZXREM0dyb3VwU2NhbGUoZGF0YSwgeXNjYWxlKSB7XG4gICAgICAgIHJldHVybiBkMy5zY2FsZUJhbmQoKVxuICAgICAgICAgICAgICAgICAucGFkZGluZygwKVxuICAgICAgICAgICAgICAgICAuZG9tYWluKHRoaXMuZ2V0S2V5cyhkYXRhKSlcbiAgICAgICAgICAgICAgICAgLnJhbmdlUm91bmQoWzAsIHlzY2FsZS5iYW5kd2lkdGgoKV0pO1xuICAgIH1cblxuICAgIHJlbmRlckxhYmVscyhzZWxlY3Rpb24sIGRhdGEsIHhzY2FsZSwgeUdyb3VwLCB5c2NhbGUsIGNvbG91clNjYWxlLCBhbmltYXRlKSB7XG4gICAgICAgIGFuaW1hdGUgPSBhbmltYXRlID09PSB1bmRlZmluZWQgPyB0cnVlIDogYW5pbWF0ZTtcbiAgICAgICAgc2VsZWN0aW9uLnNlbGVjdEFsbChcIi5jaGFydC1sYWJlbHNcIikucmVtb3ZlKCk7XG5cbiAgICAgICAgbGV0IGxhYmVscyA9IHNlbGVjdGlvbi5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwiY2hhcnQtbGFiZWxzXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKFwiLmxhYmVsLWdyb3VwXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZGF0YShkYXRhKTtcblxuICAgICAgICBsZXQgbWF4SGVpZ2h0ID0gMDsgICAgLy8gRm9yIGNhbGN1bGF0aW5nIHRoZSBtYXggaGVpZ2h0IG9mIHRleHQuXG4gICAgICAgIGxldCBtYXhXaWR0aCA9IDA7ICAgICAvLyBGb3IgY2FsY3VsYXRpbmcgdGhlIG1heCB3aWR0aCBvZiB0aGUgdGV4dC5cbiAgICAgICAgbGV0IGZvbnRTaXplID0gdGhpcy5fZm9udF9zaXplOyAgICAvLyBPdXIgaW5pdGlhbCBmb250IHNpemUuXG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IDU7ICAgICAvLyBCdWZmZXIgc3BhY2UgYmV0d2VlbiB3b3JkcyBhbmQgdGhlIHRvcCBvZiBhIGJhci5cblxuICAgICAgICAvLyBXYW50IHRvIGZpZ3VyZSBvdXQgaWYgdGhlIGxhYmVsIGlzIHRvbyBkYXJrIC8gbGlnaHQgZm9yIHRoZVxuICAgICAgICAvLyBiYXIuXG4gICAgICAgIGNvbnN0IGdldEludmVydGVkQ29sb3IgPSBkID0+IHtcbiAgICAgICAgICAgIGxldCBpbnZlcnRlZENvbG9yID0gZDMuaGNsKHRoaXMuZ2V0RDNDb2xvdXIoZCkpO1xuICAgICAgICAgICAgaW52ZXJ0ZWRDb2xvci5sICs9IE1hdGgubWluKGludmVydGVkQ29sb3IubCArIDUwLCAxMDApO1xuICAgICAgICAgICAgcmV0dXJuIGludmVydGVkQ29sb3I7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHNob3VsZEludmVydCA9IGQgPT4gZDMuaGNsKHRoaXMuZ2V0RDNDb2xvdXIoZCkpLmwgPCA2MDtcbiAgICAgICAgY29uc3QgZmlsbENvbG91ciA9IGQzLmhjbChjb2xvdXJzLmVpZ2h0ZWVuLmRhcmtHcmV5KS5icmlnaHRlcigpO1xuICAgICAgICBjb25zdCBsaWdodGVyRmlsbENvbG91ciA9IGQzLmhjbChjb2xvdXJzLmVpZ2h0ZWVuLm1pZEdyZXkpO1xuICAgICAgICBjb25zdCBmaW5kQ29sb3VyID0gKGQsIG9uQmFyLCBsYWJlbFRleHQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBvbkJhciAmJiBzaG91bGRJbnZlcnQoZClcbiAgICAgICAgICAgICAgICA/IGdldEludmVydGVkQ29sb3IoZCkudG9TdHJpbmcoKVxuICAgICAgICAgICAgICAgIDogKGxhYmVsSXNaZXJvKGxhYmVsVGV4dClcbiAgICAgICAgICAgICAgICAgICAgPyBsaWdodGVyRmlsbENvbG91clxuICAgICAgICAgICAgICAgICAgICA6IChvbkJhciA/IGQzLmhjbChmaWxsQ29sb3VyKS5kYXJrZXIoKSA6IGZpbGxDb2xvdXIpKTtcbiAgICAgICAgfTtcblxuICAgICAgICBsYWJlbHMuZW50ZXIoKS5lYWNoKChzZXJpZXMsIHNfaSwgc19ub2RlcykgPT4ge1xuICAgICAgICAgICAgLy8gV2Ugd2FudCB0byBkZXRlcm1pbmUgd2hpY2ggZ3JvdXBzIG1heSBoYXZlIG1pc3NpbmcgdmFsdWVzLCBhbmQgcHJvdmlkZSB0aGVtLlxuICAgICAgICAgICAgY29uc3QgcmVxdWlyZWRHcm91cHMgPSB7fTtcbiAgICAgICAgICAgIHlHcm91cC5kb21haW4oKS5tYXAoZnJvbUtleSkuZm9yRWFjaChkID0+IHtcbiAgICAgICAgICAgICAgICByZXF1aXJlZEdyb3Vwc1tkLl9jb2xvdXJdID0gZDtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBzZXJpZXMuZGF0YS5mb3JFYWNoKGQgPT4ge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSByZXF1aXJlZEdyb3Vwc1tkLl9jb2xvdXJdXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY29uc3QgbWlzc2luZ0dyb3VwcyA9IE9iamVjdC52YWx1ZXMocmVxdWlyZWRHcm91cHMpO1xuICAgICAgICAgICAgbWlzc2luZ0dyb3Vwcy5mb3JFYWNoKGQgPT4ge1xuICAgICAgICAgICAgICAgIGQuX3ggPSBzZXJpZXMuX2tleTtcbiAgICAgICAgICAgICAgICBkLl95ID0gMDtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBkMy5zZWxlY3Qoc19ub2Rlc1tzX2ldKVxuICAgICAgICAgICAgICAuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwibGFiZWwtZ3JvdXBcIilcbiAgICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgZCA9PiBcInRyYW5zbGF0ZSgwLFwiICsgeXNjYWxlKGQuX2tleSkgKyBcIilcIilcbiAgICAgICAgICAgICAgLnNlbGVjdEFsbChcIi5jaGFydC1sYWJlbFwiKVxuICAgICAgICAgICAgICAuZGF0YShzZXJpZXMuZGF0YS5jb25jYXQoT2JqZWN0LnZhbHVlcyhtaXNzaW5nR3JvdXBzKSkpXG4gICAgICAgICAgICAgIC5lbnRlcigpXG4gICAgICAgICAgICAgIC5lYWNoKChkLCBpLCBub2RlcykgPT4ge1xuICAgICAgICAgICAgICAgICAgY29uc3QgbGFiZWxUZXh0ID0gdGhpcy5mb3JtYXRMYWJlbCgpKGQuX3gsIGQpO1xuICAgICAgICAgICAgICAgICAgbGV0IHlwb3MgPSB5R3JvdXAoZC5fa2V5KSArIHlHcm91cC5iYW5kd2lkdGgoKSAvIDI7XG4gICAgICAgICAgICAgICAgICBsZXQgeHBvcyA9IHhzY2FsZShkLl94KTtcbiAgICAgICAgICAgICAgICAgIGxldCB0ZXh0ID0gZDMuc2VsZWN0KG5vZGVzW2ldKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcImZvbnQtc2l6ZVwiLCBmb250U2l6ZSArIFwicHhcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC50ZXh0KGxhYmVsVGV4dClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgZCA9PiBcImNoYXJ0LWxhYmVsIHNlcmllcyBzZXJpZXMtXCIgKyB0b0NvbG91cktleShkLl9jb2xvdXIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJkeFwiLCAoYW5pbWF0ZSA/IC0xNSA6IDApKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwicG9pbnRlci1ldmVudHNcIiwgXCJub25lXCIpO1xuXG4gICAgICAgICAgICAgICAgICAvLyBTZXQgdGhlIHggcG9zaXRpb24sIHdoaWNoIGlzIGJhc2VkIG9uIHdpZHRoLlxuICAgICAgICAgICAgICAgICAgY29uc3QgYmIgPSB0ZXh0Lm5vZGUoKS5nZXRCQm94KCk7XG4gICAgICAgICAgICAgICAgICBjb25zdCBoZWlnaHQgPSBiYi5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICBjb25zdCB3aWR0aCA9IGJiLndpZHRoO1xuXG4gICAgICAgICAgICAgICAgICBsZXQgZWZmZWN0aXZlQnVmZmVyID0gYnVmZmVyO1xuICAgICAgICAgICAgICAgICAgaWYgKHhwb3MgKyB3aWR0aCA+PSB0aGlzLl93aWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgIHhwb3MgPSBNYXRoLm1heCgwLCB4cG9zIC0gd2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICAgIGVmZmVjdGl2ZUJ1ZmZlciA9IC1idWZmZXI7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIG1heEhlaWdodCA9IE1hdGgubWF4KGhlaWdodCwgbWF4SGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgIHRleHRcbiAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcInlcIiwgeXBvcyArIGhlaWdodCAvIDMpIC8vIHVzZSBhIHRoaXJkIG9mIHRoZSBoZWlnaHQgcmF0aGVyIHRoYW4gaGFsZiBiZWNhdXNlIGl0IGxvb2tzIGJldHRlci5cbiAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcInhcIiwgeHBvcylcbiAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIGQgPT4gZmluZENvbG91cihkLCBlZmZlY3RpdmVCdWZmZXIgPCAwLCBsYWJlbFRleHQpKTtcblxuICAgICAgICAgICAgICAgICAgdGV4dFxuICAgICAgICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKFwibGFiZWxzXCIpXG4gICAgICAgICAgICAgICAgICAgICAgLmRlbGF5KCgpID0+IGFuaW1hdGUgPyB0aGlzLmNhbGNCYXJHcm93dGgoc19pLCBzX25vZGVzLmxlbmd0aCkgOiAwKSAvLyBEZWxheSBpbiBsb2Nrc3RlcCB3aXRoIGJhciBncm93dGguXG4gICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJkeFwiLCBlZmZlY3RpdmVCdWZmZXIpXG4gICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAxKVxuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKG1heFdpZHRoID4geHNjYWxlLnJhbmdlKClbMV0pIHtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb24uc2VsZWN0QWxsKFwiLmNoYXJ0LWxhYmVsc1wiKS5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cblxuICAgICAgICAvLyBGaWd1cmUgb3V0IGlmIHdlIGRvbid0IGhhdmUgZW5vdWdoIHNwYWNlIHRvIHNob3cgb3VyIGxhYmVscy5cbiAgICAgICAgLy8gV2UgdGhlbiB3YW50IHRvIHJlc2l6ZSwgaWYgcG9zc2libGUuXG4gICAgICAgIGlmICh5R3JvdXAuYmFuZHdpZHRoKCkgPCBtYXhIZWlnaHQgKiAxLjEwKSB7XG4gICAgICAgICAgICBsZXQgc2NhbGUgPSBtYXhIZWlnaHQgLyB5R3JvdXAuYmFuZHdpZHRoKCkgKiAxLjEwO1xuICAgICAgICAgICAgZm9udFNpemUgPSBNYXRoLmZsb29yKGZvbnRTaXplIC8gc2NhbGUpO1xuXG4gICAgICAgICAgICBpZiAoZm9udFNpemUgPCA4KSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGxhYmVscyBhcmUgdG9vIHNtYWxsLlxuICAgICAgICAgICAgICAgIGxhYmVscy5lbnRlcigpLnNlbGVjdEFsbChcInRleHRcIikucmVtb3ZlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxhYmVscy5lbnRlcigpXG4gICAgICAgICAgICAgICAgICAgICAgLm1lcmdlKGxhYmVscylcbiAgICAgICAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKFwidGV4dFwiKVxuICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcImZvbnQtc2l6ZVwiLCBmb250U2l6ZSArIFwicHhcIilcbiAgICAgICAgICAgICAgICAgICAgICAuZWFjaCgoZCwgaSwgbm9kZXMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGV4dCA9IGQzLnNlbGVjdChub2Rlc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gdGV4dC5ub2RlKCkuZ2V0QkJveCgpLndpZHRoO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB4cG9zID0geHNjYWxlKGQuX3gpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZWZmZWN0aXZlQnVmZmVyID0gYnVmZmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoeHBvcyArIHdpZHRoID49IHRoaXMuX3dpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4cG9zID0gTWF0aC5tYXgoMCwgeHBvcyAtIHdpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVmZmVjdGl2ZUJ1ZmZlciA9IC1idWZmZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcInhcIiwgeHBvcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcImZpbGxcIiwgZCA9PiBmaW5kQ29sb3VyKGQsIGVmZmVjdGl2ZUJ1ZmZlciA8IDAsIHRleHQudGV4dCgpKSkgLy8gdG9kb1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJkeFwiLCBlZmZlY3RpdmVCdWZmZXIpOyAvLyB0b2RvXG4gICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgaW1tZWRpYXRlbHlSZW5kZXJMYWJlbHMoc2hvdykge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5lbGVtZW50KCk7XG4gICAgICAgIGlmICghZWxlbWVudCkgcmV0dXJuO1xuXG4gICAgICAgIGlmICghc2hvdykgeyAvLyBIaWRlcyB0aGUgbGFiZWxzXG4gICAgICAgICAgICBlbGVtZW50XG4gICAgICAgICAgICAgICAgLnNlbGVjdCgnLmNoYXJ0LWxhYmVscycpXG4gICAgICAgICAgICAgICAgLmludGVycnVwdChcImxhYmVsc1wiKVxuICAgICAgICAgICAgICAgIC5pbnRlcnJ1cHQoXCJsYWJlbHM6ZmFkZVwiKVxuICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKFwibGFiZWxzOmZhZGVcIilcbiAgICAgICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDApXG4gICAgICAgICAgICAgICAgLm9uKFwiZW5kXCIsIChkLCBpLCBub2RlcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBkMy5zZWxlY3Qobm9kZXNbaV0pLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgbGFiZWxzID0gZWxlbWVudC5zZWxlY3QoJy5jaGFydC1sYWJlbHMnKTtcbiAgICAgICAgICAgIGlmICghbGFiZWxzLmVtcHR5KCkpIHJldHVybjtcblxuICAgICAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMucHJlcGFyZURhdGEobnVsbCwgdHJ1ZSk7XG4gICAgICAgICAgICBjb25zdCBhbGxEYXRhID0gdGhpcy5wcmVwYXJlRGF0YShudWxsLCBmYWxzZSk7XG5cbiAgICAgICAgICAgIGNvbnN0IHlzY2FsZSA9IHRoaXMuZ2V0RDNZU2NhbGUoZGF0YSksXG4gICAgICAgICAgICAgICAgICB4c2NhbGUgPSB0aGlzLmdldEQzWFNjYWxlKGRhdGEpLFxuICAgICAgICAgICAgICAgICAgeGdyb3VwID0gdGhpcy5nZXREM0dyb3VwU2NhbGUoZGF0YSwgeXNjYWxlKSxcbiAgICAgICAgICAgICAgICAgIGNvbG91clNjYWxlID0gdGhpcy5kM0NvbG91clNjYWxlKCk7XG5cbiAgICAgICAgICAgIGxhYmVscy5yZW1vdmUoKTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyTGFiZWxzKGVsZW1lbnQsIGRhdGEsIHhzY2FsZSwgeGdyb3VwLCB5c2NhbGUsIGNvbG91clNjYWxlLCBmYWxzZSk7XG4gICAgICAgIH1cblxuICAgIH1cblxuXG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGJhckNoYXJ0KCkge1xuICAgIHJldHVybiBuZXcgQmFySGlzdG9ncmFtKFwiQkFSX0NIQVJUXCIsIDAuMSk7XG59XG5cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/chart/BarChart.js\n')},"./src/chart/Bucket.js":
/*!*****************************!*\
  !*** ./src/chart/Bucket.js ***!
  \*****************************/
/*! exports provided: DateBucket, DiscreteBucket, ContinuousBucket */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DateBucket", function() { return DateBucket; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DiscreteBucket", function() { return DiscreteBucket; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ContinuousBucket", function() { return ContinuousBucket; });\n/* harmony import */ var _Statistics__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Statistics */ "./src/Statistics.js");\n// Copyright (C) 2013-2014, 2018 BrandsEye (PTY) LTD\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this\n// software and associated documentation files (the "Software"), to deal in the Software\n// without restriction, including without limitation the rights to use, copy, modify,\n//     merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following\n// conditions:\n//\n//     The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n//     INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n// CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n\nclass Bucket {\n    constructor(data) {\n        this._data = data;\n\n        this.getCount = d => d._y;\n        this.setCount = (d, v) => d._y = v;\n    }\n\n    setCountGetter(y) { this.getCount = y; return this; }\n    setCountSetter(y) { this.setCount = y; return this; }\n\n\n    /**\n     * Given a data point, this returns the bucket that the data point is a part of.\n     */\n    bucket(d) { return d; }\n\n    /**\n     * Given data that has had its buckets set up in each item\'s _key field,\n     * this consolidates the data in to a single collection of buckets.\n     */\n    consolidateBuckets(data) { return data; }\n\n}\n\n/**\n * The bucket of a Date object is just itself. We assume that\n * dates are their own buckets.\n */\nclass DateBucket extends Bucket {\n\n    // A noop: each date is its own bucket.\n    bucket(d) {\n        return d;\n    }\n\n    // A noop: our buckets are already consolidated.\n    consolidateBuckets(data) {\n        return data;\n    }\n}\n\nclass DiscreteBucket extends Bucket {\n\n    bucket(d) {\n        return d;\n    }\n\n    consolidateBuckets(data) {\n        data.forEach(bucket => {\n            const counts = {};\n            const examples = {};\n            // Count everything grouped by their keys\n            // (i.e. count individual series\n            bucket.data.forEach(d => {\n                counts[d._key] = (counts[d._key] || 0) + this.getCount(d);\n                examples[d._key] = d;\n            });\n            // Provide one summary per series, but preserve\n            // any extra data, such as colour and so on.\n            bucket.data = Object.keys(counts).map(key => {\n                const example = examples[key];\n                const result =  Object.assign({}, example);\n                this.setCount(result, counts[key])\n                return result;\n            })\n        });\n\n        return data;\n    }\n}\n\n\nclass ContinuousBucket extends Bucket {\n    // We calculate buckets based on the Freedman-Draconis\n    // inter-quartile range method.\n    constructor(data) {\n        super(data);\n        this._bucketWidth = Object(_Statistics__WEBPACK_IMPORTED_MODULE_0__["freedmanDiaconis"])(data);\n    }\n\n    bucket(d) {\n        const b = Math.floor(d / this._bucketWidth);\n        return Math.ceil(b * this._bucketWidth + this._bucketWidth);\n    }\n\n    consolidateBuckets(data) {\n        data.forEach(bucket => {\n            const counts = {};\n            const examples = {};\n            // Count everything grouped by their keys\n            // (i.e. count individual series\n            bucket.data.forEach(d => {\n                counts[d._key] = (counts[d._key] || 0) + 1;\n                examples[d._key] = d;\n            });\n            // Provide one summary per series, but preserve\n            // any extra data, such as colour and so on.\n            bucket.data = Object.keys(counts).map(key => {\n                const example = examples[key];\n                const result = Object.assign({}, example);\n                this.setCount(result, counts[key]);\n                return result;\n            })\n        });\n\n        return data;\n    }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY2hhcnQvQnVja2V0LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYjNqcy8uL3NyYy9jaGFydC9CdWNrZXQuanM/OTUxOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKEMpIDIwMTMtMjAxNCwgMjAxOCBCcmFuZHNFeWUgKFBUWSkgTFREXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZiB0aGlzXG4vLyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmVcbi8vIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSxcbi8vICAgICBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvXG4vLyBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZ1xuLy8gY29uZGl0aW9uczpcbi8vXG4vLyAgICAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4vLyBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vICAgICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SIElNUExJRUQsXG4vLyAgICAgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEFcbi8vIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFRcbi8vIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRlxuLy8gQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFXG4vLyBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IHtmcmVlZG1hbkRpYWNvbmlzfSBmcm9tIFwiLi4vU3RhdGlzdGljc1wiO1xuXG5cbmNsYXNzIEJ1Y2tldCB7XG4gICAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgICAgICB0aGlzLl9kYXRhID0gZGF0YTtcblxuICAgICAgICB0aGlzLmdldENvdW50ID0gZCA9PiBkLl95O1xuICAgICAgICB0aGlzLnNldENvdW50ID0gKGQsIHYpID0+IGQuX3kgPSB2O1xuICAgIH1cblxuICAgIHNldENvdW50R2V0dGVyKHkpIHsgdGhpcy5nZXRDb3VudCA9IHk7IHJldHVybiB0aGlzOyB9XG4gICAgc2V0Q291bnRTZXR0ZXIoeSkgeyB0aGlzLnNldENvdW50ID0geTsgcmV0dXJuIHRoaXM7IH1cblxuXG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBkYXRhIHBvaW50LCB0aGlzIHJldHVybnMgdGhlIGJ1Y2tldCB0aGF0IHRoZSBkYXRhIHBvaW50IGlzIGEgcGFydCBvZi5cbiAgICAgKi9cbiAgICBidWNrZXQoZCkgeyByZXR1cm4gZDsgfVxuXG4gICAgLyoqXG4gICAgICogR2l2ZW4gZGF0YSB0aGF0IGhhcyBoYWQgaXRzIGJ1Y2tldHMgc2V0IHVwIGluIGVhY2ggaXRlbSdzIF9rZXkgZmllbGQsXG4gICAgICogdGhpcyBjb25zb2xpZGF0ZXMgdGhlIGRhdGEgaW4gdG8gYSBzaW5nbGUgY29sbGVjdGlvbiBvZiBidWNrZXRzLlxuICAgICAqL1xuICAgIGNvbnNvbGlkYXRlQnVja2V0cyhkYXRhKSB7IHJldHVybiBkYXRhOyB9XG5cbn1cblxuLyoqXG4gKiBUaGUgYnVja2V0IG9mIGEgRGF0ZSBvYmplY3QgaXMganVzdCBpdHNlbGYuIFdlIGFzc3VtZSB0aGF0XG4gKiBkYXRlcyBhcmUgdGhlaXIgb3duIGJ1Y2tldHMuXG4gKi9cbmV4cG9ydCBjbGFzcyBEYXRlQnVja2V0IGV4dGVuZHMgQnVja2V0IHtcblxuICAgIC8vIEEgbm9vcDogZWFjaCBkYXRlIGlzIGl0cyBvd24gYnVja2V0LlxuICAgIGJ1Y2tldChkKSB7XG4gICAgICAgIHJldHVybiBkO1xuICAgIH1cblxuICAgIC8vIEEgbm9vcDogb3VyIGJ1Y2tldHMgYXJlIGFscmVhZHkgY29uc29saWRhdGVkLlxuICAgIGNvbnNvbGlkYXRlQnVja2V0cyhkYXRhKSB7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIERpc2NyZXRlQnVja2V0IGV4dGVuZHMgQnVja2V0IHtcblxuICAgIGJ1Y2tldChkKSB7XG4gICAgICAgIHJldHVybiBkO1xuICAgIH1cblxuICAgIGNvbnNvbGlkYXRlQnVja2V0cyhkYXRhKSB7XG4gICAgICAgIGRhdGEuZm9yRWFjaChidWNrZXQgPT4ge1xuICAgICAgICAgICAgY29uc3QgY291bnRzID0ge307XG4gICAgICAgICAgICBjb25zdCBleGFtcGxlcyA9IHt9O1xuICAgICAgICAgICAgLy8gQ291bnQgZXZlcnl0aGluZyBncm91cGVkIGJ5IHRoZWlyIGtleXNcbiAgICAgICAgICAgIC8vIChpLmUuIGNvdW50IGluZGl2aWR1YWwgc2VyaWVzXG4gICAgICAgICAgICBidWNrZXQuZGF0YS5mb3JFYWNoKGQgPT4ge1xuICAgICAgICAgICAgICAgIGNvdW50c1tkLl9rZXldID0gKGNvdW50c1tkLl9rZXldIHx8IDApICsgdGhpcy5nZXRDb3VudChkKTtcbiAgICAgICAgICAgICAgICBleGFtcGxlc1tkLl9rZXldID0gZDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gUHJvdmlkZSBvbmUgc3VtbWFyeSBwZXIgc2VyaWVzLCBidXQgcHJlc2VydmVcbiAgICAgICAgICAgIC8vIGFueSBleHRyYSBkYXRhLCBzdWNoIGFzIGNvbG91ciBhbmQgc28gb24uXG4gICAgICAgICAgICBidWNrZXQuZGF0YSA9IE9iamVjdC5rZXlzKGNvdW50cykubWFwKGtleSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXhhbXBsZSA9IGV4YW1wbGVzW2tleV07XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gIE9iamVjdC5hc3NpZ24oe30sIGV4YW1wbGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0Q291bnQocmVzdWx0LCBjb3VudHNba2V5XSlcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxufVxuXG5cbmV4cG9ydCBjbGFzcyBDb250aW51b3VzQnVja2V0IGV4dGVuZHMgQnVja2V0IHtcbiAgICAvLyBXZSBjYWxjdWxhdGUgYnVja2V0cyBiYXNlZCBvbiB0aGUgRnJlZWRtYW4tRHJhY29uaXNcbiAgICAvLyBpbnRlci1xdWFydGlsZSByYW5nZSBtZXRob2QuXG4gICAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgICAgICBzdXBlcihkYXRhKTtcbiAgICAgICAgdGhpcy5fYnVja2V0V2lkdGggPSBmcmVlZG1hbkRpYWNvbmlzKGRhdGEpO1xuICAgIH1cblxuICAgIGJ1Y2tldChkKSB7XG4gICAgICAgIGNvbnN0IGIgPSBNYXRoLmZsb29yKGQgLyB0aGlzLl9idWNrZXRXaWR0aCk7XG4gICAgICAgIHJldHVybiBNYXRoLmNlaWwoYiAqIHRoaXMuX2J1Y2tldFdpZHRoICsgdGhpcy5fYnVja2V0V2lkdGgpO1xuICAgIH1cblxuICAgIGNvbnNvbGlkYXRlQnVja2V0cyhkYXRhKSB7XG4gICAgICAgIGRhdGEuZm9yRWFjaChidWNrZXQgPT4ge1xuICAgICAgICAgICAgY29uc3QgY291bnRzID0ge307XG4gICAgICAgICAgICBjb25zdCBleGFtcGxlcyA9IHt9O1xuICAgICAgICAgICAgLy8gQ291bnQgZXZlcnl0aGluZyBncm91cGVkIGJ5IHRoZWlyIGtleXNcbiAgICAgICAgICAgIC8vIChpLmUuIGNvdW50IGluZGl2aWR1YWwgc2VyaWVzXG4gICAgICAgICAgICBidWNrZXQuZGF0YS5mb3JFYWNoKGQgPT4ge1xuICAgICAgICAgICAgICAgIGNvdW50c1tkLl9rZXldID0gKGNvdW50c1tkLl9rZXldIHx8IDApICsgMTtcbiAgICAgICAgICAgICAgICBleGFtcGxlc1tkLl9rZXldID0gZDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gUHJvdmlkZSBvbmUgc3VtbWFyeSBwZXIgc2VyaWVzLCBidXQgcHJlc2VydmVcbiAgICAgICAgICAgIC8vIGFueSBleHRyYSBkYXRhLCBzdWNoIGFzIGNvbG91ciBhbmQgc28gb24uXG4gICAgICAgICAgICBidWNrZXQuZGF0YSA9IE9iamVjdC5rZXlzKGNvdW50cykubWFwKGtleSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXhhbXBsZSA9IGV4YW1wbGVzW2tleV07XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gT2JqZWN0LmFzc2lnbih7fSwgZXhhbXBsZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRDb3VudChyZXN1bHQsIGNvdW50c1trZXldKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxufSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/chart/Bucket.js\n')},"./src/chart/FantasticChart.js":
/*!*************************************!*\
  !*** ./src/chart/FantasticChart.js ***!
  \*************************************/
/*! exports provided: chart */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "chart", function() { return chart; });\n/* harmony import */ var _Scales__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Scales */ "./src/chart/Scales.js");\n/* harmony import */ var _Axes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Axes */ "./src/chart/Axes.js");\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helpers */ "./src/helpers.js");\n/* harmony import */ var _Legend__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Legend */ "./src/Legend.js");\n/* harmony import */ var _Strings__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Strings */ "./src/Strings.js");\n// Copyright (C) 2013-2014, 2018 BrandsEye (PTY) LTD\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this\n// software and associated documentation files (the "Software"), to deal in the Software\n// without restriction, including without limitation the rights to use, copy, modify,\n//     merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following\n// conditions:\n//\n//     The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n//     INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n// CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n\n\n\n\n\nclass FantasticChart {\n\n    constructor(name) {\n        this._counter = this._counter || 0;\n        this._counter++;\n        this._name = name || ("Chart " + this._counter);\n        this.reset();\n    }\n\n    reset() {\n        this._geometries = [];\n        this._x_getter = d => d.x;\n        this._y_getter = d => d.y;\n        this._data = [];\n        this._element = null;\n        this._width = 900;\n        this._height = 512;\n        this._size = () => 1;\n        this._scale_x = Object(_Scales__WEBPACK_IMPORTED_MODULE_0__["scaleIdentity"])();\n        this._scale_y = Object(_Scales__WEBPACK_IMPORTED_MODULE_0__["scaleIdentity"])();\n        this._colour = () => 1;\n        this._facet_x = null;\n        this._colour_scale = d3.schemeAccent;\n        this._d3_colour_scale = d3.schemeAccent;\n        this._individual_colours = () => null;\n        this._modify_colour = c => c;\n        this._x_formatter = d => "" + d;\n        this._y_formatter = d => d;\n        this._x_importance = () => false;\n        this._dispatch = d3.dispatch(\'elementClick\', \'tooltipShow\', \'tooltipHide\');\n        this._show_labels = true;\n        this._show_legend = true;\n        this._legend_colours = () => null;\n        this._x_axis_label = null;\n        this._y_axis_label = null;\n        this._y2_axis_label = null;\n        this._hide_x_axis_min = false;\n        this._hide_y_axis_min = false;\n        this._hide_y2_axis_min = false;\n        this._show_x_axis = true;\n        this._show_y_axis = true;\n        this._show_y2_axis = true;\n        this._label_formatter = null;\n        this._font_size = 12;\n        this._x_grid_lines = false;\n        this._y_grid_lines = false;\n        this._axis_box = false;\n        this._x_label_angle = null;\n        this._grid_line_opacity = 0.15;\n        this._x_tick_values_fn = null;\n        this._y_tick_values_fn = null;\n        this._y2_tick_values_fn = null;\n        return this;\n    }\n\n    /*\n     * A DOM element that we want to render to.\n     * See, for instance, document.getElementById(id), to get\n     * such a dom element.\n     */\n    element(el) {\n        if (arguments.length === 0) return this._element;\n        this._element = el;\n        return this;\n    }\n\n    width(width) {\n        if (arguments.length === 0) return this._width;\n        if (typeof width !== "number" && width > 0) throw new Error("width must be a positive number");\n        this._width = width;\n        return this;\n    }\n\n    height(height) {\n        if (arguments.length === 0) return this._height;\n        if (typeof height !== "number" && height > 0) throw new Error("height must be a positive number");\n        this._height = height;\n        return this;\n    }\n\n    x(getter) {\n        if (arguments.length === 0) return this._x_getter;\n        if (typeof getter !== \'function\') throw new Error("x getter must be a function");\n        this._x_getter = getter;\n        return this;\n    }\n\n    y(getter) {\n        if (arguments.length === 0) return this._y_getter;\n        if (typeof getter !== \'function\') throw new Error("y getter must be a function");\n        this._y_getter = getter;\n        return this;\n    }\n\n    scaleX(scale) {\n        if (arguments.length === 0) return this._scale_x;\n        this._scale_x = scale;\n        if (scale) {\n            scale.setCountGetter(d => d._y);\n            scale.setCountSetter((d, v) => d._y = v);\n        }\n        return this;\n    }\n\n    scaleY(scale) {\n        if (arguments.length === 0) return this._scale_y;\n        this._scale_y = scale;\n        if (scale) {\n            scale.setCountGetter(d => d._x);\n            scale.setCountSetter((d, v) => d._x = v);\n        }\n\n        return this;\n    }\n\n    /**\n     * Add geometry to render. Multiple geometries can be added.\n     */\n    geometry(geom) {\n        if (arguments.length === 0) return this._geometries.slice(0);\n        geom.index(this._geometries.length);\n        this._geometries.push(geom);\n        return this;\n    }\n\n    size(getter) {\n        if (arguments.length === 0) return this._size;\n        if (typeof getter !== \'function\') throw new Error("size getter must be a function");\n        this._size = getter;\n        return this;\n    }\n\n    formatX(formatter) {\n        if (arguments.length === 0) return this._x_formatter;\n        if (typeof formatter !== \'function\') throw new Error("formatter must be a function");\n        this._x_formatter = formatter;\n        return this;\n    }\n\n    importanceX(importance) {\n        if (arguments.length === 0) return this._x_importance;\n        if (typeof importance !== \'function\') throw new Error("importance must be a function");\n        this._x_importance = importance;\n        return this;\n    }\n\n    formatY(formatter) {\n        if (arguments.length === 0) return this._y_formatter;\n        if (typeof formatter !== \'function\') throw new Error("formatter must be a function");\n        this._y_formatter = formatter;\n        return this;\n    }\n\n    formatLabel(formatter) {\n        if (arguments.length === 0) return this._label_formatter;\n        if (typeof formatter !== \'function\') throw new Error("formatter must be a function");\n        this._label_formatter = formatter;\n        return this;\n    }\n\n    xAxisLabel(label) {\n        if (arguments.length === 0) return this._x_axis_label;\n        this._x_axis_label = label;\n        return this;\n    }\n\n    yAxisLabel(label) {\n        if (arguments.length === 0) return this._y_axis_label;\n        this._y_axis_label = label;\n        return this;\n    }\n\n    y2AxisLabel(label) {\n        if (arguments.length === 0) return this._y2_axis_label;\n        this._y2_axis_label = label;\n        return this;\n    }\n\n    showXAxis(show) {\n        if (arguments.length === 0) return this._show_x_axis;\n        this._show_x_axis = !!show;\n        return this;\n    }\n\n    showYAxis(show) {\n        if (arguments.length === 0) return this._show_y_axis;\n        this._show_y_axis = !!show;\n        return this;\n    }\n\n    showY2Axis(show) {\n        if (arguments.length === 0) return this._show_y2_axis;\n        this._show_y2_axis = !!show;\n        return this;\n    }\n\n    hideXAxisMin(show) {\n        if (arguments.length === 0) return this._hide_x_axis_min;\n        this._hide_x_axis_min = !!show;\n        return this;\n    }\n\n    hideYAxisMin(show) {\n        if (arguments.length === 0) return this._hide_y_axis_min;\n        this._hide_y_axis_min = !!show;\n        return this;\n    }\n\n    hideY2AxisMin(show) {\n        if (arguments.length === 0) return this._hide_y2_axis_min;\n        this._hide_y2_axis_min = !!show;\n        return this;\n    }\n\n    /**\n     * Defines how to separate data visually using colours. It\n     * does not define what colour to use.\n     * @param colour\n     * @returns {*}\n     */\n    colour(colour) {\n        if (arguments.length === 0) return this._colour;\n        if (typeof colour !== \'function\') throw new Error("colour must be a function");\n        this._colour = colour;\n        return this;\n    }\n\n    /**\n     * Defines colours to use.\n     * @param colours\n     */\n    colourScale(colours) {\n        if (arguments.length === 0) return this._colour_scale;\n        if (colours && (typeof colours !== \'object\' || !colours.length)) throw new Error("colour must be an Array");\n        this._colour_scale = colours;\n        return this;\n    }\n\n    /**\n     * Provide a function mapping x-value fields to a colour. The function is passed\n     * the given data value, after it has been annotated with _x, _y, _colour, and so on.\n     * This overrides\n     * the colour scale. The colour scale will be used for values not defined by this map.\n     * @param colourMap\n     * @returns {*}\n     */\n    individualColours(colourMap) {\n        if (arguments.length === 0) return this._individual_colours;\n        if (typeof colourMap !== \'function\') throw new Error("colourMap must be a function");\n        this._individual_colours = colourMap;\n        return this;\n    }\n\n    modifyColour(modifier) {\n        if (arguments.length === 0) return this._modify_colour;\n        if (typeof colourMap !== \'function\') throw new Error("modifier must be a function");\n        this._modify_colour = modifier;\n        return this;\n    }\n\n    facetX(selector) {\n        if (arguments.length === 0) return this._facet_x;\n        if (selector != null && typeof selector !== \'function\') throw new Error("The facet selector must be a function");\n        this._facet_x = selector;\n        return this;\n    }\n\n    /**\n     * Whether to show labels or not. This is retained mode: it will not show the labels\n     * immediately. Please call #render() again to show the labels.\n     */\n    showLabels(show) {\n        if (arguments.length === 0) return this._show_labels;\n        this._show_labels = !!show;\n        return this;\n    }\n\n    /**\n     * Indicates whether to show the legend or not. This is retained mode: you need to\n     * call render after setting this to see a change.\n     * @param show\n     * @returns {*}\n     */\n    showLegend(show) {\n        if (arguments.length === 0) return this._show_legend;\n        this._show_legend = !!show;\n        return this;\n    }\n\n    /**\n     * Provide a function to override the mapping of legend names to colours.\n     */\n    legendColours(colourMap) {\n        if (arguments.length === 0) return this._legend_colours;\n        if (typeof colourMap !== \'function\') throw new Error("colourMap must be a function");\n        this._legend_colours = colourMap;\n        return this;\n    }\n\n    fontSize(px) {\n        if (arguments.length === 0) return this._font_size;\n        if (typeof px !== "number" && px > 0) throw new Error("fontSize must be a positive number");\n        this._font_size = px;\n        return this;\n    }\n\n    xGridLines(show) {\n        if (arguments.length === 0) return this._x_grid_lines;\n        this._x_grid_lines = !!show;\n        return this;\n    }\n\n    yGridLines(show) {\n        if (arguments.length === 0) return this._y_grid_lines;\n        this._y_grid_lines = !!show;\n        return this;\n    }\n\n    axisBox(show) {\n        if (arguments.length === 0) return this._axis_box;\n        this._axis_box = !!show;\n        return this;\n    }\n\n    xLabelAngle(degrees) {\n        if (arguments.length === 0) return this._x_label_angle;\n        if (degrees !== null && typeof degrees !== "number") throw new Error("degrees must be a number or null");\n        this._x_label_angle = degrees;\n        return this;\n    }\n\n    gridLineOpacity(opacity) {\n        if (arguments.length === 0) return this._grid_line_opacity;\n        if (typeof opacity !== "number") throw new Error("opacity must be a number or null");\n        this._grid_line_opacity = opacity;\n        return this;\n    }\n\n    /**\n     * The function is passed the xScale and must return null or an array of values to use for ticks.\n     */\n    xTickValuesFn(fn) {\n        if (arguments.length === 0) return this._x_tick_values_fn;\n        if (fn && typeof fn !== "function") throw new Error("fn must be an function or null");\n        this._x_tick_values_fn = fn;\n        return this;\n    }\n\n    /**\n     * The function is passed the scale and must return null or an array of values to use for ticks.\n     */\n    yTickValuesFn(fn) {\n        if (arguments.length === 0) return this._y_tick_values_fn;\n        if (fn && typeof fn !== "function") throw new Error("fn must be an function or null");\n        this._y_tick_values_fn = fn;\n        return this;\n    }\n\n    /**\n     * The function is passed the scale and must return null or an array of values to use for ticks.\n     */\n    y2TickValuesFn(fn) {\n        if (arguments.length === 0) return this._y2_tick_values_fn;\n        if (fn && typeof fn !== "function") throw new Error("fn must be an function or null");\n        this._y2_tick_values_fn = fn;\n        return this;\n    }\n\n    /**\n     * Renders or hides labels as they are requested.\n     */\n    immediatelyRenderLabels(show) {\n        if (this._geometries) {\n            this._geometries.forEach(geom => geom.immediatelyRenderLabels(!!show))\n        }\n    }\n\n    /**\n     * The event handle for the charts. Supports the following events:\n     *\n     * - elementClick\n     * - tooltipShow\n     * - tooltipHide\n     *\n     * @returns {*|Dispatch}\n     */\n    dispatch() {\n        return this._dispatch;\n    }\n\n    data(data) {\n        if (arguments.length === 0) return this._data.slice();\n        this._data = data;\n        return this;\n    }\n\n    /**\n     * The chart\'s name, as defined in the constructor\n     * @returns {String}\n     */\n    name() {\n        return this._name;\n    }\n\n    render() {\n        //-----------------------------------------------\n        // Create initial svg element\n        let svg = d3.select(this._element).select("svg");\n        if (svg.empty()) svg = d3.select(this._element).append("svg");\n\n        //-----------------------------------------------\n        // Setup initial data\n\n        const geometries = this.sortGeometries();\n\n        let geomBuckets = geometries.map(g => {\n            let b = Object(_Legend__WEBPACK_IMPORTED_MODULE_3__["buckets"])(this._data, g._colour || this._colour,\n                g._individual_colours || this._individual_colours, this._size)\n            b.geometry = g\n            b.colourScale = d3.scaleOrdinal(g.colourScale() || this.colourScale()).domain(Array.from(b.colours))\n            return b\n        })\n\n        const axisOptions = {\n            fontSize: this._font_size,\n            xLabelAngle: this._x_label_angle,\n            gridLineOpacity: this._grid_line_opacity,\n            axisBox: this._axis_box,\n            hideXAxisMin: this._hide_x_axis_min,\n            hideYAxisMin: this._hide_y_axis_min\n        }\n\n        //-----------------------------------------------\n        // Calculate the space that various elements will want to take up. We also\n        // restrict the y axis by a proportion of the width of the metric.\n\n        const yAxisRestriction = Math.max((this._width * 0.07), 25);\n\n        geometries.forEach((geom,i) => this.setupGeom(geom, geomBuckets[i]));\n\n        let yAxisWidth = 0, y2AxisWidth = 0, firstY2AxisGeom = null;\n        if (geometries.length) {\n            if (this._show_y_axis){\n                yAxisWidth = Object(_helpers__WEBPACK_IMPORTED_MODULE_2__["maxBounding"])(svg, geometries[0].yValues()\n                    .map(geometries[0].formatY())\n                    .map(d => Object(_Strings__WEBPACK_IMPORTED_MODULE_4__["restrictLength"])(d, yAxisRestriction)), null, this._font_size).width + 15\n            }\n            if (this._show_y2_axis) {\n                for (let i = 1; i < geometries.length; i++) {\n                    let geom = geometries[i];\n                    if (!geom.useY2Axis()) continue\n                    firstY2AxisGeom = geom\n                    y2AxisWidth = Object(_helpers__WEBPACK_IMPORTED_MODULE_2__["maxBounding"])(svg, geom.yValues()\n                        .map(geom.formatY())\n                        .map(d => Object(_Strings__WEBPACK_IMPORTED_MODULE_4__["restrictLength"])(d, yAxisRestriction)), null, this._font_size).width + 20\n                }\n            }\n        }\n\n        //-----------------------------------------------\n        // Draw the legend\n\n        let legendHeight = 0, renderLegendFn\n        if (this._show_legend) {\n            renderLegendFn = () => {\n                let csFn = (d, bs) => {\n                    if (bs.geometry.gradientId) return "url(#" + bs.geometry.gradientId + "-legend)"\n                    return this._legend_colours(d) || bs.bucketColour[d] || bs.colourScale(d);\n                }\n                return Object(_Legend__WEBPACK_IMPORTED_MODULE_3__["renderLegend"])(svg, geomBuckets,\n                    csFn, this._width, this._height, geometries.length > 1 ? 1 : null, axisOptions)\n            }\n            legendHeight = renderLegendFn()\n        } else {\n            Object(_Legend__WEBPACK_IMPORTED_MODULE_3__["removeLegend"])(svg)\n        }\n\n        //-----------------------------------------------\n        // Calculate margins without knowing the final height.\n        // We can only calculate the final height once we can accurately\n        // determine how to lay out the x-axis.\n\n        const outerPadding = 20;\n\n        const margin = {\n            top: outerPadding,\n            right: outerPadding + y2AxisWidth,\n            bottom: outerPadding + legendHeight,\n            left: outerPadding + yAxisWidth\n        };\n        if (this._show_y_axis && this._y_axis_label) margin.left += 20;\n        if (this._show_x_axis && this._x_axis_label) margin.bottom += 40;\n        if (y2AxisWidth && this._y2_axis_label) margin.right += 15;\n        const width  = this._width - margin.left - margin.right;\n\n        //-----------------------------------------------\n        // Determine initial facet / small multiple information\n\n        const facets = getFacets(this._data, this._facet_x);\n        const singleFacet = facets.length === 1;\n\n        const facetBand = d3.scaleBand()\n                            .rangeRound([0, width])\n                            .padding(singleFacet ? 0 : 0.1) // take up full space if the only facet.\n                            .domain(facets);\n\n        //-----------------------------------------------\n        // Determine x-axis height\n        // We do this by rendering the various x-axes offscreen.\n\n        const xTickCount = Math.floor(width / 90);\n\n        geometries.forEach(geom => geom.width(facetBand.bandwidth()));\n        const axisSizeArea = svg.append("g")\n            .attr("transform", "translate(-1000, -1000)");\n\n        const xAxisRestriction = Math.min(25, Math.max(this._height * 0.07, 12));\n        let axisHeight = 0;\n        if (this._show_x_axis){\n            facets.forEach(facet => {\n                const xScale = geometries[0]\n                    .width(facetBand.bandwidth())\n                    .facet(singleFacet ? null : (d => this._facet_x(d) === facet))\n                    .getD3XScale();\n\n                let axis = d3.axisBottom(xScale).ticks(xTickCount).tickSize(0).tickPadding(6)\n                    .tickFormat((d, i) => Object(_Strings__WEBPACK_IMPORTED_MODULE_4__["restrictLength"])(geometries[0].formatX()(d, i), xAxisRestriction))\n                    .tickValues(this._x_tick_values_fn ? this._x_tick_values_fn(xScale) : null)\n                let height = Object(_Axes__WEBPACK_IMPORTED_MODULE_1__["xaxis"])(axisSizeArea, this._height,\n                    xScale.bandwidth ? xScale.bandwidth() : facetBand.bandwidth() / xScale.domain().length,\n                    axis, this.importanceX(), axisOptions);\n\n                axisHeight = Math.max(height, axisHeight);\n            });\n        }\n\n        axisSizeArea.remove();\n\n        //-----------------------------------------------\n        // Update margins and calculate height\n\n        margin.bottom += axisHeight;\n        const height = this._height - margin.top - margin.bottom;\n\n        //-----------------------------------------------\n        // Setup the svg\n\n        svg\n            .style("width", this._width + "px")\n            .style("height", this._height + "px");\n\n        //-----------------------------------------------\n        // An area for us to render the geometries in to.\n\n        let drawingArea = svg.select(\'.drawing-area\');\n        if (drawingArea.empty()) {\n            drawingArea = svg.append("svg").attr("class", "drawing-area").style("overflow", "visible")\n        }\n        drawingArea.attr("x", margin.left).attr("y", margin.top)\n\n        //-----------------------------------------------\n        // Set up small multiples / facets\n\n        let facetAreas = drawingArea.selectAll(\'.facet\').data(facets);\n        facetAreas.exit().remove();\n\n        //-----------------------------------------------\n        // Setup axes.\n\n        let xAxisArea = svg.select(".x-axis-area");\n\n        xAxisArea.remove();\n        xAxisArea = svg\n            .append("g")\n            .attr("class", "x-axis-area");\n\n        xAxisArea.attr("transform", "translate(" + margin.left + "," + (margin.top + height) +")").lower();\n\n        svg.select(".y-axis-area").remove()\n        svg.select(".y2-axis-area").remove()\n\n        let yAxisArea = svg.append("g").attr("class", "y-axis-area")\n            .attr("transform", "translate(" + margin.left +"," + margin.top + ")").lower();\n\n        if (geometries.length) {\n            // Draw the yaxis.\n            const yScale = geometries[0].height(height).getD3YScale()\n            let tv = this._y_tick_values_fn ? this._y_tick_values_fn(yScale) : null\n            let tc = Math.floor(height / 30)\n            if (tc <= 2 && !tv) tv = yScale.domain()\n            if (this._show_y_axis) {\n                Object(_Axes__WEBPACK_IMPORTED_MODULE_1__["yaxis"])(yAxisArea,\n                    d3.axisLeft(yScale).ticks(tc)\n                        .tickSize(this._y_grid_lines ? -width : 0)\n                        .tickPadding(6)\n                        .tickValues(tv)\n                        .tickFormat((d, i) => Object(_Strings__WEBPACK_IMPORTED_MODULE_4__["restrictLength"])(geometries[0].formatY()(d, i), yAxisRestriction)),\n                    axisOptions);\n            }\n\n            if (y2AxisWidth && firstY2AxisGeom) {  // Draw the y2 axis\n                let y2AxisArea = svg.append("g").attr("class", "y2-axis-area")\n                    .attr("transform", "translate(" + (margin.left + width) +" ," + margin.top + ")").lower();\n\n                const y2Scale = firstY2AxisGeom.height(height).getD3YScale()\n                let tv = this._y2_tick_values_fn ? this._y2_tick_values_fn(y2Scale) : null\n                let tc = Math.floor(height / 30)\n                if (tc <= 2 && !tv) tv = y2Scale.domain()\n                axisOptions.hideYAxisMin = this._hide_y2_axis_min\n                Object(_Axes__WEBPACK_IMPORTED_MODULE_1__["yaxis"])(y2AxisArea,\n                    d3.axisRight(y2Scale).ticks(tc)\n                        .tickSize(0)\n                        .tickPadding(3)\n                        .tickValues(tv)\n                        .tickFormat((d, i) => Object(_Strings__WEBPACK_IMPORTED_MODULE_4__["restrictLength"])(firstY2AxisGeom.formatY()(d, i), yAxisRestriction)),\n                    axisOptions)\n            }\n\n            // Draw a little x-axis for every facet.\n            if (this._show_x_axis) {\n                facets.forEach(facet => {\n                    const xScale = geometries[0]\n                        .width(facetBand.bandwidth())\n                        .height(height)\n                        .facet(singleFacet ? null : (d => this._facet_x(d) === facet))\n                        .getD3XScale();\n\n                    const area = xAxisArea\n                        .append("g")\n                        .attr("transform", "translate(" + (facetBand(facet)) + ",0)")// + (this._height - axisHeight) +")")\n                        .attr("width", facetBand.bandwidth());\n\n\n                    Object(_Axes__WEBPACK_IMPORTED_MODULE_1__["xaxis"])(area, this._height,\n                        xScale.bandwidth ? xScale.bandwidth() : facetBand.bandwidth() / xScale.domain().length,\n                        d3.axisBottom(xScale).ticks(xTickCount).tickSize(this._x_grid_lines ? -height : 0).tickPadding(6)\n                            .tickFormat((d, i) => Object(_Strings__WEBPACK_IMPORTED_MODULE_4__["restrictLength"])(geometries[0].formatX()(d, i), xAxisRestriction))\n                            .tickValues(this._x_tick_values_fn ? this._x_tick_values_fn(xScale) : null),\n                        this.importanceX(), axisOptions)\n                });\n            }\n\n        }\n\n        //-----------------------------------------------\n        // Setup labels\n\n        if (this._show_y_axis) Object(_Axes__WEBPACK_IMPORTED_MODULE_1__["yAxisLabel"])(svg, height, margin, this._y_axis_label, axisOptions, 0);\n        if (this._show_y2_axis) {\n            Object(_Axes__WEBPACK_IMPORTED_MODULE_1__["yAxisLabel"])(svg, height, margin, this._y2_axis_label, axisOptions, margin.left + width + y2AxisWidth + 20);\n        }\n        if (this._show_x_axis) Object(_Axes__WEBPACK_IMPORTED_MODULE_1__["xAxisLabel"])(svg, width, height, margin, this._x_axis_label, axisOptions);\n\n        //-----------------------------------------------\n        // Draw individual geometries.\n\n        facetAreas\n            .enter()\n            .append("g")\n            .attr("class", "facet")\n            .merge(facetAreas)\n            .attr("width", facetBand.bandwidth())\n            .attr("transform", facetId => {\n                if (singleFacet) return "translate(0,0)";\n                return "translate(" + facetBand(facetId) + ",0)";\n            })\n            .each((facet, facet_i, facetNodes) => {\n                const area = d3.select(facetNodes[facet_i]);\n\n                let geoms = area.selectAll(".geometry").data(geometries, d => d.key());\n\n                const xscale = geometries[0].getD3XScale();\n                const geom_width  = facetBand.bandwidth(),\n                      geom_height = height;\n\n                //yGrid(area, geom_width, this.scaleY().isShowGrid(), d3.axisLeft(yScale).ticks(yTickCount));\n                //xGrid(area, geom_height, this.scaleX().isShowGrid(), d3.axisBottom(xscale).ticks(xTickCount));\n\n                geoms.exit().remove();\n\n                geoms.enter()\n                     .append("g")\n                     .attr("class", "geometry")\n                     .merge(geoms)\n                     .each((geom, i, nodes) => {\n                         const geom_top  = 0,\n                               geom_left = 0;\n\n                         let node = d3.select(nodes[i]);\n\n                         node\n                             .attr("transform", "translate(" + geom_left + "," + geom_top + ")")\n                             .each((d, i, nodes) => {\n                                 geom.element(d3.select(nodes[i]))\n                                     .facet(singleFacet ? null : (d => this._facet_x(d) === facet))\n                                     .height(geom_height)\n                                     .width(geom_width)\n                                     .render();\n                             })\n                     });\n\n                // Ensure this is rendered on top of other things.\n                area.select(".x-axis").raise();\n            })\n\n        // re-render the legend if any geometries are using gradients so the legend can use the gradient which is\n        // only created when the geometry is rendered\n        if (renderLegendFn && geometries.find(g => g.gradientId)) renderLegendFn()\n    }\n\n\n    /*\n     * Ensures that each geom has the settings that it needs.\n     */\n    setupGeom(geom, bs) {\n        if (!geom.setupY()) geom.setupY(this._y_getter)\n\n        geom.setupX(this._x_getter)\n            .setupColour(this._colour)\n            .setupSize(this._size)\n            .setupScaleX(this._scale_x)\n            .setupFormatX(this._x_formatter)\n            .setupFormatLabel(this._label_formatter)\n            .setupModifyColour(this._modify_colour)\n            .setupShowLabels(this._show_labels)\n            .setupYAxisLabel(this._y_axis_label)\n            .setupXAxisLabel(this._x_axis_label)\n            .fontSize(this._font_size);\n\n        if (!geom.setupFormatY()) geom.setupFormatY(this._y_formatter)\n        if (!geom.useY2Axis()) geom.setupScaleY(this._scale_y)\n\n        if (this._colour_scale) {\n            geom.setupColourScale(this._colour_scale)\n            if (this._d3_colour_scale) geom.d3ColourScale(d3.scaleOrdinal(this._d3_colour_scale))\n        } else {\n            geom.d3ColourScale(d3.scaleOrdinal(geom.colourScale()).domain(Array.from(bs.colours)))\n        }\n        if (this._individual_colours) geom.setupIndividualColours(this._individual_colours)\n\n        geom._dispatch.on("elementClick", (e) => {\n            this._dispatch.call("elementClick", this, e);\n        });\n        geom._dispatch.on("tooltipHide", () => {\n            this._dispatch.call("tooltipHide", this);\n        });\n        geom._dispatch.on("tooltipShow", (e) => {\n            this._dispatch.call("tooltipShow", this, e);\n        });\n        geom.data(this._data);\n    }\n\n\n    /**\n     * We want to ensure that geometries have a particular order to them.\n     * This is important for rendering: lines should be rendered on top of\n     * large histogram rectangles, for instance, otherwise they will be hidden.\n     */\n    sortGeometries() {\n        if (!this._geometries || !this._geometries.length) return [];\n\n        let geometries = this._geometries.slice(0);\n        geometries.sort((lhs, rhs) => {\n            return lhs.priority() - rhs.priority();\n        });\n\n        return geometries;\n    }\n}\n\n\n/*\n * Returns the unique facet choices from the data, given a facet selector.\n */\nfunction getFacets(data, selector) {\n    if (!selector || !data || !data.length) return [1];\n\n    const keys = new Set(data.map(selector));\n    return [...keys];\n}\n\n\n/**\n * Create a new chart object.\n * @param name An optional name for the chart.\n * @returns {FantasticChart}\n */\nfunction chart(name) {\n    return new FantasticChart(name);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY2hhcnQvRmFudGFzdGljQ2hhcnQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9iM2pzLy4vc3JjL2NoYXJ0L0ZhbnRhc3RpY0NoYXJ0LmpzP2VlMTEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChDKSAyMDEzLTIwMTQsIDIwMTggQnJhbmRzRXllIChQVFkpIExURFxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpc1xuLy8gc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlXG4vLyB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksXG4vLyAgICAgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0b1xuLy8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcbi8vIGNvbmRpdGlvbnM6XG4vL1xuLy8gICAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuLy8gY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyAgICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUiBJTVBMSUVELFxuLy8gICAgIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBXG4vLyBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUXG4vLyBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0Zcbi8vIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRVxuLy8gT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCB7c2NhbGVJZGVudGl0eX0gZnJvbSBcIi4vU2NhbGVzXCI7XG5pbXBvcnQge3hheGlzLCB4QXhpc0xhYmVsLCB5YXhpcywgeUF4aXNMYWJlbH0gZnJvbSBcIi4vQXhlc1wiO1xuaW1wb3J0IHttYXhCb3VuZGluZ30gZnJvbSBcIi4uL2hlbHBlcnNcIjtcbmltcG9ydCB7YnVja2V0cywgcmVtb3ZlTGVnZW5kLCByZW5kZXJMZWdlbmR9IGZyb20gXCIuLi9MZWdlbmRcIjtcbmltcG9ydCB7cmVzdHJpY3RMZW5ndGh9IGZyb20gXCIuLi9TdHJpbmdzXCI7XG5cblxuY2xhc3MgRmFudGFzdGljQ2hhcnQge1xuXG4gICAgY29uc3RydWN0b3IobmFtZSkge1xuICAgICAgICB0aGlzLl9jb3VudGVyID0gdGhpcy5fY291bnRlciB8fCAwO1xuICAgICAgICB0aGlzLl9jb3VudGVyKys7XG4gICAgICAgIHRoaXMuX25hbWUgPSBuYW1lIHx8IChcIkNoYXJ0IFwiICsgdGhpcy5fY291bnRlcik7XG4gICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICB9XG5cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy5fZ2VvbWV0cmllcyA9IFtdO1xuICAgICAgICB0aGlzLl94X2dldHRlciA9IGQgPT4gZC54O1xuICAgICAgICB0aGlzLl95X2dldHRlciA9IGQgPT4gZC55O1xuICAgICAgICB0aGlzLl9kYXRhID0gW107XG4gICAgICAgIHRoaXMuX2VsZW1lbnQgPSBudWxsO1xuICAgICAgICB0aGlzLl93aWR0aCA9IDkwMDtcbiAgICAgICAgdGhpcy5faGVpZ2h0ID0gNTEyO1xuICAgICAgICB0aGlzLl9zaXplID0gKCkgPT4gMTtcbiAgICAgICAgdGhpcy5fc2NhbGVfeCA9IHNjYWxlSWRlbnRpdHkoKTtcbiAgICAgICAgdGhpcy5fc2NhbGVfeSA9IHNjYWxlSWRlbnRpdHkoKTtcbiAgICAgICAgdGhpcy5fY29sb3VyID0gKCkgPT4gMTtcbiAgICAgICAgdGhpcy5fZmFjZXRfeCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2NvbG91cl9zY2FsZSA9IGQzLnNjaGVtZUFjY2VudDtcbiAgICAgICAgdGhpcy5fZDNfY29sb3VyX3NjYWxlID0gZDMuc2NoZW1lQWNjZW50O1xuICAgICAgICB0aGlzLl9pbmRpdmlkdWFsX2NvbG91cnMgPSAoKSA9PiBudWxsO1xuICAgICAgICB0aGlzLl9tb2RpZnlfY29sb3VyID0gYyA9PiBjO1xuICAgICAgICB0aGlzLl94X2Zvcm1hdHRlciA9IGQgPT4gXCJcIiArIGQ7XG4gICAgICAgIHRoaXMuX3lfZm9ybWF0dGVyID0gZCA9PiBkO1xuICAgICAgICB0aGlzLl94X2ltcG9ydGFuY2UgPSAoKSA9PiBmYWxzZTtcbiAgICAgICAgdGhpcy5fZGlzcGF0Y2ggPSBkMy5kaXNwYXRjaCgnZWxlbWVudENsaWNrJywgJ3Rvb2x0aXBTaG93JywgJ3Rvb2x0aXBIaWRlJyk7XG4gICAgICAgIHRoaXMuX3Nob3dfbGFiZWxzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fc2hvd19sZWdlbmQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9sZWdlbmRfY29sb3VycyA9ICgpID0+IG51bGw7XG4gICAgICAgIHRoaXMuX3hfYXhpc19sYWJlbCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3lfYXhpc19sYWJlbCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3kyX2F4aXNfbGFiZWwgPSBudWxsO1xuICAgICAgICB0aGlzLl9oaWRlX3hfYXhpc19taW4gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faGlkZV95X2F4aXNfbWluID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2hpZGVfeTJfYXhpc19taW4gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fc2hvd194X2F4aXMgPSB0cnVlO1xuICAgICAgICB0aGlzLl9zaG93X3lfYXhpcyA9IHRydWU7XG4gICAgICAgIHRoaXMuX3Nob3dfeTJfYXhpcyA9IHRydWU7XG4gICAgICAgIHRoaXMuX2xhYmVsX2Zvcm1hdHRlciA9IG51bGw7XG4gICAgICAgIHRoaXMuX2ZvbnRfc2l6ZSA9IDEyO1xuICAgICAgICB0aGlzLl94X2dyaWRfbGluZXMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5feV9ncmlkX2xpbmVzID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2F4aXNfYm94ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3hfbGFiZWxfYW5nbGUgPSBudWxsO1xuICAgICAgICB0aGlzLl9ncmlkX2xpbmVfb3BhY2l0eSA9IDAuMTU7XG4gICAgICAgIHRoaXMuX3hfdGlja192YWx1ZXNfZm4gPSBudWxsO1xuICAgICAgICB0aGlzLl95X3RpY2tfdmFsdWVzX2ZuID0gbnVsbDtcbiAgICAgICAgdGhpcy5feTJfdGlja192YWx1ZXNfZm4gPSBudWxsO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIEEgRE9NIGVsZW1lbnQgdGhhdCB3ZSB3YW50IHRvIHJlbmRlciB0by5cbiAgICAgKiBTZWUsIGZvciBpbnN0YW5jZSwgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpLCB0byBnZXRcbiAgICAgKiBzdWNoIGEgZG9tIGVsZW1lbnQuXG4gICAgICovXG4gICAgZWxlbWVudChlbCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX2VsZW1lbnQ7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQgPSBlbDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgd2lkdGgod2lkdGgpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl93aWR0aDtcbiAgICAgICAgaWYgKHR5cGVvZiB3aWR0aCAhPT0gXCJudW1iZXJcIiAmJiB3aWR0aCA+IDApIHRocm93IG5ldyBFcnJvcihcIndpZHRoIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXJcIik7XG4gICAgICAgIHRoaXMuX3dpZHRoID0gd2lkdGg7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGhlaWdodChoZWlnaHQpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl9oZWlnaHQ7XG4gICAgICAgIGlmICh0eXBlb2YgaGVpZ2h0ICE9PSBcIm51bWJlclwiICYmIGhlaWdodCA+IDApIHRocm93IG5ldyBFcnJvcihcImhlaWdodCBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyXCIpO1xuICAgICAgICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHgoZ2V0dGVyKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5feF9nZXR0ZXI7XG4gICAgICAgIGlmICh0eXBlb2YgZ2V0dGVyICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgRXJyb3IoXCJ4IGdldHRlciBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG4gICAgICAgIHRoaXMuX3hfZ2V0dGVyID0gZ2V0dGVyO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB5KGdldHRlcikge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX3lfZ2V0dGVyO1xuICAgICAgICBpZiAodHlwZW9mIGdldHRlciAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IEVycm9yKFwieSBnZXR0ZXIgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICB0aGlzLl95X2dldHRlciA9IGdldHRlcjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgc2NhbGVYKHNjYWxlKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5fc2NhbGVfeDtcbiAgICAgICAgdGhpcy5fc2NhbGVfeCA9IHNjYWxlO1xuICAgICAgICBpZiAoc2NhbGUpIHtcbiAgICAgICAgICAgIHNjYWxlLnNldENvdW50R2V0dGVyKGQgPT4gZC5feSk7XG4gICAgICAgICAgICBzY2FsZS5zZXRDb3VudFNldHRlcigoZCwgdikgPT4gZC5feSA9IHYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHNjYWxlWShzY2FsZSkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX3NjYWxlX3k7XG4gICAgICAgIHRoaXMuX3NjYWxlX3kgPSBzY2FsZTtcbiAgICAgICAgaWYgKHNjYWxlKSB7XG4gICAgICAgICAgICBzY2FsZS5zZXRDb3VudEdldHRlcihkID0+IGQuX3gpO1xuICAgICAgICAgICAgc2NhbGUuc2V0Q291bnRTZXR0ZXIoKGQsIHYpID0+IGQuX3ggPSB2KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCBnZW9tZXRyeSB0byByZW5kZXIuIE11bHRpcGxlIGdlb21ldHJpZXMgY2FuIGJlIGFkZGVkLlxuICAgICAqL1xuICAgIGdlb21ldHJ5KGdlb20pIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl9nZW9tZXRyaWVzLnNsaWNlKDApO1xuICAgICAgICBnZW9tLmluZGV4KHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoKTtcbiAgICAgICAgdGhpcy5fZ2VvbWV0cmllcy5wdXNoKGdlb20pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzaXplKGdldHRlcikge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX3NpemU7XG4gICAgICAgIGlmICh0eXBlb2YgZ2V0dGVyICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgRXJyb3IoXCJzaXplIGdldHRlciBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG4gICAgICAgIHRoaXMuX3NpemUgPSBnZXR0ZXI7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZvcm1hdFgoZm9ybWF0dGVyKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5feF9mb3JtYXR0ZXI7XG4gICAgICAgIGlmICh0eXBlb2YgZm9ybWF0dGVyICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgRXJyb3IoXCJmb3JtYXR0ZXIgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICB0aGlzLl94X2Zvcm1hdHRlciA9IGZvcm1hdHRlcjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaW1wb3J0YW5jZVgoaW1wb3J0YW5jZSkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX3hfaW1wb3J0YW5jZTtcbiAgICAgICAgaWYgKHR5cGVvZiBpbXBvcnRhbmNlICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgRXJyb3IoXCJpbXBvcnRhbmNlIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgdGhpcy5feF9pbXBvcnRhbmNlID0gaW1wb3J0YW5jZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZm9ybWF0WShmb3JtYXR0ZXIpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl95X2Zvcm1hdHRlcjtcbiAgICAgICAgaWYgKHR5cGVvZiBmb3JtYXR0ZXIgIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBFcnJvcihcImZvcm1hdHRlciBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG4gICAgICAgIHRoaXMuX3lfZm9ybWF0dGVyID0gZm9ybWF0dGVyO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmb3JtYXRMYWJlbChmb3JtYXR0ZXIpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl9sYWJlbF9mb3JtYXR0ZXI7XG4gICAgICAgIGlmICh0eXBlb2YgZm9ybWF0dGVyICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgRXJyb3IoXCJmb3JtYXR0ZXIgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICB0aGlzLl9sYWJlbF9mb3JtYXR0ZXIgPSBmb3JtYXR0ZXI7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHhBeGlzTGFiZWwobGFiZWwpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl94X2F4aXNfbGFiZWw7XG4gICAgICAgIHRoaXMuX3hfYXhpc19sYWJlbCA9IGxhYmVsO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB5QXhpc0xhYmVsKGxhYmVsKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5feV9heGlzX2xhYmVsO1xuICAgICAgICB0aGlzLl95X2F4aXNfbGFiZWwgPSBsYWJlbDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgeTJBeGlzTGFiZWwobGFiZWwpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl95Ml9heGlzX2xhYmVsO1xuICAgICAgICB0aGlzLl95Ml9heGlzX2xhYmVsID0gbGFiZWw7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHNob3dYQXhpcyhzaG93KSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5fc2hvd194X2F4aXM7XG4gICAgICAgIHRoaXMuX3Nob3dfeF9heGlzID0gISFzaG93O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzaG93WUF4aXMoc2hvdykge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX3Nob3dfeV9heGlzO1xuICAgICAgICB0aGlzLl9zaG93X3lfYXhpcyA9ICEhc2hvdztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgc2hvd1kyQXhpcyhzaG93KSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5fc2hvd195Ml9heGlzO1xuICAgICAgICB0aGlzLl9zaG93X3kyX2F4aXMgPSAhIXNob3c7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGhpZGVYQXhpc01pbihzaG93KSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5faGlkZV94X2F4aXNfbWluO1xuICAgICAgICB0aGlzLl9oaWRlX3hfYXhpc19taW4gPSAhIXNob3c7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGhpZGVZQXhpc01pbihzaG93KSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5faGlkZV95X2F4aXNfbWluO1xuICAgICAgICB0aGlzLl9oaWRlX3lfYXhpc19taW4gPSAhIXNob3c7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGhpZGVZMkF4aXNNaW4oc2hvdykge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX2hpZGVfeTJfYXhpc19taW47XG4gICAgICAgIHRoaXMuX2hpZGVfeTJfYXhpc19taW4gPSAhIXNob3c7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlZmluZXMgaG93IHRvIHNlcGFyYXRlIGRhdGEgdmlzdWFsbHkgdXNpbmcgY29sb3Vycy4gSXRcbiAgICAgKiBkb2VzIG5vdCBkZWZpbmUgd2hhdCBjb2xvdXIgdG8gdXNlLlxuICAgICAqIEBwYXJhbSBjb2xvdXJcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBjb2xvdXIoY29sb3VyKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5fY29sb3VyO1xuICAgICAgICBpZiAodHlwZW9mIGNvbG91ciAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IEVycm9yKFwiY29sb3VyIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgdGhpcy5fY29sb3VyID0gY29sb3VyO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIGNvbG91cnMgdG8gdXNlLlxuICAgICAqIEBwYXJhbSBjb2xvdXJzXG4gICAgICovXG4gICAgY29sb3VyU2NhbGUoY29sb3Vycykge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX2NvbG91cl9zY2FsZTtcbiAgICAgICAgaWYgKGNvbG91cnMgJiYgKHR5cGVvZiBjb2xvdXJzICE9PSAnb2JqZWN0JyB8fCAhY29sb3Vycy5sZW5ndGgpKSB0aHJvdyBuZXcgRXJyb3IoXCJjb2xvdXIgbXVzdCBiZSBhbiBBcnJheVwiKTtcbiAgICAgICAgdGhpcy5fY29sb3VyX3NjYWxlID0gY29sb3VycztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJvdmlkZSBhIGZ1bmN0aW9uIG1hcHBpbmcgeC12YWx1ZSBmaWVsZHMgdG8gYSBjb2xvdXIuIFRoZSBmdW5jdGlvbiBpcyBwYXNzZWRcbiAgICAgKiB0aGUgZ2l2ZW4gZGF0YSB2YWx1ZSwgYWZ0ZXIgaXQgaGFzIGJlZW4gYW5ub3RhdGVkIHdpdGggX3gsIF95LCBfY29sb3VyLCBhbmQgc28gb24uXG4gICAgICogVGhpcyBvdmVycmlkZXNcbiAgICAgKiB0aGUgY29sb3VyIHNjYWxlLiBUaGUgY29sb3VyIHNjYWxlIHdpbGwgYmUgdXNlZCBmb3IgdmFsdWVzIG5vdCBkZWZpbmVkIGJ5IHRoaXMgbWFwLlxuICAgICAqIEBwYXJhbSBjb2xvdXJNYXBcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBpbmRpdmlkdWFsQ29sb3Vycyhjb2xvdXJNYXApIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl9pbmRpdmlkdWFsX2NvbG91cnM7XG4gICAgICAgIGlmICh0eXBlb2YgY29sb3VyTWFwICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgRXJyb3IoXCJjb2xvdXJNYXAgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICB0aGlzLl9pbmRpdmlkdWFsX2NvbG91cnMgPSBjb2xvdXJNYXA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIG1vZGlmeUNvbG91cihtb2RpZmllcikge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX21vZGlmeV9jb2xvdXI7XG4gICAgICAgIGlmICh0eXBlb2YgY29sb3VyTWFwICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgRXJyb3IoXCJtb2RpZmllciBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG4gICAgICAgIHRoaXMuX21vZGlmeV9jb2xvdXIgPSBtb2RpZmllcjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZmFjZXRYKHNlbGVjdG9yKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5fZmFjZXRfeDtcbiAgICAgICAgaWYgKHNlbGVjdG9yICE9IG51bGwgJiYgdHlwZW9mIHNlbGVjdG9yICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZmFjZXQgc2VsZWN0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICB0aGlzLl9mYWNldF94ID0gc2VsZWN0b3I7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdG8gc2hvdyBsYWJlbHMgb3Igbm90LiBUaGlzIGlzIHJldGFpbmVkIG1vZGU6IGl0IHdpbGwgbm90IHNob3cgdGhlIGxhYmVsc1xuICAgICAqIGltbWVkaWF0ZWx5LiBQbGVhc2UgY2FsbCAjcmVuZGVyKCkgYWdhaW4gdG8gc2hvdyB0aGUgbGFiZWxzLlxuICAgICAqL1xuICAgIHNob3dMYWJlbHMoc2hvdykge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX3Nob3dfbGFiZWxzO1xuICAgICAgICB0aGlzLl9zaG93X2xhYmVscyA9ICEhc2hvdztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdG8gc2hvdyB0aGUgbGVnZW5kIG9yIG5vdC4gVGhpcyBpcyByZXRhaW5lZCBtb2RlOiB5b3UgbmVlZCB0b1xuICAgICAqIGNhbGwgcmVuZGVyIGFmdGVyIHNldHRpbmcgdGhpcyB0byBzZWUgYSBjaGFuZ2UuXG4gICAgICogQHBhcmFtIHNob3dcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBzaG93TGVnZW5kKHNob3cpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl9zaG93X2xlZ2VuZDtcbiAgICAgICAgdGhpcy5fc2hvd19sZWdlbmQgPSAhIXNob3c7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByb3ZpZGUgYSBmdW5jdGlvbiB0byBvdmVycmlkZSB0aGUgbWFwcGluZyBvZiBsZWdlbmQgbmFtZXMgdG8gY29sb3Vycy5cbiAgICAgKi9cbiAgICBsZWdlbmRDb2xvdXJzKGNvbG91ck1hcCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX2xlZ2VuZF9jb2xvdXJzO1xuICAgICAgICBpZiAodHlwZW9mIGNvbG91ck1hcCAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IEVycm9yKFwiY29sb3VyTWFwIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgdGhpcy5fbGVnZW5kX2NvbG91cnMgPSBjb2xvdXJNYXA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZvbnRTaXplKHB4KSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5fZm9udF9zaXplO1xuICAgICAgICBpZiAodHlwZW9mIHB4ICE9PSBcIm51bWJlclwiICYmIHB4ID4gMCkgdGhyb3cgbmV3IEVycm9yKFwiZm9udFNpemUgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlclwiKTtcbiAgICAgICAgdGhpcy5fZm9udF9zaXplID0gcHg7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHhHcmlkTGluZXMoc2hvdykge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX3hfZ3JpZF9saW5lcztcbiAgICAgICAgdGhpcy5feF9ncmlkX2xpbmVzID0gISFzaG93O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB5R3JpZExpbmVzKHNob3cpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl95X2dyaWRfbGluZXM7XG4gICAgICAgIHRoaXMuX3lfZ3JpZF9saW5lcyA9ICEhc2hvdztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgYXhpc0JveChzaG93KSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5fYXhpc19ib3g7XG4gICAgICAgIHRoaXMuX2F4aXNfYm94ID0gISFzaG93O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB4TGFiZWxBbmdsZShkZWdyZWVzKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5feF9sYWJlbF9hbmdsZTtcbiAgICAgICAgaWYgKGRlZ3JlZXMgIT09IG51bGwgJiYgdHlwZW9mIGRlZ3JlZXMgIT09IFwibnVtYmVyXCIpIHRocm93IG5ldyBFcnJvcihcImRlZ3JlZXMgbXVzdCBiZSBhIG51bWJlciBvciBudWxsXCIpO1xuICAgICAgICB0aGlzLl94X2xhYmVsX2FuZ2xlID0gZGVncmVlcztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZ3JpZExpbmVPcGFjaXR5KG9wYWNpdHkpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl9ncmlkX2xpbmVfb3BhY2l0eTtcbiAgICAgICAgaWYgKHR5cGVvZiBvcGFjaXR5ICE9PSBcIm51bWJlclwiKSB0aHJvdyBuZXcgRXJyb3IoXCJvcGFjaXR5IG11c3QgYmUgYSBudW1iZXIgb3IgbnVsbFwiKTtcbiAgICAgICAgdGhpcy5fZ3JpZF9saW5lX29wYWNpdHkgPSBvcGFjaXR5O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZnVuY3Rpb24gaXMgcGFzc2VkIHRoZSB4U2NhbGUgYW5kIG11c3QgcmV0dXJuIG51bGwgb3IgYW4gYXJyYXkgb2YgdmFsdWVzIHRvIHVzZSBmb3IgdGlja3MuXG4gICAgICovXG4gICAgeFRpY2tWYWx1ZXNGbihmbikge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX3hfdGlja192YWx1ZXNfZm47XG4gICAgICAgIGlmIChmbiAmJiB0eXBlb2YgZm4gIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IEVycm9yKFwiZm4gbXVzdCBiZSBhbiBmdW5jdGlvbiBvciBudWxsXCIpO1xuICAgICAgICB0aGlzLl94X3RpY2tfdmFsdWVzX2ZuID0gZm47XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBmdW5jdGlvbiBpcyBwYXNzZWQgdGhlIHNjYWxlIGFuZCBtdXN0IHJldHVybiBudWxsIG9yIGFuIGFycmF5IG9mIHZhbHVlcyB0byB1c2UgZm9yIHRpY2tzLlxuICAgICAqL1xuICAgIHlUaWNrVmFsdWVzRm4oZm4pIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl95X3RpY2tfdmFsdWVzX2ZuO1xuICAgICAgICBpZiAoZm4gJiYgdHlwZW9mIGZuICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBFcnJvcihcImZuIG11c3QgYmUgYW4gZnVuY3Rpb24gb3IgbnVsbFwiKTtcbiAgICAgICAgdGhpcy5feV90aWNrX3ZhbHVlc19mbiA9IGZuO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZnVuY3Rpb24gaXMgcGFzc2VkIHRoZSBzY2FsZSBhbmQgbXVzdCByZXR1cm4gbnVsbCBvciBhbiBhcnJheSBvZiB2YWx1ZXMgdG8gdXNlIGZvciB0aWNrcy5cbiAgICAgKi9cbiAgICB5MlRpY2tWYWx1ZXNGbihmbikge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX3kyX3RpY2tfdmFsdWVzX2ZuO1xuICAgICAgICBpZiAoZm4gJiYgdHlwZW9mIGZuICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBFcnJvcihcImZuIG11c3QgYmUgYW4gZnVuY3Rpb24gb3IgbnVsbFwiKTtcbiAgICAgICAgdGhpcy5feTJfdGlja192YWx1ZXNfZm4gPSBmbjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBvciBoaWRlcyBsYWJlbHMgYXMgdGhleSBhcmUgcmVxdWVzdGVkLlxuICAgICAqL1xuICAgIGltbWVkaWF0ZWx5UmVuZGVyTGFiZWxzKHNob3cpIHtcbiAgICAgICAgaWYgKHRoaXMuX2dlb21ldHJpZXMpIHtcbiAgICAgICAgICAgIHRoaXMuX2dlb21ldHJpZXMuZm9yRWFjaChnZW9tID0+IGdlb20uaW1tZWRpYXRlbHlSZW5kZXJMYWJlbHMoISFzaG93KSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBldmVudCBoYW5kbGUgZm9yIHRoZSBjaGFydHMuIFN1cHBvcnRzIHRoZSBmb2xsb3dpbmcgZXZlbnRzOlxuICAgICAqXG4gICAgICogLSBlbGVtZW50Q2xpY2tcbiAgICAgKiAtIHRvb2x0aXBTaG93XG4gICAgICogLSB0b29sdGlwSGlkZVxuICAgICAqXG4gICAgICogQHJldHVybnMgeyp8RGlzcGF0Y2h9XG4gICAgICovXG4gICAgZGlzcGF0Y2goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaXNwYXRjaDtcbiAgICB9XG5cbiAgICBkYXRhKGRhdGEpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl9kYXRhLnNsaWNlKCk7XG4gICAgICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY2hhcnQncyBuYW1lLCBhcyBkZWZpbmVkIGluIHRoZSBjb25zdHJ1Y3RvclxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIENyZWF0ZSBpbml0aWFsIHN2ZyBlbGVtZW50XG4gICAgICAgIGxldCBzdmcgPSBkMy5zZWxlY3QodGhpcy5fZWxlbWVudCkuc2VsZWN0KFwic3ZnXCIpO1xuICAgICAgICBpZiAoc3ZnLmVtcHR5KCkpIHN2ZyA9IGQzLnNlbGVjdCh0aGlzLl9lbGVtZW50KS5hcHBlbmQoXCJzdmdcIik7XG5cbiAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBTZXR1cCBpbml0aWFsIGRhdGFcblxuICAgICAgICBjb25zdCBnZW9tZXRyaWVzID0gdGhpcy5zb3J0R2VvbWV0cmllcygpO1xuXG4gICAgICAgIGxldCBnZW9tQnVja2V0cyA9IGdlb21ldHJpZXMubWFwKGcgPT4ge1xuICAgICAgICAgICAgbGV0IGIgPSBidWNrZXRzKHRoaXMuX2RhdGEsIGcuX2NvbG91ciB8fCB0aGlzLl9jb2xvdXIsXG4gICAgICAgICAgICAgICAgZy5faW5kaXZpZHVhbF9jb2xvdXJzIHx8IHRoaXMuX2luZGl2aWR1YWxfY29sb3VycywgdGhpcy5fc2l6ZSlcbiAgICAgICAgICAgIGIuZ2VvbWV0cnkgPSBnXG4gICAgICAgICAgICBiLmNvbG91clNjYWxlID0gZDMuc2NhbGVPcmRpbmFsKGcuY29sb3VyU2NhbGUoKSB8fCB0aGlzLmNvbG91clNjYWxlKCkpLmRvbWFpbihBcnJheS5mcm9tKGIuY29sb3VycykpXG4gICAgICAgICAgICByZXR1cm4gYlxuICAgICAgICB9KVxuXG4gICAgICAgIGNvbnN0IGF4aXNPcHRpb25zID0ge1xuICAgICAgICAgICAgZm9udFNpemU6IHRoaXMuX2ZvbnRfc2l6ZSxcbiAgICAgICAgICAgIHhMYWJlbEFuZ2xlOiB0aGlzLl94X2xhYmVsX2FuZ2xlLFxuICAgICAgICAgICAgZ3JpZExpbmVPcGFjaXR5OiB0aGlzLl9ncmlkX2xpbmVfb3BhY2l0eSxcbiAgICAgICAgICAgIGF4aXNCb3g6IHRoaXMuX2F4aXNfYm94LFxuICAgICAgICAgICAgaGlkZVhBeGlzTWluOiB0aGlzLl9oaWRlX3hfYXhpc19taW4sXG4gICAgICAgICAgICBoaWRlWUF4aXNNaW46IHRoaXMuX2hpZGVfeV9heGlzX21pblxuICAgICAgICB9XG5cbiAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIHNwYWNlIHRoYXQgdmFyaW91cyBlbGVtZW50cyB3aWxsIHdhbnQgdG8gdGFrZSB1cC4gV2UgYWxzb1xuICAgICAgICAvLyByZXN0cmljdCB0aGUgeSBheGlzIGJ5IGEgcHJvcG9ydGlvbiBvZiB0aGUgd2lkdGggb2YgdGhlIG1ldHJpYy5cblxuICAgICAgICBjb25zdCB5QXhpc1Jlc3RyaWN0aW9uID0gTWF0aC5tYXgoKHRoaXMuX3dpZHRoICogMC4wNyksIDI1KTtcblxuICAgICAgICBnZW9tZXRyaWVzLmZvckVhY2goKGdlb20saSkgPT4gdGhpcy5zZXR1cEdlb20oZ2VvbSwgZ2VvbUJ1Y2tldHNbaV0pKTtcblxuICAgICAgICBsZXQgeUF4aXNXaWR0aCA9IDAsIHkyQXhpc1dpZHRoID0gMCwgZmlyc3RZMkF4aXNHZW9tID0gbnVsbDtcbiAgICAgICAgaWYgKGdlb21ldHJpZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fc2hvd195X2F4aXMpe1xuICAgICAgICAgICAgICAgIHlBeGlzV2lkdGggPSBtYXhCb3VuZGluZyhzdmcsIGdlb21ldHJpZXNbMF0ueVZhbHVlcygpXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoZ2VvbWV0cmllc1swXS5mb3JtYXRZKCkpXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoZCA9PiByZXN0cmljdExlbmd0aChkLCB5QXhpc1Jlc3RyaWN0aW9uKSksIG51bGwsIHRoaXMuX2ZvbnRfc2l6ZSkud2lkdGggKyAxNVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX3Nob3dfeTJfYXhpcykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgZ2VvbWV0cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZ2VvbSA9IGdlb21ldHJpZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghZ2VvbS51c2VZMkF4aXMoKSkgY29udGludWVcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RZMkF4aXNHZW9tID0gZ2VvbVxuICAgICAgICAgICAgICAgICAgICB5MkF4aXNXaWR0aCA9IG1heEJvdW5kaW5nKHN2ZywgZ2VvbS55VmFsdWVzKClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoZ2VvbS5mb3JtYXRZKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAubWFwKGQgPT4gcmVzdHJpY3RMZW5ndGgoZCwgeUF4aXNSZXN0cmljdGlvbikpLCBudWxsLCB0aGlzLl9mb250X3NpemUpLndpZHRoICsgMjBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIERyYXcgdGhlIGxlZ2VuZFxuXG4gICAgICAgIGxldCBsZWdlbmRIZWlnaHQgPSAwLCByZW5kZXJMZWdlbmRGblxuICAgICAgICBpZiAodGhpcy5fc2hvd19sZWdlbmQpIHtcbiAgICAgICAgICAgIHJlbmRlckxlZ2VuZEZuID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBjc0ZuID0gKGQsIGJzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChicy5nZW9tZXRyeS5ncmFkaWVudElkKSByZXR1cm4gXCJ1cmwoI1wiICsgYnMuZ2VvbWV0cnkuZ3JhZGllbnRJZCArIFwiLWxlZ2VuZClcIlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbGVnZW5kX2NvbG91cnMoZCkgfHwgYnMuYnVja2V0Q29sb3VyW2RdIHx8IGJzLmNvbG91clNjYWxlKGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVuZGVyTGVnZW5kKHN2ZywgZ2VvbUJ1Y2tldHMsXG4gICAgICAgICAgICAgICAgICAgIGNzRm4sIHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHQsIGdlb21ldHJpZXMubGVuZ3RoID4gMSA/IDEgOiBudWxsLCBheGlzT3B0aW9ucylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxlZ2VuZEhlaWdodCA9IHJlbmRlckxlZ2VuZEZuKClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlbW92ZUxlZ2VuZChzdmcpXG4gICAgICAgIH1cblxuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIENhbGN1bGF0ZSBtYXJnaW5zIHdpdGhvdXQga25vd2luZyB0aGUgZmluYWwgaGVpZ2h0LlxuICAgICAgICAvLyBXZSBjYW4gb25seSBjYWxjdWxhdGUgdGhlIGZpbmFsIGhlaWdodCBvbmNlIHdlIGNhbiBhY2N1cmF0ZWx5XG4gICAgICAgIC8vIGRldGVybWluZSBob3cgdG8gbGF5IG91dCB0aGUgeC1heGlzLlxuXG4gICAgICAgIGNvbnN0IG91dGVyUGFkZGluZyA9IDIwO1xuXG4gICAgICAgIGNvbnN0IG1hcmdpbiA9IHtcbiAgICAgICAgICAgIHRvcDogb3V0ZXJQYWRkaW5nLFxuICAgICAgICAgICAgcmlnaHQ6IG91dGVyUGFkZGluZyArIHkyQXhpc1dpZHRoLFxuICAgICAgICAgICAgYm90dG9tOiBvdXRlclBhZGRpbmcgKyBsZWdlbmRIZWlnaHQsXG4gICAgICAgICAgICBsZWZ0OiBvdXRlclBhZGRpbmcgKyB5QXhpc1dpZHRoXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLl9zaG93X3lfYXhpcyAmJiB0aGlzLl95X2F4aXNfbGFiZWwpIG1hcmdpbi5sZWZ0ICs9IDIwO1xuICAgICAgICBpZiAodGhpcy5fc2hvd194X2F4aXMgJiYgdGhpcy5feF9heGlzX2xhYmVsKSBtYXJnaW4uYm90dG9tICs9IDQwO1xuICAgICAgICBpZiAoeTJBeGlzV2lkdGggJiYgdGhpcy5feTJfYXhpc19sYWJlbCkgbWFyZ2luLnJpZ2h0ICs9IDE1O1xuICAgICAgICBjb25zdCB3aWR0aCAgPSB0aGlzLl93aWR0aCAtIG1hcmdpbi5sZWZ0IC0gbWFyZ2luLnJpZ2h0O1xuXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gRGV0ZXJtaW5lIGluaXRpYWwgZmFjZXQgLyBzbWFsbCBtdWx0aXBsZSBpbmZvcm1hdGlvblxuXG4gICAgICAgIGNvbnN0IGZhY2V0cyA9IGdldEZhY2V0cyh0aGlzLl9kYXRhLCB0aGlzLl9mYWNldF94KTtcbiAgICAgICAgY29uc3Qgc2luZ2xlRmFjZXQgPSBmYWNldHMubGVuZ3RoID09PSAxO1xuXG4gICAgICAgIGNvbnN0IGZhY2V0QmFuZCA9IGQzLnNjYWxlQmFuZCgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJhbmdlUm91bmQoWzAsIHdpZHRoXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAucGFkZGluZyhzaW5nbGVGYWNldCA/IDAgOiAwLjEpIC8vIHRha2UgdXAgZnVsbCBzcGFjZSBpZiB0aGUgb25seSBmYWNldC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZG9tYWluKGZhY2V0cyk7XG5cbiAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBEZXRlcm1pbmUgeC1heGlzIGhlaWdodFxuICAgICAgICAvLyBXZSBkbyB0aGlzIGJ5IHJlbmRlcmluZyB0aGUgdmFyaW91cyB4LWF4ZXMgb2Zmc2NyZWVuLlxuXG4gICAgICAgIGNvbnN0IHhUaWNrQ291bnQgPSBNYXRoLmZsb29yKHdpZHRoIC8gOTApO1xuXG4gICAgICAgIGdlb21ldHJpZXMuZm9yRWFjaChnZW9tID0+IGdlb20ud2lkdGgoZmFjZXRCYW5kLmJhbmR3aWR0aCgpKSk7XG4gICAgICAgIGNvbnN0IGF4aXNTaXplQXJlYSA9IHN2Zy5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZSgtMTAwMCwgLTEwMDApXCIpO1xuXG4gICAgICAgIGNvbnN0IHhBeGlzUmVzdHJpY3Rpb24gPSBNYXRoLm1pbigyNSwgTWF0aC5tYXgodGhpcy5faGVpZ2h0ICogMC4wNywgMTIpKTtcbiAgICAgICAgbGV0IGF4aXNIZWlnaHQgPSAwO1xuICAgICAgICBpZiAodGhpcy5fc2hvd194X2F4aXMpe1xuICAgICAgICAgICAgZmFjZXRzLmZvckVhY2goZmFjZXQgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHhTY2FsZSA9IGdlb21ldHJpZXNbMF1cbiAgICAgICAgICAgICAgICAgICAgLndpZHRoKGZhY2V0QmFuZC5iYW5kd2lkdGgoKSlcbiAgICAgICAgICAgICAgICAgICAgLmZhY2V0KHNpbmdsZUZhY2V0ID8gbnVsbCA6IChkID0+IHRoaXMuX2ZhY2V0X3goZCkgPT09IGZhY2V0KSlcbiAgICAgICAgICAgICAgICAgICAgLmdldEQzWFNjYWxlKCk7XG5cbiAgICAgICAgICAgICAgICBsZXQgYXhpcyA9IGQzLmF4aXNCb3R0b20oeFNjYWxlKS50aWNrcyh4VGlja0NvdW50KS50aWNrU2l6ZSgwKS50aWNrUGFkZGluZyg2KVxuICAgICAgICAgICAgICAgICAgICAudGlja0Zvcm1hdCgoZCwgaSkgPT4gcmVzdHJpY3RMZW5ndGgoZ2VvbWV0cmllc1swXS5mb3JtYXRYKCkoZCwgaSksIHhBeGlzUmVzdHJpY3Rpb24pKVxuICAgICAgICAgICAgICAgICAgICAudGlja1ZhbHVlcyh0aGlzLl94X3RpY2tfdmFsdWVzX2ZuID8gdGhpcy5feF90aWNrX3ZhbHVlc19mbih4U2NhbGUpIDogbnVsbClcbiAgICAgICAgICAgICAgICBsZXQgaGVpZ2h0ID0geGF4aXMoYXhpc1NpemVBcmVhLCB0aGlzLl9oZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgIHhTY2FsZS5iYW5kd2lkdGggPyB4U2NhbGUuYmFuZHdpZHRoKCkgOiBmYWNldEJhbmQuYmFuZHdpZHRoKCkgLyB4U2NhbGUuZG9tYWluKCkubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICBheGlzLCB0aGlzLmltcG9ydGFuY2VYKCksIGF4aXNPcHRpb25zKTtcblxuICAgICAgICAgICAgICAgIGF4aXNIZWlnaHQgPSBNYXRoLm1heChoZWlnaHQsIGF4aXNIZWlnaHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBheGlzU2l6ZUFyZWEucmVtb3ZlKCk7XG5cbiAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBVcGRhdGUgbWFyZ2lucyBhbmQgY2FsY3VsYXRlIGhlaWdodFxuXG4gICAgICAgIG1hcmdpbi5ib3R0b20gKz0gYXhpc0hlaWdodDtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gdGhpcy5faGVpZ2h0IC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b207XG5cbiAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBTZXR1cCB0aGUgc3ZnXG5cbiAgICAgICAgc3ZnXG4gICAgICAgICAgICAuc3R5bGUoXCJ3aWR0aFwiLCB0aGlzLl93aWR0aCArIFwicHhcIilcbiAgICAgICAgICAgIC5zdHlsZShcImhlaWdodFwiLCB0aGlzLl9oZWlnaHQgKyBcInB4XCIpO1xuXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gQW4gYXJlYSBmb3IgdXMgdG8gcmVuZGVyIHRoZSBnZW9tZXRyaWVzIGluIHRvLlxuXG4gICAgICAgIGxldCBkcmF3aW5nQXJlYSA9IHN2Zy5zZWxlY3QoJy5kcmF3aW5nLWFyZWEnKTtcbiAgICAgICAgaWYgKGRyYXdpbmdBcmVhLmVtcHR5KCkpIHtcbiAgICAgICAgICAgIGRyYXdpbmdBcmVhID0gc3ZnLmFwcGVuZChcInN2Z1wiKS5hdHRyKFwiY2xhc3NcIiwgXCJkcmF3aW5nLWFyZWFcIikuc3R5bGUoXCJvdmVyZmxvd1wiLCBcInZpc2libGVcIilcbiAgICAgICAgfVxuICAgICAgICBkcmF3aW5nQXJlYS5hdHRyKFwieFwiLCBtYXJnaW4ubGVmdCkuYXR0cihcInlcIiwgbWFyZ2luLnRvcClcblxuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIFNldCB1cCBzbWFsbCBtdWx0aXBsZXMgLyBmYWNldHNcblxuICAgICAgICBsZXQgZmFjZXRBcmVhcyA9IGRyYXdpbmdBcmVhLnNlbGVjdEFsbCgnLmZhY2V0JykuZGF0YShmYWNldHMpO1xuICAgICAgICBmYWNldEFyZWFzLmV4aXQoKS5yZW1vdmUoKTtcblxuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIFNldHVwIGF4ZXMuXG5cbiAgICAgICAgbGV0IHhBeGlzQXJlYSA9IHN2Zy5zZWxlY3QoXCIueC1heGlzLWFyZWFcIik7XG5cbiAgICAgICAgeEF4aXNBcmVhLnJlbW92ZSgpO1xuICAgICAgICB4QXhpc0FyZWEgPSBzdmdcbiAgICAgICAgICAgIC5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwieC1heGlzLWFyZWFcIik7XG5cbiAgICAgICAgeEF4aXNBcmVhLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyBtYXJnaW4ubGVmdCArIFwiLFwiICsgKG1hcmdpbi50b3AgKyBoZWlnaHQpICtcIilcIikubG93ZXIoKTtcblxuICAgICAgICBzdmcuc2VsZWN0KFwiLnktYXhpcy1hcmVhXCIpLnJlbW92ZSgpXG4gICAgICAgIHN2Zy5zZWxlY3QoXCIueTItYXhpcy1hcmVhXCIpLnJlbW92ZSgpXG5cbiAgICAgICAgbGV0IHlBeGlzQXJlYSA9IHN2Zy5hcHBlbmQoXCJnXCIpLmF0dHIoXCJjbGFzc1wiLCBcInktYXhpcy1hcmVhXCIpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIG1hcmdpbi5sZWZ0ICtcIixcIiArIG1hcmdpbi50b3AgKyBcIilcIikubG93ZXIoKTtcblxuICAgICAgICBpZiAoZ2VvbWV0cmllcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIERyYXcgdGhlIHlheGlzLlxuICAgICAgICAgICAgY29uc3QgeVNjYWxlID0gZ2VvbWV0cmllc1swXS5oZWlnaHQoaGVpZ2h0KS5nZXREM1lTY2FsZSgpXG4gICAgICAgICAgICBsZXQgdHYgPSB0aGlzLl95X3RpY2tfdmFsdWVzX2ZuID8gdGhpcy5feV90aWNrX3ZhbHVlc19mbih5U2NhbGUpIDogbnVsbFxuICAgICAgICAgICAgbGV0IHRjID0gTWF0aC5mbG9vcihoZWlnaHQgLyAzMClcbiAgICAgICAgICAgIGlmICh0YyA8PSAyICYmICF0dikgdHYgPSB5U2NhbGUuZG9tYWluKClcbiAgICAgICAgICAgIGlmICh0aGlzLl9zaG93X3lfYXhpcykge1xuICAgICAgICAgICAgICAgIHlheGlzKHlBeGlzQXJlYSxcbiAgICAgICAgICAgICAgICAgICAgZDMuYXhpc0xlZnQoeVNjYWxlKS50aWNrcyh0YylcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aWNrU2l6ZSh0aGlzLl95X2dyaWRfbGluZXMgPyAtd2lkdGggOiAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRpY2tQYWRkaW5nKDYpXG4gICAgICAgICAgICAgICAgICAgICAgICAudGlja1ZhbHVlcyh0dilcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aWNrRm9ybWF0KChkLCBpKSA9PiByZXN0cmljdExlbmd0aChnZW9tZXRyaWVzWzBdLmZvcm1hdFkoKShkLCBpKSwgeUF4aXNSZXN0cmljdGlvbikpLFxuICAgICAgICAgICAgICAgICAgICBheGlzT3B0aW9ucyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh5MkF4aXNXaWR0aCAmJiBmaXJzdFkyQXhpc0dlb20pIHsgIC8vIERyYXcgdGhlIHkyIGF4aXNcbiAgICAgICAgICAgICAgICBsZXQgeTJBeGlzQXJlYSA9IHN2Zy5hcHBlbmQoXCJnXCIpLmF0dHIoXCJjbGFzc1wiLCBcInkyLWF4aXMtYXJlYVwiKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIChtYXJnaW4ubGVmdCArIHdpZHRoKSArXCIgLFwiICsgbWFyZ2luLnRvcCArIFwiKVwiKS5sb3dlcigpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgeTJTY2FsZSA9IGZpcnN0WTJBeGlzR2VvbS5oZWlnaHQoaGVpZ2h0KS5nZXREM1lTY2FsZSgpXG4gICAgICAgICAgICAgICAgbGV0IHR2ID0gdGhpcy5feTJfdGlja192YWx1ZXNfZm4gPyB0aGlzLl95Ml90aWNrX3ZhbHVlc19mbih5MlNjYWxlKSA6IG51bGxcbiAgICAgICAgICAgICAgICBsZXQgdGMgPSBNYXRoLmZsb29yKGhlaWdodCAvIDMwKVxuICAgICAgICAgICAgICAgIGlmICh0YyA8PSAyICYmICF0dikgdHYgPSB5MlNjYWxlLmRvbWFpbigpXG4gICAgICAgICAgICAgICAgYXhpc09wdGlvbnMuaGlkZVlBeGlzTWluID0gdGhpcy5faGlkZV95Ml9heGlzX21pblxuICAgICAgICAgICAgICAgIHlheGlzKHkyQXhpc0FyZWEsXG4gICAgICAgICAgICAgICAgICAgIGQzLmF4aXNSaWdodCh5MlNjYWxlKS50aWNrcyh0YylcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aWNrU2l6ZSgwKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRpY2tQYWRkaW5nKDMpXG4gICAgICAgICAgICAgICAgICAgICAgICAudGlja1ZhbHVlcyh0dilcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aWNrRm9ybWF0KChkLCBpKSA9PiByZXN0cmljdExlbmd0aChmaXJzdFkyQXhpc0dlb20uZm9ybWF0WSgpKGQsIGkpLCB5QXhpc1Jlc3RyaWN0aW9uKSksXG4gICAgICAgICAgICAgICAgICAgIGF4aXNPcHRpb25zKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBEcmF3IGEgbGl0dGxlIHgtYXhpcyBmb3IgZXZlcnkgZmFjZXQuXG4gICAgICAgICAgICBpZiAodGhpcy5fc2hvd194X2F4aXMpIHtcbiAgICAgICAgICAgICAgICBmYWNldHMuZm9yRWFjaChmYWNldCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHhTY2FsZSA9IGdlb21ldHJpZXNbMF1cbiAgICAgICAgICAgICAgICAgICAgICAgIC53aWR0aChmYWNldEJhbmQuYmFuZHdpZHRoKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAuaGVpZ2h0KGhlaWdodClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5mYWNldChzaW5nbGVGYWNldCA/IG51bGwgOiAoZCA9PiB0aGlzLl9mYWNldF94KGQpID09PSBmYWNldCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAuZ2V0RDNYU2NhbGUoKTtcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhcmVhID0geEF4aXNBcmVhXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyAoZmFjZXRCYW5kKGZhY2V0KSkgKyBcIiwwKVwiKS8vICsgKHRoaXMuX2hlaWdodCAtIGF4aXNIZWlnaHQpICtcIilcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwid2lkdGhcIiwgZmFjZXRCYW5kLmJhbmR3aWR0aCgpKTtcblxuXG4gICAgICAgICAgICAgICAgICAgIHhheGlzKGFyZWEsIHRoaXMuX2hlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHhTY2FsZS5iYW5kd2lkdGggPyB4U2NhbGUuYmFuZHdpZHRoKCkgOiBmYWNldEJhbmQuYmFuZHdpZHRoKCkgLyB4U2NhbGUuZG9tYWluKCkubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICAgICAgZDMuYXhpc0JvdHRvbSh4U2NhbGUpLnRpY2tzKHhUaWNrQ291bnQpLnRpY2tTaXplKHRoaXMuX3hfZ3JpZF9saW5lcyA/IC1oZWlnaHQgOiAwKS50aWNrUGFkZGluZyg2KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aWNrRm9ybWF0KChkLCBpKSA9PiByZXN0cmljdExlbmd0aChnZW9tZXRyaWVzWzBdLmZvcm1hdFgoKShkLCBpKSwgeEF4aXNSZXN0cmljdGlvbikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRpY2tWYWx1ZXModGhpcy5feF90aWNrX3ZhbHVlc19mbiA/IHRoaXMuX3hfdGlja192YWx1ZXNfZm4oeFNjYWxlKSA6IG51bGwpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbXBvcnRhbmNlWCgpLCBheGlzT3B0aW9ucylcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBTZXR1cCBsYWJlbHNcblxuICAgICAgICBpZiAodGhpcy5fc2hvd195X2F4aXMpIHlBeGlzTGFiZWwoc3ZnLCBoZWlnaHQsIG1hcmdpbiwgdGhpcy5feV9heGlzX2xhYmVsLCBheGlzT3B0aW9ucywgMCk7XG4gICAgICAgIGlmICh0aGlzLl9zaG93X3kyX2F4aXMpIHtcbiAgICAgICAgICAgIHlBeGlzTGFiZWwoc3ZnLCBoZWlnaHQsIG1hcmdpbiwgdGhpcy5feTJfYXhpc19sYWJlbCwgYXhpc09wdGlvbnMsIG1hcmdpbi5sZWZ0ICsgd2lkdGggKyB5MkF4aXNXaWR0aCArIDIwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fc2hvd194X2F4aXMpIHhBeGlzTGFiZWwoc3ZnLCB3aWR0aCwgaGVpZ2h0LCBtYXJnaW4sIHRoaXMuX3hfYXhpc19sYWJlbCwgYXhpc09wdGlvbnMpO1xuXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gRHJhdyBpbmRpdmlkdWFsIGdlb21ldHJpZXMuXG5cbiAgICAgICAgZmFjZXRBcmVhc1xuICAgICAgICAgICAgLmVudGVyKClcbiAgICAgICAgICAgIC5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwiZmFjZXRcIilcbiAgICAgICAgICAgIC5tZXJnZShmYWNldEFyZWFzKVxuICAgICAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCBmYWNldEJhbmQuYmFuZHdpZHRoKCkpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBmYWNldElkID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoc2luZ2xlRmFjZXQpIHJldHVybiBcInRyYW5zbGF0ZSgwLDApXCI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwidHJhbnNsYXRlKFwiICsgZmFjZXRCYW5kKGZhY2V0SWQpICsgXCIsMClcIjtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuZWFjaCgoZmFjZXQsIGZhY2V0X2ksIGZhY2V0Tm9kZXMpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBhcmVhID0gZDMuc2VsZWN0KGZhY2V0Tm9kZXNbZmFjZXRfaV0pO1xuXG4gICAgICAgICAgICAgICAgbGV0IGdlb21zID0gYXJlYS5zZWxlY3RBbGwoXCIuZ2VvbWV0cnlcIikuZGF0YShnZW9tZXRyaWVzLCBkID0+IGQua2V5KCkpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgeHNjYWxlID0gZ2VvbWV0cmllc1swXS5nZXREM1hTY2FsZSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGdlb21fd2lkdGggID0gZmFjZXRCYW5kLmJhbmR3aWR0aCgpLFxuICAgICAgICAgICAgICAgICAgICAgIGdlb21faGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgICAgICAgICAgICAgLy95R3JpZChhcmVhLCBnZW9tX3dpZHRoLCB0aGlzLnNjYWxlWSgpLmlzU2hvd0dyaWQoKSwgZDMuYXhpc0xlZnQoeVNjYWxlKS50aWNrcyh5VGlja0NvdW50KSk7XG4gICAgICAgICAgICAgICAgLy94R3JpZChhcmVhLCBnZW9tX2hlaWdodCwgdGhpcy5zY2FsZVgoKS5pc1Nob3dHcmlkKCksIGQzLmF4aXNCb3R0b20oeHNjYWxlKS50aWNrcyh4VGlja0NvdW50KSk7XG5cbiAgICAgICAgICAgICAgICBnZW9tcy5leGl0KCkucmVtb3ZlKCk7XG5cbiAgICAgICAgICAgICAgICBnZW9tcy5lbnRlcigpXG4gICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImdlb21ldHJ5XCIpXG4gICAgICAgICAgICAgICAgICAgICAubWVyZ2UoZ2VvbXMpXG4gICAgICAgICAgICAgICAgICAgICAuZWFjaCgoZ2VvbSwgaSwgbm9kZXMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBnZW9tX3RvcCAgPSAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlb21fbGVmdCA9IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbm9kZSA9IGQzLnNlbGVjdChub2Rlc1tpXSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICBub2RlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgZ2VvbV9sZWZ0ICsgXCIsXCIgKyBnZW9tX3RvcCArIFwiKVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZWFjaCgoZCwgaSwgbm9kZXMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlb20uZWxlbWVudChkMy5zZWxlY3Qobm9kZXNbaV0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5mYWNldChzaW5nbGVGYWNldCA/IG51bGwgOiAoZCA9PiB0aGlzLl9mYWNldF94KGQpID09PSBmYWNldCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmhlaWdodChnZW9tX2hlaWdodClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAud2lkdGgoZ2VvbV93aWR0aClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVuZGVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIEVuc3VyZSB0aGlzIGlzIHJlbmRlcmVkIG9uIHRvcCBvZiBvdGhlciB0aGluZ3MuXG4gICAgICAgICAgICAgICAgYXJlYS5zZWxlY3QoXCIueC1heGlzXCIpLnJhaXNlKCk7XG4gICAgICAgICAgICB9KVxuXG4gICAgICAgIC8vIHJlLXJlbmRlciB0aGUgbGVnZW5kIGlmIGFueSBnZW9tZXRyaWVzIGFyZSB1c2luZyBncmFkaWVudHMgc28gdGhlIGxlZ2VuZCBjYW4gdXNlIHRoZSBncmFkaWVudCB3aGljaCBpc1xuICAgICAgICAvLyBvbmx5IGNyZWF0ZWQgd2hlbiB0aGUgZ2VvbWV0cnkgaXMgcmVuZGVyZWRcbiAgICAgICAgaWYgKHJlbmRlckxlZ2VuZEZuICYmIGdlb21ldHJpZXMuZmluZChnID0+IGcuZ3JhZGllbnRJZCkpIHJlbmRlckxlZ2VuZEZuKClcbiAgICB9XG5cblxuICAgIC8qXG4gICAgICogRW5zdXJlcyB0aGF0IGVhY2ggZ2VvbSBoYXMgdGhlIHNldHRpbmdzIHRoYXQgaXQgbmVlZHMuXG4gICAgICovXG4gICAgc2V0dXBHZW9tKGdlb20sIGJzKSB7XG4gICAgICAgIGlmICghZ2VvbS5zZXR1cFkoKSkgZ2VvbS5zZXR1cFkodGhpcy5feV9nZXR0ZXIpXG5cbiAgICAgICAgZ2VvbS5zZXR1cFgodGhpcy5feF9nZXR0ZXIpXG4gICAgICAgICAgICAuc2V0dXBDb2xvdXIodGhpcy5fY29sb3VyKVxuICAgICAgICAgICAgLnNldHVwU2l6ZSh0aGlzLl9zaXplKVxuICAgICAgICAgICAgLnNldHVwU2NhbGVYKHRoaXMuX3NjYWxlX3gpXG4gICAgICAgICAgICAuc2V0dXBGb3JtYXRYKHRoaXMuX3hfZm9ybWF0dGVyKVxuICAgICAgICAgICAgLnNldHVwRm9ybWF0TGFiZWwodGhpcy5fbGFiZWxfZm9ybWF0dGVyKVxuICAgICAgICAgICAgLnNldHVwTW9kaWZ5Q29sb3VyKHRoaXMuX21vZGlmeV9jb2xvdXIpXG4gICAgICAgICAgICAuc2V0dXBTaG93TGFiZWxzKHRoaXMuX3Nob3dfbGFiZWxzKVxuICAgICAgICAgICAgLnNldHVwWUF4aXNMYWJlbCh0aGlzLl95X2F4aXNfbGFiZWwpXG4gICAgICAgICAgICAuc2V0dXBYQXhpc0xhYmVsKHRoaXMuX3hfYXhpc19sYWJlbClcbiAgICAgICAgICAgIC5mb250U2l6ZSh0aGlzLl9mb250X3NpemUpO1xuXG4gICAgICAgIGlmICghZ2VvbS5zZXR1cEZvcm1hdFkoKSkgZ2VvbS5zZXR1cEZvcm1hdFkodGhpcy5feV9mb3JtYXR0ZXIpXG4gICAgICAgIGlmICghZ2VvbS51c2VZMkF4aXMoKSkgZ2VvbS5zZXR1cFNjYWxlWSh0aGlzLl9zY2FsZV95KVxuXG4gICAgICAgIGlmICh0aGlzLl9jb2xvdXJfc2NhbGUpIHtcbiAgICAgICAgICAgIGdlb20uc2V0dXBDb2xvdXJTY2FsZSh0aGlzLl9jb2xvdXJfc2NhbGUpXG4gICAgICAgICAgICBpZiAodGhpcy5fZDNfY29sb3VyX3NjYWxlKSBnZW9tLmQzQ29sb3VyU2NhbGUoZDMuc2NhbGVPcmRpbmFsKHRoaXMuX2QzX2NvbG91cl9zY2FsZSkpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnZW9tLmQzQ29sb3VyU2NhbGUoZDMuc2NhbGVPcmRpbmFsKGdlb20uY29sb3VyU2NhbGUoKSkuZG9tYWluKEFycmF5LmZyb20oYnMuY29sb3VycykpKVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9pbmRpdmlkdWFsX2NvbG91cnMpIGdlb20uc2V0dXBJbmRpdmlkdWFsQ29sb3Vycyh0aGlzLl9pbmRpdmlkdWFsX2NvbG91cnMpXG5cbiAgICAgICAgZ2VvbS5fZGlzcGF0Y2gub24oXCJlbGVtZW50Q2xpY2tcIiwgKGUpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2Rpc3BhdGNoLmNhbGwoXCJlbGVtZW50Q2xpY2tcIiwgdGhpcywgZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBnZW9tLl9kaXNwYXRjaC5vbihcInRvb2x0aXBIaWRlXCIsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2Rpc3BhdGNoLmNhbGwoXCJ0b29sdGlwSGlkZVwiLCB0aGlzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGdlb20uX2Rpc3BhdGNoLm9uKFwidG9vbHRpcFNob3dcIiwgKGUpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2Rpc3BhdGNoLmNhbGwoXCJ0b29sdGlwU2hvd1wiLCB0aGlzLCBlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGdlb20uZGF0YSh0aGlzLl9kYXRhKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFdlIHdhbnQgdG8gZW5zdXJlIHRoYXQgZ2VvbWV0cmllcyBoYXZlIGEgcGFydGljdWxhciBvcmRlciB0byB0aGVtLlxuICAgICAqIFRoaXMgaXMgaW1wb3J0YW50IGZvciByZW5kZXJpbmc6IGxpbmVzIHNob3VsZCBiZSByZW5kZXJlZCBvbiB0b3Agb2ZcbiAgICAgKiBsYXJnZSBoaXN0b2dyYW0gcmVjdGFuZ2xlcywgZm9yIGluc3RhbmNlLCBvdGhlcndpc2UgdGhleSB3aWxsIGJlIGhpZGRlbi5cbiAgICAgKi9cbiAgICBzb3J0R2VvbWV0cmllcygpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9nZW9tZXRyaWVzIHx8ICF0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aCkgcmV0dXJuIFtdO1xuXG4gICAgICAgIGxldCBnZW9tZXRyaWVzID0gdGhpcy5fZ2VvbWV0cmllcy5zbGljZSgwKTtcbiAgICAgICAgZ2VvbWV0cmllcy5zb3J0KChsaHMsIHJocykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGxocy5wcmlvcml0eSgpIC0gcmhzLnByaW9yaXR5KCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBnZW9tZXRyaWVzO1xuICAgIH1cbn1cblxuXG4vKlxuICogUmV0dXJucyB0aGUgdW5pcXVlIGZhY2V0IGNob2ljZXMgZnJvbSB0aGUgZGF0YSwgZ2l2ZW4gYSBmYWNldCBzZWxlY3Rvci5cbiAqL1xuZnVuY3Rpb24gZ2V0RmFjZXRzKGRhdGEsIHNlbGVjdG9yKSB7XG4gICAgaWYgKCFzZWxlY3RvciB8fCAhZGF0YSB8fCAhZGF0YS5sZW5ndGgpIHJldHVybiBbMV07XG5cbiAgICBjb25zdCBrZXlzID0gbmV3IFNldChkYXRhLm1hcChzZWxlY3RvcikpO1xuICAgIHJldHVybiBbLi4ua2V5c107XG59XG5cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgY2hhcnQgb2JqZWN0LlxuICogQHBhcmFtIG5hbWUgQW4gb3B0aW9uYWwgbmFtZSBmb3IgdGhlIGNoYXJ0LlxuICogQHJldHVybnMge0ZhbnRhc3RpY0NoYXJ0fVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2hhcnQobmFtZSkge1xuICAgIHJldHVybiBuZXcgRmFudGFzdGljQ2hhcnQobmFtZSk7XG59Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/chart/FantasticChart.js\n')},"./src/chart/Geometry.js":
/*!*******************************!*\
  !*** ./src/chart/Geometry.js ***!
  \*******************************/
/*! exports provided: Geometry, getColor, getKey, fromKey */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Geometry", function() { return Geometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getColor", function() { return getColor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getKey", function() { return getKey; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromKey", function() { return fromKey; });\n// Copyright (C) 2013-2014, 2018 BrandsEye (PTY) LTD\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this\n// software and associated documentation files (the "Software"), to deal in the Software\n// without restriction, including without limitation the rights to use, copy, modify,\n//     merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following\n// conditions:\n//\n//     The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n//     INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n// CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\nclass Geometry {\n\n    constructor(name, priority) {\n        this._name = name || "[UNNAMED GEOMETRY]";\n        this._chart_x_getter = null;\n        this._chart_y_getter = null;\n        this._x_getter = null;\n        this._x2_getter = null;\n        this._y_getter = null;\n        this._y2_getter = null;\n        this._colour = null;\n        this._size = null;\n        this._scale_x = null;\n        this._scale_y = null;\n        this._axis_max_value = null;\n        this._axis_min_value = null;\n        this._facet_selector = null;\n        this._chart_colour_scale = null;\n        this._colour_scale = null;\n        this._individual_colours = null;\n        this._chart_individual_colours = null;\n        this._modify_colour = null;\n        this._chart_modify_colour = null;\n        this._x_formatter = null;\n        this._y_formatter = null;\n        this._chart_x_formatter = null;\n        this._chart_y_formatter = null;\n        this._y_axis_label = null;\n        this._x_axis_label = null;\n        this._chart_y_axis_label = null;\n        this._chart_x_axis_label = null;\n        this._label_formatter = null;\n        this._chart_label_formatter = null;\n        this._priority = priority || 1;\n        this._dispatch = d3.dispatch(\'elementClick\', \'elementMiddleClick\', \'elementRightClick\',\n            \'tooltipShow\', \'tooltipHide\');\n        this._show_labels = null;\n        this._chart_show_labels = null;\n        this._d3_colour_scale = null;\n        this._stroke_width = null;\n        this._font_size = 12;\n        this._padding = 0;\n        this._use_y2_axis = false;\n        this._gradient_fn = null;\n        this._opacity = null\n        this._index = 0;  // Used for generating unique keys\n    }\n\n    name() {\n        return this._name;\n    }\n\n    /**\n     * Used for generating a unique key.\n     */\n    index(i) {\n        if (arguments.length === 0) return this._index;\n        this._index = i;\n        return this;\n    }\n\n    key() {\n        return `${this._index}:${this._name}`\n    }\n\n    /**\n     * Provides a sort order priority for metrics. Metrics with a higher priority\n     * are drawn on top of lower priority metrics.\n     */\n    priority() {\n        return this._priority;\n    }\n\n    element(el) {\n        if (arguments.length === 0) return this._element;\n        this._element = el;\n        return this;\n    }\n\n    x(getter) {\n        if (arguments.length === 0) return this._x_getter || this._chart_x_getter;\n        if (typeof getter !== \'function\') throw new Error("x getter must be a function");\n        this._x_getter = getter;\n        return this;\n    }\n\n    x2(getter) {\n        if (arguments.length === 0) return this._x2_getter\n        if (getter && typeof getter !== \'function\') throw new Error("x2 getter must be a function");\n        this._x2_getter = getter;\n        return this;\n    }\n\n    y(getter) {\n        if (arguments.length === 0) return this._y_getter || this._chart_y_getter;\n        if (typeof getter !== \'function\') throw new Error("y getter must be a function");\n        this._y_getter = getter;\n        return this;\n    }\n\n    y2(getter) {\n        if (arguments.length === 0) return this._y2_getter;\n        if (getter && typeof getter !== \'function\') throw new Error("y2 getter must be a function");\n        this._y2_getter = getter;\n        return this;\n    }\n\n    setupX(getter) {\n        if (arguments.length === 0) return this._chart_x_getter;\n        if (typeof getter !== \'function\') throw new Error("x getter must be a function");\n        this._chart_x_getter = getter;\n        return this;\n    }\n\n    setupY(getter) {\n        if (arguments.length === 0) return this._chart_y_getter;\n        if (typeof getter !== \'function\') throw new Error("y getter must be a function");\n        this._chart_y_getter = getter;\n        return this;\n    }\n\n    colour(colour) {\n        if (arguments.length === 0) return this._colour || this._chart_colour;\n        this._colour = colour;\n        return this;\n    }\n\n    setupColour(colour) {\n        if (arguments.length === 0) return this._chart_colour;\n        this._chart_colour = colour;\n        return this;\n    }\n\n    colourScale(colours) {\n        if (arguments.length === 0) return this._chart_colour_scale || this._colour_scale;\n        if (typeof colours !== \'object\' || !colours.length) throw new Error("colour must be an Array");\n        this._colour_scale = colours;\n        return this;\n    }\n\n    setupColourScale(colours) {\n        if (arguments.length === 0) return this._chart_colour_scale;\n        if (typeof colours !== \'object\' || !colours.length) throw new Error("colour must be an Array");\n        this._chart_colour_scale = colours;\n        return this;\n    }\n\n    individualColours(colourMap) {\n        if (arguments.length === 0) return this._individual_colours || this._chart_individual_colours;\n        this._individual_colours = colourMap;\n        return this;\n    }\n\n    setupIndividualColours(colourMap) {\n        if (arguments.length === 0) return this._chart_individual_colours;\n        this._chart_individual_colours = colourMap;\n        return this;\n    }\n\n    modifyColour(modifier) {\n        if (arguments.length === 0) return this._modify_colour || this._chart_modify_colour;\n        this._modify_colour = modifier;\n        return this;\n    }\n\n    setupModifyColour(modifier) {\n        if (arguments.length === 0) return this._chart_modify_colour;\n        this._chart_modify_colour = modifier;\n        return this;\n    }\n\n    d3ColourScale(scale) {\n        if (arguments.length === 0) return this._d3_colour_scale;\n        this._d3_colour_scale = scale;\n        return this;\n    }\n\n    getD3Colour(d) {\n        return getColor(d, this.d3ColourScale(), this.individualColours(), this.modifyColour());\n    }\n\n    size(size) {\n        if (arguments.length === 0) return this._size || this._chart_size;\n        this._size = size;\n        return this;\n    }\n\n    setupSize(size) {\n        if (arguments.length === 0) return this._chart_size;\n        this._chart_size = size;\n        return this;\n    }\n\n    scaleX(scale) {\n        if (arguments.length === 0) return this._scale_x || this._chart_scale_x;\n        this._scale_x = scale;\n        return this;\n    }\n\n    setupScaleX(scale) {\n        if (arguments.length === 0) return this._chart_scale_x;\n        this._chart_scale_x = scale;\n        return this;\n    }\n\n    scaleY(scale) {\n        if (arguments.length === 0) return this._scale_y || this._chart_scale_y;\n        this._scale_y = scale;\n        return this;\n    }\n\n    setupScaleY(scale) {\n        if (arguments.length === 0) return this._chart_scale_y;\n        this._chart_scale_y = scale;\n        return this;\n    }\n\n    formatX(formatter) {\n        if (arguments.length === 0) return this._x_formatter || this._chart_x_formatter;\n        if (typeof formatter !== \'function\') throw new Error("formatter must be a function");\n        this._x_formatter = formatter;\n        return this;\n    }\n\n    setupFormatX(formatter) {\n        if (arguments.length === 0) return this._chart_x_formatter;\n        if (typeof formatter !== \'function\') throw new Error("formatter must be a function");\n        this._chart_x_formatter = formatter;\n        return this;\n    }\n\n    formatY(formatter) {\n        if (arguments.length === 0) return this._y_formatter || this._chart_y_formatter;\n        if (typeof formatter !== \'function\') throw new Error("formatter must be a function");\n        this._y_formatter = formatter;\n        return this;\n    }\n\n    setupFormatY(formatter) {\n        if (arguments.length === 0) return this._chart_y_formatter;\n        if (typeof formatter !== \'function\') throw new Error("formatter must be a function");\n        this._chart_y_formatter = formatter;\n        return this;\n    }\n\n    formatLabel(formatter) {\n        if (arguments.length === 0) return this._label_formatter || this._chart_label_formatter || this.formatY();\n        if (typeof formatter !== \'function\') throw new Error("formatter must be a function");\n        this._label_formatter = formatter;\n        return this;\n    }\n\n    setupFormatLabel(formatter) {\n        if (arguments.length === 0) return this._chart_label_formatter;\n        this._chart_label_formatter = formatter;\n        return this;\n    }\n\n    width(width) {\n        if (arguments.length === 0) return this._width;\n        this._width = width;\n        return this;\n    }\n\n    height(height) {\n        if (arguments.length === 0) return this._height;\n        this._height = height;\n        return this;\n    }\n\n    axisMaxValue(v) {\n        if (arguments.length === 0) return this._axis_max_value;\n        this._axis_max_value = v;\n        return this;\n    }\n\n    axisMinValue(v) {\n        if (arguments.length === 0) return this._axis_min_value;\n        this._axis_min_value = v;\n        return this;\n    }\n\n    showLabels(show) {\n        if (arguments.length === 0) return this._chart_show_labels || this._show_labels;\n        this._show_labels = !!show;\n        return this;\n    }\n\n    setupShowLabels(show) {\n        if (arguments.length === 0) return this._chart_show_labels;\n        this._chart_show_labels = !!show;\n        return this;\n    }\n\n    yAxisLabel(label) {\n        if (arguments.length === 0) return this._chart_y_axis_label || this._y_axis_label;\n        this._y_axis_label = label;\n        return this;\n    }\n\n    setupYAxisLabel(label) {\n        if (arguments.length === 0) return this._chart_y_axis_label;\n        this._chart_y_axis_label = label;\n        return this;\n    }\n\n    xAxisLabel(label) {\n        if (arguments.length === 0) return this._chart_x_axis_label || this._x_axis_label;\n        this._x_axis_label = label;\n        return this;\n    }\n\n    setupXAxisLabel(label) {\n        if (arguments.length === 0) return this._chart_x_axis_label;\n        this._chart_x_axis_label = label;\n        return this;\n    }\n\n    gradientFn(fn) {\n        if (arguments.length === 0) return this._gradient_fn;\n        if (fn && typeof fn !== "function") throw new Error("gradientFn must be a function");\n        this._gradient_fn = fn;\n        return this;\n    }\n\n    opacity(v) {\n        if (arguments.length === 0) return this._opacity;\n        if (v && typeof v !== "number") throw new Error("opacity must be a number");\n        this._opacity = v;\n        return this;\n    }\n\n    immediatelyRenderLabels(show) {\n        console.warn("#immediatelyRenderLabels not implemented for", this.name());\n    }\n\n    data(data) {\n        if (arguments.length === 0) return this._data;\n        this._data = data;\n        return this;\n    }\n\n    facet(selector) {\n        if (arguments.length === 0) return this._facet_selector;\n        if (selector != null && typeof selector !== \'function\' && selector !== null) throw new Error("Facet selector must be a function");\n        this._facet_selector = selector;\n        return this;\n    }\n\n    strokeWidth(pixels) {\n        if (arguments.length === 0) return this._stroke_width;\n        this._stroke_width = pixels;\n        return this;\n    }\n\n    fontSize(px) {\n        if (arguments.length === 0) return this._font_size;\n        if (typeof px !== "number" && px > 0) throw new Error("fontSize must be a positive number");\n        this._font_size = px;\n        return this;\n    }\n\n    padding(padding) {\n        if (arguments.length === 0) return this._padding;\n        this._padding = padding;\n        return this;\n    }\n\n    useY2Axis(on) {\n        if (arguments.length === 0) return this._use_y2_axis;\n        this._use_y2_axis = !!on;\n        return this;\n    }\n\n    /*\n     * This takes our array of data, and determines what elements\n     * are to be mapped to what aesthetic values, such as colour or size.\n     * Data is grouped by these fields.\n     */\n    prepareData(data, faceted) {\n        faceted = !!faceted && this.facet();\n        data = data || this._data;\n        if (!data || !data.length) return [];\n\n        const x = this.x(),\n              x2 = this.x2(),\n              y = this.y(),\n              y2 = this.y2(),\n              scaleX = this.scaleX(),\n              scaleY = this.scaleY();\n\n        let mapped = {};\n\n        data.forEach(d => {\n            if (faceted && !this.facet()(d)) return;\n            const object = Object.assign({\n                _x: scaleX.transform(x(d)),\n                _y: scaleY.transform(y(d)),\n                _colour: this.colour()(d),\n                _size: this.size()(d)\n            }, d);\n            if (x2) object._x2 = scaleX.transform(x2(d))\n            if (y2) object._y2 = scaleY.transform(y2(d))\n\n            const key = getKey(object);\n            object._key = key;\n\n            let series = mapped[key] || getKeyParameters(object);\n            series.data.push(object);\n            mapped[key] = series;\n        });\n\n        return Object.values(mapped);\n    }\n\n    getD3XScale() {\n        throw new Error("getD3XScale not implemented for " + this.name());\n    }\n\n    getD3YScale() {\n        throw new Error("getD3YScale not implemented for " + this.name());\n    }\n\n    /**\n     * Get all the Y values for this geometry, ignoring faceting.\n     */\n    yValues() {\n        return this.data()\n            .map(d => this.y()(d))\n            .map(d => this.scaleY().transform(d));\n    }\n\n    /**\n     * Get all the X values for this geometry, ignoring faceting.\n     */\n    xValues() {\n        return this.data()\n                   .map(d => this.x()(d))\n                   .map(d => this.scaleX().transform(d));\n    }\n\n\n    /**\n     * Implement your render code here.\n     */\n    render() {\n        throw new Error("RENDER NOT IMPLEMENTED FOR " + this.name());\n    }\n\n\n    /**\n     * Returns the unique values that the colour function\n     * returns.\n     * @param data\n     * @returns {*}\n     */\n    getColourDomain(data) {\n        if (!data || !data.length) return [];\n\n        const colours = new Set();\n\n        // todo calculate buckets\n        data.forEach(series => {\n            series.data.forEach(d => {\n                colours.add(this.colour()(d))\n            });\n        });\n\n        return [...colours]\n    }\n\n}\n\nfunction getColor(d, d3ColourScale, individualColours, modifyColour) {\n        const defaultColour = d3ColourScale(d._colour);\n        return modifyColour(individualColours(d, defaultColour) || defaultColour);\n}\n\nfunction getKey(d) {\n    // TODO we probably need to encode this better so we can split on the :\n    return "" + d._colour;\n}\n\nfunction fromKey(key) {\n    return {\n        _colour: key,\n        _key: key\n    }\n}\n\nfunction getKeyParameters(d) {\n    return {\n        _key: getKey(d),\n        _size: d._size,\n        _colour: d._colour,\n        data: []\n    }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY2hhcnQvR2VvbWV0cnkuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9iM2pzLy4vc3JjL2NoYXJ0L0dlb21ldHJ5LmpzPzc5MDkiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChDKSAyMDEzLTIwMTQsIDIwMTggQnJhbmRzRXllIChQVFkpIExURFxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpc1xuLy8gc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlXG4vLyB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksXG4vLyAgICAgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0b1xuLy8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcbi8vIGNvbmRpdGlvbnM6XG4vL1xuLy8gICAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuLy8gY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyAgICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUiBJTVBMSUVELFxuLy8gICAgIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBXG4vLyBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUXG4vLyBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0Zcbi8vIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRVxuLy8gT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cblxuZXhwb3J0IGNsYXNzIEdlb21ldHJ5IHtcblxuICAgIGNvbnN0cnVjdG9yKG5hbWUsIHByaW9yaXR5KSB7XG4gICAgICAgIHRoaXMuX25hbWUgPSBuYW1lIHx8IFwiW1VOTkFNRUQgR0VPTUVUUlldXCI7XG4gICAgICAgIHRoaXMuX2NoYXJ0X3hfZ2V0dGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5fY2hhcnRfeV9nZXR0ZXIgPSBudWxsO1xuICAgICAgICB0aGlzLl94X2dldHRlciA9IG51bGw7XG4gICAgICAgIHRoaXMuX3gyX2dldHRlciA9IG51bGw7XG4gICAgICAgIHRoaXMuX3lfZ2V0dGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5feTJfZ2V0dGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5fY29sb3VyID0gbnVsbDtcbiAgICAgICAgdGhpcy5fc2l6ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3NjYWxlX3ggPSBudWxsO1xuICAgICAgICB0aGlzLl9zY2FsZV95ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fYXhpc19tYXhfdmFsdWUgPSBudWxsO1xuICAgICAgICB0aGlzLl9heGlzX21pbl92YWx1ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX2ZhY2V0X3NlbGVjdG9yID0gbnVsbDtcbiAgICAgICAgdGhpcy5fY2hhcnRfY29sb3VyX3NjYWxlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fY29sb3VyX3NjYWxlID0gbnVsbDtcbiAgICAgICAgdGhpcy5faW5kaXZpZHVhbF9jb2xvdXJzID0gbnVsbDtcbiAgICAgICAgdGhpcy5fY2hhcnRfaW5kaXZpZHVhbF9jb2xvdXJzID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbW9kaWZ5X2NvbG91ciA9IG51bGw7XG4gICAgICAgIHRoaXMuX2NoYXJ0X21vZGlmeV9jb2xvdXIgPSBudWxsO1xuICAgICAgICB0aGlzLl94X2Zvcm1hdHRlciA9IG51bGw7XG4gICAgICAgIHRoaXMuX3lfZm9ybWF0dGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5fY2hhcnRfeF9mb3JtYXR0ZXIgPSBudWxsO1xuICAgICAgICB0aGlzLl9jaGFydF95X2Zvcm1hdHRlciA9IG51bGw7XG4gICAgICAgIHRoaXMuX3lfYXhpc19sYWJlbCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3hfYXhpc19sYWJlbCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2NoYXJ0X3lfYXhpc19sYWJlbCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2NoYXJ0X3hfYXhpc19sYWJlbCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2xhYmVsX2Zvcm1hdHRlciA9IG51bGw7XG4gICAgICAgIHRoaXMuX2NoYXJ0X2xhYmVsX2Zvcm1hdHRlciA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByaW9yaXR5ID0gcHJpb3JpdHkgfHwgMTtcbiAgICAgICAgdGhpcy5fZGlzcGF0Y2ggPSBkMy5kaXNwYXRjaCgnZWxlbWVudENsaWNrJywgJ2VsZW1lbnRNaWRkbGVDbGljaycsICdlbGVtZW50UmlnaHRDbGljaycsXG4gICAgICAgICAgICAndG9vbHRpcFNob3cnLCAndG9vbHRpcEhpZGUnKTtcbiAgICAgICAgdGhpcy5fc2hvd19sYWJlbHMgPSBudWxsO1xuICAgICAgICB0aGlzLl9jaGFydF9zaG93X2xhYmVscyA9IG51bGw7XG4gICAgICAgIHRoaXMuX2QzX2NvbG91cl9zY2FsZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3N0cm9rZV93aWR0aCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2ZvbnRfc2l6ZSA9IDEyO1xuICAgICAgICB0aGlzLl9wYWRkaW5nID0gMDtcbiAgICAgICAgdGhpcy5fdXNlX3kyX2F4aXMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZ3JhZGllbnRfZm4gPSBudWxsO1xuICAgICAgICB0aGlzLl9vcGFjaXR5ID0gbnVsbFxuICAgICAgICB0aGlzLl9pbmRleCA9IDA7ICAvLyBVc2VkIGZvciBnZW5lcmF0aW5nIHVuaXF1ZSBrZXlzXG4gICAgfVxuXG4gICAgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlZCBmb3IgZ2VuZXJhdGluZyBhIHVuaXF1ZSBrZXkuXG4gICAgICovXG4gICAgaW5kZXgoaSkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX2luZGV4O1xuICAgICAgICB0aGlzLl9pbmRleCA9IGk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGtleSgpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuX2luZGV4fToke3RoaXMuX25hbWV9YFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByb3ZpZGVzIGEgc29ydCBvcmRlciBwcmlvcml0eSBmb3IgbWV0cmljcy4gTWV0cmljcyB3aXRoIGEgaGlnaGVyIHByaW9yaXR5XG4gICAgICogYXJlIGRyYXduIG9uIHRvcCBvZiBsb3dlciBwcmlvcml0eSBtZXRyaWNzLlxuICAgICAqL1xuICAgIHByaW9yaXR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpb3JpdHk7XG4gICAgfVxuXG4gICAgZWxlbWVudChlbCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX2VsZW1lbnQ7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQgPSBlbDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgeChnZXR0ZXIpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl94X2dldHRlciB8fCB0aGlzLl9jaGFydF94X2dldHRlcjtcbiAgICAgICAgaWYgKHR5cGVvZiBnZXR0ZXIgIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBFcnJvcihcInggZ2V0dGVyIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgdGhpcy5feF9nZXR0ZXIgPSBnZXR0ZXI7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHgyKGdldHRlcikge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX3gyX2dldHRlclxuICAgICAgICBpZiAoZ2V0dGVyICYmIHR5cGVvZiBnZXR0ZXIgIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBFcnJvcihcIngyIGdldHRlciBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG4gICAgICAgIHRoaXMuX3gyX2dldHRlciA9IGdldHRlcjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgeShnZXR0ZXIpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl95X2dldHRlciB8fCB0aGlzLl9jaGFydF95X2dldHRlcjtcbiAgICAgICAgaWYgKHR5cGVvZiBnZXR0ZXIgIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBFcnJvcihcInkgZ2V0dGVyIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgdGhpcy5feV9nZXR0ZXIgPSBnZXR0ZXI7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHkyKGdldHRlcikge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX3kyX2dldHRlcjtcbiAgICAgICAgaWYgKGdldHRlciAmJiB0eXBlb2YgZ2V0dGVyICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgRXJyb3IoXCJ5MiBnZXR0ZXIgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICB0aGlzLl95Ml9nZXR0ZXIgPSBnZXR0ZXI7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHNldHVwWChnZXR0ZXIpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl9jaGFydF94X2dldHRlcjtcbiAgICAgICAgaWYgKHR5cGVvZiBnZXR0ZXIgIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBFcnJvcihcInggZ2V0dGVyIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgdGhpcy5fY2hhcnRfeF9nZXR0ZXIgPSBnZXR0ZXI7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHNldHVwWShnZXR0ZXIpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl9jaGFydF95X2dldHRlcjtcbiAgICAgICAgaWYgKHR5cGVvZiBnZXR0ZXIgIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBFcnJvcihcInkgZ2V0dGVyIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgdGhpcy5fY2hhcnRfeV9nZXR0ZXIgPSBnZXR0ZXI7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGNvbG91cihjb2xvdXIpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl9jb2xvdXIgfHwgdGhpcy5fY2hhcnRfY29sb3VyO1xuICAgICAgICB0aGlzLl9jb2xvdXIgPSBjb2xvdXI7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHNldHVwQ29sb3VyKGNvbG91cikge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX2NoYXJ0X2NvbG91cjtcbiAgICAgICAgdGhpcy5fY2hhcnRfY29sb3VyID0gY29sb3VyO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBjb2xvdXJTY2FsZShjb2xvdXJzKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5fY2hhcnRfY29sb3VyX3NjYWxlIHx8IHRoaXMuX2NvbG91cl9zY2FsZTtcbiAgICAgICAgaWYgKHR5cGVvZiBjb2xvdXJzICE9PSAnb2JqZWN0JyB8fCAhY29sb3Vycy5sZW5ndGgpIHRocm93IG5ldyBFcnJvcihcImNvbG91ciBtdXN0IGJlIGFuIEFycmF5XCIpO1xuICAgICAgICB0aGlzLl9jb2xvdXJfc2NhbGUgPSBjb2xvdXJzO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzZXR1cENvbG91clNjYWxlKGNvbG91cnMpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl9jaGFydF9jb2xvdXJfc2NhbGU7XG4gICAgICAgIGlmICh0eXBlb2YgY29sb3VycyAhPT0gJ29iamVjdCcgfHwgIWNvbG91cnMubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoXCJjb2xvdXIgbXVzdCBiZSBhbiBBcnJheVwiKTtcbiAgICAgICAgdGhpcy5fY2hhcnRfY29sb3VyX3NjYWxlID0gY29sb3VycztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaW5kaXZpZHVhbENvbG91cnMoY29sb3VyTWFwKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5faW5kaXZpZHVhbF9jb2xvdXJzIHx8IHRoaXMuX2NoYXJ0X2luZGl2aWR1YWxfY29sb3VycztcbiAgICAgICAgdGhpcy5faW5kaXZpZHVhbF9jb2xvdXJzID0gY29sb3VyTWFwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzZXR1cEluZGl2aWR1YWxDb2xvdXJzKGNvbG91ck1hcCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX2NoYXJ0X2luZGl2aWR1YWxfY29sb3VycztcbiAgICAgICAgdGhpcy5fY2hhcnRfaW5kaXZpZHVhbF9jb2xvdXJzID0gY29sb3VyTWFwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBtb2RpZnlDb2xvdXIobW9kaWZpZXIpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl9tb2RpZnlfY29sb3VyIHx8IHRoaXMuX2NoYXJ0X21vZGlmeV9jb2xvdXI7XG4gICAgICAgIHRoaXMuX21vZGlmeV9jb2xvdXIgPSBtb2RpZmllcjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgc2V0dXBNb2RpZnlDb2xvdXIobW9kaWZpZXIpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl9jaGFydF9tb2RpZnlfY29sb3VyO1xuICAgICAgICB0aGlzLl9jaGFydF9tb2RpZnlfY29sb3VyID0gbW9kaWZpZXI7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGQzQ29sb3VyU2NhbGUoc2NhbGUpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl9kM19jb2xvdXJfc2NhbGU7XG4gICAgICAgIHRoaXMuX2QzX2NvbG91cl9zY2FsZSA9IHNjYWxlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBnZXREM0NvbG91cihkKSB7XG4gICAgICAgIHJldHVybiBnZXRDb2xvcihkLCB0aGlzLmQzQ29sb3VyU2NhbGUoKSwgdGhpcy5pbmRpdmlkdWFsQ29sb3VycygpLCB0aGlzLm1vZGlmeUNvbG91cigpKTtcbiAgICB9XG5cbiAgICBzaXplKHNpemUpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl9zaXplIHx8IHRoaXMuX2NoYXJ0X3NpemU7XG4gICAgICAgIHRoaXMuX3NpemUgPSBzaXplO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzZXR1cFNpemUoc2l6ZSkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX2NoYXJ0X3NpemU7XG4gICAgICAgIHRoaXMuX2NoYXJ0X3NpemUgPSBzaXplO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzY2FsZVgoc2NhbGUpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl9zY2FsZV94IHx8IHRoaXMuX2NoYXJ0X3NjYWxlX3g7XG4gICAgICAgIHRoaXMuX3NjYWxlX3ggPSBzY2FsZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgc2V0dXBTY2FsZVgoc2NhbGUpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl9jaGFydF9zY2FsZV94O1xuICAgICAgICB0aGlzLl9jaGFydF9zY2FsZV94ID0gc2NhbGU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHNjYWxlWShzY2FsZSkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX3NjYWxlX3kgfHwgdGhpcy5fY2hhcnRfc2NhbGVfeTtcbiAgICAgICAgdGhpcy5fc2NhbGVfeSA9IHNjYWxlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzZXR1cFNjYWxlWShzY2FsZSkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX2NoYXJ0X3NjYWxlX3k7XG4gICAgICAgIHRoaXMuX2NoYXJ0X3NjYWxlX3kgPSBzY2FsZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZm9ybWF0WChmb3JtYXR0ZXIpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl94X2Zvcm1hdHRlciB8fCB0aGlzLl9jaGFydF94X2Zvcm1hdHRlcjtcbiAgICAgICAgaWYgKHR5cGVvZiBmb3JtYXR0ZXIgIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBFcnJvcihcImZvcm1hdHRlciBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG4gICAgICAgIHRoaXMuX3hfZm9ybWF0dGVyID0gZm9ybWF0dGVyO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzZXR1cEZvcm1hdFgoZm9ybWF0dGVyKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5fY2hhcnRfeF9mb3JtYXR0ZXI7XG4gICAgICAgIGlmICh0eXBlb2YgZm9ybWF0dGVyICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgRXJyb3IoXCJmb3JtYXR0ZXIgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICB0aGlzLl9jaGFydF94X2Zvcm1hdHRlciA9IGZvcm1hdHRlcjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZm9ybWF0WShmb3JtYXR0ZXIpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl95X2Zvcm1hdHRlciB8fCB0aGlzLl9jaGFydF95X2Zvcm1hdHRlcjtcbiAgICAgICAgaWYgKHR5cGVvZiBmb3JtYXR0ZXIgIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBFcnJvcihcImZvcm1hdHRlciBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG4gICAgICAgIHRoaXMuX3lfZm9ybWF0dGVyID0gZm9ybWF0dGVyO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzZXR1cEZvcm1hdFkoZm9ybWF0dGVyKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5fY2hhcnRfeV9mb3JtYXR0ZXI7XG4gICAgICAgIGlmICh0eXBlb2YgZm9ybWF0dGVyICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgRXJyb3IoXCJmb3JtYXR0ZXIgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICB0aGlzLl9jaGFydF95X2Zvcm1hdHRlciA9IGZvcm1hdHRlcjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZm9ybWF0TGFiZWwoZm9ybWF0dGVyKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5fbGFiZWxfZm9ybWF0dGVyIHx8IHRoaXMuX2NoYXJ0X2xhYmVsX2Zvcm1hdHRlciB8fCB0aGlzLmZvcm1hdFkoKTtcbiAgICAgICAgaWYgKHR5cGVvZiBmb3JtYXR0ZXIgIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBFcnJvcihcImZvcm1hdHRlciBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG4gICAgICAgIHRoaXMuX2xhYmVsX2Zvcm1hdHRlciA9IGZvcm1hdHRlcjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgc2V0dXBGb3JtYXRMYWJlbChmb3JtYXR0ZXIpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl9jaGFydF9sYWJlbF9mb3JtYXR0ZXI7XG4gICAgICAgIHRoaXMuX2NoYXJ0X2xhYmVsX2Zvcm1hdHRlciA9IGZvcm1hdHRlcjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgd2lkdGgod2lkdGgpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl93aWR0aDtcbiAgICAgICAgdGhpcy5fd2lkdGggPSB3aWR0aDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaGVpZ2h0KGhlaWdodCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX2hlaWdodDtcbiAgICAgICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBheGlzTWF4VmFsdWUodikge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX2F4aXNfbWF4X3ZhbHVlO1xuICAgICAgICB0aGlzLl9heGlzX21heF92YWx1ZSA9IHY7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGF4aXNNaW5WYWx1ZSh2KSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5fYXhpc19taW5fdmFsdWU7XG4gICAgICAgIHRoaXMuX2F4aXNfbWluX3ZhbHVlID0gdjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgc2hvd0xhYmVscyhzaG93KSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5fY2hhcnRfc2hvd19sYWJlbHMgfHwgdGhpcy5fc2hvd19sYWJlbHM7XG4gICAgICAgIHRoaXMuX3Nob3dfbGFiZWxzID0gISFzaG93O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzZXR1cFNob3dMYWJlbHMoc2hvdykge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX2NoYXJ0X3Nob3dfbGFiZWxzO1xuICAgICAgICB0aGlzLl9jaGFydF9zaG93X2xhYmVscyA9ICEhc2hvdztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgeUF4aXNMYWJlbChsYWJlbCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX2NoYXJ0X3lfYXhpc19sYWJlbCB8fCB0aGlzLl95X2F4aXNfbGFiZWw7XG4gICAgICAgIHRoaXMuX3lfYXhpc19sYWJlbCA9IGxhYmVsO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzZXR1cFlBeGlzTGFiZWwobGFiZWwpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl9jaGFydF95X2F4aXNfbGFiZWw7XG4gICAgICAgIHRoaXMuX2NoYXJ0X3lfYXhpc19sYWJlbCA9IGxhYmVsO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB4QXhpc0xhYmVsKGxhYmVsKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5fY2hhcnRfeF9heGlzX2xhYmVsIHx8IHRoaXMuX3hfYXhpc19sYWJlbDtcbiAgICAgICAgdGhpcy5feF9heGlzX2xhYmVsID0gbGFiZWw7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHNldHVwWEF4aXNMYWJlbChsYWJlbCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX2NoYXJ0X3hfYXhpc19sYWJlbDtcbiAgICAgICAgdGhpcy5fY2hhcnRfeF9heGlzX2xhYmVsID0gbGFiZWw7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGdyYWRpZW50Rm4oZm4pIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl9ncmFkaWVudF9mbjtcbiAgICAgICAgaWYgKGZuICYmIHR5cGVvZiBmbiAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgRXJyb3IoXCJncmFkaWVudEZuIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgdGhpcy5fZ3JhZGllbnRfZm4gPSBmbjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgb3BhY2l0eSh2KSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5fb3BhY2l0eTtcbiAgICAgICAgaWYgKHYgJiYgdHlwZW9mIHYgIT09IFwibnVtYmVyXCIpIHRocm93IG5ldyBFcnJvcihcIm9wYWNpdHkgbXVzdCBiZSBhIG51bWJlclwiKTtcbiAgICAgICAgdGhpcy5fb3BhY2l0eSA9IHY7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGltbWVkaWF0ZWx5UmVuZGVyTGFiZWxzKHNob3cpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiI2ltbWVkaWF0ZWx5UmVuZGVyTGFiZWxzIG5vdCBpbXBsZW1lbnRlZCBmb3JcIiwgdGhpcy5uYW1lKCkpO1xuICAgIH1cblxuICAgIGRhdGEoZGF0YSkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX2RhdGE7XG4gICAgICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmYWNldChzZWxlY3Rvcikge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX2ZhY2V0X3NlbGVjdG9yO1xuICAgICAgICBpZiAoc2VsZWN0b3IgIT0gbnVsbCAmJiB0eXBlb2Ygc2VsZWN0b3IgIT09ICdmdW5jdGlvbicgJiYgc2VsZWN0b3IgIT09IG51bGwpIHRocm93IG5ldyBFcnJvcihcIkZhY2V0IHNlbGVjdG9yIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgdGhpcy5fZmFjZXRfc2VsZWN0b3IgPSBzZWxlY3RvcjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgc3Ryb2tlV2lkdGgocGl4ZWxzKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5fc3Ryb2tlX3dpZHRoO1xuICAgICAgICB0aGlzLl9zdHJva2Vfd2lkdGggPSBwaXhlbHM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZvbnRTaXplKHB4KSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5fZm9udF9zaXplO1xuICAgICAgICBpZiAodHlwZW9mIHB4ICE9PSBcIm51bWJlclwiICYmIHB4ID4gMCkgdGhyb3cgbmV3IEVycm9yKFwiZm9udFNpemUgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlclwiKTtcbiAgICAgICAgdGhpcy5fZm9udF9zaXplID0gcHg7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHBhZGRpbmcocGFkZGluZykge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX3BhZGRpbmc7XG4gICAgICAgIHRoaXMuX3BhZGRpbmcgPSBwYWRkaW5nO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB1c2VZMkF4aXMob24pIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl91c2VfeTJfYXhpcztcbiAgICAgICAgdGhpcy5fdXNlX3kyX2F4aXMgPSAhIW9uO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIFRoaXMgdGFrZXMgb3VyIGFycmF5IG9mIGRhdGEsIGFuZCBkZXRlcm1pbmVzIHdoYXQgZWxlbWVudHNcbiAgICAgKiBhcmUgdG8gYmUgbWFwcGVkIHRvIHdoYXQgYWVzdGhldGljIHZhbHVlcywgc3VjaCBhcyBjb2xvdXIgb3Igc2l6ZS5cbiAgICAgKiBEYXRhIGlzIGdyb3VwZWQgYnkgdGhlc2UgZmllbGRzLlxuICAgICAqL1xuICAgIHByZXBhcmVEYXRhKGRhdGEsIGZhY2V0ZWQpIHtcbiAgICAgICAgZmFjZXRlZCA9ICEhZmFjZXRlZCAmJiB0aGlzLmZhY2V0KCk7XG4gICAgICAgIGRhdGEgPSBkYXRhIHx8IHRoaXMuX2RhdGE7XG4gICAgICAgIGlmICghZGF0YSB8fCAhZGF0YS5sZW5ndGgpIHJldHVybiBbXTtcblxuICAgICAgICBjb25zdCB4ID0gdGhpcy54KCksXG4gICAgICAgICAgICAgIHgyID0gdGhpcy54MigpLFxuICAgICAgICAgICAgICB5ID0gdGhpcy55KCksXG4gICAgICAgICAgICAgIHkyID0gdGhpcy55MigpLFxuICAgICAgICAgICAgICBzY2FsZVggPSB0aGlzLnNjYWxlWCgpLFxuICAgICAgICAgICAgICBzY2FsZVkgPSB0aGlzLnNjYWxlWSgpO1xuXG4gICAgICAgIGxldCBtYXBwZWQgPSB7fTtcblxuICAgICAgICBkYXRhLmZvckVhY2goZCA9PiB7XG4gICAgICAgICAgICBpZiAoZmFjZXRlZCAmJiAhdGhpcy5mYWNldCgpKGQpKSByZXR1cm47XG4gICAgICAgICAgICBjb25zdCBvYmplY3QgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgICAgICBfeDogc2NhbGVYLnRyYW5zZm9ybSh4KGQpKSxcbiAgICAgICAgICAgICAgICBfeTogc2NhbGVZLnRyYW5zZm9ybSh5KGQpKSxcbiAgICAgICAgICAgICAgICBfY29sb3VyOiB0aGlzLmNvbG91cigpKGQpLFxuICAgICAgICAgICAgICAgIF9zaXplOiB0aGlzLnNpemUoKShkKVxuICAgICAgICAgICAgfSwgZCk7XG4gICAgICAgICAgICBpZiAoeDIpIG9iamVjdC5feDIgPSBzY2FsZVgudHJhbnNmb3JtKHgyKGQpKVxuICAgICAgICAgICAgaWYgKHkyKSBvYmplY3QuX3kyID0gc2NhbGVZLnRyYW5zZm9ybSh5MihkKSlcblxuICAgICAgICAgICAgY29uc3Qga2V5ID0gZ2V0S2V5KG9iamVjdCk7XG4gICAgICAgICAgICBvYmplY3QuX2tleSA9IGtleTtcblxuICAgICAgICAgICAgbGV0IHNlcmllcyA9IG1hcHBlZFtrZXldIHx8IGdldEtleVBhcmFtZXRlcnMob2JqZWN0KTtcbiAgICAgICAgICAgIHNlcmllcy5kYXRhLnB1c2gob2JqZWN0KTtcbiAgICAgICAgICAgIG1hcHBlZFtrZXldID0gc2VyaWVzO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyhtYXBwZWQpO1xuICAgIH1cblxuICAgIGdldEQzWFNjYWxlKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJnZXREM1hTY2FsZSBub3QgaW1wbGVtZW50ZWQgZm9yIFwiICsgdGhpcy5uYW1lKCkpO1xuICAgIH1cblxuICAgIGdldEQzWVNjYWxlKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJnZXREM1lTY2FsZSBub3QgaW1wbGVtZW50ZWQgZm9yIFwiICsgdGhpcy5uYW1lKCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBhbGwgdGhlIFkgdmFsdWVzIGZvciB0aGlzIGdlb21ldHJ5LCBpZ25vcmluZyBmYWNldGluZy5cbiAgICAgKi9cbiAgICB5VmFsdWVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhKClcbiAgICAgICAgICAgIC5tYXAoZCA9PiB0aGlzLnkoKShkKSlcbiAgICAgICAgICAgIC5tYXAoZCA9PiB0aGlzLnNjYWxlWSgpLnRyYW5zZm9ybShkKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGFsbCB0aGUgWCB2YWx1ZXMgZm9yIHRoaXMgZ2VvbWV0cnksIGlnbm9yaW5nIGZhY2V0aW5nLlxuICAgICAqL1xuICAgIHhWYWx1ZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEoKVxuICAgICAgICAgICAgICAgICAgIC5tYXAoZCA9PiB0aGlzLngoKShkKSlcbiAgICAgICAgICAgICAgICAgICAubWFwKGQgPT4gdGhpcy5zY2FsZVgoKS50cmFuc2Zvcm0oZCkpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogSW1wbGVtZW50IHlvdXIgcmVuZGVyIGNvZGUgaGVyZS5cbiAgICAgKi9cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJFTkRFUiBOT1QgSU1QTEVNRU5URUQgRk9SIFwiICsgdGhpcy5uYW1lKCkpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdW5pcXVlIHZhbHVlcyB0aGF0IHRoZSBjb2xvdXIgZnVuY3Rpb25cbiAgICAgKiByZXR1cm5zLlxuICAgICAqIEBwYXJhbSBkYXRhXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZ2V0Q29sb3VyRG9tYWluKGRhdGEpIHtcbiAgICAgICAgaWYgKCFkYXRhIHx8ICFkYXRhLmxlbmd0aCkgcmV0dXJuIFtdO1xuXG4gICAgICAgIGNvbnN0IGNvbG91cnMgPSBuZXcgU2V0KCk7XG5cbiAgICAgICAgLy8gdG9kbyBjYWxjdWxhdGUgYnVja2V0c1xuICAgICAgICBkYXRhLmZvckVhY2goc2VyaWVzID0+IHtcbiAgICAgICAgICAgIHNlcmllcy5kYXRhLmZvckVhY2goZCA9PiB7XG4gICAgICAgICAgICAgICAgY29sb3Vycy5hZGQodGhpcy5jb2xvdXIoKShkKSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gWy4uLmNvbG91cnNdXG4gICAgfVxuXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDb2xvcihkLCBkM0NvbG91clNjYWxlLCBpbmRpdmlkdWFsQ29sb3VycywgbW9kaWZ5Q29sb3VyKSB7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRDb2xvdXIgPSBkM0NvbG91clNjYWxlKGQuX2NvbG91cik7XG4gICAgICAgIHJldHVybiBtb2RpZnlDb2xvdXIoaW5kaXZpZHVhbENvbG91cnMoZCwgZGVmYXVsdENvbG91cikgfHwgZGVmYXVsdENvbG91cik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRLZXkoZCkge1xuICAgIC8vIFRPRE8gd2UgcHJvYmFibHkgbmVlZCB0byBlbmNvZGUgdGhpcyBiZXR0ZXIgc28gd2UgY2FuIHNwbGl0IG9uIHRoZSA6XG4gICAgcmV0dXJuIFwiXCIgKyBkLl9jb2xvdXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tS2V5KGtleSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIF9jb2xvdXI6IGtleSxcbiAgICAgICAgX2tleToga2V5XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZXRLZXlQYXJhbWV0ZXJzKGQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBfa2V5OiBnZXRLZXkoZCksXG4gICAgICAgIF9zaXplOiBkLl9zaXplLFxuICAgICAgICBfY29sb3VyOiBkLl9jb2xvdXIsXG4gICAgICAgIGRhdGE6IFtdXG4gICAgfVxufSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/chart/Geometry.js\n')},"./src/chart/Histogram.js":
/*!********************************!*\
  !*** ./src/chart/Histogram.js ***!
  \********************************/
/*! exports provided: histogram, columnChart */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "histogram", function() { return histogram; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "columnChart", function() { return columnChart; });\n/* harmony import */ var _Geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Geometry */ "./src/chart/Geometry.js");\n/* harmony import */ var _Colours__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Colours */ "./src/Colours.js");\n/* harmony import */ var _Legend__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Legend */ "./src/Legend.js");\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../helpers */ "./src/helpers.js");\n// Copyright (C) 2013-2014, 2018 BrandsEye (PTY) LTD\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this\n// software and associated documentation files (the "Software"), to deal in the Software\n// without restriction, including without limitation the rights to use, copy, modify,\n//     merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following\n// conditions:\n//\n//     The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n//     INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n// CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n\n\n\n\nclass Histogram extends _Geometry__WEBPACK_IMPORTED_MODULE_0__["Geometry"] {\n\n    constructor(name, padding) {\n        super(name || "HISTOGRAM");\n        this._BAR_GROWTH = 100;\n        this._padding = padding || 0;\n        this._stroke_width = 1\n    }\n\n    render() {\n        const element = this._element;\n        const data = this.prepareData(null, true);\n        const allData = this.prepareData(null, false);\n        const width = this._width,\n              height = this._height;\n\n        element.classed("histogram", true);\n        element.style("opacity", this._opacity === null ? 1.0 : this._opacity)\n\n        const x = this.getD3XScale(data, width);\n        const y = this.getD3YScale(allData, height);\n        const usingY2 = !!this._y2_getter   // bars extend from d._y to d._y2\n        const xGroup = this.getD3XGroupScale(data, x);\n        const colours = this.d3ColourScale();\n\n        // render gradient to match the scale if needed\n        let gradientId\n        if (this._gradient_fn) {\n            element.select("g.gradient").remove()\n            this.gradientId = gradientId = this._gradient_fn(element.append("g").attr("class", "gradient"), y, this)\n        }\n\n        let groups = element.select(".bars").selectAll(\'.group\');\n\n        element.select(".chart-labels").remove();\n\n        if (groups.empty()) groups = element.append("g").attr("class", "bars").selectAll(".group")\n\n        // Ensure that we\'re always using the correct height.\n        element.select(".bars").attr("transform", "translate(0, " + height + "), scale(1, -1)");\n\n        groups = groups.data(data)\n        groups.exit().remove()\n\n        const fillFn = d => gradientId ? "url(#" + gradientId + ")" : this.getD3Colour(d)\n\n        groups.enter()\n              .append("g")\n                  .attr("class", "group")\n                  .attr("transform", d => "translate(" + x(d._key) + ",0)")\n                  .attr("width", x.bandwidth())\n                  .attr("height", "100%")\n              .merge(groups)\n              .interrupt("groups:move")\n              .transition("groups:move")\n                  .attr("transform", d => "translate(" + x(d._key) + ",0)")\n                  .attr("width", x.bandwidth())\n              .each((s_d, s_i, nodes) => {\n                  let group = d3.select(nodes[s_i]);\n\n                  let bars = group.selectAll(".bar")\n                                  .data(s_d.data);\n\n                  bars.exit().remove();\n\n                  bars.interrupt("bar:move")     // Animate the bars to their new position.\n                      .transition("bar:move")\n                      .attr("width", xGroup.bandwidth())\n                      .attr("x", d => xGroup(d._key))\n                      .attr("y", 0);\n\n                  bars.enter()\n                      .append("rect")\n                          .attr("height", 0)\n                          .style("cursor", "pointer")\n                      .on("contextmenu", () => d3.event.preventDefault()) // No right click.\n                      .merge(bars)\n                          .attr("x", d => xGroup(d._key))\n                          .attr("y", height - y(0))\n                          .attr("width", xGroup.bandwidth())\n                          .attr("class", d => "bar series series-" + Object(_Legend__WEBPACK_IMPORTED_MODULE_2__["toColourKey"])(d._colour))\n                          .style("fill", fillFn)\n                          .style("stroke", d => d3.hcl(this.getD3Colour(d)).darker())\n                          .style("stroke-width", this._stroke_width)\n                      .on("click auxclick", (d, i, nodes) => {\n                          this._dispatch.call("elementClick", this, {\n                              e: d3.event,\n                              point: d,\n                              series: d._series,\n                              seriesIndex: s_i,\n                              value: d._y\n                          })\n                      })\n                      .on("mouseover", (d, i, nodes) => { // Darken the bar on mouse over\n                          let sel = d3.select(nodes[i])\n                            .interrupt("hover:colour")\n                            .transition("hover:colour")\n                            .duration(150)\n                          if (gradientId) sel.style("opacity", "0.5")\n                          else sel.style("fill", d3.hcl(this.getD3Colour(d)).darker())\n                          this._dispatch.call("tooltipShow", this, {\n                              e: d3.event,\n                              point: d,\n                              series: s_d,\n                              seriesIndex: s_i,\n                              value: d._y\n                          })\n                      })\n                      .on("mouseout", (d, i, nodes) => { // bar is regular colour on mouse out.\n                          let sel = d3.select(nodes[i])\n                              .interrupt("hover:colour")\n                              .transition("hover:colour")\n                              .duration(100)\n                          if (gradientId) sel.style("opacity", "1.0")\n                          else sel.style("fill", d => this.getD3Colour(d))\n                          this._dispatch.call("tooltipHide", this);\n                      })\n                      .interrupt("bar:growth")    // Animate bars growing.\n                      .transition("bar:growth")\n                      .delay(() => this.calcBarGrowth(s_i, nodes.length))\n                          .style("fill", fillFn)\n                          .style("stroke", d => d3.hcl(this.getD3Colour(d)).darker())\n                          .attr("y", d => height - y(Math.min(0, d._y)))\n                          .attr("height", d => Math.abs(y(usingY2 ? d._y2 : 0) - y(d._y)));\n              });\n\n        // Labels loaded after our last bar grows.\n        if (this.showLabels()) {\n            element.transition("bar:growth")\n               .on("end", (d, i, nodes) => {\n                   if (i < nodes.length - 1) return;\n                   this.renderLabels(element, data, x, xGroup, y, colours);\n               })\n        }\n    }\n\n    calcBarGrowth(i, max) {\n        if (max < 10) return i * this._BAR_GROWTH / 2;\n        if (max < 35) return i * this._BAR_GROWTH / 4;\n        return 1;\n    }\n\n    prepareData(data, faceted) {\n        data = _Geometry__WEBPACK_IMPORTED_MODULE_0__["Geometry"].prototype.prepareData.call(this, data, faceted);\n\n        const sortOrder = {};\n        this.xValues().forEach((d, i) => {\n            sortOrder[d] = sortOrder[d] || ("" + i);\n        });\n\n        let results = {};\n\n        // We want to calculate what bucket each bit of data belongs to.\n        const buckets = this.scaleX()\n                            .buckets(Object\n                                .values(data)\n                                .map(d => d.data)\n                                .reduce((acc, cur) => acc.concat(cur))\n                                .map(d => d._x));\n\n        // Sort data in to their appropriate buckets. This may be\n        // specific date buckets, or general buckets for continuous data.\n        Object.keys(data).forEach(key => {\n            let values = data[key].data;\n            values.forEach(d => {\n                d._bucket = buckets.bucket(d._x);\n                let bucket = results[d._bucket] || { _key: d._bucket, data: [] };\n                bucket.data.push(d);\n                results[d._bucket] = bucket;\n            })\n        });\n\n        return buckets.consolidateBuckets(Object.values(results))\n            .sort((lhs, rhs) => {\n                return sortOrder["" + lhs._key] - sortOrder["" + rhs._key];\n            });\n    }\n\n    getKeys(data) {\n        if (!data || !data.length) return [];\n\n        let keys = new Set();\n\n        // todo calculate buckets\n        Object.keys(data).forEach(key => {\n            let values = data[key].data;\n            values.forEach(d => keys.add(d._key))\n        });\n\n\n        return [...keys]\n    }\n\n    getD3XScale(data, width) {\n        data = data || this.prepareData(null, true);\n        width = width || this.width();\n\n        let p = this._padding\n        if (data[0].data.length > 1 && p === 0) p = 0.2\n        return d3.scaleBand()\n                 .range([0, width])\n                 .paddingInner(p)\n                 .domain(data.map(d => d._key));\n    }\n\n    getD3YScale(data, height) {\n        data = (data || this.prepareData(null, false)).map(d => d.data).reduce((acc, val) => acc.concat(val));\n        height = height || this.height();\n\n        let extent = d3.extent(data, d => d._y)\n        if (this._y2_getter) {\n            let e2 = d3.extent(data, d => d._y2)\n            extent[0] = Math.min(extent[0], e2[0])\n            extent[1] = Math.max(extent[1], e2[1])\n        }\n\n        const max = Math.max(extent[1], this._axis_max_value || 0)\n        const min = Math.min(this._axis_min_value || 0, extent[0])\n        return d3.scaleLinear().rangeRound([height, 0]).nice().domain([min, max]);\n    }\n\n    getD3XGroupScale(data, xscale) {\n        return d3.scaleBand()\n                 .padding(0)\n                 .domain(this.getKeys(data))\n                 .rangeRound([0, xscale.bandwidth()]);\n    }\n\n    renderLabels(selection, data, xscale, xgroup, yscale, colourScale, animate) {\n        animate = animate === undefined ? true : animate;\n        selection.selectAll(".chart-labels").remove();\n\n        let labels = selection.append("g")\n                              .attr("class", "chart-labels")\n                              .selectAll(".label-group")\n                              .data(data);\n\n        let maxWidth = 0;     // For calculating the max width of text.\n        let fontSize = this._font_size;    // Our initial font size.\n        const buffer = 5;     // Buffer space between words and the top of a bar.\n        const calcDy = (y, ypos) => ((y >= 0 && ypos < 10) || ( y < 0 && this._height - ypos > 10)) ? fontSize + 2: -buffer;\n\n        // Want to figure out if the label is too dark / light for the\n        // bar.\n        const getInvertedColor = d => {\n            let invertedColor = d3.hcl(this.getD3Colour(d));\n            invertedColor.l += Math.min(invertedColor.l + 50, 100);\n            return invertedColor;\n        };\n        const shouldInvert = d => d3.hcl(this.getD3Colour(d)).l < 60;\n        const fillColour = d3.hcl(_Colours__WEBPACK_IMPORTED_MODULE_1__["colours"].eighteen.darkGrey).brighter();\n        const lighterFillColour = d3.hcl(_Colours__WEBPACK_IMPORTED_MODULE_1__["colours"].eighteen.midGrey);\n        const findColour = (d, dy, labelText) => {\n            const onBar = (d._y >= 0 && dy > 0 || d._y < 0 && dy < 0);\n            return onBar && shouldInvert(d)\n                ? getInvertedColor(d).toString()\n                : (Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["labelIsZero"])(labelText)\n                    ? lighterFillColour\n                    : (onBar ? d3.hcl(fillColour).darker() : fillColour));\n        };\n\n        labels.enter().each((series, s_i, s_nodes) => {\n            // We want to determine which groups may have missing values, and provide them.\n            const requiredGroups = {};\n            xgroup.domain().map(_Geometry__WEBPACK_IMPORTED_MODULE_0__["fromKey"]).forEach(d => {\n                requiredGroups[d._colour] = d;\n            });\n\n            series.data.forEach(d => {\n                delete requiredGroups[d._colour]\n            });\n\n            const missingGroups = Object.values(requiredGroups);\n            missingGroups.forEach(d => {\n                d._x = series._key;\n                d._y = 0;\n            });\n\n            d3.select(s_nodes[s_i])\n              .append("g")\n              .attr("class", "label-group")\n              .attr("transform", d => "translate(" + xscale(d._key) + ",0)")\n              .selectAll(".chart-label")\n              .data(series.data.concat(Object.values(missingGroups)))\n              .enter()\n              .each((d, i, nodes) => {\n                  const labelText = this.formatLabel()(d._y, d);\n                  let ypos = yscale(d._y);\n                  let dy = calcDy(d._y, ypos);\n                  let text = d3.select(nodes[i])\n                        .append("text")\n                        .text(labelText)\n                        .style("font-size", fontSize + "px")\n                        .attr("class", d => "chart-label series series-" + Object(_Legend__WEBPACK_IMPORTED_MODULE_2__["toColourKey"])(d._colour))\n                        .attr("y", ypos)\n                        .attr("dx", animate ? -15 : 0)\n                        .attr("dy", dy)\n                        .style("opacity", 0)\n                        .style("pointer-events", "none")\n                        .style("fill", d => findColour(d, dy, labelText));\n\n                  // Set the x position, which is based on width.\n                  const width = text.node().getBBox().width;\n                  maxWidth = Math.max(width, maxWidth);\n                  text\n                      .attr("x", xgroup(d._key) + xgroup.bandwidth() / 2 - width / 2);\n\n                  text\n                      .transition("labels")\n                      .delay(() => animate ? this.calcBarGrowth(s_i, s_nodes.length) : 0) // Delay in lockstep with bar growth.\n                      .attr("dx", 0)\n                      .style("opacity", 1)\n              })\n        });\n\n\n        // Figure out if we don\'t have enough space to show our labels.\n        // We then want to resize, if possible.\n        if (xgroup.bandwidth() < maxWidth * 1.10) {\n            let scale = maxWidth / xgroup.bandwidth() * 1.10;\n            fontSize = Math.floor(fontSize / scale);\n\n            if (fontSize < 10) {\n                // The labels are too small.\n                labels.enter().selectAll("text").remove();\n            } else {\n                labels.enter()\n                      .merge(labels)\n                      .selectAll("text")\n                      .style("font-size", fontSize + "px")\n                      .each((d, i, nodes) => {\n                          const text = d3.select(nodes[i]);\n                          const width = text.node().getBBox().width;\n                          const dy = calcDy(d._y, yscale(d._y));\n\n                          text\n                              .attr("x", xgroup(d._key) + xgroup.bandwidth() / 2 - width / 2)\n                              .style("fill", d => findColour(d, dy, text.text()))\n                              .attr("dy", dy);\n                      })\n            }\n        }\n    }\n\n\n    immediatelyRenderLabels(show) {\n        const element = this.element();\n        if (!element) return;\n\n        if (!show) { // Hides the labels\n            element\n              .select(\'.chart-labels\')\n              .interrupt("labels")\n              .interrupt("labels:fade")\n              .transition("labels:fade")\n              .style("opacity", 0)\n              .on("end", (d, i, nodes) => {\n                  d3.select(nodes[i]).remove();\n              })\n        } else {\n            let labels = element.select(\'.chart-labels\');\n            if (!labels.empty()) return;\n\n            const data = this.prepareData(null, true);\n            const allData = this.prepareData(null, false);\n\n            const xscale = this.getD3XScale(data),\n                  xgroup = this.getD3XGroupScale(data, xscale),\n                  yscale = this.getD3YScale(data),\n                  colourScale = this.d3ColourScale();\n\n            labels.remove();\n            this.renderLabels(element, data, xscale, xgroup, yscale, colourScale, false);\n        }\n\n    }\n\n\n}\n\n\nfunction histogram() {\n    return new Histogram();\n}\n\nfunction columnChart() {\n    return new Histogram("COLUMN_CHART", 0.1);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY2hhcnQvSGlzdG9ncmFtLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYjNqcy8uL3NyYy9jaGFydC9IaXN0b2dyYW0uanM/MTkzMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKEMpIDIwMTMtMjAxNCwgMjAxOCBCcmFuZHNFeWUgKFBUWSkgTFREXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZiB0aGlzXG4vLyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmVcbi8vIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSxcbi8vICAgICBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvXG4vLyBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZ1xuLy8gY29uZGl0aW9uczpcbi8vXG4vLyAgICAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4vLyBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vICAgICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SIElNUExJRUQsXG4vLyAgICAgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEFcbi8vIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFRcbi8vIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRlxuLy8gQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFXG4vLyBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IHsgR2VvbWV0cnksIGZyb21LZXkgfSBmcm9tICcuL0dlb21ldHJ5JztcbmltcG9ydCB7IGNvbG91cnMgfSBmcm9tIFwiLi4vQ29sb3Vyc1wiO1xuaW1wb3J0IHsgdG9Db2xvdXJLZXkgfSBmcm9tIFwiLi4vTGVnZW5kXCI7XG5pbXBvcnQgeyBsYWJlbElzWmVybyB9IGZyb20gXCIuLi9oZWxwZXJzXCI7XG5cblxuY2xhc3MgSGlzdG9ncmFtIGV4dGVuZHMgR2VvbWV0cnkge1xuXG4gICAgY29uc3RydWN0b3IobmFtZSwgcGFkZGluZykge1xuICAgICAgICBzdXBlcihuYW1lIHx8IFwiSElTVE9HUkFNXCIpO1xuICAgICAgICB0aGlzLl9CQVJfR1JPV1RIID0gMTAwO1xuICAgICAgICB0aGlzLl9wYWRkaW5nID0gcGFkZGluZyB8fCAwO1xuICAgICAgICB0aGlzLl9zdHJva2Vfd2lkdGggPSAxXG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5fZWxlbWVudDtcbiAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMucHJlcGFyZURhdGEobnVsbCwgdHJ1ZSk7XG4gICAgICAgIGNvbnN0IGFsbERhdGEgPSB0aGlzLnByZXBhcmVEYXRhKG51bGwsIGZhbHNlKTtcbiAgICAgICAgY29uc3Qgd2lkdGggPSB0aGlzLl93aWR0aCxcbiAgICAgICAgICAgICAgaGVpZ2h0ID0gdGhpcy5faGVpZ2h0O1xuXG4gICAgICAgIGVsZW1lbnQuY2xhc3NlZChcImhpc3RvZ3JhbVwiLCB0cnVlKTtcbiAgICAgICAgZWxlbWVudC5zdHlsZShcIm9wYWNpdHlcIiwgdGhpcy5fb3BhY2l0eSA9PT0gbnVsbCA/IDEuMCA6IHRoaXMuX29wYWNpdHkpXG5cbiAgICAgICAgY29uc3QgeCA9IHRoaXMuZ2V0RDNYU2NhbGUoZGF0YSwgd2lkdGgpO1xuICAgICAgICBjb25zdCB5ID0gdGhpcy5nZXREM1lTY2FsZShhbGxEYXRhLCBoZWlnaHQpO1xuICAgICAgICBjb25zdCB1c2luZ1kyID0gISF0aGlzLl95Ml9nZXR0ZXIgICAvLyBiYXJzIGV4dGVuZCBmcm9tIGQuX3kgdG8gZC5feTJcbiAgICAgICAgY29uc3QgeEdyb3VwID0gdGhpcy5nZXREM1hHcm91cFNjYWxlKGRhdGEsIHgpO1xuICAgICAgICBjb25zdCBjb2xvdXJzID0gdGhpcy5kM0NvbG91clNjYWxlKCk7XG5cbiAgICAgICAgLy8gcmVuZGVyIGdyYWRpZW50IHRvIG1hdGNoIHRoZSBzY2FsZSBpZiBuZWVkZWRcbiAgICAgICAgbGV0IGdyYWRpZW50SWRcbiAgICAgICAgaWYgKHRoaXMuX2dyYWRpZW50X2ZuKSB7XG4gICAgICAgICAgICBlbGVtZW50LnNlbGVjdChcImcuZ3JhZGllbnRcIikucmVtb3ZlKClcbiAgICAgICAgICAgIHRoaXMuZ3JhZGllbnRJZCA9IGdyYWRpZW50SWQgPSB0aGlzLl9ncmFkaWVudF9mbihlbGVtZW50LmFwcGVuZChcImdcIikuYXR0cihcImNsYXNzXCIsIFwiZ3JhZGllbnRcIiksIHksIHRoaXMpXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZ3JvdXBzID0gZWxlbWVudC5zZWxlY3QoXCIuYmFyc1wiKS5zZWxlY3RBbGwoJy5ncm91cCcpO1xuXG4gICAgICAgIGVsZW1lbnQuc2VsZWN0KFwiLmNoYXJ0LWxhYmVsc1wiKS5yZW1vdmUoKTtcblxuICAgICAgICBpZiAoZ3JvdXBzLmVtcHR5KCkpIGdyb3VwcyA9IGVsZW1lbnQuYXBwZW5kKFwiZ1wiKS5hdHRyKFwiY2xhc3NcIiwgXCJiYXJzXCIpLnNlbGVjdEFsbChcIi5ncm91cFwiKVxuXG4gICAgICAgIC8vIEVuc3VyZSB0aGF0IHdlJ3JlIGFsd2F5cyB1c2luZyB0aGUgY29ycmVjdCBoZWlnaHQuXG4gICAgICAgIGVsZW1lbnQuc2VsZWN0KFwiLmJhcnNcIikuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZSgwLCBcIiArIGhlaWdodCArIFwiKSwgc2NhbGUoMSwgLTEpXCIpO1xuXG4gICAgICAgIGdyb3VwcyA9IGdyb3Vwcy5kYXRhKGRhdGEpXG4gICAgICAgIGdyb3Vwcy5leGl0KCkucmVtb3ZlKClcblxuICAgICAgICBjb25zdCBmaWxsRm4gPSBkID0+IGdyYWRpZW50SWQgPyBcInVybCgjXCIgKyBncmFkaWVudElkICsgXCIpXCIgOiB0aGlzLmdldEQzQ29sb3VyKGQpXG5cbiAgICAgICAgZ3JvdXBzLmVudGVyKClcbiAgICAgICAgICAgICAgLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJncm91cFwiKVxuICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgZCA9PiBcInRyYW5zbGF0ZShcIiArIHgoZC5fa2V5KSArIFwiLDApXCIpXG4gICAgICAgICAgICAgICAgICAuYXR0cihcIndpZHRoXCIsIHguYmFuZHdpZHRoKCkpXG4gICAgICAgICAgICAgICAgICAuYXR0cihcImhlaWdodFwiLCBcIjEwMCVcIilcbiAgICAgICAgICAgICAgLm1lcmdlKGdyb3VwcylcbiAgICAgICAgICAgICAgLmludGVycnVwdChcImdyb3Vwczptb3ZlXCIpXG4gICAgICAgICAgICAgIC50cmFuc2l0aW9uKFwiZ3JvdXBzOm1vdmVcIilcbiAgICAgICAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIGQgPT4gXCJ0cmFuc2xhdGUoXCIgKyB4KGQuX2tleSkgKyBcIiwwKVwiKVxuICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCB4LmJhbmR3aWR0aCgpKVxuICAgICAgICAgICAgICAuZWFjaCgoc19kLCBzX2ksIG5vZGVzKSA9PiB7XG4gICAgICAgICAgICAgICAgICBsZXQgZ3JvdXAgPSBkMy5zZWxlY3Qobm9kZXNbc19pXSk7XG5cbiAgICAgICAgICAgICAgICAgIGxldCBiYXJzID0gZ3JvdXAuc2VsZWN0QWxsKFwiLmJhclwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5kYXRhKHNfZC5kYXRhKTtcblxuICAgICAgICAgICAgICAgICAgYmFycy5leGl0KCkucmVtb3ZlKCk7XG5cbiAgICAgICAgICAgICAgICAgIGJhcnMuaW50ZXJydXB0KFwiYmFyOm1vdmVcIikgICAgIC8vIEFuaW1hdGUgdGhlIGJhcnMgdG8gdGhlaXIgbmV3IHBvc2l0aW9uLlxuICAgICAgICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKFwiYmFyOm1vdmVcIilcbiAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcIndpZHRoXCIsIHhHcm91cC5iYW5kd2lkdGgoKSlcbiAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcInhcIiwgZCA9PiB4R3JvdXAoZC5fa2V5KSlcbiAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcInlcIiwgMCk7XG5cbiAgICAgICAgICAgICAgICAgIGJhcnMuZW50ZXIoKVxuICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoXCJyZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcImN1cnNvclwiLCBcInBvaW50ZXJcIilcbiAgICAgICAgICAgICAgICAgICAgICAub24oXCJjb250ZXh0bWVudVwiLCAoKSA9PiBkMy5ldmVudC5wcmV2ZW50RGVmYXVsdCgpKSAvLyBObyByaWdodCBjbGljay5cbiAgICAgICAgICAgICAgICAgICAgICAubWVyZ2UoYmFycylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIGQgPT4geEdyb3VwKGQuX2tleSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwieVwiLCBoZWlnaHQgLSB5KDApKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcIndpZHRoXCIsIHhHcm91cC5iYW5kd2lkdGgoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBkID0+IFwiYmFyIHNlcmllcyBzZXJpZXMtXCIgKyB0b0NvbG91cktleShkLl9jb2xvdXIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIGZpbGxGbilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwic3Ryb2tlXCIsIGQgPT4gZDMuaGNsKHRoaXMuZ2V0RDNDb2xvdXIoZCkpLmRhcmtlcigpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJzdHJva2Utd2lkdGhcIiwgdGhpcy5fc3Ryb2tlX3dpZHRoKVxuICAgICAgICAgICAgICAgICAgICAgIC5vbihcImNsaWNrIGF1eGNsaWNrXCIsIChkLCBpLCBub2RlcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXNwYXRjaC5jYWxsKFwiZWxlbWVudENsaWNrXCIsIHRoaXMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGU6IGQzLmV2ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQ6IGQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXM6IGQuX3NlcmllcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllc0luZGV4OiBzX2ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZC5feVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgLm9uKFwibW91c2VvdmVyXCIsIChkLCBpLCBub2RlcykgPT4geyAvLyBEYXJrZW4gdGhlIGJhciBvbiBtb3VzZSBvdmVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzZWwgPSBkMy5zZWxlY3Qobm9kZXNbaV0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmludGVycnVwdChcImhvdmVyOmNvbG91clwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKFwiaG92ZXI6Y29sb3VyXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKDE1MClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdyYWRpZW50SWQpIHNlbC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwLjVcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBzZWwuc3R5bGUoXCJmaWxsXCIsIGQzLmhjbCh0aGlzLmdldEQzQ29sb3VyKGQpKS5kYXJrZXIoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlzcGF0Y2guY2FsbChcInRvb2x0aXBTaG93XCIsIHRoaXMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGU6IGQzLmV2ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQ6IGQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXM6IHNfZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllc0luZGV4OiBzX2ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZC5feVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgLm9uKFwibW91c2VvdXRcIiwgKGQsIGksIG5vZGVzKSA9PiB7IC8vIGJhciBpcyByZWd1bGFyIGNvbG91ciBvbiBtb3VzZSBvdXQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzZWwgPSBkMy5zZWxlY3Qobm9kZXNbaV0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuaW50ZXJydXB0KFwiaG92ZXI6Y29sb3VyXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAudHJhbnNpdGlvbihcImhvdmVyOmNvbG91clwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKDEwMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdyYWRpZW50SWQpIHNlbC5zdHlsZShcIm9wYWNpdHlcIiwgXCIxLjBcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBzZWwuc3R5bGUoXCJmaWxsXCIsIGQgPT4gdGhpcy5nZXREM0NvbG91cihkKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlzcGF0Y2guY2FsbChcInRvb2x0aXBIaWRlXCIsIHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgLmludGVycnVwdChcImJhcjpncm93dGhcIikgICAgLy8gQW5pbWF0ZSBiYXJzIGdyb3dpbmcuXG4gICAgICAgICAgICAgICAgICAgICAgLnRyYW5zaXRpb24oXCJiYXI6Z3Jvd3RoXCIpXG4gICAgICAgICAgICAgICAgICAgICAgLmRlbGF5KCgpID0+IHRoaXMuY2FsY0Jhckdyb3d0aChzX2ksIG5vZGVzLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcImZpbGxcIiwgZmlsbEZuKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJzdHJva2VcIiwgZCA9PiBkMy5oY2wodGhpcy5nZXREM0NvbG91cihkKSkuZGFya2VyKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwieVwiLCBkID0+IGhlaWdodCAtIHkoTWF0aC5taW4oMCwgZC5feSkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcImhlaWdodFwiLCBkID0+IE1hdGguYWJzKHkodXNpbmdZMiA/IGQuX3kyIDogMCkgLSB5KGQuX3kpKSk7XG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIC8vIExhYmVscyBsb2FkZWQgYWZ0ZXIgb3VyIGxhc3QgYmFyIGdyb3dzLlxuICAgICAgICBpZiAodGhpcy5zaG93TGFiZWxzKCkpIHtcbiAgICAgICAgICAgIGVsZW1lbnQudHJhbnNpdGlvbihcImJhcjpncm93dGhcIilcbiAgICAgICAgICAgICAgIC5vbihcImVuZFwiLCAoZCwgaSwgbm9kZXMpID0+IHtcbiAgICAgICAgICAgICAgICAgICBpZiAoaSA8IG5vZGVzLmxlbmd0aCAtIDEpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckxhYmVscyhlbGVtZW50LCBkYXRhLCB4LCB4R3JvdXAsIHksIGNvbG91cnMpO1xuICAgICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNhbGNCYXJHcm93dGgoaSwgbWF4KSB7XG4gICAgICAgIGlmIChtYXggPCAxMCkgcmV0dXJuIGkgKiB0aGlzLl9CQVJfR1JPV1RIIC8gMjtcbiAgICAgICAgaWYgKG1heCA8IDM1KSByZXR1cm4gaSAqIHRoaXMuX0JBUl9HUk9XVEggLyA0O1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICBwcmVwYXJlRGF0YShkYXRhLCBmYWNldGVkKSB7XG4gICAgICAgIGRhdGEgPSBHZW9tZXRyeS5wcm90b3R5cGUucHJlcGFyZURhdGEuY2FsbCh0aGlzLCBkYXRhLCBmYWNldGVkKTtcblxuICAgICAgICBjb25zdCBzb3J0T3JkZXIgPSB7fTtcbiAgICAgICAgdGhpcy54VmFsdWVzKCkuZm9yRWFjaCgoZCwgaSkgPT4ge1xuICAgICAgICAgICAgc29ydE9yZGVyW2RdID0gc29ydE9yZGVyW2RdIHx8IChcIlwiICsgaSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGxldCByZXN1bHRzID0ge307XG5cbiAgICAgICAgLy8gV2Ugd2FudCB0byBjYWxjdWxhdGUgd2hhdCBidWNrZXQgZWFjaCBiaXQgb2YgZGF0YSBiZWxvbmdzIHRvLlxuICAgICAgICBjb25zdCBidWNrZXRzID0gdGhpcy5zY2FsZVgoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5idWNrZXRzKE9iamVjdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAudmFsdWVzKGRhdGEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoZCA9PiBkLmRhdGEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZWR1Y2UoKGFjYywgY3VyKSA9PiBhY2MuY29uY2F0KGN1cikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoZCA9PiBkLl94KSk7XG5cbiAgICAgICAgLy8gU29ydCBkYXRhIGluIHRvIHRoZWlyIGFwcHJvcHJpYXRlIGJ1Y2tldHMuIFRoaXMgbWF5IGJlXG4gICAgICAgIC8vIHNwZWNpZmljIGRhdGUgYnVja2V0cywgb3IgZ2VuZXJhbCBidWNrZXRzIGZvciBjb250aW51b3VzIGRhdGEuXG4gICAgICAgIE9iamVjdC5rZXlzKGRhdGEpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGxldCB2YWx1ZXMgPSBkYXRhW2tleV0uZGF0YTtcbiAgICAgICAgICAgIHZhbHVlcy5mb3JFYWNoKGQgPT4ge1xuICAgICAgICAgICAgICAgIGQuX2J1Y2tldCA9IGJ1Y2tldHMuYnVja2V0KGQuX3gpO1xuICAgICAgICAgICAgICAgIGxldCBidWNrZXQgPSByZXN1bHRzW2QuX2J1Y2tldF0gfHwgeyBfa2V5OiBkLl9idWNrZXQsIGRhdGE6IFtdIH07XG4gICAgICAgICAgICAgICAgYnVja2V0LmRhdGEucHVzaChkKTtcbiAgICAgICAgICAgICAgICByZXN1bHRzW2QuX2J1Y2tldF0gPSBidWNrZXQ7XG4gICAgICAgICAgICB9KVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gYnVja2V0cy5jb25zb2xpZGF0ZUJ1Y2tldHMoT2JqZWN0LnZhbHVlcyhyZXN1bHRzKSlcbiAgICAgICAgICAgIC5zb3J0KChsaHMsIHJocykgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBzb3J0T3JkZXJbXCJcIiArIGxocy5fa2V5XSAtIHNvcnRPcmRlcltcIlwiICsgcmhzLl9rZXldO1xuICAgICAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZ2V0S2V5cyhkYXRhKSB7XG4gICAgICAgIGlmICghZGF0YSB8fCAhZGF0YS5sZW5ndGgpIHJldHVybiBbXTtcblxuICAgICAgICBsZXQga2V5cyA9IG5ldyBTZXQoKTtcblxuICAgICAgICAvLyB0b2RvIGNhbGN1bGF0ZSBidWNrZXRzXG4gICAgICAgIE9iamVjdC5rZXlzKGRhdGEpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGxldCB2YWx1ZXMgPSBkYXRhW2tleV0uZGF0YTtcbiAgICAgICAgICAgIHZhbHVlcy5mb3JFYWNoKGQgPT4ga2V5cy5hZGQoZC5fa2V5KSlcbiAgICAgICAgfSk7XG5cblxuICAgICAgICByZXR1cm4gWy4uLmtleXNdXG4gICAgfVxuXG4gICAgZ2V0RDNYU2NhbGUoZGF0YSwgd2lkdGgpIHtcbiAgICAgICAgZGF0YSA9IGRhdGEgfHwgdGhpcy5wcmVwYXJlRGF0YShudWxsLCB0cnVlKTtcbiAgICAgICAgd2lkdGggPSB3aWR0aCB8fCB0aGlzLndpZHRoKCk7XG5cbiAgICAgICAgbGV0IHAgPSB0aGlzLl9wYWRkaW5nXG4gICAgICAgIGlmIChkYXRhWzBdLmRhdGEubGVuZ3RoID4gMSAmJiBwID09PSAwKSBwID0gMC4yXG4gICAgICAgIHJldHVybiBkMy5zY2FsZUJhbmQoKVxuICAgICAgICAgICAgICAgICAucmFuZ2UoWzAsIHdpZHRoXSlcbiAgICAgICAgICAgICAgICAgLnBhZGRpbmdJbm5lcihwKVxuICAgICAgICAgICAgICAgICAuZG9tYWluKGRhdGEubWFwKGQgPT4gZC5fa2V5KSk7XG4gICAgfVxuXG4gICAgZ2V0RDNZU2NhbGUoZGF0YSwgaGVpZ2h0KSB7XG4gICAgICAgIGRhdGEgPSAoZGF0YSB8fCB0aGlzLnByZXBhcmVEYXRhKG51bGwsIGZhbHNlKSkubWFwKGQgPT4gZC5kYXRhKS5yZWR1Y2UoKGFjYywgdmFsKSA9PiBhY2MuY29uY2F0KHZhbCkpO1xuICAgICAgICBoZWlnaHQgPSBoZWlnaHQgfHwgdGhpcy5oZWlnaHQoKTtcblxuICAgICAgICBsZXQgZXh0ZW50ID0gZDMuZXh0ZW50KGRhdGEsIGQgPT4gZC5feSlcbiAgICAgICAgaWYgKHRoaXMuX3kyX2dldHRlcikge1xuICAgICAgICAgICAgbGV0IGUyID0gZDMuZXh0ZW50KGRhdGEsIGQgPT4gZC5feTIpXG4gICAgICAgICAgICBleHRlbnRbMF0gPSBNYXRoLm1pbihleHRlbnRbMF0sIGUyWzBdKVxuICAgICAgICAgICAgZXh0ZW50WzFdID0gTWF0aC5tYXgoZXh0ZW50WzFdLCBlMlsxXSlcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG1heCA9IE1hdGgubWF4KGV4dGVudFsxXSwgdGhpcy5fYXhpc19tYXhfdmFsdWUgfHwgMClcbiAgICAgICAgY29uc3QgbWluID0gTWF0aC5taW4odGhpcy5fYXhpc19taW5fdmFsdWUgfHwgMCwgZXh0ZW50WzBdKVxuICAgICAgICByZXR1cm4gZDMuc2NhbGVMaW5lYXIoKS5yYW5nZVJvdW5kKFtoZWlnaHQsIDBdKS5uaWNlKCkuZG9tYWluKFttaW4sIG1heF0pO1xuICAgIH1cblxuICAgIGdldEQzWEdyb3VwU2NhbGUoZGF0YSwgeHNjYWxlKSB7XG4gICAgICAgIHJldHVybiBkMy5zY2FsZUJhbmQoKVxuICAgICAgICAgICAgICAgICAucGFkZGluZygwKVxuICAgICAgICAgICAgICAgICAuZG9tYWluKHRoaXMuZ2V0S2V5cyhkYXRhKSlcbiAgICAgICAgICAgICAgICAgLnJhbmdlUm91bmQoWzAsIHhzY2FsZS5iYW5kd2lkdGgoKV0pO1xuICAgIH1cblxuICAgIHJlbmRlckxhYmVscyhzZWxlY3Rpb24sIGRhdGEsIHhzY2FsZSwgeGdyb3VwLCB5c2NhbGUsIGNvbG91clNjYWxlLCBhbmltYXRlKSB7XG4gICAgICAgIGFuaW1hdGUgPSBhbmltYXRlID09PSB1bmRlZmluZWQgPyB0cnVlIDogYW5pbWF0ZTtcbiAgICAgICAgc2VsZWN0aW9uLnNlbGVjdEFsbChcIi5jaGFydC1sYWJlbHNcIikucmVtb3ZlKCk7XG5cbiAgICAgICAgbGV0IGxhYmVscyA9IHNlbGVjdGlvbi5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwiY2hhcnQtbGFiZWxzXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKFwiLmxhYmVsLWdyb3VwXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZGF0YShkYXRhKTtcblxuICAgICAgICBsZXQgbWF4V2lkdGggPSAwOyAgICAgLy8gRm9yIGNhbGN1bGF0aW5nIHRoZSBtYXggd2lkdGggb2YgdGV4dC5cbiAgICAgICAgbGV0IGZvbnRTaXplID0gdGhpcy5fZm9udF9zaXplOyAgICAvLyBPdXIgaW5pdGlhbCBmb250IHNpemUuXG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IDU7ICAgICAvLyBCdWZmZXIgc3BhY2UgYmV0d2VlbiB3b3JkcyBhbmQgdGhlIHRvcCBvZiBhIGJhci5cbiAgICAgICAgY29uc3QgY2FsY0R5ID0gKHksIHlwb3MpID0+ICgoeSA+PSAwICYmIHlwb3MgPCAxMCkgfHwgKCB5IDwgMCAmJiB0aGlzLl9oZWlnaHQgLSB5cG9zID4gMTApKSA/IGZvbnRTaXplICsgMjogLWJ1ZmZlcjtcblxuICAgICAgICAvLyBXYW50IHRvIGZpZ3VyZSBvdXQgaWYgdGhlIGxhYmVsIGlzIHRvbyBkYXJrIC8gbGlnaHQgZm9yIHRoZVxuICAgICAgICAvLyBiYXIuXG4gICAgICAgIGNvbnN0IGdldEludmVydGVkQ29sb3IgPSBkID0+IHtcbiAgICAgICAgICAgIGxldCBpbnZlcnRlZENvbG9yID0gZDMuaGNsKHRoaXMuZ2V0RDNDb2xvdXIoZCkpO1xuICAgICAgICAgICAgaW52ZXJ0ZWRDb2xvci5sICs9IE1hdGgubWluKGludmVydGVkQ29sb3IubCArIDUwLCAxMDApO1xuICAgICAgICAgICAgcmV0dXJuIGludmVydGVkQ29sb3I7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHNob3VsZEludmVydCA9IGQgPT4gZDMuaGNsKHRoaXMuZ2V0RDNDb2xvdXIoZCkpLmwgPCA2MDtcbiAgICAgICAgY29uc3QgZmlsbENvbG91ciA9IGQzLmhjbChjb2xvdXJzLmVpZ2h0ZWVuLmRhcmtHcmV5KS5icmlnaHRlcigpO1xuICAgICAgICBjb25zdCBsaWdodGVyRmlsbENvbG91ciA9IGQzLmhjbChjb2xvdXJzLmVpZ2h0ZWVuLm1pZEdyZXkpO1xuICAgICAgICBjb25zdCBmaW5kQ29sb3VyID0gKGQsIGR5LCBsYWJlbFRleHQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG9uQmFyID0gKGQuX3kgPj0gMCAmJiBkeSA+IDAgfHwgZC5feSA8IDAgJiYgZHkgPCAwKTtcbiAgICAgICAgICAgIHJldHVybiBvbkJhciAmJiBzaG91bGRJbnZlcnQoZClcbiAgICAgICAgICAgICAgICA/IGdldEludmVydGVkQ29sb3IoZCkudG9TdHJpbmcoKVxuICAgICAgICAgICAgICAgIDogKGxhYmVsSXNaZXJvKGxhYmVsVGV4dClcbiAgICAgICAgICAgICAgICAgICAgPyBsaWdodGVyRmlsbENvbG91clxuICAgICAgICAgICAgICAgICAgICA6IChvbkJhciA/IGQzLmhjbChmaWxsQ29sb3VyKS5kYXJrZXIoKSA6IGZpbGxDb2xvdXIpKTtcbiAgICAgICAgfTtcblxuICAgICAgICBsYWJlbHMuZW50ZXIoKS5lYWNoKChzZXJpZXMsIHNfaSwgc19ub2RlcykgPT4ge1xuICAgICAgICAgICAgLy8gV2Ugd2FudCB0byBkZXRlcm1pbmUgd2hpY2ggZ3JvdXBzIG1heSBoYXZlIG1pc3NpbmcgdmFsdWVzLCBhbmQgcHJvdmlkZSB0aGVtLlxuICAgICAgICAgICAgY29uc3QgcmVxdWlyZWRHcm91cHMgPSB7fTtcbiAgICAgICAgICAgIHhncm91cC5kb21haW4oKS5tYXAoZnJvbUtleSkuZm9yRWFjaChkID0+IHtcbiAgICAgICAgICAgICAgICByZXF1aXJlZEdyb3Vwc1tkLl9jb2xvdXJdID0gZDtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBzZXJpZXMuZGF0YS5mb3JFYWNoKGQgPT4ge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSByZXF1aXJlZEdyb3Vwc1tkLl9jb2xvdXJdXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY29uc3QgbWlzc2luZ0dyb3VwcyA9IE9iamVjdC52YWx1ZXMocmVxdWlyZWRHcm91cHMpO1xuICAgICAgICAgICAgbWlzc2luZ0dyb3Vwcy5mb3JFYWNoKGQgPT4ge1xuICAgICAgICAgICAgICAgIGQuX3ggPSBzZXJpZXMuX2tleTtcbiAgICAgICAgICAgICAgICBkLl95ID0gMDtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBkMy5zZWxlY3Qoc19ub2Rlc1tzX2ldKVxuICAgICAgICAgICAgICAuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwibGFiZWwtZ3JvdXBcIilcbiAgICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgZCA9PiBcInRyYW5zbGF0ZShcIiArIHhzY2FsZShkLl9rZXkpICsgXCIsMClcIilcbiAgICAgICAgICAgICAgLnNlbGVjdEFsbChcIi5jaGFydC1sYWJlbFwiKVxuICAgICAgICAgICAgICAuZGF0YShzZXJpZXMuZGF0YS5jb25jYXQoT2JqZWN0LnZhbHVlcyhtaXNzaW5nR3JvdXBzKSkpXG4gICAgICAgICAgICAgIC5lbnRlcigpXG4gICAgICAgICAgICAgIC5lYWNoKChkLCBpLCBub2RlcykgPT4ge1xuICAgICAgICAgICAgICAgICAgY29uc3QgbGFiZWxUZXh0ID0gdGhpcy5mb3JtYXRMYWJlbCgpKGQuX3ksIGQpO1xuICAgICAgICAgICAgICAgICAgbGV0IHlwb3MgPSB5c2NhbGUoZC5feSk7XG4gICAgICAgICAgICAgICAgICBsZXQgZHkgPSBjYWxjRHkoZC5feSwgeXBvcyk7XG4gICAgICAgICAgICAgICAgICBsZXQgdGV4dCA9IGQzLnNlbGVjdChub2Rlc1tpXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAudGV4dChsYWJlbFRleHQpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJmb250LXNpemVcIiwgZm9udFNpemUgKyBcInB4XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIGQgPT4gXCJjaGFydC1sYWJlbCBzZXJpZXMgc2VyaWVzLVwiICsgdG9Db2xvdXJLZXkoZC5fY29sb3VyKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwieVwiLCB5cG9zKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJkeFwiLCBhbmltYXRlID8gLTE1IDogMClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiZHlcIiwgZHkpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDApXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJwb2ludGVyLWV2ZW50c1wiLCBcIm5vbmVcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcImZpbGxcIiwgZCA9PiBmaW5kQ29sb3VyKGQsIGR5LCBsYWJlbFRleHQpKTtcblxuICAgICAgICAgICAgICAgICAgLy8gU2V0IHRoZSB4IHBvc2l0aW9uLCB3aGljaCBpcyBiYXNlZCBvbiB3aWR0aC5cbiAgICAgICAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gdGV4dC5ub2RlKCkuZ2V0QkJveCgpLndpZHRoO1xuICAgICAgICAgICAgICAgICAgbWF4V2lkdGggPSBNYXRoLm1heCh3aWR0aCwgbWF4V2lkdGgpO1xuICAgICAgICAgICAgICAgICAgdGV4dFxuICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwieFwiLCB4Z3JvdXAoZC5fa2V5KSArIHhncm91cC5iYW5kd2lkdGgoKSAvIDIgLSB3aWR0aCAvIDIpO1xuXG4gICAgICAgICAgICAgICAgICB0ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgLnRyYW5zaXRpb24oXCJsYWJlbHNcIilcbiAgICAgICAgICAgICAgICAgICAgICAuZGVsYXkoKCkgPT4gYW5pbWF0ZSA/IHRoaXMuY2FsY0Jhckdyb3d0aChzX2ksIHNfbm9kZXMubGVuZ3RoKSA6IDApIC8vIERlbGF5IGluIGxvY2tzdGVwIHdpdGggYmFyIGdyb3d0aC5cbiAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcImR4XCIsIDApXG4gICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAxKVxuICAgICAgICAgICAgICB9KVxuICAgICAgICB9KTtcblxuXG4gICAgICAgIC8vIEZpZ3VyZSBvdXQgaWYgd2UgZG9uJ3QgaGF2ZSBlbm91Z2ggc3BhY2UgdG8gc2hvdyBvdXIgbGFiZWxzLlxuICAgICAgICAvLyBXZSB0aGVuIHdhbnQgdG8gcmVzaXplLCBpZiBwb3NzaWJsZS5cbiAgICAgICAgaWYgKHhncm91cC5iYW5kd2lkdGgoKSA8IG1heFdpZHRoICogMS4xMCkge1xuICAgICAgICAgICAgbGV0IHNjYWxlID0gbWF4V2lkdGggLyB4Z3JvdXAuYmFuZHdpZHRoKCkgKiAxLjEwO1xuICAgICAgICAgICAgZm9udFNpemUgPSBNYXRoLmZsb29yKGZvbnRTaXplIC8gc2NhbGUpO1xuXG4gICAgICAgICAgICBpZiAoZm9udFNpemUgPCAxMCkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBsYWJlbHMgYXJlIHRvbyBzbWFsbC5cbiAgICAgICAgICAgICAgICBsYWJlbHMuZW50ZXIoKS5zZWxlY3RBbGwoXCJ0ZXh0XCIpLnJlbW92ZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsYWJlbHMuZW50ZXIoKVxuICAgICAgICAgICAgICAgICAgICAgIC5tZXJnZShsYWJlbHMpXG4gICAgICAgICAgICAgICAgICAgICAgLnNlbGVjdEFsbChcInRleHRcIilcbiAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJmb250LXNpemVcIiwgZm9udFNpemUgKyBcInB4XCIpXG4gICAgICAgICAgICAgICAgICAgICAgLmVhY2goKGQsIGksIG5vZGVzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRleHQgPSBkMy5zZWxlY3Qobm9kZXNbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB3aWR0aCA9IHRleHQubm9kZSgpLmdldEJCb3goKS53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZHkgPSBjYWxjRHkoZC5feSwgeXNjYWxlKGQuX3kpKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcInhcIiwgeGdyb3VwKGQuX2tleSkgKyB4Z3JvdXAuYmFuZHdpZHRoKCkgLyAyIC0gd2lkdGggLyAyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBkID0+IGZpbmRDb2xvdXIoZCwgZHksIHRleHQudGV4dCgpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiZHlcIiwgZHkpO1xuICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIGltbWVkaWF0ZWx5UmVuZGVyTGFiZWxzKHNob3cpIHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuZWxlbWVudCgpO1xuICAgICAgICBpZiAoIWVsZW1lbnQpIHJldHVybjtcblxuICAgICAgICBpZiAoIXNob3cpIHsgLy8gSGlkZXMgdGhlIGxhYmVsc1xuICAgICAgICAgICAgZWxlbWVudFxuICAgICAgICAgICAgICAuc2VsZWN0KCcuY2hhcnQtbGFiZWxzJylcbiAgICAgICAgICAgICAgLmludGVycnVwdChcImxhYmVsc1wiKVxuICAgICAgICAgICAgICAuaW50ZXJydXB0KFwibGFiZWxzOmZhZGVcIilcbiAgICAgICAgICAgICAgLnRyYW5zaXRpb24oXCJsYWJlbHM6ZmFkZVwiKVxuICAgICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDApXG4gICAgICAgICAgICAgIC5vbihcImVuZFwiLCAoZCwgaSwgbm9kZXMpID0+IHtcbiAgICAgICAgICAgICAgICAgIGQzLnNlbGVjdChub2Rlc1tpXSkucmVtb3ZlKCk7XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgbGFiZWxzID0gZWxlbWVudC5zZWxlY3QoJy5jaGFydC1sYWJlbHMnKTtcbiAgICAgICAgICAgIGlmICghbGFiZWxzLmVtcHR5KCkpIHJldHVybjtcblxuICAgICAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMucHJlcGFyZURhdGEobnVsbCwgdHJ1ZSk7XG4gICAgICAgICAgICBjb25zdCBhbGxEYXRhID0gdGhpcy5wcmVwYXJlRGF0YShudWxsLCBmYWxzZSk7XG5cbiAgICAgICAgICAgIGNvbnN0IHhzY2FsZSA9IHRoaXMuZ2V0RDNYU2NhbGUoZGF0YSksXG4gICAgICAgICAgICAgICAgICB4Z3JvdXAgPSB0aGlzLmdldEQzWEdyb3VwU2NhbGUoZGF0YSwgeHNjYWxlKSxcbiAgICAgICAgICAgICAgICAgIHlzY2FsZSA9IHRoaXMuZ2V0RDNZU2NhbGUoZGF0YSksXG4gICAgICAgICAgICAgICAgICBjb2xvdXJTY2FsZSA9IHRoaXMuZDNDb2xvdXJTY2FsZSgpO1xuXG4gICAgICAgICAgICBsYWJlbHMucmVtb3ZlKCk7XG4gICAgICAgICAgICB0aGlzLnJlbmRlckxhYmVscyhlbGVtZW50LCBkYXRhLCB4c2NhbGUsIHhncm91cCwgeXNjYWxlLCBjb2xvdXJTY2FsZSwgZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICB9XG5cblxufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBoaXN0b2dyYW0oKSB7XG4gICAgcmV0dXJuIG5ldyBIaXN0b2dyYW0oKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbHVtbkNoYXJ0KCkge1xuICAgIHJldHVybiBuZXcgSGlzdG9ncmFtKFwiQ09MVU1OX0NIQVJUXCIsIDAuMSk7XG59Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/chart/Histogram.js\n')},"./src/chart/Line.js":
/*!***************************!*\
  !*** ./src/chart/Line.js ***!
  \***************************/
/*! exports provided: line */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "line", function() { return line; });\n/* harmony import */ var _Geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Geometry */ "./src/chart/Geometry.js");\n/* harmony import */ var _Legend__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Legend */ "./src/Legend.js");\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helpers */ "./src/helpers.js");\n/* harmony import */ var _Colours__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Colours */ "./src/Colours.js");\n// Copyright (C) 2013-2014, 2018 BrandsEye (PTY) LTD\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this\n// software and associated documentation files (the "Software"), to deal in the Software\n// without restriction, including without limitation the rights to use, copy, modify,\n//     merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following\n// conditions:\n//\n//     The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n//     INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n// CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n\n\n\n\nclass Line extends _Geometry__WEBPACK_IMPORTED_MODULE_0__["Geometry"] {\n\n    constructor() {\n        super("LINE", 2);\n        this._stroke_width = 2\n        this._curve = \'curveCatmullRom\'\n    }\n\n    curve(curve) {\n        if (arguments.length === 0) return this._curve;\n        this._curve = curve;\n        return this;\n    }\n\n    render() {\n        const element = this._element;\n        const data = this.prepareData(null, true);\n        const width = this._width,\n              height = this._height;\n        const allData = this.prepareData(null, false).map(d => d.data).reduce((acc, val) => acc.concat(val));\n\n        element.classed("line-chart", true);\n        element.style("opacity", this._opacity === null ? 1.0 : this._opacity)\n\n\n        const x = this.getD3XScale(allData, width);\n        const y = this.getD3YScale(allData, height);\n        const invert = d3.scaleQuantize().domain(x.range()).range(x.domain());\n\n        // render gradient to match the scale if needed\n        let gradientId\n        if (this._gradient_fn) {\n            element.select("g.gradient").remove()\n            this.gradientId = gradientId = this._gradient_fn(element.append("g").attr("class", "gradient"), y, this)\n        }\n\n        //---------------------------------\n        // append the lines\n        let lineGroup = element.select(".lines");\n        lineGroup.selectAll("circle").remove();\n\n        let circle = false;\n        let lastMouse = null;\n        let lastMin = null;\n        const firstGeometry = !this._index\n        let that = this\n\n        if (lineGroup.empty()) {\n            lineGroup = element\n                .append("g")\n                .attr("class", "lines")\n                .attr("width", this.width())\n                .attr("height", this.height());\n\n            if (firstGeometry) { // only add the bg rectangle if we are the first geometry or we will obscure the others\n                // This is needed to provide area for mouse interactions.\n                lineGroup\n                    .append("rect")\n                    .style("opacity", "0")\n                    .attr("width", "100%")\n                    .attr("height", "100%");\n            }\n        }\n\n        if (this.scaleX().isContinuous() && firstGeometry) {\n            lineGroup\n                .on("mousemove", (d, i, nodes) => { // Darken the bar on mouse over\n                    const mouse = d3.mouse(nodes[i]);\n\n                    const xval = invert(mouse[0]);\n                    const yval = y.invert(mouse[1]);\n                    // let min = this.getClosestPoint(xval, yval, this.getTransformedData()[0].data);\n\n                    let mins = data.map(d => getClosestPoint(xval, yval, d.data));\n                    mins.forEach(d => d._dist =  [x(d._x), y(d._y)]);\n\n                    mins = mins.filter(min => {\n                        const minScreenDist = Math.sqrt((mouse[0] - min._dist[0]) ** 2 + (mouse[1] - min._dist[1]) ** 2);\n                        min._min_screen = minScreenDist;\n                        return minScreenDist < 100;\n                    });\n\n\n                    if (!mins || !mins.length) {\n                        lastMouse = null;\n                        lineGroup.selectAll("circle").remove();\n                        return;\n                    }\n\n                    mins = mins.sort((lhs, rhs) => lhs._min_screen - rhs._min_screen);\n                    let min = mins[0];\n\n                    if (circle) {\n                        if (lastMin && min._x.getTime() === lastMin._x.getTime()) return;\n                        lineGroup.selectAll("circle").remove();\n                    }\n\n                    circle = true;\n                    lastMouse = mouse;\n                    lastMin = min;\n                    lineGroup\n                        .append("circle")\n                        .attr("cx", x(min._x) + x.bandwidth() / 2)\n                        .attr("cy", y(min._y))\n                        .attr("r", 10)\n                        .attr("fill", this.getD3Colour(d))\n                        .style("opacity", 0.1)\n                        .on("contextmenu", () => d3.event.preventDefault()) // No right click.\n                        .on("click auxclick", (d, i, nodes) => {\n                            this._dispatch.call("elementClick", this, {\n                                e: d3.event,\n                                point: min,\n                                series: data[min._s_i],\n                                seriesIndex: min._s_i,\n                                value: min._y,\n                                geometry: that\n                            })\n                        })\n                        .on("mouseover", () => {\n                            this._dispatch.call("tooltipShow", this, {\n                                e: d3.event,\n                                point: min,\n                                series: data[min._s_i],\n                                seriesIndex: min._s_i,\n                                value: min._y,\n                                geometry: that\n                            })\n                        })\n                        .on("mouseout", (d, i, nodes) => { // bar is regular colour on mouse out.\n                            this._dispatch.call("tooltipHide", this);\n                        })\n                        .transition()\n                        .style("opacity", 0.5)\n\n                });\n        }\n\n        const lineGeom = d3.line()\n            .x(d => x(d._x) + x.bandwidth() / 2)\n            .y(d => y(d._y))\n            .curve(d3[this._curve]);\n\n        const flatGeom = d3.line()\n            .x(d => x(d._x) + x.bandwidth() / 2)\n            .y(y(0))\n            .curve(d3[this._curve]);\n\n        let lines = lineGroup.selectAll(\'.line\');\n        lines = lines.data(data, d => d._key);\n\n        lines.exit()\n            .interrupt()\n            .transition()\n            .attr("d", d => flatGeom(d.data))\n            .style("opacity", 0)\n            .on("end", (d, i, nodes) => d3.select(nodes[i]).remove());\n\n\n\n        const determineStrokeWidth = d => d.data.length <= 1 ? 20 : this._stroke_width;\n        const transparentColour = d3.hcl(_Colours__WEBPACK_IMPORTED_MODULE_3__["colours"].eighteen.darkGrey);\n        transparentColour.opacity = 0.8;\n        const determineStrokeColour = d => d3.hcl(this.getD3Colour(d)).c < 20 ? transparentColour : "none";\n        const strokeFn = d => gradientId ? "url(#" + gradientId + ")" : d3.hcl(this.getD3Colour(d.data[0]))\n\n        lines.interrupt("line:resize")\n            .transition("line:resize")\n            .duration(500)\n            .attr("d", d => lineGeom(d.data))\n            .attr("stroke", strokeFn)\n            .style("stroke-width", determineStrokeWidth);\n\n        lines\n            .enter()\n            .append("path")\n                .attr("class", d => "line series series-" + Object(_Legend__WEBPACK_IMPORTED_MODULE_1__["toColourKey"])(d.data[0]._colour))\n                .attr("fill", "none")\n                .attr("stroke-linejoin", "round")\n                .attr("stroke-linecap", "round")\n                .style("opacity", 0)\n                .attr("d", d => flatGeom(d.data))\n            .merge(lines)\n            .style("stroke-width", determineStrokeWidth) // Want to make a circle if we have a line with only a single data point\n            .attr("stroke", strokeFn)\n            .transition("line:introduction")\n            .duration(500)\n            .delay(100)\n                .style("opacity", 1)\n                .attr("d", d => lineGeom(d.data));\n\n\n        element.selectAll(".domain-selector").remove();\n        if (this.scaleX().isDiscrete()) {\n            if (!firstGeometry) { // can\'t use bars as we are on top of another geometry\n                let mid = x.bandwidth() / 2\n                let r = Math.min(Math.max(mid, 3), 12)\n\n                let dsg = lineGroup.selectAll(\'g.domain-selector\').data(data, d => d._key)\n                dsg.exit().remove()\n                dsg = dsg.enter().append("g").attr("class", "domain-selector").merge(dsg)\n                dsg.each(function(row) {\n                    let colour = strokeFn(row)\n                    let sel = d3.select(this)\n                    let circles = sel.selectAll("circle.target").data(row.data)\n                    circles.exit().remove()\n                    circles = circles.enter().append("circle").attr("class", "target").merge(circles)\n                    circles.attr("r", r).attr("cx", d => x(d._x) + mid).attr("cy", d => y(d._y)).attr("fill", colour)\n                        .attr("opacity", 0.0)\n                        .on("mouseenter", d => that._dispatch.call("tooltipShow", that, { e: d3.event, point: d, geometry: that }))\n                        .on("contextmenu", () => d3.event.preventDefault()) // No right click.\n                        .on("click auxclick", d => that._dispatch.call("elementClick", that, { e: d3.event, point: d, geometry: that }))\n                })\n            } else {\n                const selectors = element\n                    .selectAll(".domain-selector")\n                    .data(x.domain());\n\n                selectors.enter()\n                         .append("g")\n                         .attr("class", "domain-selector")\n                         .each((d, i, nodes) => {\n                             const selector = d3.select(nodes[i]);\n                             selector.append("rect")\n                                 .attr("x", d => x(d))\n                                 .attr("y", y.range()[1])\n                                 .attr("width", x.bandwidth() + "px")\n                                 .attr("height", Math.abs(y.range()[0] - y.range()[1]))\n                                 .style("fill", d3.color("#487329"))\n                                 .style("opacity", 0);\n\n                             const STANDARD_OPACITY = 0.7;\n                             const RADIUS = 10;\n\n                             selector.on("mouseenter", d => {\n                                     const rect = selector.select("rect");\n                                     rect.interrupt("selector:highlight")\n                                         .transition("selector:highlight")\n                                         .duration(250)\n                                         .style("opacity", 0.2);\n\n                                     var inSelection = data\n                                         .map(line => {\n                                             return line.data.filter(p => {\n                                                 return Object(_helpers__WEBPACK_IMPORTED_MODULE_2__["equals"])(p._x, d);\n                                             })\n                                         })\n                                         .flat();\n\n                                     if (inSelection.length) {\n                                         // this._dispatch.call("tooltipShow", this, {\n                                         //     e: d3.event,\n                                         //     point: inSelection[0],\n                                         //     points: inSelection\n                                         // });\n\n                                         selector\n                                             .selectAll(".line-highlight")\n                                             .data(inSelection)\n                                             .enter()\n                                             .append("circle")\n                                                 .attr("class", "line-highlight")\n                                                 .attr("cx", d => x(d._x) + x.bandwidth() / 2)\n                                                 .attr("cy", d => y(d._y))\n                                                 .attr("r", 1)\n                                                 .style("cursor", "pointer")\n                                                 .style("opacity", 0)\n                                                 .style("fill", d => this.getD3Colour(d))\n                                                 .style("stroke", determineStrokeColour)\n                                             .on("contextmenu", () => d3.event.preventDefault()) // No right click.\n                                             .on("click auxclick", d => {\n                                                 this._dispatch.call("elementClick", this, {\n                                                     e: d3.event,\n                                                     point: d\n                                                 })\n                                             })\n                                             .on("mouseover", (d, i, nodes) => {\n                                                 this._dispatch.call("tooltipShow", this, {\n                                                     e: d3.event,\n                                                     point: d\n                                                 });\n\n                                                 d3.select(nodes[i])\n                                                   .interrupt()\n                                                   .transition()\n                                                   .style("opacity", 1)\n                                                   .attr("r", 15);\n                                             })\n                                             .on("mouseout", (d, i, nodes) => {\n                                                 d3.select(nodes[i])\n                                                   .interrupt()\n                                                   .transition()\n                                                   .style("opacity", STANDARD_OPACITY)\n                                                   .attr("r", RADIUS);\n                                             })\n                                             .transition()\n                                                 .delay(150)\n                                                 .duration(250)\n                                                 .attr("r", RADIUS)\n                                                 .style("opacity", STANDARD_OPACITY);\n                                     }\n\n\n\n                                 })\n                                 .on("mouseleave", d => {\n                                     const rect = selector.select("rect");\n                                     rect.interrupt("selector:highlight")\n                                         .transition()\n                                         .style("opacity", 0);\n\n                                     selector.selectAll(".line-highlight")\n                                             .interrupt()\n                                             .transition()\n                                             .style("opacity", 0)\n                                             .attr("r", 1)\n                                             .on("end", (d, i, nodes) => d3.select(nodes[i]).remove());\n                                 });\n                         })\n            }\n        }\n    }\n\n\n    getD3XScale(data, width) {\n        width = width || this.width();\n        data = data || this.prepareData()\n                           .map(d => d.data)\n                           .reduce((acc, val) => acc.concat(val));\n\n\n        return d3.scaleBand()\n            .range([0, width])\n            .paddingInner(this._padding || 0)    // must use padding so lines fit properly over bars\n            .domain(data.map(d => d._x));\n    }\n\n    getD3YScale(data, height) {\n        data = data || this.prepareData()\n                           .map(d => d.data)\n                           .reduce((acc, val) => acc.concat(val));\n        height = height || this.height();\n\n        let extent = d3.extent(data, d => d._y)\n        let max = Math.max(extent[1], this._axis_max_value || 0)\n        let min = Math.min(this._axis_min_value || 0, extent[0])\n        return d3.scaleLinear().range([height, 0]).nice(5).domain([min, max])\n    }\n}\n\n\nfunction getClosestPoint(xval, yval, data) {\n    let calcDist = d => Math.sqrt(Math.abs(d._x - xval) ** 2 + (d._y - yval) ** 2);\n    let min = data[0];\n    let minDist = calcDist(min);\n\n    data.forEach(d => {\n        let dist = calcDist(d);\n        if (dist < minDist) {\n            minDist = dist;\n            min = d;\n        }\n    });\n\n    return min;\n}\n\n\n\nfunction line() {\n    return new Line();\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY2hhcnQvTGluZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2IzanMvLi9zcmMvY2hhcnQvTGluZS5qcz8yZDkxIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoQykgMjAxMy0yMDE0LCAyMDE4IEJyYW5kc0V5ZSAoUFRZKSBMVERcbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXNcbi8vIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZVxuLy8gd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LFxuLy8gICAgIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG9cbi8vIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nXG4vLyBjb25kaXRpb25zOlxuLy9cbi8vICAgICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbi8vIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gICAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1IgSU1QTElFRCxcbi8vICAgICBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQVxuLy8gUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxuLy8gSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GXG4vLyBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkVcbi8vIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5pbXBvcnQge0dlb21ldHJ5fSBmcm9tICcuL0dlb21ldHJ5JztcbmltcG9ydCB7dG9Db2xvdXJLZXl9IGZyb20gXCIuLi9MZWdlbmRcIjtcbmltcG9ydCB7ZXF1YWxzfSBmcm9tIFwiLi4vaGVscGVyc1wiO1xuaW1wb3J0IHtjb2xvdXJzfSBmcm9tIFwiLi4vQ29sb3Vyc1wiO1xuXG5cbmNsYXNzIExpbmUgZXh0ZW5kcyBHZW9tZXRyeSB7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoXCJMSU5FXCIsIDIpO1xuICAgICAgICB0aGlzLl9zdHJva2Vfd2lkdGggPSAyXG4gICAgICAgIHRoaXMuX2N1cnZlID0gJ2N1cnZlQ2F0bXVsbFJvbSdcbiAgICB9XG5cbiAgICBjdXJ2ZShjdXJ2ZSkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX2N1cnZlO1xuICAgICAgICB0aGlzLl9jdXJ2ZSA9IGN1cnZlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLl9lbGVtZW50O1xuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5wcmVwYXJlRGF0YShudWxsLCB0cnVlKTtcbiAgICAgICAgY29uc3Qgd2lkdGggPSB0aGlzLl93aWR0aCxcbiAgICAgICAgICAgICAgaGVpZ2h0ID0gdGhpcy5faGVpZ2h0O1xuICAgICAgICBjb25zdCBhbGxEYXRhID0gdGhpcy5wcmVwYXJlRGF0YShudWxsLCBmYWxzZSkubWFwKGQgPT4gZC5kYXRhKS5yZWR1Y2UoKGFjYywgdmFsKSA9PiBhY2MuY29uY2F0KHZhbCkpO1xuXG4gICAgICAgIGVsZW1lbnQuY2xhc3NlZChcImxpbmUtY2hhcnRcIiwgdHJ1ZSk7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUoXCJvcGFjaXR5XCIsIHRoaXMuX29wYWNpdHkgPT09IG51bGwgPyAxLjAgOiB0aGlzLl9vcGFjaXR5KVxuXG5cbiAgICAgICAgY29uc3QgeCA9IHRoaXMuZ2V0RDNYU2NhbGUoYWxsRGF0YSwgd2lkdGgpO1xuICAgICAgICBjb25zdCB5ID0gdGhpcy5nZXREM1lTY2FsZShhbGxEYXRhLCBoZWlnaHQpO1xuICAgICAgICBjb25zdCBpbnZlcnQgPSBkMy5zY2FsZVF1YW50aXplKCkuZG9tYWluKHgucmFuZ2UoKSkucmFuZ2UoeC5kb21haW4oKSk7XG5cbiAgICAgICAgLy8gcmVuZGVyIGdyYWRpZW50IHRvIG1hdGNoIHRoZSBzY2FsZSBpZiBuZWVkZWRcbiAgICAgICAgbGV0IGdyYWRpZW50SWRcbiAgICAgICAgaWYgKHRoaXMuX2dyYWRpZW50X2ZuKSB7XG4gICAgICAgICAgICBlbGVtZW50LnNlbGVjdChcImcuZ3JhZGllbnRcIikucmVtb3ZlKClcbiAgICAgICAgICAgIHRoaXMuZ3JhZGllbnRJZCA9IGdyYWRpZW50SWQgPSB0aGlzLl9ncmFkaWVudF9mbihlbGVtZW50LmFwcGVuZChcImdcIikuYXR0cihcImNsYXNzXCIsIFwiZ3JhZGllbnRcIiksIHksIHRoaXMpXG4gICAgICAgIH1cblxuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBhcHBlbmQgdGhlIGxpbmVzXG4gICAgICAgIGxldCBsaW5lR3JvdXAgPSBlbGVtZW50LnNlbGVjdChcIi5saW5lc1wiKTtcbiAgICAgICAgbGluZUdyb3VwLnNlbGVjdEFsbChcImNpcmNsZVwiKS5yZW1vdmUoKTtcblxuICAgICAgICBsZXQgY2lyY2xlID0gZmFsc2U7XG4gICAgICAgIGxldCBsYXN0TW91c2UgPSBudWxsO1xuICAgICAgICBsZXQgbGFzdE1pbiA9IG51bGw7XG4gICAgICAgIGNvbnN0IGZpcnN0R2VvbWV0cnkgPSAhdGhpcy5faW5kZXhcbiAgICAgICAgbGV0IHRoYXQgPSB0aGlzXG5cbiAgICAgICAgaWYgKGxpbmVHcm91cC5lbXB0eSgpKSB7XG4gICAgICAgICAgICBsaW5lR3JvdXAgPSBlbGVtZW50XG4gICAgICAgICAgICAgICAgLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwibGluZXNcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcIndpZHRoXCIsIHRoaXMud2lkdGgoKSlcbiAgICAgICAgICAgICAgICAuYXR0cihcImhlaWdodFwiLCB0aGlzLmhlaWdodCgpKTtcblxuICAgICAgICAgICAgaWYgKGZpcnN0R2VvbWV0cnkpIHsgLy8gb25seSBhZGQgdGhlIGJnIHJlY3RhbmdsZSBpZiB3ZSBhcmUgdGhlIGZpcnN0IGdlb21ldHJ5IG9yIHdlIHdpbGwgb2JzY3VyZSB0aGUgb3RoZXJzXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBuZWVkZWQgdG8gcHJvdmlkZSBhcmVhIGZvciBtb3VzZSBpbnRlcmFjdGlvbnMuXG4gICAgICAgICAgICAgICAgbGluZUdyb3VwXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoXCJyZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFwid2lkdGhcIiwgXCIxMDAlXCIpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIFwiMTAwJVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnNjYWxlWCgpLmlzQ29udGludW91cygpICYmIGZpcnN0R2VvbWV0cnkpIHtcbiAgICAgICAgICAgIGxpbmVHcm91cFxuICAgICAgICAgICAgICAgIC5vbihcIm1vdXNlbW92ZVwiLCAoZCwgaSwgbm9kZXMpID0+IHsgLy8gRGFya2VuIHRoZSBiYXIgb24gbW91c2Ugb3ZlclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBtb3VzZSA9IGQzLm1vdXNlKG5vZGVzW2ldKTtcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCB4dmFsID0gaW52ZXJ0KG1vdXNlWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeXZhbCA9IHkuaW52ZXJ0KG1vdXNlWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gbGV0IG1pbiA9IHRoaXMuZ2V0Q2xvc2VzdFBvaW50KHh2YWwsIHl2YWwsIHRoaXMuZ2V0VHJhbnNmb3JtZWREYXRhKClbMF0uZGF0YSk7XG5cbiAgICAgICAgICAgICAgICAgICAgbGV0IG1pbnMgPSBkYXRhLm1hcChkID0+IGdldENsb3Nlc3RQb2ludCh4dmFsLCB5dmFsLCBkLmRhdGEpKTtcbiAgICAgICAgICAgICAgICAgICAgbWlucy5mb3JFYWNoKGQgPT4gZC5fZGlzdCA9ICBbeChkLl94KSwgeShkLl95KV0pO1xuXG4gICAgICAgICAgICAgICAgICAgIG1pbnMgPSBtaW5zLmZpbHRlcihtaW4gPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWluU2NyZWVuRGlzdCA9IE1hdGguc3FydCgobW91c2VbMF0gLSBtaW4uX2Rpc3RbMF0pICoqIDIgKyAobW91c2VbMV0gLSBtaW4uX2Rpc3RbMV0pICoqIDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWluLl9taW5fc2NyZWVuID0gbWluU2NyZWVuRGlzdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtaW5TY3JlZW5EaXN0IDwgMTAwO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuXG4gICAgICAgICAgICAgICAgICAgIGlmICghbWlucyB8fCAhbWlucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RNb3VzZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lR3JvdXAuc2VsZWN0QWxsKFwiY2lyY2xlXCIpLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgbWlucyA9IG1pbnMuc29ydCgobGhzLCByaHMpID0+IGxocy5fbWluX3NjcmVlbiAtIHJocy5fbWluX3NjcmVlbik7XG4gICAgICAgICAgICAgICAgICAgIGxldCBtaW4gPSBtaW5zWzBdO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaXJjbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsYXN0TWluICYmIG1pbi5feC5nZXRUaW1lKCkgPT09IGxhc3RNaW4uX3guZ2V0VGltZSgpKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lR3JvdXAuc2VsZWN0QWxsKFwiY2lyY2xlXCIpLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY2lyY2xlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgbGFzdE1vdXNlID0gbW91c2U7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RNaW4gPSBtaW47XG4gICAgICAgICAgICAgICAgICAgIGxpbmVHcm91cFxuICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZChcImNpcmNsZVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJjeFwiLCB4KG1pbi5feCkgKyB4LmJhbmR3aWR0aCgpIC8gMilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiY3lcIiwgeShtaW4uX3kpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJyXCIsIDEwKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJmaWxsXCIsIHRoaXMuZ2V0RDNDb2xvdXIoZCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDAuMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5vbihcImNvbnRleHRtZW51XCIsICgpID0+IGQzLmV2ZW50LnByZXZlbnREZWZhdWx0KCkpIC8vIE5vIHJpZ2h0IGNsaWNrLlxuICAgICAgICAgICAgICAgICAgICAgICAgLm9uKFwiY2xpY2sgYXV4Y2xpY2tcIiwgKGQsIGksIG5vZGVzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlzcGF0Y2guY2FsbChcImVsZW1lbnRDbGlja1wiLCB0aGlzLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGU6IGQzLmV2ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludDogbWluLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXM6IGRhdGFbbWluLl9zX2ldLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXNJbmRleDogbWluLl9zX2ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBtaW4uX3ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5OiB0aGF0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAub24oXCJtb3VzZW92ZXJcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3BhdGNoLmNhbGwoXCJ0b29sdGlwU2hvd1wiLCB0aGlzLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGU6IGQzLmV2ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludDogbWluLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXM6IGRhdGFbbWluLl9zX2ldLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXNJbmRleDogbWluLl9zX2ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBtaW4uX3ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5OiB0aGF0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAub24oXCJtb3VzZW91dFwiLCAoZCwgaSwgbm9kZXMpID0+IHsgLy8gYmFyIGlzIHJlZ3VsYXIgY29sb3VyIG9uIG1vdXNlIG91dC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXNwYXRjaC5jYWxsKFwidG9vbHRpcEhpZGVcIiwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRyYW5zaXRpb24oKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAwLjUpXG5cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGxpbmVHZW9tID0gZDMubGluZSgpXG4gICAgICAgICAgICAueChkID0+IHgoZC5feCkgKyB4LmJhbmR3aWR0aCgpIC8gMilcbiAgICAgICAgICAgIC55KGQgPT4geShkLl95KSlcbiAgICAgICAgICAgIC5jdXJ2ZShkM1t0aGlzLl9jdXJ2ZV0pO1xuXG4gICAgICAgIGNvbnN0IGZsYXRHZW9tID0gZDMubGluZSgpXG4gICAgICAgICAgICAueChkID0+IHgoZC5feCkgKyB4LmJhbmR3aWR0aCgpIC8gMilcbiAgICAgICAgICAgIC55KHkoMCkpXG4gICAgICAgICAgICAuY3VydmUoZDNbdGhpcy5fY3VydmVdKTtcblxuICAgICAgICBsZXQgbGluZXMgPSBsaW5lR3JvdXAuc2VsZWN0QWxsKCcubGluZScpO1xuICAgICAgICBsaW5lcyA9IGxpbmVzLmRhdGEoZGF0YSwgZCA9PiBkLl9rZXkpO1xuXG4gICAgICAgIGxpbmVzLmV4aXQoKVxuICAgICAgICAgICAgLmludGVycnVwdCgpXG4gICAgICAgICAgICAudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAuYXR0cihcImRcIiwgZCA9PiBmbGF0R2VvbShkLmRhdGEpKVxuICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAwKVxuICAgICAgICAgICAgLm9uKFwiZW5kXCIsIChkLCBpLCBub2RlcykgPT4gZDMuc2VsZWN0KG5vZGVzW2ldKS5yZW1vdmUoKSk7XG5cblxuXG4gICAgICAgIGNvbnN0IGRldGVybWluZVN0cm9rZVdpZHRoID0gZCA9PiBkLmRhdGEubGVuZ3RoIDw9IDEgPyAyMCA6IHRoaXMuX3N0cm9rZV93aWR0aDtcbiAgICAgICAgY29uc3QgdHJhbnNwYXJlbnRDb2xvdXIgPSBkMy5oY2woY29sb3Vycy5laWdodGVlbi5kYXJrR3JleSk7XG4gICAgICAgIHRyYW5zcGFyZW50Q29sb3VyLm9wYWNpdHkgPSAwLjg7XG4gICAgICAgIGNvbnN0IGRldGVybWluZVN0cm9rZUNvbG91ciA9IGQgPT4gZDMuaGNsKHRoaXMuZ2V0RDNDb2xvdXIoZCkpLmMgPCAyMCA/IHRyYW5zcGFyZW50Q29sb3VyIDogXCJub25lXCI7XG4gICAgICAgIGNvbnN0IHN0cm9rZUZuID0gZCA9PiBncmFkaWVudElkID8gXCJ1cmwoI1wiICsgZ3JhZGllbnRJZCArIFwiKVwiIDogZDMuaGNsKHRoaXMuZ2V0RDNDb2xvdXIoZC5kYXRhWzBdKSlcblxuICAgICAgICBsaW5lcy5pbnRlcnJ1cHQoXCJsaW5lOnJlc2l6ZVwiKVxuICAgICAgICAgICAgLnRyYW5zaXRpb24oXCJsaW5lOnJlc2l6ZVwiKVxuICAgICAgICAgICAgLmR1cmF0aW9uKDUwMClcbiAgICAgICAgICAgIC5hdHRyKFwiZFwiLCBkID0+IGxpbmVHZW9tKGQuZGF0YSkpXG4gICAgICAgICAgICAuYXR0cihcInN0cm9rZVwiLCBzdHJva2VGbilcbiAgICAgICAgICAgIC5zdHlsZShcInN0cm9rZS13aWR0aFwiLCBkZXRlcm1pbmVTdHJva2VXaWR0aCk7XG5cbiAgICAgICAgbGluZXNcbiAgICAgICAgICAgIC5lbnRlcigpXG4gICAgICAgICAgICAuYXBwZW5kKFwicGF0aFwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgZCA9PiBcImxpbmUgc2VyaWVzIHNlcmllcy1cIiArIHRvQ29sb3VyS2V5KGQuZGF0YVswXS5fY29sb3VyKSlcbiAgICAgICAgICAgICAgICAuYXR0cihcImZpbGxcIiwgXCJub25lXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJzdHJva2UtbGluZWpvaW5cIiwgXCJyb3VuZFwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwic3Ryb2tlLWxpbmVjYXBcIiwgXCJyb3VuZFwiKVxuICAgICAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMClcbiAgICAgICAgICAgICAgICAuYXR0cihcImRcIiwgZCA9PiBmbGF0R2VvbShkLmRhdGEpKVxuICAgICAgICAgICAgLm1lcmdlKGxpbmVzKVxuICAgICAgICAgICAgLnN0eWxlKFwic3Ryb2tlLXdpZHRoXCIsIGRldGVybWluZVN0cm9rZVdpZHRoKSAvLyBXYW50IHRvIG1ha2UgYSBjaXJjbGUgaWYgd2UgaGF2ZSBhIGxpbmUgd2l0aCBvbmx5IGEgc2luZ2xlIGRhdGEgcG9pbnRcbiAgICAgICAgICAgIC5hdHRyKFwic3Ryb2tlXCIsIHN0cm9rZUZuKVxuICAgICAgICAgICAgLnRyYW5zaXRpb24oXCJsaW5lOmludHJvZHVjdGlvblwiKVxuICAgICAgICAgICAgLmR1cmF0aW9uKDUwMClcbiAgICAgICAgICAgIC5kZWxheSgxMDApXG4gICAgICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAxKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiZFwiLCBkID0+IGxpbmVHZW9tKGQuZGF0YSkpO1xuXG5cbiAgICAgICAgZWxlbWVudC5zZWxlY3RBbGwoXCIuZG9tYWluLXNlbGVjdG9yXCIpLnJlbW92ZSgpO1xuICAgICAgICBpZiAodGhpcy5zY2FsZVgoKS5pc0Rpc2NyZXRlKCkpIHtcbiAgICAgICAgICAgIGlmICghZmlyc3RHZW9tZXRyeSkgeyAvLyBjYW4ndCB1c2UgYmFycyBhcyB3ZSBhcmUgb24gdG9wIG9mIGFub3RoZXIgZ2VvbWV0cnlcbiAgICAgICAgICAgICAgICBsZXQgbWlkID0geC5iYW5kd2lkdGgoKSAvIDJcbiAgICAgICAgICAgICAgICBsZXQgciA9IE1hdGgubWluKE1hdGgubWF4KG1pZCwgMyksIDEyKVxuXG4gICAgICAgICAgICAgICAgbGV0IGRzZyA9IGxpbmVHcm91cC5zZWxlY3RBbGwoJ2cuZG9tYWluLXNlbGVjdG9yJykuZGF0YShkYXRhLCBkID0+IGQuX2tleSlcbiAgICAgICAgICAgICAgICBkc2cuZXhpdCgpLnJlbW92ZSgpXG4gICAgICAgICAgICAgICAgZHNnID0gZHNnLmVudGVyKCkuYXBwZW5kKFwiZ1wiKS5hdHRyKFwiY2xhc3NcIiwgXCJkb21haW4tc2VsZWN0b3JcIikubWVyZ2UoZHNnKVxuICAgICAgICAgICAgICAgIGRzZy5lYWNoKGZ1bmN0aW9uKHJvdykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY29sb3VyID0gc3Ryb2tlRm4ocm93KVxuICAgICAgICAgICAgICAgICAgICBsZXQgc2VsID0gZDMuc2VsZWN0KHRoaXMpXG4gICAgICAgICAgICAgICAgICAgIGxldCBjaXJjbGVzID0gc2VsLnNlbGVjdEFsbChcImNpcmNsZS50YXJnZXRcIikuZGF0YShyb3cuZGF0YSlcbiAgICAgICAgICAgICAgICAgICAgY2lyY2xlcy5leGl0KCkucmVtb3ZlKClcbiAgICAgICAgICAgICAgICAgICAgY2lyY2xlcyA9IGNpcmNsZXMuZW50ZXIoKS5hcHBlbmQoXCJjaXJjbGVcIikuYXR0cihcImNsYXNzXCIsIFwidGFyZ2V0XCIpLm1lcmdlKGNpcmNsZXMpXG4gICAgICAgICAgICAgICAgICAgIGNpcmNsZXMuYXR0cihcInJcIiwgcikuYXR0cihcImN4XCIsIGQgPT4geChkLl94KSArIG1pZCkuYXR0cihcImN5XCIsIGQgPT4geShkLl95KSkuYXR0cihcImZpbGxcIiwgY29sb3VyKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJvcGFjaXR5XCIsIDAuMClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5vbihcIm1vdXNlZW50ZXJcIiwgZCA9PiB0aGF0Ll9kaXNwYXRjaC5jYWxsKFwidG9vbHRpcFNob3dcIiwgdGhhdCwgeyBlOiBkMy5ldmVudCwgcG9pbnQ6IGQsIGdlb21ldHJ5OiB0aGF0IH0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm9uKFwiY29udGV4dG1lbnVcIiwgKCkgPT4gZDMuZXZlbnQucHJldmVudERlZmF1bHQoKSkgLy8gTm8gcmlnaHQgY2xpY2suXG4gICAgICAgICAgICAgICAgICAgICAgICAub24oXCJjbGljayBhdXhjbGlja1wiLCBkID0+IHRoYXQuX2Rpc3BhdGNoLmNhbGwoXCJlbGVtZW50Q2xpY2tcIiwgdGhhdCwgeyBlOiBkMy5ldmVudCwgcG9pbnQ6IGQsIGdlb21ldHJ5OiB0aGF0IH0pKVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlbGVjdG9ycyA9IGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgLnNlbGVjdEFsbChcIi5kb21haW4tc2VsZWN0b3JcIilcbiAgICAgICAgICAgICAgICAgICAgLmRhdGEoeC5kb21haW4oKSk7XG5cbiAgICAgICAgICAgICAgICBzZWxlY3RvcnMuZW50ZXIoKVxuICAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImRvbWFpbi1zZWxlY3RvclwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgIC5lYWNoKChkLCBpLCBub2RlcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3RvciA9IGQzLnNlbGVjdChub2Rlc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yLmFwcGVuZChcInJlY3RcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwieFwiLCBkID0+IHgoZCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcInlcIiwgeS5yYW5nZSgpWzFdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCB4LmJhbmR3aWR0aCgpICsgXCJweFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgTWF0aC5hYnMoeS5yYW5nZSgpWzBdIC0geS5yYW5nZSgpWzFdKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcImZpbGxcIiwgZDMuY29sb3IoXCIjNDg3MzI5XCIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAwKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBTVEFOREFSRF9PUEFDSVRZID0gMC43O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBSQURJVVMgPSAxMDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rvci5vbihcIm1vdXNlZW50ZXJcIiwgZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVjdCA9IHNlbGVjdG9yLnNlbGVjdChcInJlY3RcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjdC5pbnRlcnJ1cHQoXCJzZWxlY3RvcjpoaWdobGlnaHRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRyYW5zaXRpb24oXCJzZWxlY3RvcjpoaWdobGlnaHRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKDI1MClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAwLjIpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluU2VsZWN0aW9uID0gZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKGxpbmUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxpbmUuZGF0YS5maWx0ZXIocCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVxdWFscyhwLl94LCBkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5mbGF0KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5TZWxlY3Rpb24ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMuX2Rpc3BhdGNoLmNhbGwoXCJ0b29sdGlwU2hvd1wiLCB0aGlzLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICBlOiBkMy5ldmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgIHBvaW50OiBpblNlbGVjdGlvblswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgIHBvaW50czogaW5TZWxlY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zZWxlY3RBbGwoXCIubGluZS1oaWdobGlnaHRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5kYXRhKGluU2VsZWN0aW9uKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmVudGVyKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoXCJjaXJjbGVcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwibGluZS1oaWdobGlnaHRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcImN4XCIsIGQgPT4geChkLl94KSArIHguYmFuZHdpZHRoKCkgLyAyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiY3lcIiwgZCA9PiB5KGQuX3kpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiclwiLCAxKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcImN1cnNvclwiLCBcInBvaW50ZXJcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBkID0+IHRoaXMuZ2V0RDNDb2xvdXIoZCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwic3Ryb2tlXCIsIGRldGVybWluZVN0cm9rZUNvbG91cilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5vbihcImNvbnRleHRtZW51XCIsICgpID0+IGQzLmV2ZW50LnByZXZlbnREZWZhdWx0KCkpIC8vIE5vIHJpZ2h0IGNsaWNrLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLm9uKFwiY2xpY2sgYXV4Y2xpY2tcIiwgZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlzcGF0Y2guY2FsbChcImVsZW1lbnRDbGlja1wiLCB0aGlzLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGU6IGQzLmV2ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludDogZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLm9uKFwibW91c2VvdmVyXCIsIChkLCBpLCBub2RlcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3BhdGNoLmNhbGwoXCJ0b29sdGlwU2hvd1wiLCB0aGlzLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGU6IGQzLmV2ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludDogZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZDMuc2VsZWN0KG5vZGVzW2ldKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmludGVycnVwdCgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcInJcIiwgMTUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5vbihcIm1vdXNlb3V0XCIsIChkLCBpLCBub2RlcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQzLnNlbGVjdChub2Rlc1tpXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5pbnRlcnJ1cHQoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRyYW5zaXRpb24oKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCBTVEFOREFSRF9PUEFDSVRZKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJyXCIsIFJBRElVUyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRyYW5zaXRpb24oKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5kZWxheSgxNTApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKDI1MClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcInJcIiwgUkFESVVTKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgU1RBTkRBUkRfT1BBQ0lUWSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG5cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5vbihcIm1vdXNlbGVhdmVcIiwgZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVjdCA9IHNlbGVjdG9yLnNlbGVjdChcInJlY3RcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjdC5pbnRlcnJ1cHQoXCJzZWxlY3RvcjpoaWdobGlnaHRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRyYW5zaXRpb24oKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3Iuc2VsZWN0QWxsKFwiLmxpbmUtaGlnaGxpZ2h0XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuaW50ZXJydXB0KClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiclwiLCAxKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLm9uKFwiZW5kXCIsIChkLCBpLCBub2RlcykgPT4gZDMuc2VsZWN0KG5vZGVzW2ldKS5yZW1vdmUoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICBnZXREM1hTY2FsZShkYXRhLCB3aWR0aCkge1xuICAgICAgICB3aWR0aCA9IHdpZHRoIHx8IHRoaXMud2lkdGgoKTtcbiAgICAgICAgZGF0YSA9IGRhdGEgfHwgdGhpcy5wcmVwYXJlRGF0YSgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKGQgPT4gZC5kYXRhKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlZHVjZSgoYWNjLCB2YWwpID0+IGFjYy5jb25jYXQodmFsKSk7XG5cblxuICAgICAgICByZXR1cm4gZDMuc2NhbGVCYW5kKClcbiAgICAgICAgICAgIC5yYW5nZShbMCwgd2lkdGhdKVxuICAgICAgICAgICAgLnBhZGRpbmdJbm5lcih0aGlzLl9wYWRkaW5nIHx8IDApICAgIC8vIG11c3QgdXNlIHBhZGRpbmcgc28gbGluZXMgZml0IHByb3Blcmx5IG92ZXIgYmFyc1xuICAgICAgICAgICAgLmRvbWFpbihkYXRhLm1hcChkID0+IGQuX3gpKTtcbiAgICB9XG5cbiAgICBnZXREM1lTY2FsZShkYXRhLCBoZWlnaHQpIHtcbiAgICAgICAgZGF0YSA9IGRhdGEgfHwgdGhpcy5wcmVwYXJlRGF0YSgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKGQgPT4gZC5kYXRhKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlZHVjZSgoYWNjLCB2YWwpID0+IGFjYy5jb25jYXQodmFsKSk7XG4gICAgICAgIGhlaWdodCA9IGhlaWdodCB8fCB0aGlzLmhlaWdodCgpO1xuXG4gICAgICAgIGxldCBleHRlbnQgPSBkMy5leHRlbnQoZGF0YSwgZCA9PiBkLl95KVxuICAgICAgICBsZXQgbWF4ID0gTWF0aC5tYXgoZXh0ZW50WzFdLCB0aGlzLl9heGlzX21heF92YWx1ZSB8fCAwKVxuICAgICAgICBsZXQgbWluID0gTWF0aC5taW4odGhpcy5fYXhpc19taW5fdmFsdWUgfHwgMCwgZXh0ZW50WzBdKVxuICAgICAgICByZXR1cm4gZDMuc2NhbGVMaW5lYXIoKS5yYW5nZShbaGVpZ2h0LCAwXSkubmljZSg1KS5kb21haW4oW21pbiwgbWF4XSlcbiAgICB9XG59XG5cblxuZnVuY3Rpb24gZ2V0Q2xvc2VzdFBvaW50KHh2YWwsIHl2YWwsIGRhdGEpIHtcbiAgICBsZXQgY2FsY0Rpc3QgPSBkID0+IE1hdGguc3FydChNYXRoLmFicyhkLl94IC0geHZhbCkgKiogMiArIChkLl95IC0geXZhbCkgKiogMik7XG4gICAgbGV0IG1pbiA9IGRhdGFbMF07XG4gICAgbGV0IG1pbkRpc3QgPSBjYWxjRGlzdChtaW4pO1xuXG4gICAgZGF0YS5mb3JFYWNoKGQgPT4ge1xuICAgICAgICBsZXQgZGlzdCA9IGNhbGNEaXN0KGQpO1xuICAgICAgICBpZiAoZGlzdCA8IG1pbkRpc3QpIHtcbiAgICAgICAgICAgIG1pbkRpc3QgPSBkaXN0O1xuICAgICAgICAgICAgbWluID0gZDtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIG1pbjtcbn1cblxuXG5cbmV4cG9ydCBmdW5jdGlvbiBsaW5lKCkge1xuICAgIHJldHVybiBuZXcgTGluZSgpO1xufSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/chart/Line.js\n')},"./src/chart/Pie.js":
/*!**************************!*\
  !*** ./src/chart/Pie.js ***!
  \**************************/
/*! exports provided: pie */function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pie\", function() { return pie; });\n/* harmony import */ var _Geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Geometry */ \"./src/chart/Geometry.js\");\n/* harmony import */ var _Colours__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Colours */ \"./src/Colours.js\");\n// Copyright (C) 2020 BrandsEye (PTY) LTD\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this\n// software and associated documentation files (the \"Software\"), to deal in the Software\n// without restriction, including without limitation the rights to use, copy, modify,\n//     merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following\n// conditions:\n//\n//     The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n//     INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n// CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n\nclass Pie extends _Geometry__WEBPACK_IMPORTED_MODULE_0__[\"Geometry\"] {\n    constructor(name, isDonut, useOutsideLabels){\n        super(name || 'PIE');\n        this._is_donut = (typeof isDonut !== 'undefined' && isDonut !== null) ? isDonut : false;\n        this._use_outside_labels = (typeof useOutsideLabels !== 'undefined' && useOutsideLabels !== null) ? useOutsideLabels : false;\n        this._transition_duration = 200;\n        this._line_height = 1.1;\n        this._ellipsis = '...'; //\\u2026\n    }\n\n    _appendIfEmpty(appendTo, elementName, className) {\n        let selection = appendTo.select('.' + className);\n        if (selection.empty()) selection = appendTo.append(elementName).attr('class', className);\n        return selection\n    }\n\n    _getOverlayLabelColour(d){\n        const segmentColour = d3.hcl(this.getD3Colour(d.data));\n        let labelColour = d3.hcl(_Colours__WEBPACK_IMPORTED_MODULE_1__[\"colours\"].eighteen.darkGrey);\n        let multiply = true;\n\n        // invert\n        if (segmentColour.l < 65) {\n            labelColour.l += Math.min(labelColour.l + 50, 100);\n            multiply = false\n        }\n\n        return { colour: labelColour, multiply: multiply }\n    }\n\n    _getWidthOfWidestLabel(){\n        const allLabels = [\n          ...this.xValues().map(xVal => this.formatX()(xVal)),\n          ...this.yValues().map(yVal => this.formatLabel()(yVal))\n        ];\n        const text = this._element\n            .append('text')\n            .style('font-size', this._font_size + 'px')\n            .attr('class', 'label-width-check')\n            .style('visibility', 'hidden')\n\n        text.selectAll('tspan')\n            .data(allLabels)\n            .enter()\n            .append('tspan')\n            .attr('x','0')\n            .text(d => d)\n\n        const textWidth = text.node().getBBox().width;\n\n        text.remove();\n\n        return textWidth\n    }\n\n    _getMidAngle(segment) {\n        return segment.startAngle + (segment.endAngle - segment.startAngle)/2;\n    }\n\n    _getLabelHeight(){\n      const text = this._element\n        .append('text')\n        .style('font-size', this._font_size + 'px')\n        .attr('class', 'label-height-check')\n        .style('visibility', 'hidden')\n\n      const data = this.showLabels() ? ['Category', 'Value'] : ['Category'];\n\n      text.selectAll('tspan')\n        .data(data)\n        .enter()\n        .append('tspan')\n        .text(d => d)\n        .attr('x',0)\n        .attr('dy','1em')\n\n      const textHeight = text.node().getBBox().height;\n\n      text.remove()\n\n      return textHeight\n    }\n\n    _getLabelBoundingPoints(label, atPoint) {\n        /*\n        assumes:\n         label is centred around a given point. e.g.:\n         - text-anchor: middle\n         - left === atPoint[0] + width/2\n         - top === atPoint[1] + height/2\n         label.node() is not a tspan\n        */\n\n        // consider x and y attribute\n        const xOffset = parseFloat(label.attr('x') || 0);\n        const yOffset = parseFloat(label.attr('y') || 0);\n\n        const bounds = label.node().getBBox();\n        const w = bounds.width; //label.node().getComputedTextLength();\n        const h = bounds.height;\n        const x = atPoint[0] + xOffset;\n        const y = atPoint[1] + yOffset;\n\n        return [\n            {x: x-w/2, y: y-h/2},\n            {x: x+w/2, y: y-h/2},\n            {x: x-w/2, y: y+h/2},\n            {x: x+w/2, y: y+h/2}\n        ];\n    }\n\n    /**\n     * @param {{x: number, y: number}[]} points Array of points\n     * @param {number} startAngle Number in radians\n     * @param {number} endAngle Number in radians\n     * @param {number} innerRadius\n     * @param {number} outerRadius\n     */\n    _allPointsWithinSegment(points, startAngle, endAngle, innerRadius, outerRadius){\n\n        const anyPointOutOfBounds = points.some( point => {\n\n            // edge case where point is exactly centered in a pie chart\n            // and therefore always valid\n            if (innerRadius === 0 && point.x === 0 && point.y === 0) return false\n\n            const lineLength = Math.sqrt( Math.pow(point.x, 2) + Math.pow(point.y, 2))\n\n            /*\n            let failCondition = (\n                lineLength === 0 ? 'line length === 0'\n              : lineLength > outerRadius ? 'lineLength > outerRadius'\n              : lineLength < innerRadius ? 'lineLength < innerRadius'\n              : null\n            )\n            if (failCondition) console.log(failCondition)\n            */\n\n            // point is outside radius bounds\n            // -\n            // zero line length here refers to a point at the centre of a donut chart\n            // It's a case technically caught by by lineLength, but want to be sure to avoid\n            // divide by 0 errors below\n            if ( lineLength === 0 || lineLength > outerRadius || lineLength < innerRadius) return true\n\n            const normalisedRads = Math.acos(Math.abs(point.y) / lineLength)\n            const circle = Math.PI * 2;\n\n            let lineAngle = (\n                  point.x >= 0 && point.y < 0 ?                 normalisedRads // top right\n                : point.x >= 0 && point.y >= 0 ? circle * 0.5 - normalisedRads // bottom right\n                : point.x < 0 &&  point.y >= 0 ? circle * 0.5 + normalisedRads // bottom left\n                : point.x < 0 &&  point.y < 0 ?  circle       - normalisedRads // top left\n                : null\n            )\n\n            /*\n            failCondition = (\n                lineAngle === null ? 'lineAngle === null'\n              : lineAngle < startAngle ? 'lineAngle < startAngle'\n              : lineAngle > endAngle ? 'lineAngle > endAngle'\n              : null\n            )\n            if (failCondition) console.log(failCondition)\n            */\n\n            // angle is invalid or out of bounds\n            if (lineAngle === null || lineAngle < startAngle || lineAngle > endAngle ) return true\n\n            // dev\n            // if (showLines){\n            //     d3.select('.pie')\n            //         .append('polyline')\n            //         .attr('class','dev')\n            //         .style('stroke-width', '1px')\n            //         .style('stroke', 'rgba(0,0,0,0.3)')\n            //         .attr('points', [[0,0], [point.x,point.y]])\n            // }\n        })\n\n        return !anyPointOutOfBounds\n    }\n\n    _renderSegmentLabel(labelWrapper, segment, labelSizes) {\n        const textWrapper = this._appendIfEmpty(labelWrapper, 'g', 'text-wrapper');\n        const overlayColour = this._getOverlayLabelColour(segment);\n        const textColour = this._use_outside_labels\n            ? d3.hcl(_Colours__WEBPACK_IMPORTED_MODULE_1__[\"colours\"].eighteen.darkGrey).brighter()\n            : overlayColour.colour;\n\n        textWrapper.attr('pointer-events', 'none')\n            .attr('fill', textColour)\n            .style('mix-blend-mode', overlayColour.multiply ? 'multiply' : null)\n            .style('font-size', this._font_size + 'px');\n\n        const labels = [this.formatX()(this.x()(segment.data))];\n        if (this.showLabels()) labels.push(this.formatLabel()(this.y()(segment.data)));\n\n        const isWithinSegment = label => {\n            const boundingPoints = this._getLabelBoundingPoints(label, this._label_arc.centroid(segment));\n            return this._allPointsWithinSegment(boundingPoints, segment.startAngle, segment.endAngle, this._inner_radius, this._outer_radius);\n        }\n\n        const isntTooWide = label => {\n            return label.node().getBBox().width < this._max_label_width;\n        }\n\n        const testFn = this._use_outside_labels ? isntTooWide : isWithinSegment;\n        const strings = labels.map(l => l.toString());\n        this._fitLabelsInSegment(strings, textWrapper, testFn, !this._use_outside_labels)\n\n        this._transformSegmentLabel(textWrapper)\n\n        const finalPos = this._outer_arc.centroid(segment);\n        const rightHandSide = this._getMidAngle(segment) < Math.PI;\n        const rect = textWrapper.node().getBoundingClientRect();\n        labelSizes[segment.index] = {y: finalPos[1], height: rect.height, rightHandSide};\n\n        this._renderLeaderLines(labelWrapper)\n    }\n\n    _hideOutOfBoundLabels(labelWrapper, segment, labelSizes) {\n        const texts = labelWrapper.selectAll('text');\n\n        let withinBounds = true;\n\n        texts.each((string, i, nodes) => {\n            const text = d3.select(nodes[i]);\n            if (this._use_outside_labels){\n                let hide = text.node().getBBox().width > this._max_label_width;\n                if (!hide && segment.index !== 0 && this._use_outside_labels){ // skip first label\n                    const thisLabel = labelSizes[segment.index];\n                    const previousLabel = labelSizes[segment.index - 1];\n\n                    if (thisLabel.rightHandSide !== previousLabel.rightHandSide){\n                        // different sides  ignore\n                    } else if (thisLabel.rightHandSide) {\n                        hide = (previousLabel.y + previousLabel.height) > thisLabel.y;\n                    } else {\n                        hide = ( thisLabel.y + thisLabel.height ) > previousLabel.y;\n                    }\n                }\n                if (hide) withinBounds = false\n            } else {\n                const points = this._getLabelBoundingPoints(text, this._label_arc.centroid(segment));\n                const isWithinSegment = this._allPointsWithinSegment(points, segment.startAngle, segment.endAngle, this._inner_radius, this._outer_radius, string === '351');\n                // console.log(string, isWithinSegment)\n                if (!isWithinSegment) withinBounds = false\n            }\n        })\n\n        labelWrapper.style('visibility', withinBounds ? null : 'hidden');\n\n\n    }\n\n    _renderSegmentLabels(segments) {\n        const segmentLabelsWrapper = this._appendIfEmpty(this._pie, 'g', 'segment-labels').style('font-family', 'sans-serif');\n\n        const segmentLabels = segmentLabelsWrapper.selectAll('.segment-label')\n            .data(segments, d => d.data._x);\n\n        const labelSizes = [];\n\n        segmentLabels.enter()\n            .append('g')\n            .attr('class', 'segment-label')\n            .merge(segmentLabels)\n            .each((segment, i, nodes) => {\n                const labelWrapper = d3.select(nodes[i]);\n                this._renderSegmentLabel(labelWrapper, segment, labelSizes)\n            })\n            // hide intersecting or too-wide labels\n            // giving preference to labels a lower arc index\n            // only do this for outside labels for now\n            .each((segment, i, nodes) => {\n               const labelWrapper = d3.select(nodes[i]);\n               this._hideOutOfBoundLabels(labelWrapper, segment, labelSizes);\n            })\n\n        segmentLabels.exit().remove();\n    }\n\n    _renderLeaderLines(labelWrapper) {\n        const leaderArc = d3.arc()\n            .innerRadius(this._outer_radius - 5)\n            .outerRadius(this._outer_radius - 5);\n\n        const line = this._appendIfEmpty(labelWrapper, 'polyline', 'label-line');\n        if (!this._use_outside_labels) {\n            line.remove()\n        } else {\n            const that = this;\n            line\n                .attr('stroke', d3.hcl(_Colours__WEBPACK_IMPORTED_MODULE_1__[\"colours\"].eighteen.darkGrey).brighter())\n                .attr('opacity', 0.5)\n                .attr('stroke-width', '1px')\n                .attr('fill', 'none')\n                .style('mix-blend-mode', 'multiply')\n                .transition().duration(this._transition_duration)\n                .attrTween(\"points\", function(d){\n                    this._current = this._current || d;\n                    var interpolate = d3.interpolate(this._current, d);\n                    this._current = interpolate(0);\n\n                    return function(t) {\n                        var d2 = interpolate(t);\n                        var start = leaderArc.centroid(d2);\n                        var elbow = that._outer_arc.centroid(d2);\n                        var terminal = that._outer_arc.centroid(d2);\n                        const leftAligned = that._getMidAngle(d2) < Math.PI;\n                        terminal[0] = that._outer_radius * 1.05 * (leftAligned ? 1 : -1);\n                        const positions = [start, elbow];\n                        if (leftAligned ? terminal[0] > elbow[0] : elbow[0] > terminal[0]){\n                            positions.push(terminal);\n                        }\n                        return positions;\n                    };\n                });\n        }\n    }\n\n    _transformSegmentLabel(text) {\n        const that = this;\n        text\n            .transition().duration(this._transition_duration)\n            .attrTween(\"transform\", function(arcData) {\n                this._current = this._current || arcData;\n                const interpolate = d3.interpolate(this._current, arcData);\n                this._current = interpolate(0);\n\n                return function(t) {\n                    const dInt = interpolate(t);\n                    if (that._use_outside_labels){\n                        const pos = that._outer_arc.centroid(dInt);\n                        pos[0] = that._outer_radius * 1.09 * (that._getMidAngle(dInt) < Math.PI ? 1 : -1);\n                        return \"translate(\"+ pos +\")\";\n                    } else {\n                        return \"translate(\" + that._label_arc.centroid(dInt) + \")\";\n                    }\n                };\n            })\n            .styleTween(\"text-anchor\", function(arcData){\n                this._current = this._current || arcData;\n                const interpolate = d3.interpolate(this._current, arcData);\n                this._current = interpolate(0);\n\n                return function(t) {\n                    const dInt = interpolate(t);\n                    return that._use_outside_labels ? ( that._getMidAngle(dInt) < Math.PI ? 'start' : 'end' ) : 'middle';\n                }\n            })\n    }\n\n    _splitInHalfByNearestSpace(string) {\n\n        const minChars = 3\n\n        if (string.indexOf(' ') === -1){\n            return [string]\n        }\n\n        const halfIndex = Math.floor(string.length/2);\n        const maxIndex = string.length - 1;\n        let preIndex = string.slice(0, halfIndex + 1).lastIndexOf(' ');\n        let postIndex = string.slice(halfIndex).indexOf(' ');\n\n        preIndex = preIndex === -1 ? maxIndex : preIndex\n        postIndex = postIndex === -1 ? maxIndex : postIndex + halfIndex\n\n        const preferredIndex = Math.min(\n            preIndex  !== -1 && halfIndex - preIndex > minChars ? maxIndex : preIndex,\n            postIndex !== -1 && maxIndex - postIndex < minChars ? maxIndex : postIndex\n        );\n\n        if ( preferredIndex < maxIndex - minChars && preferredIndex >= minChars){\n            return [ string.slice(0, preferredIndex), string.slice(preferredIndex + 1) ]\n        }\n\n        return [string]\n    }\n\n    _getTruncatedText(text, truncSize) {\n        const minChars = 3;\n\n        const words = text.split(' ');\n        words.splice(Math.ceil(words.length / 2) - Math.floor(truncSize / 2), truncSize, this._ellipsis);\n        const truncatedText = words.join(' ');\n        const labelLength = truncatedText.length;\n\n        if (labelLength - this._ellipsis.length < minChars) {\n            return text\n        } else {\n            return truncatedText\n        }\n    }\n\n    _arrayEquals(a, b) {\n        if (a === b) return true\n        if (a === null || b === null || a.length !== b.length) return false\n        a.forEach((item, index) => { if (item !== b[index]) return false } )\n        return true\n    }\n\n    /**\n     *\n     * @param {string[]} strings\n     * @param {object} element\n     * @param {function} testFn\n     */\n    _fitLabelsInSegment(initialStrings, element, testFn, tryLineWrap, maxAttempts) {\n        if (typeof maxAttempts !== 'undefined' && (typeof maxAttempts !== 'number' || parseInt(maxAttempts) !== maxAttempts)){\n            console.error('maxAttempts should be an integer')\n        }\n\n        let numAttempts = 0;\n        maxAttempts = maxAttempts || 5;\n\n        let didFit = false\n        let strings = initialStrings.slice()\n\n        // let attempts = [];\n        let newStrings = []\n        let wrapFailed = false\n\n        // loop lines\n        while (!didFit && numAttempts < maxAttempts){\n\n            didFit = true;\n\n            element.selectAll('text').remove();\n\n            let texts = element.selectAll('text');\n\n            newStrings = [];\n\n            texts\n                .data(strings)\n                .enter()\n                .append('text')\n                .merge(texts)\n                .text(string => string)\n                .attr('y',(string, i, nodes) => {\n                    const lineHeightFactor = i - nodes.length/2 + 1;\n                    return lineHeightFactor * this._font_size * this._line_height +'px'\n                })\n                .each((string, i, nodes) => {\n                    const text = d3.select(nodes[i]);\n                    if (testFn(text)){\n                        newStrings.push(string);\n                    } else if (tryLineWrap && !wrapFailed){ //&& strings.length < 3\n                        didFit = false\n                        // split into strings for next iteration\n                        const words = this._splitInHalfByNearestSpace(string)\n                        words.forEach(s => newStrings.push(s))\n                    } else {\n                        // try truncation\n                        let truncSize = 0\n                        while( truncSize < string.length) {\n                            const truncatedText = this._getTruncatedText(string, truncSize);\n                            if (truncatedText === string ){\n                                didFit = false\n                                newStrings.push(i === 0 ? string : this._ellipsis)\n                                break\n                            }\n                            text.text(truncatedText)\n                            if(testFn(text)) {\n                                // text fits, continue\n                                newStrings.push(truncatedText)\n                                break\n                            } else {\n                                truncSize += 1\n                            }\n                        }\n                        if (truncSize === string.length){\n                            didFit = false\n                            // if ( i === 0 ) console.log(string, 'i == 0')\n                            newStrings.push(i === 0 ? string : this._ellipsis)\n                        }\n                    }\n                })\n                .exit()\n                .remove()\n\n            // attempts.push(strings);\n\n            const numEllipses = 0;\n            newStrings = newStrings.filter((string, i, arr) => {\n                const beginsWithEllipsis = string.trim().indexOf(this._ellipsis) === 0;\n\n                if (beginsWithEllipsis && i === 0){\n                    return false\n                }\n\n                // follows ellipsis in prev string\n                const prevString = (arr[i - 1] || '').trim();\n                const prevStringEndsWithEllipsis = prevString && prevString.indexOf(this._ellipsis) === prevString.length - this._ellipsis.length;\n                if (beginsWithEllipsis && prevStringEndsWithEllipsis){\n                    return false\n                }\n                return true\n            })\n\n            if (numEllipses > 1) newStrings = []\n\n            const justEllipses = newStrings.filter(s => s === this._ellipsis).length;\n            if (justEllipses === newStrings.length) newStrings = []\n\n            // console.log(newStrings)\n            // console.log(' ')\n\n            if (this._arrayEquals(strings, newStrings) && !wrapFailed) wrapFailed = true;\n\n            strings = newStrings;\n            numAttempts += 1;\n        }\n\n        // console.log(attempts)\n\n        return numAttempts < maxAttempts && didFit\n\n    }\n\n    _addCentreLabel() {\n\n        let xText = this.xAxisLabel();\n        let yText = this.yAxisLabel();\n\n        const hasYText = yText || yText === 0;\n        const hasXText = xText || xText === 0;\n\n        const labels = [];\n\n        if (hasYText) labels.push(yText && yText.short || yText);\n        if (hasXText) labels.push(xText && xText.short || xText);\n\n        const centreText = this._appendIfEmpty(this._pie, 'g', 'centre-label')\n            .style('font-family', 'sans-serif')\n            .style('font-size', this._font_size + 'px')\n            .attr('text-anchor', 'middle');\n\n        if (labels.length === 0){\n            centreText.remove();\n            return\n        }\n\n        const isWithinSegment = label => {\n            const boundingPoints = this._getLabelBoundingPoints(label, [0,0])\n            return this._allPointsWithinSegment(boundingPoints, 0, 2 * Math.PI, 0, this._inner_radius)\n        }\n\n        const strings = labels.map(l => l.toString());\n\n        const fitted = this._fitLabelsInSegment(strings, centreText, isWithinSegment, true, 10 )\n\n        centreText.style('visibility', fitted ? null : 'hidden')\n    }\n\n    _renderSegments(segments) {\n        const segmentWrapper = this._appendIfEmpty(this._pie, 'g', 'segments');\n        const paths = segmentWrapper.selectAll('.segment')\n            .data(segments, d => d.data._x);\n\n        const that = this;\n        paths.enter()\n          .append('path')\n          .attr('class','segment')\n          .merge(paths)\n          .on(\"mouseover\", (d, i, nodes) => {\n              d3.select(nodes[i])\n              .interrupt(\"hover:colour\")\n              .transition(\"hover:colour\")\n              .duration(50)\n              .attr(\"fill\", d3.hcl(this.getD3Colour(d.data)).brighter(0.2))\n              .attr(\"stroke\", d => d3.hcl(this.getD3Colour(d.data)).darker(0.4));\n              this._dispatch.call(\"tooltipShow\", this, {\n                  e: d3.event,\n                  point: d.data,\n                  series: d.data._series,\n                  seriesIndex: 0,//s_i\n                  value: d.data._y\n              })\n          })\n          .on(\"mouseout\", (d, i, nodes) => { // bar is regular colour on mouse out.\n              d3.select(nodes[i])\n              .interrupt(\"hover:colour\")\n              .transition(\"hover:colour\")\n              .duration(100)\n              .attr(\"fill\", d => this.getD3Colour(d.data))\n              .attr(\"stroke\", d => d3.hcl(this.getD3Colour(d.data)).darker());\n              this._dispatch.call(\"tooltipHide\", this);\n          })\n          .on(\"click auxclick\", (d, i, nodes) => {\n              this._dispatch.call(\"elementClick\", this, {\n                  e: d3.event,\n                  point: d.data,\n                  series: d.data._series,\n                  seriesIndex: 0, //d.data._s_i,\n                  value: d.data._y\n              })\n          })\n          .transition().duration(this._transition_duration)\n          .attr(\"fill\", d => this.getD3Colour(d.data))\n          .attr(\"stroke\", d => d3.hcl(this.getD3Colour(d.data)).darker())\n          .style(\"cursor\", \"pointer\")\n          .attrTween('d', function(p,pi,pnodes){\n              var pInt = d3.interpolate(this._current, p);\n              this._current = pInt(0);\n              return t => that._arc(pInt(t));\n          })\n\n        paths.exit().remove();\n    }\n\n    isDonut(bool) {\n        if (arguments.length === 0) return this._is_donut;\n        this._is_donut = bool;\n        return this\n    }\n\n    useOutsideLabels(bool) {\n        if (arguments.length === 0) return this._use_outside_labels;\n        this._use_outside_labels = bool;\n        return this\n    }\n\n    prepareData(data, faceted) {\n        faceted = !!faceted && this.facet();\n        data = data || this._data;\n        if (!data || !data.length) return [];\n\n        const x = this.x(),\n              y = this.y(),\n              scaleX = this.scaleX(),\n              scaleY = this.scaleY();\n\n        let mapped = [];\n\n        data.forEach((d,index) => {\n            if (faceted && !this.facet()(d)) return;\n            const xVal = scaleX.transform(x(d));\n            const yVal = scaleY.transform(y(d));\n            if (yVal !== 0){\n                const object = Object.assign({\n                    _key: index,\n                    _x: xVal,\n                    _y: yVal,\n                    _colour: xVal,\n                    _size: this.size()(d)\n                }, d);\n\n                if (mapped[index]){\n                    mapped[index].data.push(object)\n                } else {\n                    mapped.push({\n                        _key: index,\n                        _size: object._size,\n                        _colour: object._colour,\n                        data: [object]\n                    })\n                }\n            }\n        });\n\n        return mapped\n    }\n\n    getD3XScale(data, width) {\n        data = data || this.prepareData(null, true).map(d => d.data).reduce((acc, val) => acc.concat(val), []);\n        width = width || this.width();\n        return d3.scaleBand()\n                 .rangeRound([0, width])\n                 .domain(data.map(d => d._x));\n    }\n\n    getD3YScale(data, height) {\n        data = data || this.prepareData(null, false);\n        height = height || this.height();\n\n        const max = Math.max(d3.max(data, d => d3.max(d.data, d => d._y)), 0);\n        const min = Math.min(0, d3.min(data, d => d3.min(d.data, d => d._y)));\n        return d3.scaleLinear()\n                 .rangeRound([height, 0])\n                 .nice()\n                 .domain([min, max]);\n    }\n\n    getD3Colour(data) {\n        let colour = _Geometry__WEBPACK_IMPORTED_MODULE_0__[\"Geometry\"].prototype.getD3Colour.call(this, data);\n        if (this._tints) {\n            colour = this._tints[data._key] || colour\n        }\n        return colour\n    }\n\n    immediatelyRenderLabels(show){\n        this.showLabels(!!show);\n        this.render();\n    }\n\n    render() {\n\n        const data = this.prepareData(null, true).map(d => d.data).reduce((acc, val) => acc.concat(val), []);\n\n        /*\n        Set up dimensions\n        */\n        let availableWidth = this._width;\n        let availableHeight = this._height;\n\n        let widestLabelWidth = 0;\n        let labelHeight = 0;\n\n        this._max_label_width = availableWidth / 4;\n\n        if (this._use_outside_labels){\n          widestLabelWidth = Math.min(this._getWidthOfWidestLabel(), this._max_label_width);\n          labelHeight = this._getLabelHeight();\n          availableWidth -= widestLabelWidth * 2;\n          availableHeight -= labelHeight * 2;\n        }\n\n        const minDimension = Math.min(availableWidth, availableHeight);\n\n        /*\n        Set up arcs\n        */\n        this._inner_radius = this._is_donut ? minDimension / 4 : 0;\n        this._outer_radius = minDimension / 2;\n\n        this._outer_arc = d3.arc()\n            .innerRadius(this._outer_radius + 10)\n            .outerRadius(this._outer_radius + 10)\n\n        this._arc = d3.arc()\n            .innerRadius(this._inner_radius)\n            .outerRadius(this._outer_radius);\n\n        this._label_arc = this._is_donut\n            ? this._arc\n            : d3.arc()\n                .innerRadius(minDimension / 5)\n                .outerRadius(this._outer_radius)\n\n        /*\n            Prep tints if necessary\n        */\n        let firstColour;\n        let useTintShift = true;\n        // if we encounter more than one colour,\n        // don't use tint shift\n        for(let i = 0; i < data.length; i++) {\n            const colour = _Geometry__WEBPACK_IMPORTED_MODULE_0__[\"Geometry\"].prototype.getD3Colour.call(this,data[i]);\n            if (typeof firstColour === 'undefined'){\n                firstColour = colour;\n            } else if (colour !== firstColour) {\n                useTintShift = false;\n                break\n            }\n        }\n\n        if (useTintShift) {\n            const tints = [];\n            const shiftLevels = 3; //in both directions\n            const cycleLength = shiftLevels * 4;\n\n            data.forEach((d, index) => {\n                const colour = _Geometry__WEBPACK_IMPORTED_MODULE_0__[\"Geometry\"].prototype.getD3Colour.call(this, d);\n                const shiftFactor = Math.abs( shiftLevels * 2 - Math.abs(index - shiftLevels) % cycleLength) - shiftLevels;\n                tints.push(d3.hsl(colour).brighter(shiftFactor * 0.4));\n                // TODO: test for black and white\n                // TODO: consider zigzag palette within given hue\n            })\n            this._tints = tints;\n        }\n\n        const segments = d3.pie().value(this.y())(data);\n\n        this._pie = this._appendIfEmpty(this._element, 'g', 'pie');\n\n        this._pie.attr(\"transform\", 'translate(' + (availableWidth/2 + widestLabelWidth) + ',' + (minDimension/2 + labelHeight) + ')')\n\n        this._renderSegments(segments)\n\n        this._renderSegmentLabels(segments)\n\n        this._is_donut\n            ? this._addCentreLabel()\n            : this._element.select('.centre-label').remove();\n    }\n\n}\n\nfunction pie() {\n    return new Pie();\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY2hhcnQvUGllLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYjNqcy8uL3NyYy9jaGFydC9QaWUuanM/YWIzNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKEMpIDIwMjAgQnJhbmRzRXllIChQVFkpIExURFxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpc1xuLy8gc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlXG4vLyB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksXG4vLyAgICAgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0b1xuLy8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcbi8vIGNvbmRpdGlvbnM6XG4vL1xuLy8gICAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuLy8gY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyAgICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUiBJTVBMSUVELFxuLy8gICAgIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBXG4vLyBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUXG4vLyBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0Zcbi8vIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRVxuLy8gT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCB7IEdlb21ldHJ5IH0gZnJvbSAnLi9HZW9tZXRyeSc7XG5pbXBvcnQgeyBjb2xvdXJzIH0gZnJvbSBcIi4uL0NvbG91cnNcIjtcblxuY2xhc3MgUGllIGV4dGVuZHMgR2VvbWV0cnkge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIGlzRG9udXQsIHVzZU91dHNpZGVMYWJlbHMpe1xuICAgICAgICBzdXBlcihuYW1lIHx8ICdQSUUnKTtcbiAgICAgICAgdGhpcy5faXNfZG9udXQgPSAodHlwZW9mIGlzRG9udXQgIT09ICd1bmRlZmluZWQnICYmIGlzRG9udXQgIT09IG51bGwpID8gaXNEb251dCA6IGZhbHNlO1xuICAgICAgICB0aGlzLl91c2Vfb3V0c2lkZV9sYWJlbHMgPSAodHlwZW9mIHVzZU91dHNpZGVMYWJlbHMgIT09ICd1bmRlZmluZWQnICYmIHVzZU91dHNpZGVMYWJlbHMgIT09IG51bGwpID8gdXNlT3V0c2lkZUxhYmVscyA6IGZhbHNlO1xuICAgICAgICB0aGlzLl90cmFuc2l0aW9uX2R1cmF0aW9uID0gMjAwO1xuICAgICAgICB0aGlzLl9saW5lX2hlaWdodCA9IDEuMTtcbiAgICAgICAgdGhpcy5fZWxsaXBzaXMgPSAnLi4uJzsgLy9cXHUyMDI2XG4gICAgfVxuXG4gICAgX2FwcGVuZElmRW1wdHkoYXBwZW5kVG8sIGVsZW1lbnROYW1lLCBjbGFzc05hbWUpIHtcbiAgICAgICAgbGV0IHNlbGVjdGlvbiA9IGFwcGVuZFRvLnNlbGVjdCgnLicgKyBjbGFzc05hbWUpO1xuICAgICAgICBpZiAoc2VsZWN0aW9uLmVtcHR5KCkpIHNlbGVjdGlvbiA9IGFwcGVuZFRvLmFwcGVuZChlbGVtZW50TmFtZSkuYXR0cignY2xhc3MnLCBjbGFzc05hbWUpO1xuICAgICAgICByZXR1cm4gc2VsZWN0aW9uXG4gICAgfVxuXG4gICAgX2dldE92ZXJsYXlMYWJlbENvbG91cihkKXtcbiAgICAgICAgY29uc3Qgc2VnbWVudENvbG91ciA9IGQzLmhjbCh0aGlzLmdldEQzQ29sb3VyKGQuZGF0YSkpO1xuICAgICAgICBsZXQgbGFiZWxDb2xvdXIgPSBkMy5oY2woY29sb3Vycy5laWdodGVlbi5kYXJrR3JleSk7XG4gICAgICAgIGxldCBtdWx0aXBseSA9IHRydWU7XG5cbiAgICAgICAgLy8gaW52ZXJ0XG4gICAgICAgIGlmIChzZWdtZW50Q29sb3VyLmwgPCA2NSkge1xuICAgICAgICAgICAgbGFiZWxDb2xvdXIubCArPSBNYXRoLm1pbihsYWJlbENvbG91ci5sICsgNTAsIDEwMCk7XG4gICAgICAgICAgICBtdWx0aXBseSA9IGZhbHNlXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyBjb2xvdXI6IGxhYmVsQ29sb3VyLCBtdWx0aXBseTogbXVsdGlwbHkgfVxuICAgIH1cblxuICAgIF9nZXRXaWR0aE9mV2lkZXN0TGFiZWwoKXtcbiAgICAgICAgY29uc3QgYWxsTGFiZWxzID0gW1xuICAgICAgICAgIC4uLnRoaXMueFZhbHVlcygpLm1hcCh4VmFsID0+IHRoaXMuZm9ybWF0WCgpKHhWYWwpKSxcbiAgICAgICAgICAuLi50aGlzLnlWYWx1ZXMoKS5tYXAoeVZhbCA9PiB0aGlzLmZvcm1hdExhYmVsKCkoeVZhbCkpXG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IHRleHQgPSB0aGlzLl9lbGVtZW50XG4gICAgICAgICAgICAuYXBwZW5kKCd0ZXh0JylcbiAgICAgICAgICAgIC5zdHlsZSgnZm9udC1zaXplJywgdGhpcy5fZm9udF9zaXplICsgJ3B4JylcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdsYWJlbC13aWR0aC1jaGVjaycpXG4gICAgICAgICAgICAuc3R5bGUoJ3Zpc2liaWxpdHknLCAnaGlkZGVuJylcblxuICAgICAgICB0ZXh0LnNlbGVjdEFsbCgndHNwYW4nKVxuICAgICAgICAgICAgLmRhdGEoYWxsTGFiZWxzKVxuICAgICAgICAgICAgLmVudGVyKClcbiAgICAgICAgICAgIC5hcHBlbmQoJ3RzcGFuJylcbiAgICAgICAgICAgIC5hdHRyKCd4JywnMCcpXG4gICAgICAgICAgICAudGV4dChkID0+IGQpXG5cbiAgICAgICAgY29uc3QgdGV4dFdpZHRoID0gdGV4dC5ub2RlKCkuZ2V0QkJveCgpLndpZHRoO1xuXG4gICAgICAgIHRleHQucmVtb3ZlKCk7XG5cbiAgICAgICAgcmV0dXJuIHRleHRXaWR0aFxuICAgIH1cblxuICAgIF9nZXRNaWRBbmdsZShzZWdtZW50KSB7XG4gICAgICAgIHJldHVybiBzZWdtZW50LnN0YXJ0QW5nbGUgKyAoc2VnbWVudC5lbmRBbmdsZSAtIHNlZ21lbnQuc3RhcnRBbmdsZSkvMjtcbiAgICB9XG5cbiAgICBfZ2V0TGFiZWxIZWlnaHQoKXtcbiAgICAgIGNvbnN0IHRleHQgPSB0aGlzLl9lbGVtZW50XG4gICAgICAgIC5hcHBlbmQoJ3RleHQnKVxuICAgICAgICAuc3R5bGUoJ2ZvbnQtc2l6ZScsIHRoaXMuX2ZvbnRfc2l6ZSArICdweCcpXG4gICAgICAgIC5hdHRyKCdjbGFzcycsICdsYWJlbC1oZWlnaHQtY2hlY2snKVxuICAgICAgICAuc3R5bGUoJ3Zpc2liaWxpdHknLCAnaGlkZGVuJylcblxuICAgICAgY29uc3QgZGF0YSA9IHRoaXMuc2hvd0xhYmVscygpID8gWydDYXRlZ29yeScsICdWYWx1ZSddIDogWydDYXRlZ29yeSddO1xuXG4gICAgICB0ZXh0LnNlbGVjdEFsbCgndHNwYW4nKVxuICAgICAgICAuZGF0YShkYXRhKVxuICAgICAgICAuZW50ZXIoKVxuICAgICAgICAuYXBwZW5kKCd0c3BhbicpXG4gICAgICAgIC50ZXh0KGQgPT4gZClcbiAgICAgICAgLmF0dHIoJ3gnLDApXG4gICAgICAgIC5hdHRyKCdkeScsJzFlbScpXG5cbiAgICAgIGNvbnN0IHRleHRIZWlnaHQgPSB0ZXh0Lm5vZGUoKS5nZXRCQm94KCkuaGVpZ2h0O1xuXG4gICAgICB0ZXh0LnJlbW92ZSgpXG5cbiAgICAgIHJldHVybiB0ZXh0SGVpZ2h0XG4gICAgfVxuXG4gICAgX2dldExhYmVsQm91bmRpbmdQb2ludHMobGFiZWwsIGF0UG9pbnQpIHtcbiAgICAgICAgLypcbiAgICAgICAgYXNzdW1lczpcbiAgICAgICAg4oCiIGxhYmVsIGlzIGNlbnRyZWQgYXJvdW5kIGEgZ2l2ZW4gcG9pbnQuIGUuZy46XG4gICAgICAgICAtIHRleHQtYW5jaG9yOiBtaWRkbGVcbiAgICAgICAgIC0gbGVmdCA9PT0gYXRQb2ludFswXSArIHdpZHRoLzJcbiAgICAgICAgIC0gdG9wID09PSBhdFBvaW50WzFdICsgaGVpZ2h0LzJcbiAgICAgICAg4oCiIGxhYmVsLm5vZGUoKSBpcyBub3QgYSB0c3BhblxuICAgICAgICAqL1xuXG4gICAgICAgIC8vIGNvbnNpZGVyIHggYW5kIHkgYXR0cmlidXRlXG4gICAgICAgIGNvbnN0IHhPZmZzZXQgPSBwYXJzZUZsb2F0KGxhYmVsLmF0dHIoJ3gnKSB8fCAwKTtcbiAgICAgICAgY29uc3QgeU9mZnNldCA9IHBhcnNlRmxvYXQobGFiZWwuYXR0cigneScpIHx8IDApO1xuXG4gICAgICAgIGNvbnN0IGJvdW5kcyA9IGxhYmVsLm5vZGUoKS5nZXRCQm94KCk7XG4gICAgICAgIGNvbnN0IHcgPSBib3VuZHMud2lkdGg7IC8vbGFiZWwubm9kZSgpLmdldENvbXB1dGVkVGV4dExlbmd0aCgpO1xuICAgICAgICBjb25zdCBoID0gYm91bmRzLmhlaWdodDtcbiAgICAgICAgY29uc3QgeCA9IGF0UG9pbnRbMF0gKyB4T2Zmc2V0O1xuICAgICAgICBjb25zdCB5ID0gYXRQb2ludFsxXSArIHlPZmZzZXQ7XG5cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHt4OiB4LXcvMiwgeTogeS1oLzJ9LFxuICAgICAgICAgICAge3g6IHgrdy8yLCB5OiB5LWgvMn0sXG4gICAgICAgICAgICB7eDogeC13LzIsIHk6IHkraC8yfSxcbiAgICAgICAgICAgIHt4OiB4K3cvMiwgeTogeStoLzJ9XG4gICAgICAgIF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9W119IHBvaW50cyBBcnJheSBvZiBwb2ludHNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRBbmdsZSBOdW1iZXIgaW4gcmFkaWFuc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmRBbmdsZSBOdW1iZXIgaW4gcmFkaWFuc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbm5lclJhZGl1c1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvdXRlclJhZGl1c1xuICAgICAqL1xuICAgIF9hbGxQb2ludHNXaXRoaW5TZWdtZW50KHBvaW50cywgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cyl7XG5cbiAgICAgICAgY29uc3QgYW55UG9pbnRPdXRPZkJvdW5kcyA9IHBvaW50cy5zb21lKCBwb2ludCA9PiB7XG5cbiAgICAgICAgICAgIC8vIGVkZ2UgY2FzZSB3aGVyZSBwb2ludCBpcyBleGFjdGx5IGNlbnRlcmVkIGluIGEgcGllIGNoYXJ0XG4gICAgICAgICAgICAvLyBhbmQgdGhlcmVmb3JlIGFsd2F5cyB2YWxpZFxuICAgICAgICAgICAgaWYgKGlubmVyUmFkaXVzID09PSAwICYmIHBvaW50LnggPT09IDAgJiYgcG9pbnQueSA9PT0gMCkgcmV0dXJuIGZhbHNlXG5cbiAgICAgICAgICAgIGNvbnN0IGxpbmVMZW5ndGggPSBNYXRoLnNxcnQoIE1hdGgucG93KHBvaW50LngsIDIpICsgTWF0aC5wb3cocG9pbnQueSwgMikpXG5cbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICBsZXQgZmFpbENvbmRpdGlvbiA9IChcbiAgICAgICAgICAgICAgICBsaW5lTGVuZ3RoID09PSAwID8gJ2xpbmUgbGVuZ3RoID09PSAwJ1xuICAgICAgICAgICAgICA6IGxpbmVMZW5ndGggPiBvdXRlclJhZGl1cyA/ICdsaW5lTGVuZ3RoID4gb3V0ZXJSYWRpdXMnXG4gICAgICAgICAgICAgIDogbGluZUxlbmd0aCA8IGlubmVyUmFkaXVzID8gJ2xpbmVMZW5ndGggPCBpbm5lclJhZGl1cydcbiAgICAgICAgICAgICAgOiBudWxsXG4gICAgICAgICAgICApXG4gICAgICAgICAgICBpZiAoZmFpbENvbmRpdGlvbikgY29uc29sZS5sb2coZmFpbENvbmRpdGlvbilcbiAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIC8vIHBvaW50IGlzIG91dHNpZGUgcmFkaXVzIGJvdW5kc1xuICAgICAgICAgICAgLy8gLVxuICAgICAgICAgICAgLy8gemVybyBsaW5lIGxlbmd0aCBoZXJlIHJlZmVycyB0byBhIHBvaW50IGF0IHRoZSBjZW50cmUgb2YgYSBkb251dCBjaGFydFxuICAgICAgICAgICAgLy8gSXQncyBhIGNhc2UgdGVjaG5pY2FsbHkgY2F1Z2h0IGJ5IGJ5IGxpbmVMZW5ndGgsIGJ1dCB3YW50IHRvIGJlIHN1cmUgdG8gYXZvaWRcbiAgICAgICAgICAgIC8vIGRpdmlkZSBieSAwIGVycm9ycyBiZWxvd1xuICAgICAgICAgICAgaWYgKCBsaW5lTGVuZ3RoID09PSAwIHx8IGxpbmVMZW5ndGggPiBvdXRlclJhZGl1cyB8fCBsaW5lTGVuZ3RoIDwgaW5uZXJSYWRpdXMpIHJldHVybiB0cnVlXG5cbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbGlzZWRSYWRzID0gTWF0aC5hY29zKE1hdGguYWJzKHBvaW50LnkpIC8gbGluZUxlbmd0aClcbiAgICAgICAgICAgIGNvbnN0IGNpcmNsZSA9IE1hdGguUEkgKiAyO1xuXG4gICAgICAgICAgICBsZXQgbGluZUFuZ2xlID0gKFxuICAgICAgICAgICAgICAgICAgcG9pbnQueCA+PSAwICYmIHBvaW50LnkgPCAwID8gICAgICAgICAgICAgICAgIG5vcm1hbGlzZWRSYWRzIC8vIHRvcCByaWdodFxuICAgICAgICAgICAgICAgIDogcG9pbnQueCA+PSAwICYmIHBvaW50LnkgPj0gMCA/IGNpcmNsZSAqIDAuNSAtIG5vcm1hbGlzZWRSYWRzIC8vIGJvdHRvbSByaWdodFxuICAgICAgICAgICAgICAgIDogcG9pbnQueCA8IDAgJiYgIHBvaW50LnkgPj0gMCA/IGNpcmNsZSAqIDAuNSArIG5vcm1hbGlzZWRSYWRzIC8vIGJvdHRvbSBsZWZ0XG4gICAgICAgICAgICAgICAgOiBwb2ludC54IDwgMCAmJiAgcG9pbnQueSA8IDAgPyAgY2lyY2xlICAgICAgIC0gbm9ybWFsaXNlZFJhZHMgLy8gdG9wIGxlZnRcbiAgICAgICAgICAgICAgICA6IG51bGxcbiAgICAgICAgICAgIClcblxuICAgICAgICAgICAgLypcbiAgICAgICAgICAgIGZhaWxDb25kaXRpb24gPSAoXG4gICAgICAgICAgICAgICAgbGluZUFuZ2xlID09PSBudWxsID8gJ2xpbmVBbmdsZSA9PT0gbnVsbCdcbiAgICAgICAgICAgICAgOiBsaW5lQW5nbGUgPCBzdGFydEFuZ2xlID8gJ2xpbmVBbmdsZSA8IHN0YXJ0QW5nbGUnXG4gICAgICAgICAgICAgIDogbGluZUFuZ2xlID4gZW5kQW5nbGUgPyAnbGluZUFuZ2xlID4gZW5kQW5nbGUnXG4gICAgICAgICAgICAgIDogbnVsbFxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgaWYgKGZhaWxDb25kaXRpb24pIGNvbnNvbGUubG9nKGZhaWxDb25kaXRpb24pXG4gICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICAvLyBhbmdsZSBpcyBpbnZhbGlkIG9yIG91dCBvZiBib3VuZHNcbiAgICAgICAgICAgIGlmIChsaW5lQW5nbGUgPT09IG51bGwgfHwgbGluZUFuZ2xlIDwgc3RhcnRBbmdsZSB8fCBsaW5lQW5nbGUgPiBlbmRBbmdsZSApIHJldHVybiB0cnVlXG5cbiAgICAgICAgICAgIC8vIGRldlxuICAgICAgICAgICAgLy8gaWYgKHNob3dMaW5lcyl7XG4gICAgICAgICAgICAvLyAgICAgZDMuc2VsZWN0KCcucGllJylcbiAgICAgICAgICAgIC8vICAgICAgICAgLmFwcGVuZCgncG9seWxpbmUnKVxuICAgICAgICAgICAgLy8gICAgICAgICAuYXR0cignY2xhc3MnLCdkZXYnKVxuICAgICAgICAgICAgLy8gICAgICAgICAuc3R5bGUoJ3N0cm9rZS13aWR0aCcsICcxcHgnKVxuICAgICAgICAgICAgLy8gICAgICAgICAuc3R5bGUoJ3N0cm9rZScsICdyZ2JhKDAsMCwwLDAuMyknKVxuICAgICAgICAgICAgLy8gICAgICAgICAuYXR0cigncG9pbnRzJywgW1swLDBdLCBbcG9pbnQueCxwb2ludC55XV0pXG4gICAgICAgICAgICAvLyB9XG4gICAgICAgIH0pXG5cbiAgICAgICAgcmV0dXJuICFhbnlQb2ludE91dE9mQm91bmRzXG4gICAgfVxuXG4gICAgX3JlbmRlclNlZ21lbnRMYWJlbChsYWJlbFdyYXBwZXIsIHNlZ21lbnQsIGxhYmVsU2l6ZXMpIHtcbiAgICAgICAgY29uc3QgdGV4dFdyYXBwZXIgPSB0aGlzLl9hcHBlbmRJZkVtcHR5KGxhYmVsV3JhcHBlciwgJ2cnLCAndGV4dC13cmFwcGVyJyk7XG4gICAgICAgIGNvbnN0IG92ZXJsYXlDb2xvdXIgPSB0aGlzLl9nZXRPdmVybGF5TGFiZWxDb2xvdXIoc2VnbWVudCk7XG4gICAgICAgIGNvbnN0IHRleHRDb2xvdXIgPSB0aGlzLl91c2Vfb3V0c2lkZV9sYWJlbHNcbiAgICAgICAgICAgID8gZDMuaGNsKGNvbG91cnMuZWlnaHRlZW4uZGFya0dyZXkpLmJyaWdodGVyKClcbiAgICAgICAgICAgIDogb3ZlcmxheUNvbG91ci5jb2xvdXI7XG5cbiAgICAgICAgdGV4dFdyYXBwZXIuYXR0cigncG9pbnRlci1ldmVudHMnLCAnbm9uZScpXG4gICAgICAgICAgICAuYXR0cignZmlsbCcsIHRleHRDb2xvdXIpXG4gICAgICAgICAgICAuc3R5bGUoJ21peC1ibGVuZC1tb2RlJywgb3ZlcmxheUNvbG91ci5tdWx0aXBseSA/ICdtdWx0aXBseScgOiBudWxsKVxuICAgICAgICAgICAgLnN0eWxlKCdmb250LXNpemUnLCB0aGlzLl9mb250X3NpemUgKyAncHgnKTtcblxuICAgICAgICBjb25zdCBsYWJlbHMgPSBbdGhpcy5mb3JtYXRYKCkodGhpcy54KCkoc2VnbWVudC5kYXRhKSldO1xuICAgICAgICBpZiAodGhpcy5zaG93TGFiZWxzKCkpIGxhYmVscy5wdXNoKHRoaXMuZm9ybWF0TGFiZWwoKSh0aGlzLnkoKShzZWdtZW50LmRhdGEpKSk7XG5cbiAgICAgICAgY29uc3QgaXNXaXRoaW5TZWdtZW50ID0gbGFiZWwgPT4ge1xuICAgICAgICAgICAgY29uc3QgYm91bmRpbmdQb2ludHMgPSB0aGlzLl9nZXRMYWJlbEJvdW5kaW5nUG9pbnRzKGxhYmVsLCB0aGlzLl9sYWJlbF9hcmMuY2VudHJvaWQoc2VnbWVudCkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FsbFBvaW50c1dpdGhpblNlZ21lbnQoYm91bmRpbmdQb2ludHMsIHNlZ21lbnQuc3RhcnRBbmdsZSwgc2VnbWVudC5lbmRBbmdsZSwgdGhpcy5faW5uZXJfcmFkaXVzLCB0aGlzLl9vdXRlcl9yYWRpdXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaXNudFRvb1dpZGUgPSBsYWJlbCA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbGFiZWwubm9kZSgpLmdldEJCb3goKS53aWR0aCA8IHRoaXMuX21heF9sYWJlbF93aWR0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRlc3RGbiA9IHRoaXMuX3VzZV9vdXRzaWRlX2xhYmVscyA/IGlzbnRUb29XaWRlIDogaXNXaXRoaW5TZWdtZW50O1xuICAgICAgICBjb25zdCBzdHJpbmdzID0gbGFiZWxzLm1hcChsID0+IGwudG9TdHJpbmcoKSk7XG4gICAgICAgIHRoaXMuX2ZpdExhYmVsc0luU2VnbWVudChzdHJpbmdzLCB0ZXh0V3JhcHBlciwgdGVzdEZuLCAhdGhpcy5fdXNlX291dHNpZGVfbGFiZWxzKVxuXG4gICAgICAgIHRoaXMuX3RyYW5zZm9ybVNlZ21lbnRMYWJlbCh0ZXh0V3JhcHBlcilcblxuICAgICAgICBjb25zdCBmaW5hbFBvcyA9IHRoaXMuX291dGVyX2FyYy5jZW50cm9pZChzZWdtZW50KTtcbiAgICAgICAgY29uc3QgcmlnaHRIYW5kU2lkZSA9IHRoaXMuX2dldE1pZEFuZ2xlKHNlZ21lbnQpIDwgTWF0aC5QSTtcbiAgICAgICAgY29uc3QgcmVjdCA9IHRleHRXcmFwcGVyLm5vZGUoKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgbGFiZWxTaXplc1tzZWdtZW50LmluZGV4XSA9IHt5OiBmaW5hbFBvc1sxXSwgaGVpZ2h0OiByZWN0LmhlaWdodCwgcmlnaHRIYW5kU2lkZX07XG5cbiAgICAgICAgdGhpcy5fcmVuZGVyTGVhZGVyTGluZXMobGFiZWxXcmFwcGVyKVxuICAgIH1cblxuICAgIF9oaWRlT3V0T2ZCb3VuZExhYmVscyhsYWJlbFdyYXBwZXIsIHNlZ21lbnQsIGxhYmVsU2l6ZXMpIHtcbiAgICAgICAgY29uc3QgdGV4dHMgPSBsYWJlbFdyYXBwZXIuc2VsZWN0QWxsKCd0ZXh0Jyk7XG5cbiAgICAgICAgbGV0IHdpdGhpbkJvdW5kcyA9IHRydWU7XG5cbiAgICAgICAgdGV4dHMuZWFjaCgoc3RyaW5nLCBpLCBub2RlcykgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGV4dCA9IGQzLnNlbGVjdChub2Rlc1tpXSk7XG4gICAgICAgICAgICBpZiAodGhpcy5fdXNlX291dHNpZGVfbGFiZWxzKXtcbiAgICAgICAgICAgICAgICBsZXQgaGlkZSA9IHRleHQubm9kZSgpLmdldEJCb3goKS53aWR0aCA+IHRoaXMuX21heF9sYWJlbF93aWR0aDtcbiAgICAgICAgICAgICAgICBpZiAoIWhpZGUgJiYgc2VnbWVudC5pbmRleCAhPT0gMCAmJiB0aGlzLl91c2Vfb3V0c2lkZV9sYWJlbHMpeyAvLyBza2lwIGZpcnN0IGxhYmVsXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRoaXNMYWJlbCA9IGxhYmVsU2l6ZXNbc2VnbWVudC5pbmRleF07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzTGFiZWwgPSBsYWJlbFNpemVzW3NlZ21lbnQuaW5kZXggLSAxXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpc0xhYmVsLnJpZ2h0SGFuZFNpZGUgIT09IHByZXZpb3VzTGFiZWwucmlnaHRIYW5kU2lkZSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkaWZmZXJlbnQgc2lkZXMg4oCTIGlnbm9yZVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXNMYWJlbC5yaWdodEhhbmRTaWRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoaWRlID0gKHByZXZpb3VzTGFiZWwueSArIHByZXZpb3VzTGFiZWwuaGVpZ2h0KSA+IHRoaXNMYWJlbC55O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGlkZSA9ICggdGhpc0xhYmVsLnkgKyB0aGlzTGFiZWwuaGVpZ2h0ICkgPiBwcmV2aW91c0xhYmVsLnk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGhpZGUpIHdpdGhpbkJvdW5kcyA9IGZhbHNlXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBvaW50cyA9IHRoaXMuX2dldExhYmVsQm91bmRpbmdQb2ludHModGV4dCwgdGhpcy5fbGFiZWxfYXJjLmNlbnRyb2lkKHNlZ21lbnQpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBpc1dpdGhpblNlZ21lbnQgPSB0aGlzLl9hbGxQb2ludHNXaXRoaW5TZWdtZW50KHBvaW50cywgc2VnbWVudC5zdGFydEFuZ2xlLCBzZWdtZW50LmVuZEFuZ2xlLCB0aGlzLl9pbm5lcl9yYWRpdXMsIHRoaXMuX291dGVyX3JhZGl1cywgc3RyaW5nID09PSAnMzUxJyk7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coc3RyaW5nLCBpc1dpdGhpblNlZ21lbnQpXG4gICAgICAgICAgICAgICAgaWYgKCFpc1dpdGhpblNlZ21lbnQpIHdpdGhpbkJvdW5kcyA9IGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG5cbiAgICAgICAgbGFiZWxXcmFwcGVyLnN0eWxlKCd2aXNpYmlsaXR5Jywgd2l0aGluQm91bmRzID8gbnVsbCA6ICdoaWRkZW4nKTtcblxuXG4gICAgfVxuXG4gICAgX3JlbmRlclNlZ21lbnRMYWJlbHMoc2VnbWVudHMpIHtcbiAgICAgICAgY29uc3Qgc2VnbWVudExhYmVsc1dyYXBwZXIgPSB0aGlzLl9hcHBlbmRJZkVtcHR5KHRoaXMuX3BpZSwgJ2cnLCAnc2VnbWVudC1sYWJlbHMnKS5zdHlsZSgnZm9udC1mYW1pbHknLCAnc2Fucy1zZXJpZicpO1xuXG4gICAgICAgIGNvbnN0IHNlZ21lbnRMYWJlbHMgPSBzZWdtZW50TGFiZWxzV3JhcHBlci5zZWxlY3RBbGwoJy5zZWdtZW50LWxhYmVsJylcbiAgICAgICAgICAgIC5kYXRhKHNlZ21lbnRzLCBkID0+IGQuZGF0YS5feCk7XG5cbiAgICAgICAgY29uc3QgbGFiZWxTaXplcyA9IFtdO1xuXG4gICAgICAgIHNlZ21lbnRMYWJlbHMuZW50ZXIoKVxuICAgICAgICAgICAgLmFwcGVuZCgnZycpXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnc2VnbWVudC1sYWJlbCcpXG4gICAgICAgICAgICAubWVyZ2Uoc2VnbWVudExhYmVscylcbiAgICAgICAgICAgIC5lYWNoKChzZWdtZW50LCBpLCBub2RlcykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxhYmVsV3JhcHBlciA9IGQzLnNlbGVjdChub2Rlc1tpXSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyU2VnbWVudExhYmVsKGxhYmVsV3JhcHBlciwgc2VnbWVudCwgbGFiZWxTaXplcylcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAvLyBoaWRlIGludGVyc2VjdGluZyBvciB0b28td2lkZSBsYWJlbHNcbiAgICAgICAgICAgIC8vIGdpdmluZyBwcmVmZXJlbmNlIHRvIGxhYmVscyBhIGxvd2VyIGFyYyBpbmRleFxuICAgICAgICAgICAgLy8gb25seSBkbyB0aGlzIGZvciBvdXRzaWRlIGxhYmVscyBmb3Igbm93XG4gICAgICAgICAgICAuZWFjaCgoc2VnbWVudCwgaSwgbm9kZXMpID0+IHtcbiAgICAgICAgICAgICAgIGNvbnN0IGxhYmVsV3JhcHBlciA9IGQzLnNlbGVjdChub2Rlc1tpXSk7XG4gICAgICAgICAgICAgICB0aGlzLl9oaWRlT3V0T2ZCb3VuZExhYmVscyhsYWJlbFdyYXBwZXIsIHNlZ21lbnQsIGxhYmVsU2l6ZXMpO1xuICAgICAgICAgICAgfSlcblxuICAgICAgICBzZWdtZW50TGFiZWxzLmV4aXQoKS5yZW1vdmUoKTtcbiAgICB9XG5cbiAgICBfcmVuZGVyTGVhZGVyTGluZXMobGFiZWxXcmFwcGVyKSB7XG4gICAgICAgIGNvbnN0IGxlYWRlckFyYyA9IGQzLmFyYygpXG4gICAgICAgICAgICAuaW5uZXJSYWRpdXModGhpcy5fb3V0ZXJfcmFkaXVzIC0gNSlcbiAgICAgICAgICAgIC5vdXRlclJhZGl1cyh0aGlzLl9vdXRlcl9yYWRpdXMgLSA1KTtcblxuICAgICAgICBjb25zdCBsaW5lID0gdGhpcy5fYXBwZW5kSWZFbXB0eShsYWJlbFdyYXBwZXIsICdwb2x5bGluZScsICdsYWJlbC1saW5lJyk7XG4gICAgICAgIGlmICghdGhpcy5fdXNlX291dHNpZGVfbGFiZWxzKSB7XG4gICAgICAgICAgICBsaW5lLnJlbW92ZSgpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgIGxpbmVcbiAgICAgICAgICAgICAgICAuYXR0cignc3Ryb2tlJywgZDMuaGNsKGNvbG91cnMuZWlnaHRlZW4uZGFya0dyZXkpLmJyaWdodGVyKCkpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ29wYWNpdHknLCAwLjUpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZS13aWR0aCcsICcxcHgnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgJ25vbmUnKVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnbWl4LWJsZW5kLW1vZGUnLCAnbXVsdGlwbHknKVxuICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKCkuZHVyYXRpb24odGhpcy5fdHJhbnNpdGlvbl9kdXJhdGlvbilcbiAgICAgICAgICAgICAgICAuYXR0clR3ZWVuKFwicG9pbnRzXCIsIGZ1bmN0aW9uKGQpe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50ID0gdGhpcy5fY3VycmVudCB8fCBkO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW50ZXJwb2xhdGUgPSBkMy5pbnRlcnBvbGF0ZSh0aGlzLl9jdXJyZW50LCBkKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudCA9IGludGVycG9sYXRlKDApO1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZDIgPSBpbnRlcnBvbGF0ZSh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IGxlYWRlckFyYy5jZW50cm9pZChkMik7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWxib3cgPSB0aGF0Ll9vdXRlcl9hcmMuY2VudHJvaWQoZDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRlcm1pbmFsID0gdGhhdC5fb3V0ZXJfYXJjLmNlbnRyb2lkKGQyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxlZnRBbGlnbmVkID0gdGhhdC5fZ2V0TWlkQW5nbGUoZDIpIDwgTWF0aC5QSTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlcm1pbmFsWzBdID0gdGhhdC5fb3V0ZXJfcmFkaXVzICogMS4wNSAqIChsZWZ0QWxpZ25lZCA/IDEgOiAtMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwb3NpdGlvbnMgPSBbc3RhcnQsIGVsYm93XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsZWZ0QWxpZ25lZCA/IHRlcm1pbmFsWzBdID4gZWxib3dbMF0gOiBlbGJvd1swXSA+IHRlcm1pbmFsWzBdKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbnMucHVzaCh0ZXJtaW5hbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcG9zaXRpb25zO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX3RyYW5zZm9ybVNlZ21lbnRMYWJlbCh0ZXh0KSB7XG4gICAgICAgIGNvbnN0IHRoYXQgPSB0aGlzO1xuICAgICAgICB0ZXh0XG4gICAgICAgICAgICAudHJhbnNpdGlvbigpLmR1cmF0aW9uKHRoaXMuX3RyYW5zaXRpb25fZHVyYXRpb24pXG4gICAgICAgICAgICAuYXR0clR3ZWVuKFwidHJhbnNmb3JtXCIsIGZ1bmN0aW9uKGFyY0RhdGEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50ID0gdGhpcy5fY3VycmVudCB8fCBhcmNEYXRhO1xuICAgICAgICAgICAgICAgIGNvbnN0IGludGVycG9sYXRlID0gZDMuaW50ZXJwb2xhdGUodGhpcy5fY3VycmVudCwgYXJjRGF0YSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudCA9IGludGVycG9sYXRlKDApO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZEludCA9IGludGVycG9sYXRlKHQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhhdC5fdXNlX291dHNpZGVfbGFiZWxzKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvcyA9IHRoYXQuX291dGVyX2FyYy5jZW50cm9pZChkSW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc1swXSA9IHRoYXQuX291dGVyX3JhZGl1cyAqIDEuMDkgKiAodGhhdC5fZ2V0TWlkQW5nbGUoZEludCkgPCBNYXRoLlBJID8gMSA6IC0xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcInRyYW5zbGF0ZShcIisgcG9zICtcIilcIjtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcInRyYW5zbGF0ZShcIiArIHRoYXQuX2xhYmVsX2FyYy5jZW50cm9pZChkSW50KSArIFwiKVwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuc3R5bGVUd2VlbihcInRleHQtYW5jaG9yXCIsIGZ1bmN0aW9uKGFyY0RhdGEpe1xuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnQgPSB0aGlzLl9jdXJyZW50IHx8IGFyY0RhdGE7XG4gICAgICAgICAgICAgICAgY29uc3QgaW50ZXJwb2xhdGUgPSBkMy5pbnRlcnBvbGF0ZSh0aGlzLl9jdXJyZW50LCBhcmNEYXRhKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50ID0gaW50ZXJwb2xhdGUoMCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkSW50ID0gaW50ZXJwb2xhdGUodCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGF0Ll91c2Vfb3V0c2lkZV9sYWJlbHMgPyAoIHRoYXQuX2dldE1pZEFuZ2xlKGRJbnQpIDwgTWF0aC5QSSA/ICdzdGFydCcgOiAnZW5kJyApIDogJ21pZGRsZSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICB9XG5cbiAgICBfc3BsaXRJbkhhbGZCeU5lYXJlc3RTcGFjZShzdHJpbmcpIHtcblxuICAgICAgICBjb25zdCBtaW5DaGFycyA9IDNcblxuICAgICAgICBpZiAoc3RyaW5nLmluZGV4T2YoJyAnKSA9PT0gLTEpe1xuICAgICAgICAgICAgcmV0dXJuIFtzdHJpbmddXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBoYWxmSW5kZXggPSBNYXRoLmZsb29yKHN0cmluZy5sZW5ndGgvMik7XG4gICAgICAgIGNvbnN0IG1heEluZGV4ID0gc3RyaW5nLmxlbmd0aCAtIDE7XG4gICAgICAgIGxldCBwcmVJbmRleCA9IHN0cmluZy5zbGljZSgwLCBoYWxmSW5kZXggKyAxKS5sYXN0SW5kZXhPZignICcpO1xuICAgICAgICBsZXQgcG9zdEluZGV4ID0gc3RyaW5nLnNsaWNlKGhhbGZJbmRleCkuaW5kZXhPZignICcpO1xuXG4gICAgICAgIHByZUluZGV4ID0gcHJlSW5kZXggPT09IC0xID8gbWF4SW5kZXggOiBwcmVJbmRleFxuICAgICAgICBwb3N0SW5kZXggPSBwb3N0SW5kZXggPT09IC0xID8gbWF4SW5kZXggOiBwb3N0SW5kZXggKyBoYWxmSW5kZXhcblxuICAgICAgICBjb25zdCBwcmVmZXJyZWRJbmRleCA9IE1hdGgubWluKFxuICAgICAgICAgICAgcHJlSW5kZXggICE9PSAtMSAmJiBoYWxmSW5kZXggLSBwcmVJbmRleCA+IG1pbkNoYXJzID8gbWF4SW5kZXggOiBwcmVJbmRleCxcbiAgICAgICAgICAgIHBvc3RJbmRleCAhPT0gLTEgJiYgbWF4SW5kZXggLSBwb3N0SW5kZXggPCBtaW5DaGFycyA/IG1heEluZGV4IDogcG9zdEluZGV4XG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKCBwcmVmZXJyZWRJbmRleCA8IG1heEluZGV4IC0gbWluQ2hhcnMgJiYgcHJlZmVycmVkSW5kZXggPj0gbWluQ2hhcnMpe1xuICAgICAgICAgICAgcmV0dXJuIFsgc3RyaW5nLnNsaWNlKDAsIHByZWZlcnJlZEluZGV4KSwgc3RyaW5nLnNsaWNlKHByZWZlcnJlZEluZGV4ICsgMSkgXVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFtzdHJpbmddXG4gICAgfVxuXG4gICAgX2dldFRydW5jYXRlZFRleHQodGV4dCwgdHJ1bmNTaXplKSB7XG4gICAgICAgIGNvbnN0IG1pbkNoYXJzID0gMztcblxuICAgICAgICBjb25zdCB3b3JkcyA9IHRleHQuc3BsaXQoJyAnKTtcbiAgICAgICAgd29yZHMuc3BsaWNlKE1hdGguY2VpbCh3b3Jkcy5sZW5ndGggLyAyKSAtIE1hdGguZmxvb3IodHJ1bmNTaXplIC8gMiksIHRydW5jU2l6ZSwgdGhpcy5fZWxsaXBzaXMpO1xuICAgICAgICBjb25zdCB0cnVuY2F0ZWRUZXh0ID0gd29yZHMuam9pbignICcpO1xuICAgICAgICBjb25zdCBsYWJlbExlbmd0aCA9IHRydW5jYXRlZFRleHQubGVuZ3RoO1xuXG4gICAgICAgIGlmIChsYWJlbExlbmd0aCAtIHRoaXMuX2VsbGlwc2lzLmxlbmd0aCA8IG1pbkNoYXJzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGV4dFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRydW5jYXRlZFRleHRcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9hcnJheUVxdWFscyhhLCBiKSB7XG4gICAgICAgIGlmIChhID09PSBiKSByZXR1cm4gdHJ1ZVxuICAgICAgICBpZiAoYSA9PT0gbnVsbCB8fCBiID09PSBudWxsIHx8IGEubGVuZ3RoICE9PSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlXG4gICAgICAgIGEuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHsgaWYgKGl0ZW0gIT09IGJbaW5kZXhdKSByZXR1cm4gZmFsc2UgfSApXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBzdHJpbmdzXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSB0ZXN0Rm5cbiAgICAgKi9cbiAgICBfZml0TGFiZWxzSW5TZWdtZW50KGluaXRpYWxTdHJpbmdzLCBlbGVtZW50LCB0ZXN0Rm4sIHRyeUxpbmVXcmFwLCBtYXhBdHRlbXB0cykge1xuICAgICAgICBpZiAodHlwZW9mIG1heEF0dGVtcHRzICE9PSAndW5kZWZpbmVkJyAmJiAodHlwZW9mIG1heEF0dGVtcHRzICE9PSAnbnVtYmVyJyB8fCBwYXJzZUludChtYXhBdHRlbXB0cykgIT09IG1heEF0dGVtcHRzKSl7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdtYXhBdHRlbXB0cyBzaG91bGQgYmUgYW4gaW50ZWdlcicpXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbnVtQXR0ZW1wdHMgPSAwO1xuICAgICAgICBtYXhBdHRlbXB0cyA9IG1heEF0dGVtcHRzIHx8IDU7XG5cbiAgICAgICAgbGV0IGRpZEZpdCA9IGZhbHNlXG4gICAgICAgIGxldCBzdHJpbmdzID0gaW5pdGlhbFN0cmluZ3Muc2xpY2UoKVxuXG4gICAgICAgIC8vIGxldCBhdHRlbXB0cyA9IFtdO1xuICAgICAgICBsZXQgbmV3U3RyaW5ncyA9IFtdXG4gICAgICAgIGxldCB3cmFwRmFpbGVkID0gZmFsc2VcblxuICAgICAgICAvLyBsb29wIGxpbmVzXG4gICAgICAgIHdoaWxlICghZGlkRml0ICYmIG51bUF0dGVtcHRzIDwgbWF4QXR0ZW1wdHMpe1xuXG4gICAgICAgICAgICBkaWRGaXQgPSB0cnVlO1xuXG4gICAgICAgICAgICBlbGVtZW50LnNlbGVjdEFsbCgndGV4dCcpLnJlbW92ZSgpO1xuXG4gICAgICAgICAgICBsZXQgdGV4dHMgPSBlbGVtZW50LnNlbGVjdEFsbCgndGV4dCcpO1xuXG4gICAgICAgICAgICBuZXdTdHJpbmdzID0gW107XG5cbiAgICAgICAgICAgIHRleHRzXG4gICAgICAgICAgICAgICAgLmRhdGEoc3RyaW5ncylcbiAgICAgICAgICAgICAgICAuZW50ZXIoKVxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxuICAgICAgICAgICAgICAgIC5tZXJnZSh0ZXh0cylcbiAgICAgICAgICAgICAgICAudGV4dChzdHJpbmcgPT4gc3RyaW5nKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd5Jywoc3RyaW5nLCBpLCBub2RlcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsaW5lSGVpZ2h0RmFjdG9yID0gaSAtIG5vZGVzLmxlbmd0aC8yICsgMTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxpbmVIZWlnaHRGYWN0b3IgKiB0aGlzLl9mb250X3NpemUgKiB0aGlzLl9saW5lX2hlaWdodCArJ3B4J1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmVhY2goKHN0cmluZywgaSwgbm9kZXMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGV4dCA9IGQzLnNlbGVjdChub2Rlc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZXN0Rm4odGV4dCkpe1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3U3RyaW5ncy5wdXNoKHN0cmluZyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHJ5TGluZVdyYXAgJiYgIXdyYXBGYWlsZWQpeyAvLyYmIHN0cmluZ3MubGVuZ3RoIDwgM1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlkRml0ID0gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNwbGl0IGludG8gc3RyaW5ncyBmb3IgbmV4dCBpdGVyYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHdvcmRzID0gdGhpcy5fc3BsaXRJbkhhbGZCeU5lYXJlc3RTcGFjZShzdHJpbmcpXG4gICAgICAgICAgICAgICAgICAgICAgICB3b3Jkcy5mb3JFYWNoKHMgPT4gbmV3U3RyaW5ncy5wdXNoKHMpKVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJ5IHRydW5jYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0cnVuY1NpemUgPSAwXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSggdHJ1bmNTaXplIDwgc3RyaW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRydW5jYXRlZFRleHQgPSB0aGlzLl9nZXRUcnVuY2F0ZWRUZXh0KHN0cmluZywgdHJ1bmNTaXplKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHJ1bmNhdGVkVGV4dCA9PT0gc3RyaW5nICl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpZEZpdCA9IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1N0cmluZ3MucHVzaChpID09PSAwID8gc3RyaW5nIDogdGhpcy5fZWxsaXBzaXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQudGV4dCh0cnVuY2F0ZWRUZXh0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRlc3RGbih0ZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0ZXh0IGZpdHMsIGNvbnRpbnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1N0cmluZ3MucHVzaCh0cnVuY2F0ZWRUZXh0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRydW5jU2l6ZSArPSAxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRydW5jU2l6ZSA9PT0gc3RyaW5nLmxlbmd0aCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlkRml0ID0gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiAoIGkgPT09IDAgKSBjb25zb2xlLmxvZyhzdHJpbmcsICdpID09IDAnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1N0cmluZ3MucHVzaChpID09PSAwID8gc3RyaW5nIDogdGhpcy5fZWxsaXBzaXMpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5leGl0KClcbiAgICAgICAgICAgICAgICAucmVtb3ZlKClcblxuICAgICAgICAgICAgLy8gYXR0ZW1wdHMucHVzaChzdHJpbmdzKTtcblxuICAgICAgICAgICAgY29uc3QgbnVtRWxsaXBzZXMgPSAwO1xuICAgICAgICAgICAgbmV3U3RyaW5ncyA9IG5ld1N0cmluZ3MuZmlsdGVyKChzdHJpbmcsIGksIGFycikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJlZ2luc1dpdGhFbGxpcHNpcyA9IHN0cmluZy50cmltKCkuaW5kZXhPZih0aGlzLl9lbGxpcHNpcykgPT09IDA7XG5cbiAgICAgICAgICAgICAgICBpZiAoYmVnaW5zV2l0aEVsbGlwc2lzICYmIGkgPT09IDApe1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBmb2xsb3dzIGVsbGlwc2lzIGluIHByZXYgc3RyaW5nXG4gICAgICAgICAgICAgICAgY29uc3QgcHJldlN0cmluZyA9IChhcnJbaSAtIDFdIHx8ICcnKS50cmltKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJldlN0cmluZ0VuZHNXaXRoRWxsaXBzaXMgPSBwcmV2U3RyaW5nICYmIHByZXZTdHJpbmcuaW5kZXhPZih0aGlzLl9lbGxpcHNpcykgPT09IHByZXZTdHJpbmcubGVuZ3RoIC0gdGhpcy5fZWxsaXBzaXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChiZWdpbnNXaXRoRWxsaXBzaXMgJiYgcHJldlN0cmluZ0VuZHNXaXRoRWxsaXBzaXMpe1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgIGlmIChudW1FbGxpcHNlcyA+IDEpIG5ld1N0cmluZ3MgPSBbXVxuXG4gICAgICAgICAgICBjb25zdCBqdXN0RWxsaXBzZXMgPSBuZXdTdHJpbmdzLmZpbHRlcihzID0+IHMgPT09IHRoaXMuX2VsbGlwc2lzKS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoanVzdEVsbGlwc2VzID09PSBuZXdTdHJpbmdzLmxlbmd0aCkgbmV3U3RyaW5ncyA9IFtdXG5cbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKG5ld1N0cmluZ3MpXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnICcpXG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9hcnJheUVxdWFscyhzdHJpbmdzLCBuZXdTdHJpbmdzKSAmJiAhd3JhcEZhaWxlZCkgd3JhcEZhaWxlZCA9IHRydWU7XG5cbiAgICAgICAgICAgIHN0cmluZ3MgPSBuZXdTdHJpbmdzO1xuICAgICAgICAgICAgbnVtQXR0ZW1wdHMgKz0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGF0dGVtcHRzKVxuXG4gICAgICAgIHJldHVybiBudW1BdHRlbXB0cyA8IG1heEF0dGVtcHRzICYmIGRpZEZpdFxuXG4gICAgfVxuXG4gICAgX2FkZENlbnRyZUxhYmVsKCkge1xuXG4gICAgICAgIGxldCB4VGV4dCA9IHRoaXMueEF4aXNMYWJlbCgpO1xuICAgICAgICBsZXQgeVRleHQgPSB0aGlzLnlBeGlzTGFiZWwoKTtcblxuICAgICAgICBjb25zdCBoYXNZVGV4dCA9IHlUZXh0IHx8IHlUZXh0ID09PSAwO1xuICAgICAgICBjb25zdCBoYXNYVGV4dCA9IHhUZXh0IHx8IHhUZXh0ID09PSAwO1xuXG4gICAgICAgIGNvbnN0IGxhYmVscyA9IFtdO1xuXG4gICAgICAgIGlmIChoYXNZVGV4dCkgbGFiZWxzLnB1c2goeVRleHQgJiYgeVRleHQuc2hvcnQgfHwgeVRleHQpO1xuICAgICAgICBpZiAoaGFzWFRleHQpIGxhYmVscy5wdXNoKHhUZXh0ICYmIHhUZXh0LnNob3J0IHx8IHhUZXh0KTtcblxuICAgICAgICBjb25zdCBjZW50cmVUZXh0ID0gdGhpcy5fYXBwZW5kSWZFbXB0eSh0aGlzLl9waWUsICdnJywgJ2NlbnRyZS1sYWJlbCcpXG4gICAgICAgICAgICAuc3R5bGUoJ2ZvbnQtZmFtaWx5JywgJ3NhbnMtc2VyaWYnKVxuICAgICAgICAgICAgLnN0eWxlKCdmb250LXNpemUnLCB0aGlzLl9mb250X3NpemUgKyAncHgnKVxuICAgICAgICAgICAgLmF0dHIoJ3RleHQtYW5jaG9yJywgJ21pZGRsZScpO1xuXG4gICAgICAgIGlmIChsYWJlbHMubGVuZ3RoID09PSAwKXtcbiAgICAgICAgICAgIGNlbnRyZVRleHQucmVtb3ZlKCk7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGlzV2l0aGluU2VnbWVudCA9IGxhYmVsID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGJvdW5kaW5nUG9pbnRzID0gdGhpcy5fZ2V0TGFiZWxCb3VuZGluZ1BvaW50cyhsYWJlbCwgWzAsMF0pXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYWxsUG9pbnRzV2l0aGluU2VnbWVudChib3VuZGluZ1BvaW50cywgMCwgMiAqIE1hdGguUEksIDAsIHRoaXMuX2lubmVyX3JhZGl1cylcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHN0cmluZ3MgPSBsYWJlbHMubWFwKGwgPT4gbC50b1N0cmluZygpKTtcblxuICAgICAgICBjb25zdCBmaXR0ZWQgPSB0aGlzLl9maXRMYWJlbHNJblNlZ21lbnQoc3RyaW5ncywgY2VudHJlVGV4dCwgaXNXaXRoaW5TZWdtZW50LCB0cnVlLCAxMCApXG5cbiAgICAgICAgY2VudHJlVGV4dC5zdHlsZSgndmlzaWJpbGl0eScsIGZpdHRlZCA/IG51bGwgOiAnaGlkZGVuJylcbiAgICB9XG5cbiAgICBfcmVuZGVyU2VnbWVudHMoc2VnbWVudHMpIHtcbiAgICAgICAgY29uc3Qgc2VnbWVudFdyYXBwZXIgPSB0aGlzLl9hcHBlbmRJZkVtcHR5KHRoaXMuX3BpZSwgJ2cnLCAnc2VnbWVudHMnKTtcbiAgICAgICAgY29uc3QgcGF0aHMgPSBzZWdtZW50V3JhcHBlci5zZWxlY3RBbGwoJy5zZWdtZW50JylcbiAgICAgICAgICAgIC5kYXRhKHNlZ21lbnRzLCBkID0+IGQuZGF0YS5feCk7XG5cbiAgICAgICAgY29uc3QgdGhhdCA9IHRoaXM7XG4gICAgICAgIHBhdGhzLmVudGVyKClcbiAgICAgICAgICAuYXBwZW5kKCdwYXRoJylcbiAgICAgICAgICAuYXR0cignY2xhc3MnLCdzZWdtZW50JylcbiAgICAgICAgICAubWVyZ2UocGF0aHMpXG4gICAgICAgICAgLm9uKFwibW91c2VvdmVyXCIsIChkLCBpLCBub2RlcykgPT4ge1xuICAgICAgICAgICAgICBkMy5zZWxlY3Qobm9kZXNbaV0pXG4gICAgICAgICAgICAgIC5pbnRlcnJ1cHQoXCJob3Zlcjpjb2xvdXJcIilcbiAgICAgICAgICAgICAgLnRyYW5zaXRpb24oXCJob3Zlcjpjb2xvdXJcIilcbiAgICAgICAgICAgICAgLmR1cmF0aW9uKDUwKVxuICAgICAgICAgICAgICAuYXR0cihcImZpbGxcIiwgZDMuaGNsKHRoaXMuZ2V0RDNDb2xvdXIoZC5kYXRhKSkuYnJpZ2h0ZXIoMC4yKSlcbiAgICAgICAgICAgICAgLmF0dHIoXCJzdHJva2VcIiwgZCA9PiBkMy5oY2wodGhpcy5nZXREM0NvbG91cihkLmRhdGEpKS5kYXJrZXIoMC40KSk7XG4gICAgICAgICAgICAgIHRoaXMuX2Rpc3BhdGNoLmNhbGwoXCJ0b29sdGlwU2hvd1wiLCB0aGlzLCB7XG4gICAgICAgICAgICAgICAgICBlOiBkMy5ldmVudCxcbiAgICAgICAgICAgICAgICAgIHBvaW50OiBkLmRhdGEsXG4gICAgICAgICAgICAgICAgICBzZXJpZXM6IGQuZGF0YS5fc2VyaWVzLFxuICAgICAgICAgICAgICAgICAgc2VyaWVzSW5kZXg6IDAsLy9zX2lcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiBkLmRhdGEuX3lcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5vbihcIm1vdXNlb3V0XCIsIChkLCBpLCBub2RlcykgPT4geyAvLyBiYXIgaXMgcmVndWxhciBjb2xvdXIgb24gbW91c2Ugb3V0LlxuICAgICAgICAgICAgICBkMy5zZWxlY3Qobm9kZXNbaV0pXG4gICAgICAgICAgICAgIC5pbnRlcnJ1cHQoXCJob3Zlcjpjb2xvdXJcIilcbiAgICAgICAgICAgICAgLnRyYW5zaXRpb24oXCJob3Zlcjpjb2xvdXJcIilcbiAgICAgICAgICAgICAgLmR1cmF0aW9uKDEwMClcbiAgICAgICAgICAgICAgLmF0dHIoXCJmaWxsXCIsIGQgPT4gdGhpcy5nZXREM0NvbG91cihkLmRhdGEpKVxuICAgICAgICAgICAgICAuYXR0cihcInN0cm9rZVwiLCBkID0+IGQzLmhjbCh0aGlzLmdldEQzQ29sb3VyKGQuZGF0YSkpLmRhcmtlcigpKTtcbiAgICAgICAgICAgICAgdGhpcy5fZGlzcGF0Y2guY2FsbChcInRvb2x0aXBIaWRlXCIsIHRoaXMpO1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLm9uKFwiY2xpY2sgYXV4Y2xpY2tcIiwgKGQsIGksIG5vZGVzKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMuX2Rpc3BhdGNoLmNhbGwoXCJlbGVtZW50Q2xpY2tcIiwgdGhpcywge1xuICAgICAgICAgICAgICAgICAgZTogZDMuZXZlbnQsXG4gICAgICAgICAgICAgICAgICBwb2ludDogZC5kYXRhLFxuICAgICAgICAgICAgICAgICAgc2VyaWVzOiBkLmRhdGEuX3NlcmllcyxcbiAgICAgICAgICAgICAgICAgIHNlcmllc0luZGV4OiAwLCAvL2QuZGF0YS5fc19pLFxuICAgICAgICAgICAgICAgICAgdmFsdWU6IGQuZGF0YS5feVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgIH0pXG4gICAgICAgICAgLnRyYW5zaXRpb24oKS5kdXJhdGlvbih0aGlzLl90cmFuc2l0aW9uX2R1cmF0aW9uKVxuICAgICAgICAgIC5hdHRyKFwiZmlsbFwiLCBkID0+IHRoaXMuZ2V0RDNDb2xvdXIoZC5kYXRhKSlcbiAgICAgICAgICAuYXR0cihcInN0cm9rZVwiLCBkID0+IGQzLmhjbCh0aGlzLmdldEQzQ29sb3VyKGQuZGF0YSkpLmRhcmtlcigpKVxuICAgICAgICAgIC5zdHlsZShcImN1cnNvclwiLCBcInBvaW50ZXJcIilcbiAgICAgICAgICAuYXR0clR3ZWVuKCdkJywgZnVuY3Rpb24ocCxwaSxwbm9kZXMpe1xuICAgICAgICAgICAgICB2YXIgcEludCA9IGQzLmludGVycG9sYXRlKHRoaXMuX2N1cnJlbnQsIHApO1xuICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50ID0gcEludCgwKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHQgPT4gdGhhdC5fYXJjKHBJbnQodCkpO1xuICAgICAgICAgIH0pXG5cbiAgICAgICAgcGF0aHMuZXhpdCgpLnJlbW92ZSgpO1xuICAgIH1cblxuICAgIGlzRG9udXQoYm9vbCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX2lzX2RvbnV0O1xuICAgICAgICB0aGlzLl9pc19kb251dCA9IGJvb2w7XG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgdXNlT3V0c2lkZUxhYmVscyhib29sKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5fdXNlX291dHNpZGVfbGFiZWxzO1xuICAgICAgICB0aGlzLl91c2Vfb3V0c2lkZV9sYWJlbHMgPSBib29sO1xuICAgICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIHByZXBhcmVEYXRhKGRhdGEsIGZhY2V0ZWQpIHtcbiAgICAgICAgZmFjZXRlZCA9ICEhZmFjZXRlZCAmJiB0aGlzLmZhY2V0KCk7XG4gICAgICAgIGRhdGEgPSBkYXRhIHx8IHRoaXMuX2RhdGE7XG4gICAgICAgIGlmICghZGF0YSB8fCAhZGF0YS5sZW5ndGgpIHJldHVybiBbXTtcblxuICAgICAgICBjb25zdCB4ID0gdGhpcy54KCksXG4gICAgICAgICAgICAgIHkgPSB0aGlzLnkoKSxcbiAgICAgICAgICAgICAgc2NhbGVYID0gdGhpcy5zY2FsZVgoKSxcbiAgICAgICAgICAgICAgc2NhbGVZID0gdGhpcy5zY2FsZVkoKTtcblxuICAgICAgICBsZXQgbWFwcGVkID0gW107XG5cbiAgICAgICAgZGF0YS5mb3JFYWNoKChkLGluZGV4KSA9PiB7XG4gICAgICAgICAgICBpZiAoZmFjZXRlZCAmJiAhdGhpcy5mYWNldCgpKGQpKSByZXR1cm47XG4gICAgICAgICAgICBjb25zdCB4VmFsID0gc2NhbGVYLnRyYW5zZm9ybSh4KGQpKTtcbiAgICAgICAgICAgIGNvbnN0IHlWYWwgPSBzY2FsZVkudHJhbnNmb3JtKHkoZCkpO1xuICAgICAgICAgICAgaWYgKHlWYWwgIT09IDApe1xuICAgICAgICAgICAgICAgIGNvbnN0IG9iamVjdCA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgICAgICAgICBfa2V5OiBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgX3g6IHhWYWwsXG4gICAgICAgICAgICAgICAgICAgIF95OiB5VmFsLFxuICAgICAgICAgICAgICAgICAgICBfY29sb3VyOiB4VmFsLFxuICAgICAgICAgICAgICAgICAgICBfc2l6ZTogdGhpcy5zaXplKCkoZClcbiAgICAgICAgICAgICAgICB9LCBkKTtcblxuICAgICAgICAgICAgICAgIGlmIChtYXBwZWRbaW5kZXhdKXtcbiAgICAgICAgICAgICAgICAgICAgbWFwcGVkW2luZGV4XS5kYXRhLnB1c2gob2JqZWN0KVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1hcHBlZC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9rZXk6IGluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgX3NpemU6IG9iamVjdC5fc2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jb2xvdXI6IG9iamVjdC5fY29sb3VyLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogW29iamVjdF1cbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBtYXBwZWRcbiAgICB9XG5cbiAgICBnZXREM1hTY2FsZShkYXRhLCB3aWR0aCkge1xuICAgICAgICBkYXRhID0gZGF0YSB8fCB0aGlzLnByZXBhcmVEYXRhKG51bGwsIHRydWUpLm1hcChkID0+IGQuZGF0YSkucmVkdWNlKChhY2MsIHZhbCkgPT4gYWNjLmNvbmNhdCh2YWwpLCBbXSk7XG4gICAgICAgIHdpZHRoID0gd2lkdGggfHwgdGhpcy53aWR0aCgpO1xuICAgICAgICByZXR1cm4gZDMuc2NhbGVCYW5kKClcbiAgICAgICAgICAgICAgICAgLnJhbmdlUm91bmQoWzAsIHdpZHRoXSlcbiAgICAgICAgICAgICAgICAgLmRvbWFpbihkYXRhLm1hcChkID0+IGQuX3gpKTtcbiAgICB9XG5cbiAgICBnZXREM1lTY2FsZShkYXRhLCBoZWlnaHQpIHtcbiAgICAgICAgZGF0YSA9IGRhdGEgfHwgdGhpcy5wcmVwYXJlRGF0YShudWxsLCBmYWxzZSk7XG4gICAgICAgIGhlaWdodCA9IGhlaWdodCB8fCB0aGlzLmhlaWdodCgpO1xuXG4gICAgICAgIGNvbnN0IG1heCA9IE1hdGgubWF4KGQzLm1heChkYXRhLCBkID0+IGQzLm1heChkLmRhdGEsIGQgPT4gZC5feSkpLCAwKTtcbiAgICAgICAgY29uc3QgbWluID0gTWF0aC5taW4oMCwgZDMubWluKGRhdGEsIGQgPT4gZDMubWluKGQuZGF0YSwgZCA9PiBkLl95KSkpO1xuICAgICAgICByZXR1cm4gZDMuc2NhbGVMaW5lYXIoKVxuICAgICAgICAgICAgICAgICAucmFuZ2VSb3VuZChbaGVpZ2h0LCAwXSlcbiAgICAgICAgICAgICAgICAgLm5pY2UoKVxuICAgICAgICAgICAgICAgICAuZG9tYWluKFttaW4sIG1heF0pO1xuICAgIH1cblxuICAgIGdldEQzQ29sb3VyKGRhdGEpIHtcbiAgICAgICAgbGV0IGNvbG91ciA9IEdlb21ldHJ5LnByb3RvdHlwZS5nZXREM0NvbG91ci5jYWxsKHRoaXMsIGRhdGEpO1xuICAgICAgICBpZiAodGhpcy5fdGludHMpIHtcbiAgICAgICAgICAgIGNvbG91ciA9IHRoaXMuX3RpbnRzW2RhdGEuX2tleV0gfHwgY29sb3VyXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbG91clxuICAgIH1cblxuICAgIGltbWVkaWF0ZWx5UmVuZGVyTGFiZWxzKHNob3cpe1xuICAgICAgICB0aGlzLnNob3dMYWJlbHMoISFzaG93KTtcbiAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG5cbiAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMucHJlcGFyZURhdGEobnVsbCwgdHJ1ZSkubWFwKGQgPT4gZC5kYXRhKS5yZWR1Y2UoKGFjYywgdmFsKSA9PiBhY2MuY29uY2F0KHZhbCksIFtdKTtcblxuICAgICAgICAvKlxuICAgICAgICBTZXQgdXAgZGltZW5zaW9uc1xuICAgICAgICAqL1xuICAgICAgICBsZXQgYXZhaWxhYmxlV2lkdGggPSB0aGlzLl93aWR0aDtcbiAgICAgICAgbGV0IGF2YWlsYWJsZUhlaWdodCA9IHRoaXMuX2hlaWdodDtcblxuICAgICAgICBsZXQgd2lkZXN0TGFiZWxXaWR0aCA9IDA7XG4gICAgICAgIGxldCBsYWJlbEhlaWdodCA9IDA7XG5cbiAgICAgICAgdGhpcy5fbWF4X2xhYmVsX3dpZHRoID0gYXZhaWxhYmxlV2lkdGggLyA0O1xuXG4gICAgICAgIGlmICh0aGlzLl91c2Vfb3V0c2lkZV9sYWJlbHMpe1xuICAgICAgICAgIHdpZGVzdExhYmVsV2lkdGggPSBNYXRoLm1pbih0aGlzLl9nZXRXaWR0aE9mV2lkZXN0TGFiZWwoKSwgdGhpcy5fbWF4X2xhYmVsX3dpZHRoKTtcbiAgICAgICAgICBsYWJlbEhlaWdodCA9IHRoaXMuX2dldExhYmVsSGVpZ2h0KCk7XG4gICAgICAgICAgYXZhaWxhYmxlV2lkdGggLT0gd2lkZXN0TGFiZWxXaWR0aCAqIDI7XG4gICAgICAgICAgYXZhaWxhYmxlSGVpZ2h0IC09IGxhYmVsSGVpZ2h0ICogMjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG1pbkRpbWVuc2lvbiA9IE1hdGgubWluKGF2YWlsYWJsZVdpZHRoLCBhdmFpbGFibGVIZWlnaHQpO1xuXG4gICAgICAgIC8qXG4gICAgICAgIFNldCB1cCBhcmNzXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuX2lubmVyX3JhZGl1cyA9IHRoaXMuX2lzX2RvbnV0ID8gbWluRGltZW5zaW9uIC8gNCA6IDA7XG4gICAgICAgIHRoaXMuX291dGVyX3JhZGl1cyA9IG1pbkRpbWVuc2lvbiAvIDI7XG5cbiAgICAgICAgdGhpcy5fb3V0ZXJfYXJjID0gZDMuYXJjKClcbiAgICAgICAgICAgIC5pbm5lclJhZGl1cyh0aGlzLl9vdXRlcl9yYWRpdXMgKyAxMClcbiAgICAgICAgICAgIC5vdXRlclJhZGl1cyh0aGlzLl9vdXRlcl9yYWRpdXMgKyAxMClcblxuICAgICAgICB0aGlzLl9hcmMgPSBkMy5hcmMoKVxuICAgICAgICAgICAgLmlubmVyUmFkaXVzKHRoaXMuX2lubmVyX3JhZGl1cylcbiAgICAgICAgICAgIC5vdXRlclJhZGl1cyh0aGlzLl9vdXRlcl9yYWRpdXMpO1xuXG4gICAgICAgIHRoaXMuX2xhYmVsX2FyYyA9IHRoaXMuX2lzX2RvbnV0XG4gICAgICAgICAgICA/IHRoaXMuX2FyY1xuICAgICAgICAgICAgOiBkMy5hcmMoKVxuICAgICAgICAgICAgICAgIC5pbm5lclJhZGl1cyhtaW5EaW1lbnNpb24gLyA1KVxuICAgICAgICAgICAgICAgIC5vdXRlclJhZGl1cyh0aGlzLl9vdXRlcl9yYWRpdXMpXG5cbiAgICAgICAgLypcbiAgICAgICAgICAgIFByZXAgdGludHMgaWYgbmVjZXNzYXJ5XG4gICAgICAgICovXG4gICAgICAgIGxldCBmaXJzdENvbG91cjtcbiAgICAgICAgbGV0IHVzZVRpbnRTaGlmdCA9IHRydWU7XG4gICAgICAgIC8vIGlmIHdlIGVuY291bnRlciBtb3JlIHRoYW4gb25lIGNvbG91cixcbiAgICAgICAgLy8gZG9uJ3QgdXNlIHRpbnQgc2hpZnRcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbG91ciA9IEdlb21ldHJ5LnByb3RvdHlwZS5nZXREM0NvbG91ci5jYWxsKHRoaXMsZGF0YVtpXSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGZpcnN0Q29sb3VyID09PSAndW5kZWZpbmVkJyl7XG4gICAgICAgICAgICAgICAgZmlyc3RDb2xvdXIgPSBjb2xvdXI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvbG91ciAhPT0gZmlyc3RDb2xvdXIpIHtcbiAgICAgICAgICAgICAgICB1c2VUaW50U2hpZnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHVzZVRpbnRTaGlmdCkge1xuICAgICAgICAgICAgY29uc3QgdGludHMgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IHNoaWZ0TGV2ZWxzID0gMzsgLy9pbiBib3RoIGRpcmVjdGlvbnNcbiAgICAgICAgICAgIGNvbnN0IGN5Y2xlTGVuZ3RoID0gc2hpZnRMZXZlbHMgKiA0O1xuXG4gICAgICAgICAgICBkYXRhLmZvckVhY2goKGQsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29sb3VyID0gR2VvbWV0cnkucHJvdG90eXBlLmdldEQzQ29sb3VyLmNhbGwodGhpcywgZCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2hpZnRGYWN0b3IgPSBNYXRoLmFicyggc2hpZnRMZXZlbHMgKiAyIC0gTWF0aC5hYnMoaW5kZXggLSBzaGlmdExldmVscykgJSBjeWNsZUxlbmd0aCkgLSBzaGlmdExldmVscztcbiAgICAgICAgICAgICAgICB0aW50cy5wdXNoKGQzLmhzbChjb2xvdXIpLmJyaWdodGVyKHNoaWZ0RmFjdG9yICogMC40KSk7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogdGVzdCBmb3IgYmxhY2sgYW5kIHdoaXRlXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogY29uc2lkZXIgemlnemFnIHBhbGV0dGUgd2l0aGluIGdpdmVuIGh1ZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIHRoaXMuX3RpbnRzID0gdGludHM7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzZWdtZW50cyA9IGQzLnBpZSgpLnZhbHVlKHRoaXMueSgpKShkYXRhKTtcblxuICAgICAgICB0aGlzLl9waWUgPSB0aGlzLl9hcHBlbmRJZkVtcHR5KHRoaXMuX2VsZW1lbnQsICdnJywgJ3BpZScpO1xuXG4gICAgICAgIHRoaXMuX3BpZS5hdHRyKFwidHJhbnNmb3JtXCIsICd0cmFuc2xhdGUoJyArIChhdmFpbGFibGVXaWR0aC8yICsgd2lkZXN0TGFiZWxXaWR0aCkgKyAnLCcgKyAobWluRGltZW5zaW9uLzIgKyBsYWJlbEhlaWdodCkgKyAnKScpXG5cbiAgICAgICAgdGhpcy5fcmVuZGVyU2VnbWVudHMoc2VnbWVudHMpXG5cbiAgICAgICAgdGhpcy5fcmVuZGVyU2VnbWVudExhYmVscyhzZWdtZW50cylcblxuICAgICAgICB0aGlzLl9pc19kb251dFxuICAgICAgICAgICAgPyB0aGlzLl9hZGRDZW50cmVMYWJlbCgpXG4gICAgICAgICAgICA6IHRoaXMuX2VsZW1lbnQuc2VsZWN0KCcuY2VudHJlLWxhYmVsJykucmVtb3ZlKCk7XG4gICAgfVxuXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwaWUoKSB7XG4gICAgcmV0dXJuIG5ldyBQaWUoKTtcbn0iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/chart/Pie.js\n")},"./src/chart/Points.js":
/*!*****************************!*\
  !*** ./src/chart/Points.js ***!
  \*****************************/
/*! exports provided: points */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "points", function() { return points; });\n/* harmony import */ var _Geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Geometry */ "./src/chart/Geometry.js");\n/* harmony import */ var _Colours__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Colours */ "./src/Colours.js");\n/* harmony import */ var _Legend__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Legend */ "./src/Legend.js");\n// Copyright (C) 2013-2014, 2018 BrandsEye (PTY) LTD\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this\n// software and associated documentation files (the "Software"), to deal in the Software\n// without restriction, including without limitation the rights to use, copy, modify,\n//     merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following\n// conditions:\n//\n//     The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n//     INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n// CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n\n\n\nclass Point extends _Geometry__WEBPACK_IMPORTED_MODULE_0__["Geometry"] {\n\n    constructor() {\n        super("POINT", 3);\n    }\n\n    render() {\n        const element = this._element;\n        const data = this.prepareData(null, true);\n        const width = this._width,\n              height = this._height;\n        const allData = this.prepareData(null, false).map(d => d.data).reduce((acc, val) => acc.concat(val));\n        const totalElements = data.map(d => d.data.length).reduce( (acc, val) => acc + val);\n\n        element.classed("points", true);\n        element.style("opacity", this._opacity === null ? 1.0 : this._opacity)\n\n        const x = this.getD3XScale(allData, width);\n        const y = this.getD3YScale(allData, height);\n        const sizeScale = this.getSizeScale(allData);\n\n        let groups = element.selectAll(\'.point-groups\');\n        groups = groups.data(data, d => d._key);\n\n        groups.exit().remove();\n\n        const transparentColour = d3.hcl(_Colours__WEBPACK_IMPORTED_MODULE_1__["colours"].eighteen.darkGrey);\n        transparentColour.opacity = 0.8;\n        const determineStroke = d => d3.hcl(this.getD3Colour(d)).c < 20 ? transparentColour : "none";\n\n        // Try to choose opacity of the points based on how much data there is,\n        // and how much space we have to display them. When they are overlapping (this is\n        // a heuristic to determine that), greater opacity helps to see clustering and distribution.\n        const diagonal = Math.sqrt(this.width() * this.width() + this.height() * this.height());\n        const defaultOpacity = Math.max(Math.min(0.9, diagonal / totalElements / 15), 0.5);\n\n        groups.enter()\n              .append("g")\n              .attr("class", d => "point-groups series series-" + Object(_Legend__WEBPACK_IMPORTED_MODULE_2__["toColourKey"])(d.data[0]._colour))\n              .merge(groups)\n              .each((d, i, nodes) => {\n                  const group = d3.select(nodes[i]);\n                  const points = group.selectAll(".point")\n                      .data(d.data, d => d._x);\n\n                  const isFirstRender = !group.property("renderedOnce");\n                  group.property("renderedOnce", true);\n\n                  points.interrupt("point:move")\n                      .transition("point:move")\n                      .duration(500)\n                          .attr("cy", d => y(d._y))\n                          .attr("cx", d => x(d._x) + x.bandwidth() / 2)\n                          .attr("r", d => sizeScale(Math.abs(d._size)))\n                          .style("stroke", determineStroke)\n                          .style("fill", d => this.getD3Colour(d));\n\n                  points.enter()\n                      .append("circle")\n                          .attr("class", "point")\n                          .style("opacity", 0)\n                          .attr("cx", d => x(d._x) + x.bandwidth() / 2)\n                          .attr("cy", y(0))\n                          .attr("r", 1)\n                          .style("fill", d => this.getD3Colour(d))\n                          .style("stroke", determineStroke)\n                          .style("cursor", "pointer")\n                      .merge(points)\n                      .on("contextmenu", () => d3.event.preventDefault()) // No right click.\n                      .on("mouseover", (d, i, nodes) => {\n                          this._dispatch.call("tooltipShow", this, {\n                              e: d3.event,\n                              point: d\n                          });\n\n                          const point = d3.select(nodes[i]);\n\n                          point.interrupt("point:grow")\n                              .transition("point:grow")\n                              .duration(250)\n                              .style("opacity", 1)\n                              .style("fill", d => d3.hcl(this.getD3Colour(d)).darker())\n                              .attr("r", d => sizeScale(Math.abs(d._size)) + 5);\n                      })\n                      .on("mouseout", (d, i, nodes) => {\n                          const point = d3.select(nodes[i]);\n\n                          point.interrupt("point:grow")\n                              .transition("point:grow")\n                              .duration(250)\n                              .style("opacity", defaultOpacity)\n                              .style("fill", d => this.getD3Colour(d))\n                              .attr("r", d => sizeScale(Math.abs(d._size)));\n                      })\n                      .on("click auxclick", d => {\n                          this._dispatch.call("elementClick", this, {\n                              e: d3.event,\n                              point: d\n                          })\n                      })\n                      .transition("point:grow")\n                      .duration(800)\n                      .delay(isFirstRender ? 0 : 500)\n                        .attr("cy", d => y(d._y))\n                        .style("opacity", defaultOpacity)\n                        .attr("r", d => sizeScale(Math.abs(d._size)));\n\n                  points.exit()\n                      .interrupt()\n                      .transition()\n                      .duration(800)\n                      .style("opacity", 0)\n                      .attr("cy", y(0))\n                      .on("end", (d, i, nodes) => d3.select(nodes[i]).remove());\n\n\n              });\n    }\n\n    getD3XScale(data, width) {\n        width = width || this.width();\n        data = data || this.prepareData()\n            .map(d => d.data)\n            .reduce((acc, val) => acc.concat(val));\n\n        return d3.scaleBand()\n            .rangeRound([0, width])\n            .domain(data.map(d => d._x));\n    }\n\n    getD3YScale(data, height) {\n        data = data || this.prepareData().map(d => d.data).reduce((acc, val) => acc.concat(val))\n        height = height || this.height();\n\n        let max = Math.max(d3.max(data, d => d._y), this._axis_max_value || 0)\n        let min = Math.min(this._axis_min_value || 0, d3.min(data, d => d._y))\n        return d3.scaleLinear().range([height, 0]).nice(5).domain([min, max])\n    }\n\n    getSizeScale(data) {\n        data = data || this.prepareData()\n            .map(d => d.data)\n            .reduce((acc, val) => acc.concat(val));\n\n        const min = d3.min(data, d => Math.abs(d._size));\n        const max = d3.max(data, d => Math.abs(d._size));\n\n        if (min === max) return () => 5;\n\n        let rangeMin = 5;\n        let rangeMax = 20;\n        const size = Math.min(this.width(), this.height());\n        if (size < 200) {\n            rangeMax = Math.max(8, size * 0.05);\n            rangeMin = Math.max(2, size * 0.025);\n        }\n\n        return d3.scaleLinear()\n            .range([rangeMin, rangeMax])\n            .domain([Math.min(0, min), Math.max(max, 0)]);\n    }\n}\n\n\nfunction points() {\n    return new Point();\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY2hhcnQvUG9pbnRzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYjNqcy8uL3NyYy9jaGFydC9Qb2ludHMuanM/Nzc0MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKEMpIDIwMTMtMjAxNCwgMjAxOCBCcmFuZHNFeWUgKFBUWSkgTFREXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZiB0aGlzXG4vLyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmVcbi8vIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSxcbi8vICAgICBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvXG4vLyBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZ1xuLy8gY29uZGl0aW9uczpcbi8vXG4vLyAgICAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4vLyBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vICAgICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SIElNUExJRUQsXG4vLyAgICAgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEFcbi8vIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFRcbi8vIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRlxuLy8gQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFXG4vLyBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IHsgR2VvbWV0cnkgfSBmcm9tICcuL0dlb21ldHJ5JztcbmltcG9ydCB7IGNvbG91cnMgfSBmcm9tIFwiLi4vQ29sb3Vyc1wiO1xuaW1wb3J0IHsgdG9Db2xvdXJLZXkgfSBmcm9tIFwiLi4vTGVnZW5kXCI7XG5cblxuY2xhc3MgUG9pbnQgZXh0ZW5kcyBHZW9tZXRyeSB7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoXCJQT0lOVFwiLCAzKTtcbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLl9lbGVtZW50O1xuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5wcmVwYXJlRGF0YShudWxsLCB0cnVlKTtcbiAgICAgICAgY29uc3Qgd2lkdGggPSB0aGlzLl93aWR0aCxcbiAgICAgICAgICAgICAgaGVpZ2h0ID0gdGhpcy5faGVpZ2h0O1xuICAgICAgICBjb25zdCBhbGxEYXRhID0gdGhpcy5wcmVwYXJlRGF0YShudWxsLCBmYWxzZSkubWFwKGQgPT4gZC5kYXRhKS5yZWR1Y2UoKGFjYywgdmFsKSA9PiBhY2MuY29uY2F0KHZhbCkpO1xuICAgICAgICBjb25zdCB0b3RhbEVsZW1lbnRzID0gZGF0YS5tYXAoZCA9PiBkLmRhdGEubGVuZ3RoKS5yZWR1Y2UoIChhY2MsIHZhbCkgPT4gYWNjICsgdmFsKTtcblxuICAgICAgICBlbGVtZW50LmNsYXNzZWQoXCJwb2ludHNcIiwgdHJ1ZSk7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUoXCJvcGFjaXR5XCIsIHRoaXMuX29wYWNpdHkgPT09IG51bGwgPyAxLjAgOiB0aGlzLl9vcGFjaXR5KVxuXG4gICAgICAgIGNvbnN0IHggPSB0aGlzLmdldEQzWFNjYWxlKGFsbERhdGEsIHdpZHRoKTtcbiAgICAgICAgY29uc3QgeSA9IHRoaXMuZ2V0RDNZU2NhbGUoYWxsRGF0YSwgaGVpZ2h0KTtcbiAgICAgICAgY29uc3Qgc2l6ZVNjYWxlID0gdGhpcy5nZXRTaXplU2NhbGUoYWxsRGF0YSk7XG5cbiAgICAgICAgbGV0IGdyb3VwcyA9IGVsZW1lbnQuc2VsZWN0QWxsKCcucG9pbnQtZ3JvdXBzJyk7XG4gICAgICAgIGdyb3VwcyA9IGdyb3Vwcy5kYXRhKGRhdGEsIGQgPT4gZC5fa2V5KTtcblxuICAgICAgICBncm91cHMuZXhpdCgpLnJlbW92ZSgpO1xuXG4gICAgICAgIGNvbnN0IHRyYW5zcGFyZW50Q29sb3VyID0gZDMuaGNsKGNvbG91cnMuZWlnaHRlZW4uZGFya0dyZXkpO1xuICAgICAgICB0cmFuc3BhcmVudENvbG91ci5vcGFjaXR5ID0gMC44O1xuICAgICAgICBjb25zdCBkZXRlcm1pbmVTdHJva2UgPSBkID0+IGQzLmhjbCh0aGlzLmdldEQzQ29sb3VyKGQpKS5jIDwgMjAgPyB0cmFuc3BhcmVudENvbG91ciA6IFwibm9uZVwiO1xuXG4gICAgICAgIC8vIFRyeSB0byBjaG9vc2Ugb3BhY2l0eSBvZiB0aGUgcG9pbnRzIGJhc2VkIG9uIGhvdyBtdWNoIGRhdGEgdGhlcmUgaXMsXG4gICAgICAgIC8vIGFuZCBob3cgbXVjaCBzcGFjZSB3ZSBoYXZlIHRvIGRpc3BsYXkgdGhlbS4gV2hlbiB0aGV5IGFyZSBvdmVybGFwcGluZyAodGhpcyBpc1xuICAgICAgICAvLyBhIGhldXJpc3RpYyB0byBkZXRlcm1pbmUgdGhhdCksIGdyZWF0ZXIgb3BhY2l0eSBoZWxwcyB0byBzZWUgY2x1c3RlcmluZyBhbmQgZGlzdHJpYnV0aW9uLlxuICAgICAgICBjb25zdCBkaWFnb25hbCA9IE1hdGguc3FydCh0aGlzLndpZHRoKCkgKiB0aGlzLndpZHRoKCkgKyB0aGlzLmhlaWdodCgpICogdGhpcy5oZWlnaHQoKSk7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRPcGFjaXR5ID0gTWF0aC5tYXgoTWF0aC5taW4oMC45LCBkaWFnb25hbCAvIHRvdGFsRWxlbWVudHMgLyAxNSksIDAuNSk7XG5cbiAgICAgICAgZ3JvdXBzLmVudGVyKClcbiAgICAgICAgICAgICAgLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBkID0+IFwicG9pbnQtZ3JvdXBzIHNlcmllcyBzZXJpZXMtXCIgKyB0b0NvbG91cktleShkLmRhdGFbMF0uX2NvbG91cikpXG4gICAgICAgICAgICAgIC5tZXJnZShncm91cHMpXG4gICAgICAgICAgICAgIC5lYWNoKChkLCBpLCBub2RlcykgPT4ge1xuICAgICAgICAgICAgICAgICAgY29uc3QgZ3JvdXAgPSBkMy5zZWxlY3Qobm9kZXNbaV0pO1xuICAgICAgICAgICAgICAgICAgY29uc3QgcG9pbnRzID0gZ3JvdXAuc2VsZWN0QWxsKFwiLnBvaW50XCIpXG4gICAgICAgICAgICAgICAgICAgICAgLmRhdGEoZC5kYXRhLCBkID0+IGQuX3gpO1xuXG4gICAgICAgICAgICAgICAgICBjb25zdCBpc0ZpcnN0UmVuZGVyID0gIWdyb3VwLnByb3BlcnR5KFwicmVuZGVyZWRPbmNlXCIpO1xuICAgICAgICAgICAgICAgICAgZ3JvdXAucHJvcGVydHkoXCJyZW5kZXJlZE9uY2VcIiwgdHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICAgIHBvaW50cy5pbnRlcnJ1cHQoXCJwb2ludDptb3ZlXCIpXG4gICAgICAgICAgICAgICAgICAgICAgLnRyYW5zaXRpb24oXCJwb2ludDptb3ZlXCIpXG4gICAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKDUwMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJjeVwiLCBkID0+IHkoZC5feSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiY3hcIiwgZCA9PiB4KGQuX3gpICsgeC5iYW5kd2lkdGgoKSAvIDIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiclwiLCBkID0+IHNpemVTY2FsZShNYXRoLmFicyhkLl9zaXplKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcInN0cm9rZVwiLCBkZXRlcm1pbmVTdHJva2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcImZpbGxcIiwgZCA9PiB0aGlzLmdldEQzQ29sb3VyKGQpKTtcblxuICAgICAgICAgICAgICAgICAgcG9pbnRzLmVudGVyKClcbiAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKFwiY2lyY2xlXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJwb2ludFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiY3hcIiwgZCA9PiB4KGQuX3gpICsgeC5iYW5kd2lkdGgoKSAvIDIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiY3lcIiwgeSgwKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJyXCIsIDEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcImZpbGxcIiwgZCA9PiB0aGlzLmdldEQzQ29sb3VyKGQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJzdHJva2VcIiwgZGV0ZXJtaW5lU3Ryb2tlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJjdXJzb3JcIiwgXCJwb2ludGVyXCIpXG4gICAgICAgICAgICAgICAgICAgICAgLm1lcmdlKHBvaW50cylcbiAgICAgICAgICAgICAgICAgICAgICAub24oXCJjb250ZXh0bWVudVwiLCAoKSA9PiBkMy5ldmVudC5wcmV2ZW50RGVmYXVsdCgpKSAvLyBObyByaWdodCBjbGljay5cbiAgICAgICAgICAgICAgICAgICAgICAub24oXCJtb3VzZW92ZXJcIiwgKGQsIGksIG5vZGVzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3BhdGNoLmNhbGwoXCJ0b29sdGlwU2hvd1wiLCB0aGlzLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlOiBkMy5ldmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50OiBkXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvaW50ID0gZDMuc2VsZWN0KG5vZGVzW2ldKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludC5pbnRlcnJ1cHQoXCJwb2ludDpncm93XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAudHJhbnNpdGlvbihcInBvaW50Omdyb3dcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbigyNTApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIGQgPT4gZDMuaGNsKHRoaXMuZ2V0RDNDb2xvdXIoZCkpLmRhcmtlcigpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJyXCIsIGQgPT4gc2l6ZVNjYWxlKE1hdGguYWJzKGQuX3NpemUpKSArIDUpO1xuICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgLm9uKFwibW91c2VvdXRcIiwgKGQsIGksIG5vZGVzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvaW50ID0gZDMuc2VsZWN0KG5vZGVzW2ldKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludC5pbnRlcnJ1cHQoXCJwb2ludDpncm93XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAudHJhbnNpdGlvbihcInBvaW50Omdyb3dcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbigyNTApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIGRlZmF1bHRPcGFjaXR5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBkID0+IHRoaXMuZ2V0RDNDb2xvdXIoZCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcInJcIiwgZCA9PiBzaXplU2NhbGUoTWF0aC5hYnMoZC5fc2l6ZSkpKTtcbiAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgIC5vbihcImNsaWNrIGF1eGNsaWNrXCIsIGQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXNwYXRjaC5jYWxsKFwiZWxlbWVudENsaWNrXCIsIHRoaXMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGU6IGQzLmV2ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQ6IGRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKFwicG9pbnQ6Z3Jvd1wiKVxuICAgICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbig4MDApXG4gICAgICAgICAgICAgICAgICAgICAgLmRlbGF5KGlzRmlyc3RSZW5kZXIgPyAwIDogNTAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJjeVwiLCBkID0+IHkoZC5feSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIGRlZmF1bHRPcGFjaXR5KVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJyXCIsIGQgPT4gc2l6ZVNjYWxlKE1hdGguYWJzKGQuX3NpemUpKSk7XG5cbiAgICAgICAgICAgICAgICAgIHBvaW50cy5leGl0KClcbiAgICAgICAgICAgICAgICAgICAgICAuaW50ZXJydXB0KClcbiAgICAgICAgICAgICAgICAgICAgICAudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKDgwMClcbiAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDApXG4gICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJjeVwiLCB5KDApKVxuICAgICAgICAgICAgICAgICAgICAgIC5vbihcImVuZFwiLCAoZCwgaSwgbm9kZXMpID0+IGQzLnNlbGVjdChub2Rlc1tpXSkucmVtb3ZlKCkpO1xuXG5cbiAgICAgICAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZ2V0RDNYU2NhbGUoZGF0YSwgd2lkdGgpIHtcbiAgICAgICAgd2lkdGggPSB3aWR0aCB8fCB0aGlzLndpZHRoKCk7XG4gICAgICAgIGRhdGEgPSBkYXRhIHx8IHRoaXMucHJlcGFyZURhdGEoKVxuICAgICAgICAgICAgLm1hcChkID0+IGQuZGF0YSlcbiAgICAgICAgICAgIC5yZWR1Y2UoKGFjYywgdmFsKSA9PiBhY2MuY29uY2F0KHZhbCkpO1xuXG4gICAgICAgIHJldHVybiBkMy5zY2FsZUJhbmQoKVxuICAgICAgICAgICAgLnJhbmdlUm91bmQoWzAsIHdpZHRoXSlcbiAgICAgICAgICAgIC5kb21haW4oZGF0YS5tYXAoZCA9PiBkLl94KSk7XG4gICAgfVxuXG4gICAgZ2V0RDNZU2NhbGUoZGF0YSwgaGVpZ2h0KSB7XG4gICAgICAgIGRhdGEgPSBkYXRhIHx8IHRoaXMucHJlcGFyZURhdGEoKS5tYXAoZCA9PiBkLmRhdGEpLnJlZHVjZSgoYWNjLCB2YWwpID0+IGFjYy5jb25jYXQodmFsKSlcbiAgICAgICAgaGVpZ2h0ID0gaGVpZ2h0IHx8IHRoaXMuaGVpZ2h0KCk7XG5cbiAgICAgICAgbGV0IG1heCA9IE1hdGgubWF4KGQzLm1heChkYXRhLCBkID0+IGQuX3kpLCB0aGlzLl9heGlzX21heF92YWx1ZSB8fCAwKVxuICAgICAgICBsZXQgbWluID0gTWF0aC5taW4odGhpcy5fYXhpc19taW5fdmFsdWUgfHwgMCwgZDMubWluKGRhdGEsIGQgPT4gZC5feSkpXG4gICAgICAgIHJldHVybiBkMy5zY2FsZUxpbmVhcigpLnJhbmdlKFtoZWlnaHQsIDBdKS5uaWNlKDUpLmRvbWFpbihbbWluLCBtYXhdKVxuICAgIH1cblxuICAgIGdldFNpemVTY2FsZShkYXRhKSB7XG4gICAgICAgIGRhdGEgPSBkYXRhIHx8IHRoaXMucHJlcGFyZURhdGEoKVxuICAgICAgICAgICAgLm1hcChkID0+IGQuZGF0YSlcbiAgICAgICAgICAgIC5yZWR1Y2UoKGFjYywgdmFsKSA9PiBhY2MuY29uY2F0KHZhbCkpO1xuXG4gICAgICAgIGNvbnN0IG1pbiA9IGQzLm1pbihkYXRhLCBkID0+IE1hdGguYWJzKGQuX3NpemUpKTtcbiAgICAgICAgY29uc3QgbWF4ID0gZDMubWF4KGRhdGEsIGQgPT4gTWF0aC5hYnMoZC5fc2l6ZSkpO1xuXG4gICAgICAgIGlmIChtaW4gPT09IG1heCkgcmV0dXJuICgpID0+IDU7XG5cbiAgICAgICAgbGV0IHJhbmdlTWluID0gNTtcbiAgICAgICAgbGV0IHJhbmdlTWF4ID0gMjA7XG4gICAgICAgIGNvbnN0IHNpemUgPSBNYXRoLm1pbih0aGlzLndpZHRoKCksIHRoaXMuaGVpZ2h0KCkpO1xuICAgICAgICBpZiAoc2l6ZSA8IDIwMCkge1xuICAgICAgICAgICAgcmFuZ2VNYXggPSBNYXRoLm1heCg4LCBzaXplICogMC4wNSk7XG4gICAgICAgICAgICByYW5nZU1pbiA9IE1hdGgubWF4KDIsIHNpemUgKiAwLjAyNSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZDMuc2NhbGVMaW5lYXIoKVxuICAgICAgICAgICAgLnJhbmdlKFtyYW5nZU1pbiwgcmFuZ2VNYXhdKVxuICAgICAgICAgICAgLmRvbWFpbihbTWF0aC5taW4oMCwgbWluKSwgTWF0aC5tYXgobWF4LCAwKV0pO1xuICAgIH1cbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gcG9pbnRzKCkge1xuICAgIHJldHVybiBuZXcgUG9pbnQoKTtcbn0iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/chart/Points.js\n')},"./src/chart/Scales.js":
/*!*****************************!*\
  !*** ./src/chart/Scales.js ***!
  \*****************************/
/*! exports provided: scaleTime, scaleIdentity, scaleDiscrete, chooseScale */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaleTime", function() { return scaleTime; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaleIdentity", function() { return scaleIdentity; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaleDiscrete", function() { return scaleDiscrete; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "chooseScale", function() { return chooseScale; });\n/* harmony import */ var _Bucket__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Bucket */ "./src/chart/Bucket.js");\n// Copyright (C) 2013-2014, 2018 BrandsEye (PTY) LTD\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this\n// software and associated documentation files (the "Software"), to deal in the Software\n// without restriction, including without limitation the rights to use, copy, modify,\n//     merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following\n// conditions:\n//\n//     The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n//     INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n// CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nclass Scale {\n    constructor() {\n        this.getCount = d => d._y;\n        this.setCount = (d, v) => d._y = v;\n    }\n\n    transform(val) {\n        return val;\n    }\n\n    setCountGetter(y) {\n        this.getCount = y;\n        return this;\n    }\n\n    setCountSetter(y) {\n        this.setCount = y;\n        return this;\n    }\n\n    isShowGrid() { return true };\n\n    isContinuous() { return !this.isDiscrete() };\n    isDiscrete() { throw new Error("Not implemented") };\n}\n\n\nclass ScaleTime extends Scale {\n    transform(val) {\n        if (val instanceof Date) return val;\n        if (typeof val !== \'string\') throw new Error("Value is not a string and cannot be converted to a date");\n        return new Date(val);\n    }\n\n    buckets(data) {\n        return new _Bucket__WEBPACK_IMPORTED_MODULE_0__["DateBucket"](data)\n            .setCountSetter(this.setCount)\n            .setCountGetter(this.getCount);\n    }\n\n    isShowGrid() { return false };\n    isDiscrete() { return true };\n}\n\nclass ScaleIdentity extends Scale  {\n    transform(val) {\n        return val;\n    }\n\n    buckets(data) {\n        return new _Bucket__WEBPACK_IMPORTED_MODULE_0__["ContinuousBucket"](data)\n            .setCountSetter(this.setCount)\n            .setCountGetter(this.getCount)\n    }\n\n    isShowGrid() { return true };\n    isDiscrete() { return false };\n}\n\nclass ScaleDiscrete extends Scale  {\n    transform(val) {\n        return val;\n    }\n\n    buckets(data) {\n        return new _Bucket__WEBPACK_IMPORTED_MODULE_0__["DiscreteBucket"](data)\n            .setCountSetter(this.setCount)\n            .setCountGetter(this.getCount)\n    }\n\n    isShowGrid() { return false };\n    isDiscrete() { return true };\n}\n\n\nfunction scaleTime() {\n    return new ScaleTime();\n}\n\nfunction scaleIdentity() {\n    return new ScaleIdentity();\n}\n\nfunction scaleDiscrete() {\n    return new ScaleDiscrete();\n}\n\nfunction chooseScale(exampleValue) {\n    if (Array.isArray(exampleValue)) {\n        const scales = new Set();\n        for (const example of exampleValue) {\n            scales.add(chooseScale(example).constructor);\n        }\n\n        if (scales.size === 0) {\n            throw new Error("Unable to determine scales");\n        }\n\n        if (scales.size === 1) {\n            return new (scales.values().next().value);\n        }\n\n        // There is a priority amongst the scale types.\n        let scale = null;\n        for (const s of scales) {\n            if (s === ScaleIdentity) scale = scaleIdentity();\n            else if (s === ScaleDiscrete) scale = scaleDiscrete();\n            else scale = scaleTime();\n        }\n\n        return scale;\n    }\n\n    if (exampleValue === undefined) throw new Error("No value provided for chooseScale");\n    try {\n        if (Date.parse(exampleValue)) return scaleTime();\n    } catch (e) {\n        // ignore - likely not a valid date\n    }\n    if (exampleValue instanceof Date) return scaleTime();\n    if (typeof exampleValue === \'string\') return scaleDiscrete();\n    if (typeof exampleValue === \'number\') return scaleIdentity();\n\n    throw new Error("Unable to determine wanted scale for example value [" + exampleValue + "]");\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY2hhcnQvU2NhbGVzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYjNqcy8uL3NyYy9jaGFydC9TY2FsZXMuanM/NjI4YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKEMpIDIwMTMtMjAxNCwgMjAxOCBCcmFuZHNFeWUgKFBUWSkgTFREXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZiB0aGlzXG4vLyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmVcbi8vIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSxcbi8vICAgICBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvXG4vLyBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZ1xuLy8gY29uZGl0aW9uczpcbi8vXG4vLyAgICAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4vLyBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vICAgICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SIElNUExJRUQsXG4vLyAgICAgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEFcbi8vIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFRcbi8vIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRlxuLy8gQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFXG4vLyBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IHtEYXRlQnVja2V0LCBDb250aW51b3VzQnVja2V0LCBEaXNjcmV0ZUJ1Y2tldH0gZnJvbSBcIi4vQnVja2V0XCI7XG5cbmNsYXNzIFNjYWxlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5nZXRDb3VudCA9IGQgPT4gZC5feTtcbiAgICAgICAgdGhpcy5zZXRDb3VudCA9IChkLCB2KSA9PiBkLl95ID0gdjtcbiAgICB9XG5cbiAgICB0cmFuc2Zvcm0odmFsKSB7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuXG4gICAgc2V0Q291bnRHZXR0ZXIoeSkge1xuICAgICAgICB0aGlzLmdldENvdW50ID0geTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgc2V0Q291bnRTZXR0ZXIoeSkge1xuICAgICAgICB0aGlzLnNldENvdW50ID0geTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaXNTaG93R3JpZCgpIHsgcmV0dXJuIHRydWUgfTtcblxuICAgIGlzQ29udGludW91cygpIHsgcmV0dXJuICF0aGlzLmlzRGlzY3JldGUoKSB9O1xuICAgIGlzRGlzY3JldGUoKSB7IHRocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZFwiKSB9O1xufVxuXG5cbmNsYXNzIFNjYWxlVGltZSBleHRlbmRzIFNjYWxlIHtcbiAgICB0cmFuc2Zvcm0odmFsKSB7XG4gICAgICAgIGlmICh2YWwgaW5zdGFuY2VvZiBEYXRlKSByZXR1cm4gdmFsO1xuICAgICAgICBpZiAodHlwZW9mIHZhbCAhPT0gJ3N0cmluZycpIHRocm93IG5ldyBFcnJvcihcIlZhbHVlIGlzIG5vdCBhIHN0cmluZyBhbmQgY2Fubm90IGJlIGNvbnZlcnRlZCB0byBhIGRhdGVcIik7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSh2YWwpO1xuICAgIH1cblxuICAgIGJ1Y2tldHMoZGF0YSkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGVCdWNrZXQoZGF0YSlcbiAgICAgICAgICAgIC5zZXRDb3VudFNldHRlcih0aGlzLnNldENvdW50KVxuICAgICAgICAgICAgLnNldENvdW50R2V0dGVyKHRoaXMuZ2V0Q291bnQpO1xuICAgIH1cblxuICAgIGlzU2hvd0dyaWQoKSB7IHJldHVybiBmYWxzZSB9O1xuICAgIGlzRGlzY3JldGUoKSB7IHJldHVybiB0cnVlIH07XG59XG5cbmNsYXNzIFNjYWxlSWRlbnRpdHkgZXh0ZW5kcyBTY2FsZSAge1xuICAgIHRyYW5zZm9ybSh2YWwpIHtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG5cbiAgICBidWNrZXRzKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb250aW51b3VzQnVja2V0KGRhdGEpXG4gICAgICAgICAgICAuc2V0Q291bnRTZXR0ZXIodGhpcy5zZXRDb3VudClcbiAgICAgICAgICAgIC5zZXRDb3VudEdldHRlcih0aGlzLmdldENvdW50KVxuICAgIH1cblxuICAgIGlzU2hvd0dyaWQoKSB7IHJldHVybiB0cnVlIH07XG4gICAgaXNEaXNjcmV0ZSgpIHsgcmV0dXJuIGZhbHNlIH07XG59XG5cbmNsYXNzIFNjYWxlRGlzY3JldGUgZXh0ZW5kcyBTY2FsZSAge1xuICAgIHRyYW5zZm9ybSh2YWwpIHtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG5cbiAgICBidWNrZXRzKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEaXNjcmV0ZUJ1Y2tldChkYXRhKVxuICAgICAgICAgICAgLnNldENvdW50U2V0dGVyKHRoaXMuc2V0Q291bnQpXG4gICAgICAgICAgICAuc2V0Q291bnRHZXR0ZXIodGhpcy5nZXRDb3VudClcbiAgICB9XG5cbiAgICBpc1Nob3dHcmlkKCkgeyByZXR1cm4gZmFsc2UgfTtcbiAgICBpc0Rpc2NyZXRlKCkgeyByZXR1cm4gdHJ1ZSB9O1xufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBzY2FsZVRpbWUoKSB7XG4gICAgcmV0dXJuIG5ldyBTY2FsZVRpbWUoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlSWRlbnRpdHkoKSB7XG4gICAgcmV0dXJuIG5ldyBTY2FsZUlkZW50aXR5KCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzY2FsZURpc2NyZXRlKCkge1xuICAgIHJldHVybiBuZXcgU2NhbGVEaXNjcmV0ZSgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2hvb3NlU2NhbGUoZXhhbXBsZVZhbHVlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZXhhbXBsZVZhbHVlKSkge1xuICAgICAgICBjb25zdCBzY2FsZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIGZvciAoY29uc3QgZXhhbXBsZSBvZiBleGFtcGxlVmFsdWUpIHtcbiAgICAgICAgICAgIHNjYWxlcy5hZGQoY2hvb3NlU2NhbGUoZXhhbXBsZSkuY29uc3RydWN0b3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNjYWxlcy5zaXplID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gZGV0ZXJtaW5lIHNjYWxlc1wiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzY2FsZXMuc2l6ZSA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyAoc2NhbGVzLnZhbHVlcygpLm5leHQoKS52YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGVyZSBpcyBhIHByaW9yaXR5IGFtb25nc3QgdGhlIHNjYWxlIHR5cGVzLlxuICAgICAgICBsZXQgc2NhbGUgPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IHMgb2Ygc2NhbGVzKSB7XG4gICAgICAgICAgICBpZiAocyA9PT0gU2NhbGVJZGVudGl0eSkgc2NhbGUgPSBzY2FsZUlkZW50aXR5KCk7XG4gICAgICAgICAgICBlbHNlIGlmIChzID09PSBTY2FsZURpc2NyZXRlKSBzY2FsZSA9IHNjYWxlRGlzY3JldGUoKTtcbiAgICAgICAgICAgIGVsc2Ugc2NhbGUgPSBzY2FsZVRpbWUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzY2FsZTtcbiAgICB9XG5cbiAgICBpZiAoZXhhbXBsZVZhbHVlID09PSB1bmRlZmluZWQpIHRocm93IG5ldyBFcnJvcihcIk5vIHZhbHVlIHByb3ZpZGVkIGZvciBjaG9vc2VTY2FsZVwiKTtcbiAgICB0cnkge1xuICAgICAgICBpZiAoRGF0ZS5wYXJzZShleGFtcGxlVmFsdWUpKSByZXR1cm4gc2NhbGVUaW1lKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBpZ25vcmUgLSBsaWtlbHkgbm90IGEgdmFsaWQgZGF0ZVxuICAgIH1cbiAgICBpZiAoZXhhbXBsZVZhbHVlIGluc3RhbmNlb2YgRGF0ZSkgcmV0dXJuIHNjYWxlVGltZSgpO1xuICAgIGlmICh0eXBlb2YgZXhhbXBsZVZhbHVlID09PSAnc3RyaW5nJykgcmV0dXJuIHNjYWxlRGlzY3JldGUoKTtcbiAgICBpZiAodHlwZW9mIGV4YW1wbGVWYWx1ZSA9PT0gJ251bWJlcicpIHJldHVybiBzY2FsZUlkZW50aXR5KCk7XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gZGV0ZXJtaW5lIHdhbnRlZCBzY2FsZSBmb3IgZXhhbXBsZSB2YWx1ZSBbXCIgKyBleGFtcGxlVmFsdWUgKyBcIl1cIik7XG59Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/chart/Scales.js\n')},"./src/helpers.js":
/*!************************!*\
  !*** ./src/helpers.js ***!
  \************************/
/*! exports provided: maxBounding, getBoundings, labelIsZero, equals */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "maxBounding", function() { return maxBounding; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBoundings", function() { return getBoundings; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "labelIsZero", function() { return labelIsZero; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });\n// Copyright (C) 2013-2014, 2018 BrandsEye (PTY) LTD\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this\n// software and associated documentation files (the "Software"), to deal in the Software\n// without restriction, including without limitation the rights to use, copy, modify,\n//     merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following\n// conditions:\n//\n//     The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n//     INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n// CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n/**\n * Given an array of text, this places things in the DOM to figure out how\n * much pixel space the text takes up.\n */\nfunction maxBounding(selection, text, font, fontSize) {\n    // font = font || "Open Sans, sans-serif";\n    // fontSize = fontSize || "12";\n\n    const boundings = getBoundings(selection, text, font, fontSize);\n\n    let width = 0;\n    let height = 0;\n\n    Object.values(boundings).forEach(bounding => {\n        if (bounding.width > width) width = bounding.width;\n        if (bounding.height > height) height = bounding.height;\n    });\n\n    return {\n        width: width,\n        height: height\n    }\n}\n\nfunction getBoundings(selection, text, font, fontSize) {\n    // font = font || "Open Sans, sans-serif";\n    // fontSize = fontSize || "12";\n\n    const boundings = {};\n    selection.append("g")\n             .attr("class", "text-size")\n             .style("opacity", 0)\n             .attr("transform", "translate(-100, -100)")\n             .selectAll(".text-measurement")\n             .data(text)\n             .enter()\n             .append("text")\n             .text(d => d)\n             .style("font-size", fontSize ? fontSize + "px" : null)\n             .each((d, i, nodes) => {\n                 const node = nodes[i];\n                 const bb = node.getBBox();\n                 boundings[d] = {\n                     width: bb.width,\n                     height: bb.height\n                 };\n             });\n\n    selection.select(".text-size").remove();\n    return boundings;\n}\n\n\n\n/** A test to whether a given data label is 0, or 0%. */\nfunction labelIsZero(label) {\n    label = "" + label;\n    return label === "0" || label === "0%" || label === "0.0%"\n}\n\nfunction equals(lhs, rhs) {\n    if (lhs instanceof Date && rhs instanceof Date) {\n        return lhs.getTime() === rhs.getTime();\n    }\n\n    return lhs === rhs;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaGVscGVycy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2IzanMvLi9zcmMvaGVscGVycy5qcz9kN2MyIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoQykgMjAxMy0yMDE0LCAyMDE4IEJyYW5kc0V5ZSAoUFRZKSBMVERcbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXNcbi8vIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZVxuLy8gd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LFxuLy8gICAgIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG9cbi8vIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nXG4vLyBjb25kaXRpb25zOlxuLy9cbi8vICAgICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbi8vIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gICAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1IgSU1QTElFRCxcbi8vICAgICBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQVxuLy8gUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxuLy8gSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GXG4vLyBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkVcbi8vIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5cbi8qKlxuICogR2l2ZW4gYW4gYXJyYXkgb2YgdGV4dCwgdGhpcyBwbGFjZXMgdGhpbmdzIGluIHRoZSBET00gdG8gZmlndXJlIG91dCBob3dcbiAqIG11Y2ggcGl4ZWwgc3BhY2UgdGhlIHRleHQgdGFrZXMgdXAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXhCb3VuZGluZyhzZWxlY3Rpb24sIHRleHQsIGZvbnQsIGZvbnRTaXplKSB7XG4gICAgLy8gZm9udCA9IGZvbnQgfHwgXCJPcGVuIFNhbnMsIHNhbnMtc2VyaWZcIjtcbiAgICAvLyBmb250U2l6ZSA9IGZvbnRTaXplIHx8IFwiMTJcIjtcblxuICAgIGNvbnN0IGJvdW5kaW5ncyA9IGdldEJvdW5kaW5ncyhzZWxlY3Rpb24sIHRleHQsIGZvbnQsIGZvbnRTaXplKTtcblxuICAgIGxldCB3aWR0aCA9IDA7XG4gICAgbGV0IGhlaWdodCA9IDA7XG5cbiAgICBPYmplY3QudmFsdWVzKGJvdW5kaW5ncykuZm9yRWFjaChib3VuZGluZyA9PiB7XG4gICAgICAgIGlmIChib3VuZGluZy53aWR0aCA+IHdpZHRoKSB3aWR0aCA9IGJvdW5kaW5nLndpZHRoO1xuICAgICAgICBpZiAoYm91bmRpbmcuaGVpZ2h0ID4gaGVpZ2h0KSBoZWlnaHQgPSBib3VuZGluZy5oZWlnaHQ7XG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Qm91bmRpbmdzKHNlbGVjdGlvbiwgdGV4dCwgZm9udCwgZm9udFNpemUpIHtcbiAgICAvLyBmb250ID0gZm9udCB8fCBcIk9wZW4gU2Fucywgc2Fucy1zZXJpZlwiO1xuICAgIC8vIGZvbnRTaXplID0gZm9udFNpemUgfHwgXCIxMlwiO1xuXG4gICAgY29uc3QgYm91bmRpbmdzID0ge307XG4gICAgc2VsZWN0aW9uLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwidGV4dC1zaXplXCIpXG4gICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAwKVxuICAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKC0xMDAsIC0xMDApXCIpXG4gICAgICAgICAgICAgLnNlbGVjdEFsbChcIi50ZXh0LW1lYXN1cmVtZW50XCIpXG4gICAgICAgICAgICAgLmRhdGEodGV4dClcbiAgICAgICAgICAgICAuZW50ZXIoKVxuICAgICAgICAgICAgIC5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgICAgICAgICAgLnRleHQoZCA9PiBkKVxuICAgICAgICAgICAgIC5zdHlsZShcImZvbnQtc2l6ZVwiLCBmb250U2l6ZSA/IGZvbnRTaXplICsgXCJweFwiIDogbnVsbClcbiAgICAgICAgICAgICAuZWFjaCgoZCwgaSwgbm9kZXMpID0+IHtcbiAgICAgICAgICAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICAgICAgICAgICBjb25zdCBiYiA9IG5vZGUuZ2V0QkJveCgpO1xuICAgICAgICAgICAgICAgICBib3VuZGluZ3NbZF0gPSB7XG4gICAgICAgICAgICAgICAgICAgICB3aWR0aDogYmIud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGJiLmhlaWdodFxuICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgIH0pO1xuXG4gICAgc2VsZWN0aW9uLnNlbGVjdChcIi50ZXh0LXNpemVcIikucmVtb3ZlKCk7XG4gICAgcmV0dXJuIGJvdW5kaW5ncztcbn1cblxuXG5cbi8qKiBBIHRlc3QgdG8gd2hldGhlciBhIGdpdmVuIGRhdGEgbGFiZWwgaXMgMCwgb3IgMCUuICovXG5leHBvcnQgZnVuY3Rpb24gbGFiZWxJc1plcm8obGFiZWwpIHtcbiAgICBsYWJlbCA9IFwiXCIgKyBsYWJlbDtcbiAgICByZXR1cm4gbGFiZWwgPT09IFwiMFwiIHx8IGxhYmVsID09PSBcIjAlXCIgfHwgbGFiZWwgPT09IFwiMC4wJVwiXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbHMobGhzLCByaHMpIHtcbiAgICBpZiAobGhzIGluc3RhbmNlb2YgRGF0ZSAmJiByaHMgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIHJldHVybiBsaHMuZ2V0VGltZSgpID09PSByaHMuZ2V0VGltZSgpO1xuICAgIH1cblxuICAgIHJldHVybiBsaHMgPT09IHJocztcbn0iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/helpers.js\n')},"./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! exports provided: ColumnChart, BarChart, PieChart, LineChart, colours, chart, histogram, columnChart, barChart, line, pie, points, scaleTime, scaleIdentity, scaleDiscrete, chooseScale */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _ColumnChart__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ColumnChart */ "./src/ColumnChart.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ColumnChart", function() { return _ColumnChart__WEBPACK_IMPORTED_MODULE_0__["ColumnChart"]; });\n\n/* harmony import */ var _BarChart__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BarChart */ "./src/BarChart.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BarChart", function() { return _BarChart__WEBPACK_IMPORTED_MODULE_1__["BarChart"]; });\n\n/* harmony import */ var _PieChart__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./PieChart */ "./src/PieChart.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PieChart", function() { return _PieChart__WEBPACK_IMPORTED_MODULE_2__["PieChart"]; });\n\n/* harmony import */ var _LineChart__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./LineChart */ "./src/LineChart.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LineChart", function() { return _LineChart__WEBPACK_IMPORTED_MODULE_3__["LineChart"]; });\n\n/* harmony import */ var _Colours__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Colours */ "./src/Colours.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "colours", function() { return _Colours__WEBPACK_IMPORTED_MODULE_4__["colours"]; });\n\n/* harmony import */ var _chart_FantasticChart__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./chart/FantasticChart */ "./src/chart/FantasticChart.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "chart", function() { return _chart_FantasticChart__WEBPACK_IMPORTED_MODULE_5__["chart"]; });\n\n/* harmony import */ var _chart_Histogram__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./chart/Histogram */ "./src/chart/Histogram.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "histogram", function() { return _chart_Histogram__WEBPACK_IMPORTED_MODULE_6__["histogram"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "columnChart", function() { return _chart_Histogram__WEBPACK_IMPORTED_MODULE_6__["columnChart"]; });\n\n/* harmony import */ var _chart_BarChart__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./chart/BarChart */ "./src/chart/BarChart.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "barChart", function() { return _chart_BarChart__WEBPACK_IMPORTED_MODULE_7__["barChart"]; });\n\n/* harmony import */ var _chart_Line__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./chart/Line */ "./src/chart/Line.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "line", function() { return _chart_Line__WEBPACK_IMPORTED_MODULE_8__["line"]; });\n\n/* harmony import */ var _chart_Pie__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./chart/Pie */ "./src/chart/Pie.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pie", function() { return _chart_Pie__WEBPACK_IMPORTED_MODULE_9__["pie"]; });\n\n/* harmony import */ var _chart_Points__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./chart/Points */ "./src/chart/Points.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "points", function() { return _chart_Points__WEBPACK_IMPORTED_MODULE_10__["points"]; });\n\n/* harmony import */ var _chart_Scales__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./chart/Scales */ "./src/chart/Scales.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleTime", function() { return _chart_Scales__WEBPACK_IMPORTED_MODULE_11__["scaleTime"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleIdentity", function() { return _chart_Scales__WEBPACK_IMPORTED_MODULE_11__["scaleIdentity"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleDiscrete", function() { return _chart_Scales__WEBPACK_IMPORTED_MODULE_11__["scaleDiscrete"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "chooseScale", function() { return _chart_Scales__WEBPACK_IMPORTED_MODULE_11__["chooseScale"]; });\n\n// Copyright (C) 2013-2014, 2018 BrandsEye (PTY) LTD\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this\n// software and associated documentation files (the "Software"), to deal in the Software\n// without restriction, including without limitation the rights to use, copy, modify,\n//     merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following\n// conditions:\n//\n//     The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n//     INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n// CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n\n\n\n\n// For the Fantastic Chart\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9iM2pzLy4vc3JjL2luZGV4LmpzP2I2MzUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChDKSAyMDEzLTIwMTQsIDIwMTggQnJhbmRzRXllIChQVFkpIExURFxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpc1xuLy8gc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlXG4vLyB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksXG4vLyAgICAgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0b1xuLy8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcbi8vIGNvbmRpdGlvbnM6XG4vL1xuLy8gICAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuLy8gY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyAgICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUiBJTVBMSUVELFxuLy8gICAgIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBXG4vLyBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUXG4vLyBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0Zcbi8vIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRVxuLy8gT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbmV4cG9ydCB7IENvbHVtbkNoYXJ0IGFzIENvbHVtbkNoYXJ0IH0gZnJvbSAnLi9Db2x1bW5DaGFydCc7XG5leHBvcnQgeyBCYXJDaGFydCBhcyBCYXJDaGFydCB9IGZyb20gJy4vQmFyQ2hhcnQnO1xuZXhwb3J0IHsgUGllQ2hhcnQgYXMgUGllQ2hhcnQgfSBmcm9tICcuL1BpZUNoYXJ0JztcbmV4cG9ydCB7IExpbmVDaGFydCBhcyBMaW5lQ2hhcnQgfSBmcm9tICcuL0xpbmVDaGFydCc7XG5leHBvcnQgeyBjb2xvdXJzIH0gZnJvbSAnLi9Db2xvdXJzJztcblxuLy8gRm9yIHRoZSBGYW50YXN0aWMgQ2hhcnRcbmV4cG9ydCB7IGNoYXJ0IH0gZnJvbSAnLi9jaGFydC9GYW50YXN0aWNDaGFydCc7XG5leHBvcnQgeyBoaXN0b2dyYW0sIGNvbHVtbkNoYXJ0IH0gZnJvbSAnLi9jaGFydC9IaXN0b2dyYW0nO1xuZXhwb3J0IHsgYmFyQ2hhcnQgfSBmcm9tICcuL2NoYXJ0L0JhckNoYXJ0JztcbmV4cG9ydCB7IGxpbmUgfSBmcm9tICcuL2NoYXJ0L0xpbmUnO1xuZXhwb3J0IHsgcGllIH0gZnJvbSAnLi9jaGFydC9QaWUnO1xuZXhwb3J0IHsgcG9pbnRzIH0gZnJvbSAnLi9jaGFydC9Qb2ludHMnO1xuZXhwb3J0IHsgc2NhbGVUaW1lLCBzY2FsZUlkZW50aXR5LCBzY2FsZURpc2NyZXRlLCBjaG9vc2VTY2FsZSB9IGZyb20gJy4vY2hhcnQvU2NhbGVzJzsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/index.js\n')}});