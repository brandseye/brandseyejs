var b3js=function(C){var A={};function t(I){if(A[I])return A[I].exports;var g=A[I]={i:I,l:!1,exports:{}};return C[I].call(g.exports,g,g.exports,t),g.l=!0,g.exports}return t.m=C,t.c=A,t.d=function(I,g,C){t.o(I,g)||Object.defineProperty(I,g,{enumerable:!0,get:C})},t.r=function(I){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(I,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(I,"__esModule",{value:!0})},t.t=function(g,I){if(1&I&&(g=t(g)),8&I)return g;if(4&I&&"object"==typeof g&&g&&g.__esModule)return g;var C=Object.create(null);if(t.r(C),Object.defineProperty(C,"default",{enumerable:!0,value:g}),2&I&&"string"!=typeof g)for(var A in g)t.d(C,A,function(I){return g[I]}.bind(null,A));return C},t.n=function(I){var g=I&&I.__esModule?function(){return I.default}:function(){return I};return t.d(g,"a",g),g},t.o=function(I,g){return Object.prototype.hasOwnProperty.call(I,g)},t.p="",t(t.s="./src/index.js")}({"./node_modules/compute-iqr/lib/index.js":
/*!***********************************************!*\
  !*** ./node_modules/compute-iqr/lib/index.js ***!
  \***********************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("/**\n*\n*\tCOMPUTE: iqr\n*\n*\n*\tDESCRIPTION:\n*\t\t- Computes the interquartile range for an array of values.\n*\n*\n*\tNOTES:\n*\t\t[1]\n*\n*\n*\tTODO:\n*\t\t[1]\n*\n*\n*\tLICENSE:\n*\t\tMIT\n*\n*\tCopyright (c) 2014. Athan Reines.\n*\n*\n*\tAUTHOR:\n*\t\tAthan Reines. kgryte@gmail.com. 2014.\n*\n*/\n\n\n\n// MODULES //\n\nvar isObject = __webpack_require__( /*! validate.io-object */ \"./node_modules/validate.io-object/lib/index.js\" ),\n\tquantile = __webpack_require__( /*! compute-quantile */ \"./node_modules/compute-quantile/lib/index.js\" );\n\n\n// FUNCTIONS //\n\n/**\n* FUNCTION: ascending( a, b )\n*\tComparator function used to sort values in ascending order.\n*\n* @private\n* @param {Number} a\n* @param {Number} b\n* @returns {Number} difference between `a` and `b`\n*/\nfunction ascending( a, b ) {\n\treturn a - b;\n} // end FUNCTION ascending()\n\n\n// INTERQUARTILE RANGE //\n\n/**\n* FUNCTION: iqr( arr )\n*\tComputes the interquartile range for an array.\n*\n* @param {Array} arr - array of values\n* @returns {Number} interquartile range\n*/\nfunction iqr( arr, opts ) {\n\tif ( !Array.isArray( arr ) ) {\n\t\tthrow new TypeError( 'iqr()::invalid input argument. Must provide an array.' );\n\t}\n\tif ( arguments.length > 1 ) {\n\t\tif ( !isObject( opts ) ) {\n\t\t\tthrow new TypeError( 'iqr()::invalid input argument. Options should be an object.' );\n\t\t}\n\t} else {\n\t\topts = {\n\t\t\t'sorted': false\n\t\t};\n\t}\n\tif ( !opts.sorted ) {\n\t\tarr = arr.slice();\n\t\tarr.sort( ascending );\n\t\topts.sorted = true;\n\t}\n\treturn quantile( arr, 0.75, opts ) - quantile( arr, 0.25, opts );\n} // end FUNCTION iqr()\n\n\n// EXPORTS //\n\nmodule.exports = iqr;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY29tcHV0ZS1pcXIvbGliL2luZGV4LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYjNqcy8uL25vZGVfbW9kdWxlcy9jb21wdXRlLWlxci9saWIvaW5kZXguanM/MDBhOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbipcbipcdENPTVBVVEU6IGlxclxuKlxuKlxuKlx0REVTQ1JJUFRJT046XG4qXHRcdC0gQ29tcHV0ZXMgdGhlIGludGVycXVhcnRpbGUgcmFuZ2UgZm9yIGFuIGFycmF5IG9mIHZhbHVlcy5cbipcbipcbipcdE5PVEVTOlxuKlx0XHRbMV1cbipcbipcbipcdFRPRE86XG4qXHRcdFsxXVxuKlxuKlxuKlx0TElDRU5TRTpcbipcdFx0TUlUXG4qXG4qXHRDb3B5cmlnaHQgKGMpIDIwMTQuIEF0aGFuIFJlaW5lcy5cbipcbipcbipcdEFVVEhPUjpcbipcdFx0QXRoYW4gUmVpbmVzLiBrZ3J5dGVAZ21haWwuY29tLiAyMDE0LlxuKlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBpc09iamVjdCA9IHJlcXVpcmUoICd2YWxpZGF0ZS5pby1vYmplY3QnICksXG5cdHF1YW50aWxlID0gcmVxdWlyZSggJ2NvbXB1dGUtcXVhbnRpbGUnICk7XG5cblxuLy8gRlVOQ1RJT05TIC8vXG5cbi8qKlxuKiBGVU5DVElPTjogYXNjZW5kaW5nKCBhLCBiIClcbipcdENvbXBhcmF0b3IgZnVuY3Rpb24gdXNlZCB0byBzb3J0IHZhbHVlcyBpbiBhc2NlbmRpbmcgb3JkZXIuXG4qXG4qIEBwcml2YXRlXG4qIEBwYXJhbSB7TnVtYmVyfSBhXG4qIEBwYXJhbSB7TnVtYmVyfSBiXG4qIEByZXR1cm5zIHtOdW1iZXJ9IGRpZmZlcmVuY2UgYmV0d2VlbiBgYWAgYW5kIGBiYFxuKi9cbmZ1bmN0aW9uIGFzY2VuZGluZyggYSwgYiApIHtcblx0cmV0dXJuIGEgLSBiO1xufSAvLyBlbmQgRlVOQ1RJT04gYXNjZW5kaW5nKClcblxuXG4vLyBJTlRFUlFVQVJUSUxFIFJBTkdFIC8vXG5cbi8qKlxuKiBGVU5DVElPTjogaXFyKCBhcnIgKVxuKlx0Q29tcHV0ZXMgdGhlIGludGVycXVhcnRpbGUgcmFuZ2UgZm9yIGFuIGFycmF5LlxuKlxuKiBAcGFyYW0ge0FycmF5fSBhcnIgLSBhcnJheSBvZiB2YWx1ZXNcbiogQHJldHVybnMge051bWJlcn0gaW50ZXJxdWFydGlsZSByYW5nZVxuKi9cbmZ1bmN0aW9uIGlxciggYXJyLCBvcHRzICkge1xuXHRpZiAoICFBcnJheS5pc0FycmF5KCBhcnIgKSApIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCAnaXFyKCk6OmludmFsaWQgaW5wdXQgYXJndW1lbnQuIE11c3QgcHJvdmlkZSBhbiBhcnJheS4nICk7XG5cdH1cblx0aWYgKCBhcmd1bWVudHMubGVuZ3RoID4gMSApIHtcblx0XHRpZiAoICFpc09iamVjdCggb3B0cyApICkge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvciggJ2lxcigpOjppbnZhbGlkIGlucHV0IGFyZ3VtZW50LiBPcHRpb25zIHNob3VsZCBiZSBhbiBvYmplY3QuJyApO1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRvcHRzID0ge1xuXHRcdFx0J3NvcnRlZCc6IGZhbHNlXG5cdFx0fTtcblx0fVxuXHRpZiAoICFvcHRzLnNvcnRlZCApIHtcblx0XHRhcnIgPSBhcnIuc2xpY2UoKTtcblx0XHRhcnIuc29ydCggYXNjZW5kaW5nICk7XG5cdFx0b3B0cy5zb3J0ZWQgPSB0cnVlO1xuXHR9XG5cdHJldHVybiBxdWFudGlsZSggYXJyLCAwLjc1LCBvcHRzICkgLSBxdWFudGlsZSggYXJyLCAwLjI1LCBvcHRzICk7XG59IC8vIGVuZCBGVU5DVElPTiBpcXIoKVxuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBpcXI7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/compute-iqr/lib/index.js\n")},"./node_modules/compute-quantile/lib/index.js":
/*!****************************************************!*\
  !*** ./node_modules/compute-quantile/lib/index.js ***!
  \****************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("/**\n*\n*\tCOMPUTE: quantile\n*\n*\n*\tDESCRIPTION:\n*\t\t- Computes a quantile for a numeric array.\n*\n*\n*\tNOTES:\n*\t\t[1]\n*\n*\n*\tTODO:\n*\t\t[1]\n*\n*\n*\tLICENSE:\n*\t\tMIT\n*\n*\tCopyright (c) 2014. Athan Reines.\n*\n*\n*\tAUTHOR:\n*\t\tAthan Reines. kgryte@gmail.com. 2014.\n*\n*/\n\n\n\n// MODULES //\n\nvar isObject = __webpack_require__( /*! validate.io-object */ \"./node_modules/validate.io-object/lib/index.js\" );\n\n\n// FUNCTIONS //\n\n/**\n* FUNCTION: ascending( a, b )\n*\tComparator function used to sort values in ascending order.\n*\n* @private\n* @param {Number} a\n* @param {Number} b\n* @returns {Number} difference between `a` and `b`\n*/\nfunction ascending( a, b ) {\n\treturn a - b;\n} // end FUNCTION ascending()\n\n\n// QUANTILE //\n\n/**\n* FUNCTION: quantile( arr, prob[, opts] )\n*\tComputes a quantile for a numeric array.\n*\n* @private\n* @param {Array} arr - 1d array\n* @param {Number} prob - quantile prob [0,1]\n* @param {Object} [opts] - method options:\n\t`method`: method used to interpolate a quantile value\n\t`sorted`: boolean flag indicating if the input array is sorted\n* @returns {Number} quantile value\n*/\nfunction quantile( arr, p, opts ) {\n\tif ( !Array.isArray( arr ) ) {\n\t\tthrow new TypeError( 'quantile()::invalid input argument. First argument must be an array.' );\n\t}\n\tif ( typeof p !== 'number' || p !== p ) {\n\t\tthrow new TypeError( 'quantile()::invalid input argument. Quantile probability must be numeric.' );\n\t}\n\tif ( p < 0 || p > 1 ) {\n\t\tthrow new TypeError( 'quantile()::invalid input argument. Quantile probability must be on the interval [0,1].' );\n\t}\n\tif ( arguments.length > 2 ) {\n\t\tif ( !isObject( opts ) ) {\n\t\t\tthrow new TypeError( 'quantile()::invalid input argument. Options must be an object.' );\n\t\t}\n\t\tif ( opts.hasOwnProperty( 'sorted' ) && typeof opts.sorted !== 'boolean' ) {\n\t\t\tthrow new TypeError( 'quantile()::invalid input argument. Sorted flag must be a boolean.' );\n\t\t}\n\t\tif ( opts.hasOwnProperty( 'method' ) && typeof opts.method !== 'string' ) {\n\t\t\tthrow new TypeError( 'quantile()::invalid input argument. Method must be a string.' );\n\t\t}\n\t\t// TODO: validate that the requested method is supported. list.indexOf( method )\n\t} else {\n\t\topts = {};\n\t}\n\tvar len = arr.length,\n\t\tid;\n\n\tif ( !opts.sorted ) {\n\t\tarr = arr.slice();\n\t\tarr.sort( ascending );\n\t}\n\n\t// Cases...\n\n\t// [0] 0th percentile is the minimum value...\n\tif ( p === 0.0 ) {\n\t\treturn arr[ 0 ];\n\t}\n\t// [1] 100th percentile is the maximum value...\n\tif ( p === 1.0 ) {\n\t\treturn arr[ len-1 ];\n\t}\n\t// Calculate the vector index marking the quantile:\n\tid = ( len*p ) - 1;\n\n\t// [2] Is the index an integer?\n\tif ( id === Math.floor( id ) ) {\n\t\t// Value is the average between the value at id and id+1:\n\t\treturn ( arr[ id ] + arr[ id+1 ] ) / 2.0;\n\t}\n\t// [3] Round up to the next index:\n\tid = Math.ceil( id );\n\treturn arr[ id ];\n} // end FUNCTION quantile()\n\n\n// EXPORTS //\n\nmodule.exports = quantile;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY29tcHV0ZS1xdWFudGlsZS9saWIvaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9iM2pzLy4vbm9kZV9tb2R1bGVzL2NvbXB1dGUtcXVhbnRpbGUvbGliL2luZGV4LmpzP2FhZjciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4qXG4qXHRDT01QVVRFOiBxdWFudGlsZVxuKlxuKlxuKlx0REVTQ1JJUFRJT046XG4qXHRcdC0gQ29tcHV0ZXMgYSBxdWFudGlsZSBmb3IgYSBudW1lcmljIGFycmF5LlxuKlxuKlxuKlx0Tk9URVM6XG4qXHRcdFsxXVxuKlxuKlxuKlx0VE9ETzpcbipcdFx0WzFdXG4qXG4qXG4qXHRMSUNFTlNFOlxuKlx0XHRNSVRcbipcbipcdENvcHlyaWdodCAoYykgMjAxNC4gQXRoYW4gUmVpbmVzLlxuKlxuKlxuKlx0QVVUSE9SOlxuKlx0XHRBdGhhbiBSZWluZXMuIGtncnl0ZUBnbWFpbC5jb20uIDIwMTQuXG4qXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSggJ3ZhbGlkYXRlLmlvLW9iamVjdCcgKTtcblxuXG4vLyBGVU5DVElPTlMgLy9cblxuLyoqXG4qIEZVTkNUSU9OOiBhc2NlbmRpbmcoIGEsIGIgKVxuKlx0Q29tcGFyYXRvciBmdW5jdGlvbiB1c2VkIHRvIHNvcnQgdmFsdWVzIGluIGFzY2VuZGluZyBvcmRlci5cbipcbiogQHByaXZhdGVcbiogQHBhcmFtIHtOdW1iZXJ9IGFcbiogQHBhcmFtIHtOdW1iZXJ9IGJcbiogQHJldHVybnMge051bWJlcn0gZGlmZmVyZW5jZSBiZXR3ZWVuIGBhYCBhbmQgYGJgXG4qL1xuZnVuY3Rpb24gYXNjZW5kaW5nKCBhLCBiICkge1xuXHRyZXR1cm4gYSAtIGI7XG59IC8vIGVuZCBGVU5DVElPTiBhc2NlbmRpbmcoKVxuXG5cbi8vIFFVQU5USUxFIC8vXG5cbi8qKlxuKiBGVU5DVElPTjogcXVhbnRpbGUoIGFyciwgcHJvYlssIG9wdHNdIClcbipcdENvbXB1dGVzIGEgcXVhbnRpbGUgZm9yIGEgbnVtZXJpYyBhcnJheS5cbipcbiogQHByaXZhdGVcbiogQHBhcmFtIHtBcnJheX0gYXJyIC0gMWQgYXJyYXlcbiogQHBhcmFtIHtOdW1iZXJ9IHByb2IgLSBxdWFudGlsZSBwcm9iIFswLDFdXG4qIEBwYXJhbSB7T2JqZWN0fSBbb3B0c10gLSBtZXRob2Qgb3B0aW9uczpcblx0YG1ldGhvZGA6IG1ldGhvZCB1c2VkIHRvIGludGVycG9sYXRlIGEgcXVhbnRpbGUgdmFsdWVcblx0YHNvcnRlZGA6IGJvb2xlYW4gZmxhZyBpbmRpY2F0aW5nIGlmIHRoZSBpbnB1dCBhcnJheSBpcyBzb3J0ZWRcbiogQHJldHVybnMge051bWJlcn0gcXVhbnRpbGUgdmFsdWVcbiovXG5mdW5jdGlvbiBxdWFudGlsZSggYXJyLCBwLCBvcHRzICkge1xuXHRpZiAoICFBcnJheS5pc0FycmF5KCBhcnIgKSApIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCAncXVhbnRpbGUoKTo6aW52YWxpZCBpbnB1dCBhcmd1bWVudC4gRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhbiBhcnJheS4nICk7XG5cdH1cblx0aWYgKCB0eXBlb2YgcCAhPT0gJ251bWJlcicgfHwgcCAhPT0gcCApIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCAncXVhbnRpbGUoKTo6aW52YWxpZCBpbnB1dCBhcmd1bWVudC4gUXVhbnRpbGUgcHJvYmFiaWxpdHkgbXVzdCBiZSBudW1lcmljLicgKTtcblx0fVxuXHRpZiAoIHAgPCAwIHx8IHAgPiAxICkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoICdxdWFudGlsZSgpOjppbnZhbGlkIGlucHV0IGFyZ3VtZW50LiBRdWFudGlsZSBwcm9iYWJpbGl0eSBtdXN0IGJlIG9uIHRoZSBpbnRlcnZhbCBbMCwxXS4nICk7XG5cdH1cblx0aWYgKCBhcmd1bWVudHMubGVuZ3RoID4gMiApIHtcblx0XHRpZiAoICFpc09iamVjdCggb3B0cyApICkge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvciggJ3F1YW50aWxlKCk6OmludmFsaWQgaW5wdXQgYXJndW1lbnQuIE9wdGlvbnMgbXVzdCBiZSBhbiBvYmplY3QuJyApO1xuXHRcdH1cblx0XHRpZiAoIG9wdHMuaGFzT3duUHJvcGVydHkoICdzb3J0ZWQnICkgJiYgdHlwZW9mIG9wdHMuc29ydGVkICE9PSAnYm9vbGVhbicgKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCAncXVhbnRpbGUoKTo6aW52YWxpZCBpbnB1dCBhcmd1bWVudC4gU29ydGVkIGZsYWcgbXVzdCBiZSBhIGJvb2xlYW4uJyApO1xuXHRcdH1cblx0XHRpZiAoIG9wdHMuaGFzT3duUHJvcGVydHkoICdtZXRob2QnICkgJiYgdHlwZW9mIG9wdHMubWV0aG9kICE9PSAnc3RyaW5nJyApIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoICdxdWFudGlsZSgpOjppbnZhbGlkIGlucHV0IGFyZ3VtZW50LiBNZXRob2QgbXVzdCBiZSBhIHN0cmluZy4nICk7XG5cdFx0fVxuXHRcdC8vIFRPRE86IHZhbGlkYXRlIHRoYXQgdGhlIHJlcXVlc3RlZCBtZXRob2QgaXMgc3VwcG9ydGVkLiBsaXN0LmluZGV4T2YoIG1ldGhvZCApXG5cdH0gZWxzZSB7XG5cdFx0b3B0cyA9IHt9O1xuXHR9XG5cdHZhciBsZW4gPSBhcnIubGVuZ3RoLFxuXHRcdGlkO1xuXG5cdGlmICggIW9wdHMuc29ydGVkICkge1xuXHRcdGFyciA9IGFyci5zbGljZSgpO1xuXHRcdGFyci5zb3J0KCBhc2NlbmRpbmcgKTtcblx0fVxuXG5cdC8vIENhc2VzLi4uXG5cblx0Ly8gWzBdIDB0aCBwZXJjZW50aWxlIGlzIHRoZSBtaW5pbXVtIHZhbHVlLi4uXG5cdGlmICggcCA9PT0gMC4wICkge1xuXHRcdHJldHVybiBhcnJbIDAgXTtcblx0fVxuXHQvLyBbMV0gMTAwdGggcGVyY2VudGlsZSBpcyB0aGUgbWF4aW11bSB2YWx1ZS4uLlxuXHRpZiAoIHAgPT09IDEuMCApIHtcblx0XHRyZXR1cm4gYXJyWyBsZW4tMSBdO1xuXHR9XG5cdC8vIENhbGN1bGF0ZSB0aGUgdmVjdG9yIGluZGV4IG1hcmtpbmcgdGhlIHF1YW50aWxlOlxuXHRpZCA9ICggbGVuKnAgKSAtIDE7XG5cblx0Ly8gWzJdIElzIHRoZSBpbmRleCBhbiBpbnRlZ2VyP1xuXHRpZiAoIGlkID09PSBNYXRoLmZsb29yKCBpZCApICkge1xuXHRcdC8vIFZhbHVlIGlzIHRoZSBhdmVyYWdlIGJldHdlZW4gdGhlIHZhbHVlIGF0IGlkIGFuZCBpZCsxOlxuXHRcdHJldHVybiAoIGFyclsgaWQgXSArIGFyclsgaWQrMSBdICkgLyAyLjA7XG5cdH1cblx0Ly8gWzNdIFJvdW5kIHVwIHRvIHRoZSBuZXh0IGluZGV4OlxuXHRpZCA9IE1hdGguY2VpbCggaWQgKTtcblx0cmV0dXJuIGFyclsgaWQgXTtcbn0gLy8gZW5kIEZVTkNUSU9OIHF1YW50aWxlKClcblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gcXVhbnRpbGU7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/compute-quantile/lib/index.js\n")},"./node_modules/validate.io-array/lib/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/validate.io-array/lib/index.js ***!
  \*****************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\n\n/**\n* FUNCTION: isArray( value )\n*\tValidates if a value is an array.\n*\n* @param {*} value - value to be validated\n* @returns {Boolean} boolean indicating whether value is an array\n*/\nfunction isArray( value ) {\n\treturn Object.prototype.toString.call( value ) === '[object Array]';\n} // end FUNCTION isArray()\n\n// EXPORTS //\n\nmodule.exports = Array.isArray || isArray;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdmFsaWRhdGUuaW8tYXJyYXkvbGliL2luZGV4LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYjNqcy8uL25vZGVfbW9kdWxlcy92YWxpZGF0ZS5pby1hcnJheS9saWIvaW5kZXguanM/NjMzNyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKlxuKiBGVU5DVElPTjogaXNBcnJheSggdmFsdWUgKVxuKlx0VmFsaWRhdGVzIGlmIGEgdmFsdWUgaXMgYW4gYXJyYXkuXG4qXG4qIEBwYXJhbSB7Kn0gdmFsdWUgLSB2YWx1ZSB0byBiZSB2YWxpZGF0ZWRcbiogQHJldHVybnMge0Jvb2xlYW59IGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHZhbHVlIGlzIGFuIGFycmF5XG4qL1xuZnVuY3Rpb24gaXNBcnJheSggdmFsdWUgKSB7XG5cdHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoIHZhbHVlICkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59IC8vIGVuZCBGVU5DVElPTiBpc0FycmF5KClcblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgaXNBcnJheTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/validate.io-array/lib/index.js\n")},"./node_modules/validate.io-object/lib/index.js":
/*!******************************************************!*\
  !*** ./node_modules/validate.io-object/lib/index.js ***!
  \******************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\n\n// MODULES //\n\nvar isArray = __webpack_require__( /*! validate.io-array */ \"./node_modules/validate.io-array/lib/index.js\" );\n\n\n// ISOBJECT //\n\n/**\n* FUNCTION: isObject( value )\n*\tValidates if a value is a object; e.g., {}.\n*\n* @param {*} value - value to be validated\n* @returns {Boolean} boolean indicating whether value is a object\n*/\nfunction isObject( value ) {\n\treturn ( typeof value === 'object' && value !== null && !isArray( value ) );\n} // end FUNCTION isObject()\n\n\n// EXPORTS //\n\nmodule.exports = isObject;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdmFsaWRhdGUuaW8tb2JqZWN0L2xpYi9pbmRleC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2IzanMvLi9ub2RlX21vZHVsZXMvdmFsaWRhdGUuaW8tb2JqZWN0L2xpYi9pbmRleC5qcz8yMjlmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLy8gTU9EVUxFUyAvL1xuXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoICd2YWxpZGF0ZS5pby1hcnJheScgKTtcblxuXG4vLyBJU09CSkVDVCAvL1xuXG4vKipcbiogRlVOQ1RJT046IGlzT2JqZWN0KCB2YWx1ZSApXG4qXHRWYWxpZGF0ZXMgaWYgYSB2YWx1ZSBpcyBhIG9iamVjdDsgZS5nLiwge30uXG4qXG4qIEBwYXJhbSB7Kn0gdmFsdWUgLSB2YWx1ZSB0byBiZSB2YWxpZGF0ZWRcbiogQHJldHVybnMge0Jvb2xlYW59IGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHZhbHVlIGlzIGEgb2JqZWN0XG4qL1xuZnVuY3Rpb24gaXNPYmplY3QoIHZhbHVlICkge1xuXHRyZXR1cm4gKCB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsICYmICFpc0FycmF5KCB2YWx1ZSApICk7XG59IC8vIGVuZCBGVU5DVElPTiBpc09iamVjdCgpXG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/validate.io-object/lib/index.js\n")},"./src/BarChart.js":
/*!*************************!*\
  !*** ./src/BarChart.js ***!
  \*************************/
/*! exports provided: BarChart */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BarChart", function() { return BarChart; });\n/* harmony import */ var _Colours__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Colours */ "./src/Colours.js");\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers */ "./src/helpers.js");\n/* harmony import */ var _Chart__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Chart */ "./src/Chart.js");\n// Copyright (C) 2013-2014, 2018 BrandsEye (PTY) LTD\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this\n// software and associated documentation files (the "Software"), to deal in the Software\n// without restriction, including without limitation the rights to use, copy, modify,\n//     merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following\n// conditions:\n//\n//     The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n//     INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n// CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n\n\n\n\nclass BarChart extends _Chart__WEBPACK_IMPORTED_MODULE_2__["Chart"] {\n\n    //------------------------------------------------------\n\n    data(data) {\n        if (!arguments.length) return this._data;\n        if (data && data[0].key === undefined) {\n            data = [\n                {\n                    key: "series 1",\n                    values: data\n                }\n            ];\n        }\n        this._data = data;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    element(element) {\n        if (!arguments.length) return this._element;\n        this._element = element;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    showLabels(show) {\n        if (!arguments.length) return this._show_labels;\n        this._show_labels = show;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    // todo dispatch\n    showLegend(show) {\n        if (!arguments.length) return this._show_legend;\n        this._show_legend = show;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    x(x) {\n        if (!arguments.length) return this._x;\n        this._x = x;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    y(y) {\n        if (!arguments.length) return this._y;\n        this._y = y;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    width(width) {\n        if (!arguments.length) return this._width;\n        this._width = width;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    height(height) {\n        if (!arguments.length) return this._height;\n        this._height = height;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    colours(colours) {\n        if (!arguments.length) return this._colours;\n        this._colours = colours;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    backgroundColour(colour) {\n        if (!arguments.length) return this._backgroundColour;\n        this._backgroundColour = colour || "#FFF"; // never set it to null.\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    tickFormat(format) {\n        if (!arguments.length) return this._tickFormat;\n        this._tickFormat = format;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    xAxisTickFormat(format) {\n        if (!arguments.length) return this._xAxisTickFormat;\n        this._xAxisTickFormat = format || (d => d.toString());\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    labelFormat(format) {\n        if (!arguments.length) return this._labelFormat;\n        this._labelFormat = format || (d => d.toString());\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    // todo missing\n    labelCompression(compression) {\n        if (!arguments.length) return this._compression;\n        this._compression = compression;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    //todo missing\n    dataAxisLabel(label) {\n        if (!arguments.length) return this._dataAxisLabel;\n        this._dataAxisLabel = label;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    tooltip(tooltip) {\n        if (!arguments.length) return this._tooltip;\n        this._tooltip = tooltip;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    forceY(force) {\n        if (!arguments.length) return this._forceY;\n        this._forceY = force;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n// todo missing\n    duration(duration) {\n        if (!arguments.length) return this._duration;\n        this._duration = duration;\n        return this;\n    }\n\n// todo missing\n    coarseness(coarseness) {\n        if (!arguments.length) return this._coarseness;\n        this._coarseness = coarseness;\n        return this;\n    }\n\n    // todo missing\n    padding(padding) {\n        if (!arguments.length) return this._padding;\n        this._padding = padding;\n        return this;\n    }\n\n    // todo missing\n    xAxisTooltips(tooltips) {\n        if (!arguments.length) return this._xAxisTooltips;\n        this._xAxisTooltips = tooltips;\n        return this;\n    }\n\n    xAxisOverride(override) {\n        if (!arguments.length) return this._xAxisOverride;\n        this._xAxisOverride = override;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    dispatch() {\n        return this._dispatch;\n    }\n\n    //------------------------------------------------------\n\n    render() {\n        if (!this._element) throw new Error("No element set for ColumnChart. See #element()");\n        if (!this._data) {\n            console.warn("No data set for ColumnChart. See #data()");\n            return;\n        }\n\n        const data = this.getTransformedData();\n        const keys = this.getKeys();\n\n        //------------------------------------------------\n        // Set up the SVG area\n\n        let topLevel = d3.select(this._element).select("svg");\n        if (topLevel.empty()) topLevel = d3.select(this._element).append("svg")\n\n        topLevel\n            .style("width", this._width + "px")\n            .style("height", this._height + "px");\n\n\n        // ---------------------------------\n        // Measure max data axis text length\n\n        const dataAxisBB = Object(_helpers__WEBPACK_IMPORTED_MODULE_1__["maxBounding"])(topLevel, data.map(d => this._xAxisTickFormat(d.key)));\n\n        // ---------------------------------\n        // Layout the showLegend.\n        //\n        // We do this now because we need to know how much space the legend\n        // takes up in order to finish calculating the margins.\n\n        const legendHeight = this.renderLegend();\n\n        //----------------------------------\n        // Calculate margins.\n\n        const margin = {top: 20, right: 20, bottom: 40, left: 10};\n        margin.bottom += legendHeight ? legendHeight + 20 : 0;\n        margin.left += dataAxisBB.width + 10;\n        if (this._dataAxisLabel) margin.bottom += 10 + 12;\n\n        const width = this._width - margin.left - margin.right,\n              height = this._height - margin.top - margin.bottom;\n\n        //----------------------------------\n        // Calculate scales and so on.\n\n        const x = d3.scaleLinear()\n            .rangeRound([0, width])\n            .nice();\n\n        const y = d3.scaleBand()\n            .rangeRound([0, height])\n            .padding(this._data.length > 1 ? 0.08 : 0.1);\n\n        const yGroup = d3.scaleBand()\n            .padding(0);\n\n        this._xscale = x;\n        this._ygroupscale = yGroup;\n        this._yscale = y;\n\n        // Scale the range of the data in the domains\n        y.domain(data.map(d => d.key));\n        yGroup.rangeRound([0, y.bandwidth()]).domain(keys);\n        x.domain([0, d3.max(data, d => d3.max(d.data, d => d._y))]);\n\n        //------------------------------\n\n        let svg = topLevel.select(\'.main-group\');\n\n        if (svg.empty()) {\n            svg = topLevel\n                .append("g")\n                .attr("class", "main-group")\n        }\n\n        svg.attr("transform", "translate(" + margin.left + "," + margin.top + ")");\n\n        //---------------------------------\n        // Get rid of current labels.\n        svg.select(".chart-labels")\n            .remove();\n\n        //---------------------------------\n        // append the rectangles for the bar chart\n        let groups = svg.select(".bars").selectAll(\'.group\');\n\n        if (groups.empty()) {\n            groups = svg\n                .append("g")\n                .attr("class", "bars")\n                .selectAll(".group");\n        }\n\n        groups = groups.data(data);\n\n        groups.exit().remove();\n\n        // Adding new groups, and hence adding new bars to those groups.\n        groups.enter()\n            .append("g")\n                .attr("class", "group")\n                .attr("transform", d => "translate(0," + y(d.key) + ")")\n                .attr("height", height - y.bandwidth())\n                .attr("width", "100%")\n            .merge(groups)\n            .interrupt("groups:move")\n            .transition("groups:move")\n                .attr("transform", d => "translate(0," + y(d.key) + ")")\n                .attr("height", y.bandwidth())\n            .each((s_d, s_i, nodes) => {\n                let group = d3.select(nodes[s_i]);\n\n                let bars = group.selectAll(".bar")\n                    .data(s_d.data);\n\n                bars.exit().remove();\n\n                bars.interrupt("bar:move")     // Animate the bars to their new position.\n                    .transition("bar:move")\n                        .attr("height", yGroup.bandwidth())\n                        .attr("y", d => yGroup(d._key))\n                        .attr("x", 0);\n\n                bars.enter()\n                    .append("rect")\n                        .attr("class", (d, i) => "bar series series-" + i)\n                        .attr("y", d => yGroup(d._key))\n                        .attr("x", 0)\n                        .attr("height", yGroup.bandwidth())\n                        .attr("width", 0)\n                        .style("fill", (d, i) => this.getSeriesColour(i))\n                        .style("cursor", "pointer")\n                    .on("mouseover", (d, i, nodes) => { // Darken the bar on mouse over\n                        d3.select(nodes[i])\n                            .interrupt("hover:colour")\n                            .transition("hover:colour")\n                            .duration(400)\n                            .style("fill", d3.hcl(this.getSeriesColour(i)).darker())\n                        this._dispatch.call("tooltipShow", this, {\n                            e: d3.event,\n                            point: d,\n                            series: s_d,\n                            seriesIndex: s_i,\n                            value: d._y\n                        })\n                    })\n                    .on("mouseout", (d, i, nodes) => { // bar is regular colour on mouse out.\n                        d3.select(nodes[i])\n                            .interrupt("hover:colour")\n                            .transition("hover:colour")\n                            .duration(400)\n                            .style("fill", this.getSeriesColour(i));\n                        this._dispatch.call("tooltipHide", this);\n                    })\n                    .on("click auxclick", (d, i, nodes) => {\n                        this._dispatch.call("elementClick", this, {\n                            e: d3.event,\n                            point: d,\n                            series: d._series,\n                            seriesIndex: s_i,\n                            value: this._y(d)\n                        })\n                    })\n                    .merge(bars)\n                    .interrupt("bar:growth")    // Animate bars growing.\n                    .transition("bar:growth")\n                    .delay(() => {\n                        return this.calcBarGrowth(s_i, nodes.length);\n                    })\n                    .duration(this._duration)\n                        .style("fill", (d, i) => this.getSeriesColour(i))\n                        .attr("width", d => x(d._y));\n\n            });\n\n        // ---------------------------------\n        // Labels loaded after our first bar grows.\n        if (this._show_labels) {\n            svg.transition("bar:growth")\n                .on("end", (d, i, nodes) => {\n                    if (i < nodes.length - 1) return;\n                    this.renderLabels(svg, data, x, yGroup, y);\n                })\n        }\n\n        // ---------------------------------\n        // Draw the data axis data label.\n\n        if (this._dataAxisLabel) {\n            this.renderDataAxisLabel(width, margin);\n        }\n\n        // ---------------------------------\n        // Set the background colour\n\n        d3.select(this._element).select(".background").remove();\n        if (this._backgroundColour) {\n            d3.select(this._element).select("svg")\n                .append("rect")\n                    .attr("class", "background")\n                    .attr("width", "100%")\n                    .attr("height", "100%")\n                    .style("fill", this._backgroundColour)\n                .lower();\n        }\n\n        //---------------------------------\n        // add the Y gridlines\n        svg.call(this.grid, height, d3.axisBottom(x).ticks(5));\n\n        //---------------------------------\n        // axes\n        svg.call(this.labelAxis, d3.axisLeft(y).tickSize(0).tickPadding(5).tickFormat(this._xAxisTickFormat));\n        svg.call(this.dataAxis, height, d3.axisBottom(x).ticks(5).tickFormat(this._tickFormat));\n    }\n\n    //------------------------------------------------------\n\n    /*\n     * Returns an object with two functions, #show() and #hide(),\n     * to show and hide the labels.\n     */\n    labels() {\n        return {\n\n            show: () => {\n                if (this._element) {\n                    let selection = this._element,\n                        data = this.getTransformedData(),\n                        xscale = this._xscale,\n                        ygroup = this._ygroupscale,\n                        yscale = this._yscale;\n\n                    if (selection) selection = d3.select(this._element).select("svg").select("g");\n                    if (!selection.empty() && data && xscale && yscale && ygroup) {\n                        let labels = selection.select(\'.chart-labels\');\n                        if (!labels.empty()) return;\n                        labels.remove()\n                        this.renderLabels(selection, data, xscale, ygroup, yscale, false);\n                    }\n                }\n\n            },\n\n            hide: () => {\n                if (this._element) {\n                    d3.select(this._element)\n                        .select(\'.chart-labels\')\n                        .interrupt("labels")\n                        .interrupt("labels:fade")\n                        .transition("labels:fade")\n                        .style("opacity", 0)\n                        .on("end", (d, i, nodes) => {\n                            d3.select(nodes[i]).remove();\n                        })\n                }\n            }\n        }\n    }\n\n    //------------------------------------------------------\n\n    renderLabels(selection, data, xscale, ygroup, yscale, animate) {\n        animate = animate === undefined ? true : animate;\n        selection.selectAll(".chart-labels").remove();\n\n        let labels = selection.append("g")\n            .attr("class", "chart-labels")\n            .selectAll(".label-group")\n            .data(data);\n\n        let fontSize = this._font_size;    // Our initial font size.\n        const buffer = 5;     // Buffer space between words and the top of a bar.\n\n        labels.enter().each((series, s_i, s_nodes) => {\n            let group = d3.select(s_nodes[s_i])\n                .append("g")\n                .attr("class", "label-group")\n                .attr("transform", d => "translate(0," + yscale(d.key) + ")")\n                .selectAll(".chart-label")\n                .data(series.data)\n                .enter()\n                .each((d, i, nodes) => {\n\n                    // Want to figure out if the label is too dark / light for the\n                    // bar.\n                    let invertedColor = d3.hcl(this.getSeriesColour(i));\n                    invertedColor.l += Math.min(invertedColor.l + 50, 100);\n                    let invert = d3.hcl(this.getSeriesColour(i)).l < 60;\n\n                    let xpos = xscale(d._y);\n\n                    let text = d3.select(nodes[i])\n                        .append("text")\n                        .text(this._labelFormat(d._y))\n                            .attr("class", "chart-label")\n                            .attr("x", xpos + buffer)\n                            .attr("dx", animate ? -15 : 0)\n                            .style("opacity", 0)\n                            .style("pointer-events", "none")\n                            .style("font-size", fontSize + "px");\n\n\n                    const bb = text.node().getBBox();\n                    const oversize = xpos + bb.width + buffer > xscale.range()[1];\n\n                    text\n                        .attr("y", ygroup(d._key) + fontSize / 2 + ygroup.bandwidth() / 2)\n                        .attr("x", oversize ? xpos - buffer - bb.width : xpos + buffer)\n                        .style("fill", oversize && invert ? invertedColor.toString() : _Colours__WEBPACK_IMPORTED_MODULE_0__["colours"].eighteen.darkGrey);\n\n                    text\n                        .transition("labels")\n                        .delay(() => animate ? this.calcBarGrowth(s_i, s_nodes.length) : 0) // Delay in lockstep with bar growth.\n                        .duration(this._duration)\n                        .attr("dx", 0)\n                        .style("opacity", 1)\n                })\n        });\n\n    }\n\n    //------------------------------------------------------\n\n    renderDataAxisLabel(width, margins) {\n        let svg = d3.select(this._element).select(\'svg\');\n        svg.selectAll(".data-labels").remove();\n\n        if (!this._dataAxisLabel) return;\n        let text = this._dataAxisLabel;\n        if (text.long) text = text.long;\n\n        let x = (margins.left + width / 2);\n\n        let label = svg.append("g")\n            .attr("class", "data-labels")\n            .append("text")\n            .text(text)\n            .attr("transform", "translate(" + x + "," + (this._height - margins.bottom + 50) + ")")\n            .style("fill", _Colours__WEBPACK_IMPORTED_MODULE_0__["colours"].eighteen.darkGrey);\n\n        let textWidth = label.node().getBBox().width;\n        if (textWidth >= width && this._dataAxisLabel.short) {\n            label.text(this._dataAxisLabel.short);\n            textWidth = label.node().getBBox().width;\n        }\n\n        label.attr("dx", -textWidth / 2);\n    }\n\n    //------------------------------------------------------\n\n\n\n    grid(selection, height, axis) {\n        selection.select(".grid").remove();\n\n        let grid = selection.append("g")\n            .attr("class", "grid")\n            .call(axis\n                .tickSize(height)\n                .tickFormat("")\n            );\n\n        grid.selectAll("line")\n            .style("stroke", _Colours__WEBPACK_IMPORTED_MODULE_0__["colours"].eighteen.lightGrey);\n        grid.selectAll(".domain").remove();\n\n        grid\n            .lower() // Always ensure that this is earlier in the dom. Things must be drawn on top of it.\n            .style("opacity", 0)\n            .transition()\n            .delay(500)\n            .duration(500)\n            .style("opacity", 1);\n    }\n\n    //------------------------------------------------------\n\n    labelAxis(selection, axis_object) {\n        selection.select(".label-axis").remove();\n        let axis = selection.append("g")\n            .attr("class", "label-axis")\n            .style("opacity", 0)\n            .call(axis_object);\n\n        axis.select(".domain").remove();\n\n        let max = 0;\n        axis.selectAll("text")\n            .style("font-size", this._font_size + "px")\n            .style("fill", _Colours__WEBPACK_IMPORTED_MODULE_0__["colours"].eighteen.darkGrey)\n            .nodes()\n            .forEach(text => max = Math.max(max, text.getBBox().width));\n\n        axis\n            .transition()\n            .duration(1000)\n            .style("opacity", 1);\n    }\n\n    //------------------------------------------------------\n\n    dataAxis(selection, height, axis_object) {\n        selection.select(".data-axis").remove();\n        let axis = selection.append("g")\n                .attr("class", "data-axis")\n                .attr("transform", "translate(0," + height + ")")\n            .call(axis_object.tickSize(0).tickPadding(10))\n                .style("opacity", 0)\n            .transition()\n            .duration(1000)\n                .style("opacity", 1);\n\n        axis.selectAll("text")\n                .style("fill", _Colours__WEBPACK_IMPORTED_MODULE_0__["colours"].eighteen.darkGrey)\n    }\n\n    //------------------------------------------------------\n\n    calcBarGrowth(i, max) {\n        if (max < 10) return i * this._BAR_GROWTH / 2;\n        if (max < 35) return i * this._BAR_GROWTH / 4;\n        return 1;\n    }\n\n    getSeriesColour(i) {\n        if (i < 0 || !this._colours) return _Colours__WEBPACK_IMPORTED_MODULE_0__["colours"].eighteen.midGrey;\n\n        i = i % this._colours.length;\n        return this._colours[i];\n    }\n\n    getSortedData() {\n        let data = this._data;\n        if (!data || !data.length) return [];\n\n        data = this._data.sort((lhs, rhs) => {\n            lhs = lhs.key.toLowerCase();\n            rhs = rhs.key.toLowerCase();\n\n            if (lhs === rhs) return 0;\n            if (lhs < rhs) return -1;\n            return 1;\n        });\n\n        return data;\n    }\n\n    getTransformedData() {\n        let data = this.getSortedData();\n        if (!data || !data.length) return [];\n\n        let results = [];\n\n        const getX = d => this._xAxisOverride ? this._xAxisOverride[this._x(d)] : this._x(d);\n\n        data.forEach((series, s_i) => {\n            series.values.forEach((d, d_i) => {\n                let field = results.find(bucket => bucket.key === getX(d));\n                if (!field) {\n                    field = {\n                        data: [],\n                        key: getX(d)\n                    };\n                    results.push(field);\n                }\n\n                field.data.push(Object.assign({\n                    _series: series,\n                    _s_i: s_i,\n                    _key: series.key,\n                    _y: this._y(d)\n                }, d));\n            })\n        });\n\n        return results;\n    }\n\n    getKeys() {\n        let data = this._data;\n        if (!data || !data.length) return [];\n\n        return [...new Set(data.map(d => d.key))]\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvQmFyQ2hhcnQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9iM2pzLy4vc3JjL0JhckNoYXJ0LmpzPzNjODUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChDKSAyMDEzLTIwMTQsIDIwMTggQnJhbmRzRXllIChQVFkpIExURFxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpc1xuLy8gc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlXG4vLyB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksXG4vLyAgICAgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0b1xuLy8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcbi8vIGNvbmRpdGlvbnM6XG4vL1xuLy8gICAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuLy8gY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyAgICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUiBJTVBMSUVELFxuLy8gICAgIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBXG4vLyBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUXG4vLyBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0Zcbi8vIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRVxuLy8gT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cblxuaW1wb3J0IHsgY29sb3VycyB9IGZyb20gJy4vQ29sb3Vycyc7XG5pbXBvcnQgeyBtYXhCb3VuZGluZyB9IGZyb20gXCIuL2hlbHBlcnNcIjtcbmltcG9ydCB7IENoYXJ0IH0gZnJvbSBcIi4vQ2hhcnRcIjtcblxuXG5leHBvcnQgY2xhc3MgQmFyQ2hhcnQgZXh0ZW5kcyBDaGFydCB7XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgZGF0YShkYXRhKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX2RhdGE7XG4gICAgICAgIGlmIChkYXRhICYmIGRhdGFbMF0ua2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRhdGEgPSBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBrZXk6IFwic2VyaWVzIDFcIixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzOiBkYXRhXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGVsZW1lbnQoZWxlbWVudCkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9lbGVtZW50O1xuICAgICAgICB0aGlzLl9lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHNob3dMYWJlbHMoc2hvdykge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9zaG93X2xhYmVscztcbiAgICAgICAgdGhpcy5fc2hvd19sYWJlbHMgPSBzaG93O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLy8gdG9kbyBkaXNwYXRjaFxuICAgIHNob3dMZWdlbmQoc2hvdykge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9zaG93X2xlZ2VuZDtcbiAgICAgICAgdGhpcy5fc2hvd19sZWdlbmQgPSBzaG93O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgeCh4KSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3g7XG4gICAgICAgIHRoaXMuX3ggPSB4O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgeSh5KSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3k7XG4gICAgICAgIHRoaXMuX3kgPSB5O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgd2lkdGgod2lkdGgpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fd2lkdGg7XG4gICAgICAgIHRoaXMuX3dpZHRoID0gd2lkdGg7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBoZWlnaHQoaGVpZ2h0KSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX2hlaWdodDtcbiAgICAgICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgY29sb3Vycyhjb2xvdXJzKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX2NvbG91cnM7XG4gICAgICAgIHRoaXMuX2NvbG91cnMgPSBjb2xvdXJzO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgYmFja2dyb3VuZENvbG91cihjb2xvdXIpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fYmFja2dyb3VuZENvbG91cjtcbiAgICAgICAgdGhpcy5fYmFja2dyb3VuZENvbG91ciA9IGNvbG91ciB8fCBcIiNGRkZcIjsgLy8gbmV2ZXIgc2V0IGl0IHRvIG51bGwuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB0aWNrRm9ybWF0KGZvcm1hdCkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl90aWNrRm9ybWF0O1xuICAgICAgICB0aGlzLl90aWNrRm9ybWF0ID0gZm9ybWF0O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgeEF4aXNUaWNrRm9ybWF0KGZvcm1hdCkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl94QXhpc1RpY2tGb3JtYXQ7XG4gICAgICAgIHRoaXMuX3hBeGlzVGlja0Zvcm1hdCA9IGZvcm1hdCB8fCAoZCA9PiBkLnRvU3RyaW5nKCkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgbGFiZWxGb3JtYXQoZm9ybWF0KSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX2xhYmVsRm9ybWF0O1xuICAgICAgICB0aGlzLl9sYWJlbEZvcm1hdCA9IGZvcm1hdCB8fCAoZCA9PiBkLnRvU3RyaW5nKCkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLy8gdG9kbyBtaXNzaW5nXG4gICAgbGFiZWxDb21wcmVzc2lvbihjb21wcmVzc2lvbikge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9jb21wcmVzc2lvbjtcbiAgICAgICAgdGhpcy5fY29tcHJlc3Npb24gPSBjb21wcmVzc2lvbjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8vdG9kbyBtaXNzaW5nXG4gICAgZGF0YUF4aXNMYWJlbChsYWJlbCkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9kYXRhQXhpc0xhYmVsO1xuICAgICAgICB0aGlzLl9kYXRhQXhpc0xhYmVsID0gbGFiZWw7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB0b29sdGlwKHRvb2x0aXApIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fdG9vbHRpcDtcbiAgICAgICAgdGhpcy5fdG9vbHRpcCA9IHRvb2x0aXA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBmb3JjZVkoZm9yY2UpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fZm9yY2VZO1xuICAgICAgICB0aGlzLl9mb3JjZVkgPSBmb3JjZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLy8gdG9kbyBtaXNzaW5nXG4gICAgZHVyYXRpb24oZHVyYXRpb24pIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fZHVyYXRpb247XG4gICAgICAgIHRoaXMuX2R1cmF0aW9uID0gZHVyYXRpb247XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuLy8gdG9kbyBtaXNzaW5nXG4gICAgY29hcnNlbmVzcyhjb2Fyc2VuZXNzKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX2NvYXJzZW5lc3M7XG4gICAgICAgIHRoaXMuX2NvYXJzZW5lc3MgPSBjb2Fyc2VuZXNzO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyB0b2RvIG1pc3NpbmdcbiAgICBwYWRkaW5nKHBhZGRpbmcpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fcGFkZGluZztcbiAgICAgICAgdGhpcy5fcGFkZGluZyA9IHBhZGRpbmc7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIHRvZG8gbWlzc2luZ1xuICAgIHhBeGlzVG9vbHRpcHModG9vbHRpcHMpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5feEF4aXNUb29sdGlwcztcbiAgICAgICAgdGhpcy5feEF4aXNUb29sdGlwcyA9IHRvb2x0aXBzO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB4QXhpc092ZXJyaWRlKG92ZXJyaWRlKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3hBeGlzT3ZlcnJpZGU7XG4gICAgICAgIHRoaXMuX3hBeGlzT3ZlcnJpZGUgPSBvdmVycmlkZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGRpc3BhdGNoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGlzcGF0Y2g7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9lbGVtZW50KSB0aHJvdyBuZXcgRXJyb3IoXCJObyBlbGVtZW50IHNldCBmb3IgQ29sdW1uQ2hhcnQuIFNlZSAjZWxlbWVudCgpXCIpO1xuICAgICAgICBpZiAoIXRoaXMuX2RhdGEpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIk5vIGRhdGEgc2V0IGZvciBDb2x1bW5DaGFydC4gU2VlICNkYXRhKClcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5nZXRUcmFuc2Zvcm1lZERhdGEoKTtcbiAgICAgICAgY29uc3Qga2V5cyA9IHRoaXMuZ2V0S2V5cygpO1xuXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIFNldCB1cCB0aGUgU1ZHIGFyZWFcblxuICAgICAgICBsZXQgdG9wTGV2ZWwgPSBkMy5zZWxlY3QodGhpcy5fZWxlbWVudCkuc2VsZWN0KFwic3ZnXCIpO1xuICAgICAgICBpZiAodG9wTGV2ZWwuZW1wdHkoKSkgdG9wTGV2ZWwgPSBkMy5zZWxlY3QodGhpcy5fZWxlbWVudCkuYXBwZW5kKFwic3ZnXCIpXG5cbiAgICAgICAgdG9wTGV2ZWxcbiAgICAgICAgICAgIC5zdHlsZShcIndpZHRoXCIsIHRoaXMuX3dpZHRoICsgXCJweFwiKVxuICAgICAgICAgICAgLnN0eWxlKFwiaGVpZ2h0XCIsIHRoaXMuX2hlaWdodCArIFwicHhcIik7XG5cblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gTWVhc3VyZSBtYXggZGF0YSBheGlzIHRleHQgbGVuZ3RoXG5cbiAgICAgICAgY29uc3QgZGF0YUF4aXNCQiA9IG1heEJvdW5kaW5nKHRvcExldmVsLCBkYXRhLm1hcChkID0+IHRoaXMuX3hBeGlzVGlja0Zvcm1hdChkLmtleSkpKTtcblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gTGF5b3V0IHRoZSBzaG93TGVnZW5kLlxuICAgICAgICAvL1xuICAgICAgICAvLyBXZSBkbyB0aGlzIG5vdyBiZWNhdXNlIHdlIG5lZWQgdG8ga25vdyBob3cgbXVjaCBzcGFjZSB0aGUgbGVnZW5kXG4gICAgICAgIC8vIHRha2VzIHVwIGluIG9yZGVyIHRvIGZpbmlzaCBjYWxjdWxhdGluZyB0aGUgbWFyZ2lucy5cblxuICAgICAgICBjb25zdCBsZWdlbmRIZWlnaHQgPSB0aGlzLnJlbmRlckxlZ2VuZCgpO1xuXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBDYWxjdWxhdGUgbWFyZ2lucy5cblxuICAgICAgICBjb25zdCBtYXJnaW4gPSB7dG9wOiAyMCwgcmlnaHQ6IDIwLCBib3R0b206IDQwLCBsZWZ0OiAxMH07XG4gICAgICAgIG1hcmdpbi5ib3R0b20gKz0gbGVnZW5kSGVpZ2h0ID8gbGVnZW5kSGVpZ2h0ICsgMjAgOiAwO1xuICAgICAgICBtYXJnaW4ubGVmdCArPSBkYXRhQXhpc0JCLndpZHRoICsgMTA7XG4gICAgICAgIGlmICh0aGlzLl9kYXRhQXhpc0xhYmVsKSBtYXJnaW4uYm90dG9tICs9IDEwICsgMTI7XG5cbiAgICAgICAgY29uc3Qgd2lkdGggPSB0aGlzLl93aWR0aCAtIG1hcmdpbi5sZWZ0IC0gbWFyZ2luLnJpZ2h0LFxuICAgICAgICAgICAgICBoZWlnaHQgPSB0aGlzLl9oZWlnaHQgLSBtYXJnaW4udG9wIC0gbWFyZ2luLmJvdHRvbTtcblxuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHNjYWxlcyBhbmQgc28gb24uXG5cbiAgICAgICAgY29uc3QgeCA9IGQzLnNjYWxlTGluZWFyKClcbiAgICAgICAgICAgIC5yYW5nZVJvdW5kKFswLCB3aWR0aF0pXG4gICAgICAgICAgICAubmljZSgpO1xuXG4gICAgICAgIGNvbnN0IHkgPSBkMy5zY2FsZUJhbmQoKVxuICAgICAgICAgICAgLnJhbmdlUm91bmQoWzAsIGhlaWdodF0pXG4gICAgICAgICAgICAucGFkZGluZyh0aGlzLl9kYXRhLmxlbmd0aCA+IDEgPyAwLjA4IDogMC4xKTtcblxuICAgICAgICBjb25zdCB5R3JvdXAgPSBkMy5zY2FsZUJhbmQoKVxuICAgICAgICAgICAgLnBhZGRpbmcoMCk7XG5cbiAgICAgICAgdGhpcy5feHNjYWxlID0geDtcbiAgICAgICAgdGhpcy5feWdyb3Vwc2NhbGUgPSB5R3JvdXA7XG4gICAgICAgIHRoaXMuX3lzY2FsZSA9IHk7XG5cbiAgICAgICAgLy8gU2NhbGUgdGhlIHJhbmdlIG9mIHRoZSBkYXRhIGluIHRoZSBkb21haW5zXG4gICAgICAgIHkuZG9tYWluKGRhdGEubWFwKGQgPT4gZC5rZXkpKTtcbiAgICAgICAgeUdyb3VwLnJhbmdlUm91bmQoWzAsIHkuYmFuZHdpZHRoKCldKS5kb21haW4oa2V5cyk7XG4gICAgICAgIHguZG9tYWluKFswLCBkMy5tYXgoZGF0YSwgZCA9PiBkMy5tYXgoZC5kYXRhLCBkID0+IGQuX3kpKV0pO1xuXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgbGV0IHN2ZyA9IHRvcExldmVsLnNlbGVjdCgnLm1haW4tZ3JvdXAnKTtcblxuICAgICAgICBpZiAoc3ZnLmVtcHR5KCkpIHtcbiAgICAgICAgICAgIHN2ZyA9IHRvcExldmVsXG4gICAgICAgICAgICAgICAgLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwibWFpbi1ncm91cFwiKVxuICAgICAgICB9XG5cbiAgICAgICAgc3ZnLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyBtYXJnaW4ubGVmdCArIFwiLFwiICsgbWFyZ2luLnRvcCArIFwiKVwiKTtcblxuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBHZXQgcmlkIG9mIGN1cnJlbnQgbGFiZWxzLlxuICAgICAgICBzdmcuc2VsZWN0KFwiLmNoYXJ0LWxhYmVsc1wiKVxuICAgICAgICAgICAgLnJlbW92ZSgpO1xuXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIGFwcGVuZCB0aGUgcmVjdGFuZ2xlcyBmb3IgdGhlIGJhciBjaGFydFxuICAgICAgICBsZXQgZ3JvdXBzID0gc3ZnLnNlbGVjdChcIi5iYXJzXCIpLnNlbGVjdEFsbCgnLmdyb3VwJyk7XG5cbiAgICAgICAgaWYgKGdyb3Vwcy5lbXB0eSgpKSB7XG4gICAgICAgICAgICBncm91cHMgPSBzdmdcbiAgICAgICAgICAgICAgICAuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJiYXJzXCIpXG4gICAgICAgICAgICAgICAgLnNlbGVjdEFsbChcIi5ncm91cFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdyb3VwcyA9IGdyb3Vwcy5kYXRhKGRhdGEpO1xuXG4gICAgICAgIGdyb3Vwcy5leGl0KCkucmVtb3ZlKCk7XG5cbiAgICAgICAgLy8gQWRkaW5nIG5ldyBncm91cHMsIGFuZCBoZW5jZSBhZGRpbmcgbmV3IGJhcnMgdG8gdGhvc2UgZ3JvdXBzLlxuICAgICAgICBncm91cHMuZW50ZXIoKVxuICAgICAgICAgICAgLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwiZ3JvdXBcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBkID0+IFwidHJhbnNsYXRlKDAsXCIgKyB5KGQua2V5KSArIFwiKVwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIGhlaWdodCAtIHkuYmFuZHdpZHRoKCkpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCBcIjEwMCVcIilcbiAgICAgICAgICAgIC5tZXJnZShncm91cHMpXG4gICAgICAgICAgICAuaW50ZXJydXB0KFwiZ3JvdXBzOm1vdmVcIilcbiAgICAgICAgICAgIC50cmFuc2l0aW9uKFwiZ3JvdXBzOm1vdmVcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBkID0+IFwidHJhbnNsYXRlKDAsXCIgKyB5KGQua2V5KSArIFwiKVwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIHkuYmFuZHdpZHRoKCkpXG4gICAgICAgICAgICAuZWFjaCgoc19kLCBzX2ksIG5vZGVzKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGdyb3VwID0gZDMuc2VsZWN0KG5vZGVzW3NfaV0pO1xuXG4gICAgICAgICAgICAgICAgbGV0IGJhcnMgPSBncm91cC5zZWxlY3RBbGwoXCIuYmFyXCIpXG4gICAgICAgICAgICAgICAgICAgIC5kYXRhKHNfZC5kYXRhKTtcblxuICAgICAgICAgICAgICAgIGJhcnMuZXhpdCgpLnJlbW92ZSgpO1xuXG4gICAgICAgICAgICAgICAgYmFycy5pbnRlcnJ1cHQoXCJiYXI6bW92ZVwiKSAgICAgLy8gQW5pbWF0ZSB0aGUgYmFycyB0byB0aGVpciBuZXcgcG9zaXRpb24uXG4gICAgICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKFwiYmFyOm1vdmVcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIHlHcm91cC5iYW5kd2lkdGgoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwieVwiLCBkID0+IHlHcm91cChkLl9rZXkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIDApO1xuXG4gICAgICAgICAgICAgICAgYmFycy5lbnRlcigpXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoXCJyZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIChkLCBpKSA9PiBcImJhciBzZXJpZXMgc2VyaWVzLVwiICsgaSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwieVwiLCBkID0+IHlHcm91cChkLl9rZXkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIDApXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcImhlaWdodFwiLCB5R3JvdXAuYmFuZHdpZHRoKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcIndpZHRoXCIsIDApXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIChkLCBpKSA9PiB0aGlzLmdldFNlcmllc0NvbG91cihpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcImN1cnNvclwiLCBcInBvaW50ZXJcIilcbiAgICAgICAgICAgICAgICAgICAgLm9uKFwibW91c2VvdmVyXCIsIChkLCBpLCBub2RlcykgPT4geyAvLyBEYXJrZW4gdGhlIGJhciBvbiBtb3VzZSBvdmVyXG4gICAgICAgICAgICAgICAgICAgICAgICBkMy5zZWxlY3Qobm9kZXNbaV0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmludGVycnVwdChcImhvdmVyOmNvbG91clwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKFwiaG92ZXI6Y29sb3VyXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKDQwMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIGQzLmhjbCh0aGlzLmdldFNlcmllc0NvbG91cihpKSkuZGFya2VyKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXNwYXRjaC5jYWxsKFwidG9vbHRpcFNob3dcIiwgdGhpcywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGU6IGQzLmV2ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50OiBkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllczogc19kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllc0luZGV4OiBzX2ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGQuX3lcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5vbihcIm1vdXNlb3V0XCIsIChkLCBpLCBub2RlcykgPT4geyAvLyBiYXIgaXMgcmVndWxhciBjb2xvdXIgb24gbW91c2Ugb3V0LlxuICAgICAgICAgICAgICAgICAgICAgICAgZDMuc2VsZWN0KG5vZGVzW2ldKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5pbnRlcnJ1cHQoXCJob3Zlcjpjb2xvdXJcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudHJhbnNpdGlvbihcImhvdmVyOmNvbG91clwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbig0MDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCB0aGlzLmdldFNlcmllc0NvbG91cihpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXNwYXRjaC5jYWxsKFwidG9vbHRpcEhpZGVcIiwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5vbihcImNsaWNrIGF1eGNsaWNrXCIsIChkLCBpLCBub2RlcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlzcGF0Y2guY2FsbChcImVsZW1lbnRDbGlja1wiLCB0aGlzLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZTogZDMuZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQ6IGQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzOiBkLl9zZXJpZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzSW5kZXg6IHNfaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy5feShkKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLm1lcmdlKGJhcnMpXG4gICAgICAgICAgICAgICAgICAgIC5pbnRlcnJ1cHQoXCJiYXI6Z3Jvd3RoXCIpICAgIC8vIEFuaW1hdGUgYmFycyBncm93aW5nLlxuICAgICAgICAgICAgICAgICAgICAudHJhbnNpdGlvbihcImJhcjpncm93dGhcIilcbiAgICAgICAgICAgICAgICAgICAgLmRlbGF5KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNhbGNCYXJHcm93dGgoc19pLCBub2Rlcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24odGhpcy5fZHVyYXRpb24pXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIChkLCBpKSA9PiB0aGlzLmdldFNlcmllc0NvbG91cihpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwid2lkdGhcIiwgZCA9PiB4KGQuX3kpKTtcblxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIExhYmVscyBsb2FkZWQgYWZ0ZXIgb3VyIGZpcnN0IGJhciBncm93cy5cbiAgICAgICAgaWYgKHRoaXMuX3Nob3dfbGFiZWxzKSB7XG4gICAgICAgICAgICBzdmcudHJhbnNpdGlvbihcImJhcjpncm93dGhcIilcbiAgICAgICAgICAgICAgICAub24oXCJlbmRcIiwgKGQsIGksIG5vZGVzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpIDwgbm9kZXMubGVuZ3RoIC0gMSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckxhYmVscyhzdmcsIGRhdGEsIHgsIHlHcm91cCwgeSk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBEcmF3IHRoZSBkYXRhIGF4aXMgZGF0YSBsYWJlbC5cblxuICAgICAgICBpZiAodGhpcy5fZGF0YUF4aXNMYWJlbCkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJEYXRhQXhpc0xhYmVsKHdpZHRoLCBtYXJnaW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIFNldCB0aGUgYmFja2dyb3VuZCBjb2xvdXJcblxuICAgICAgICBkMy5zZWxlY3QodGhpcy5fZWxlbWVudCkuc2VsZWN0KFwiLmJhY2tncm91bmRcIikucmVtb3ZlKCk7XG4gICAgICAgIGlmICh0aGlzLl9iYWNrZ3JvdW5kQ29sb3VyKSB7XG4gICAgICAgICAgICBkMy5zZWxlY3QodGhpcy5fZWxlbWVudCkuc2VsZWN0KFwic3ZnXCIpXG4gICAgICAgICAgICAgICAgLmFwcGVuZChcInJlY3RcIilcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImJhY2tncm91bmRcIilcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCBcIjEwMCVcIilcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgXCIxMDAlXCIpXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZShcImZpbGxcIiwgdGhpcy5fYmFja2dyb3VuZENvbG91cilcbiAgICAgICAgICAgICAgICAubG93ZXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIGFkZCB0aGUgWSBncmlkbGluZXNcbiAgICAgICAgc3ZnLmNhbGwodGhpcy5ncmlkLCBoZWlnaHQsIGQzLmF4aXNCb3R0b20oeCkudGlja3MoNSkpO1xuXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIGF4ZXNcbiAgICAgICAgc3ZnLmNhbGwodGhpcy5sYWJlbEF4aXMsIGQzLmF4aXNMZWZ0KHkpLnRpY2tTaXplKDApLnRpY2tQYWRkaW5nKDUpLnRpY2tGb3JtYXQodGhpcy5feEF4aXNUaWNrRm9ybWF0KSk7XG4gICAgICAgIHN2Zy5jYWxsKHRoaXMuZGF0YUF4aXMsIGhlaWdodCwgZDMuYXhpc0JvdHRvbSh4KS50aWNrcyg1KS50aWNrRm9ybWF0KHRoaXMuX3RpY2tGb3JtYXQpKTtcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLypcbiAgICAgKiBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIHR3byBmdW5jdGlvbnMsICNzaG93KCkgYW5kICNoaWRlKCksXG4gICAgICogdG8gc2hvdyBhbmQgaGlkZSB0aGUgbGFiZWxzLlxuICAgICAqL1xuICAgIGxhYmVscygpIHtcbiAgICAgICAgcmV0dXJuIHtcblxuICAgICAgICAgICAgc2hvdzogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9lbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzZWxlY3Rpb24gPSB0aGlzLl9lbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHRoaXMuZ2V0VHJhbnNmb3JtZWREYXRhKCksXG4gICAgICAgICAgICAgICAgICAgICAgICB4c2NhbGUgPSB0aGlzLl94c2NhbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB5Z3JvdXAgPSB0aGlzLl95Z3JvdXBzY2FsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHlzY2FsZSA9IHRoaXMuX3lzY2FsZTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uKSBzZWxlY3Rpb24gPSBkMy5zZWxlY3QodGhpcy5fZWxlbWVudCkuc2VsZWN0KFwic3ZnXCIpLnNlbGVjdChcImdcIik7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2VsZWN0aW9uLmVtcHR5KCkgJiYgZGF0YSAmJiB4c2NhbGUgJiYgeXNjYWxlICYmIHlncm91cCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGxhYmVscyA9IHNlbGVjdGlvbi5zZWxlY3QoJy5jaGFydC1sYWJlbHMnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbGFiZWxzLmVtcHR5KCkpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVscy5yZW1vdmUoKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJMYWJlbHMoc2VsZWN0aW9uLCBkYXRhLCB4c2NhbGUsIHlncm91cCwgeXNjYWxlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGhpZGU6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBkMy5zZWxlY3QodGhpcy5fZWxlbWVudClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZWxlY3QoJy5jaGFydC1sYWJlbHMnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmludGVycnVwdChcImxhYmVsc1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmludGVycnVwdChcImxhYmVsczpmYWRlXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAudHJhbnNpdGlvbihcImxhYmVsczpmYWRlXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDApXG4gICAgICAgICAgICAgICAgICAgICAgICAub24oXCJlbmRcIiwgKGQsIGksIG5vZGVzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZDMuc2VsZWN0KG5vZGVzW2ldKS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHJlbmRlckxhYmVscyhzZWxlY3Rpb24sIGRhdGEsIHhzY2FsZSwgeWdyb3VwLCB5c2NhbGUsIGFuaW1hdGUpIHtcbiAgICAgICAgYW5pbWF0ZSA9IGFuaW1hdGUgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBhbmltYXRlO1xuICAgICAgICBzZWxlY3Rpb24uc2VsZWN0QWxsKFwiLmNoYXJ0LWxhYmVsc1wiKS5yZW1vdmUoKTtcblxuICAgICAgICBsZXQgbGFiZWxzID0gc2VsZWN0aW9uLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJjaGFydC1sYWJlbHNcIilcbiAgICAgICAgICAgIC5zZWxlY3RBbGwoXCIubGFiZWwtZ3JvdXBcIilcbiAgICAgICAgICAgIC5kYXRhKGRhdGEpO1xuXG4gICAgICAgIGxldCBmb250U2l6ZSA9IHRoaXMuX2ZvbnRfc2l6ZTsgICAgLy8gT3VyIGluaXRpYWwgZm9udCBzaXplLlxuICAgICAgICBjb25zdCBidWZmZXIgPSA1OyAgICAgLy8gQnVmZmVyIHNwYWNlIGJldHdlZW4gd29yZHMgYW5kIHRoZSB0b3Agb2YgYSBiYXIuXG5cbiAgICAgICAgbGFiZWxzLmVudGVyKCkuZWFjaCgoc2VyaWVzLCBzX2ksIHNfbm9kZXMpID0+IHtcbiAgICAgICAgICAgIGxldCBncm91cCA9IGQzLnNlbGVjdChzX25vZGVzW3NfaV0pXG4gICAgICAgICAgICAgICAgLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwibGFiZWwtZ3JvdXBcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBkID0+IFwidHJhbnNsYXRlKDAsXCIgKyB5c2NhbGUoZC5rZXkpICsgXCIpXCIpXG4gICAgICAgICAgICAgICAgLnNlbGVjdEFsbChcIi5jaGFydC1sYWJlbFwiKVxuICAgICAgICAgICAgICAgIC5kYXRhKHNlcmllcy5kYXRhKVxuICAgICAgICAgICAgICAgIC5lbnRlcigpXG4gICAgICAgICAgICAgICAgLmVhY2goKGQsIGksIG5vZGVzKSA9PiB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gV2FudCB0byBmaWd1cmUgb3V0IGlmIHRoZSBsYWJlbCBpcyB0b28gZGFyayAvIGxpZ2h0IGZvciB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gYmFyLlxuICAgICAgICAgICAgICAgICAgICBsZXQgaW52ZXJ0ZWRDb2xvciA9IGQzLmhjbCh0aGlzLmdldFNlcmllc0NvbG91cihpKSk7XG4gICAgICAgICAgICAgICAgICAgIGludmVydGVkQ29sb3IubCArPSBNYXRoLm1pbihpbnZlcnRlZENvbG9yLmwgKyA1MCwgMTAwKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGludmVydCA9IGQzLmhjbCh0aGlzLmdldFNlcmllc0NvbG91cihpKSkubCA8IDYwO1xuXG4gICAgICAgICAgICAgICAgICAgIGxldCB4cG9zID0geHNjYWxlKGQuX3kpO1xuXG4gICAgICAgICAgICAgICAgICAgIGxldCB0ZXh0ID0gZDMuc2VsZWN0KG5vZGVzW2ldKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC50ZXh0KHRoaXMuX2xhYmVsRm9ybWF0KGQuX3kpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJjaGFydC1sYWJlbFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwieFwiLCB4cG9zICsgYnVmZmVyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiZHhcIiwgYW5pbWF0ZSA/IC0xNSA6IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcInBvaW50ZXItZXZlbnRzXCIsIFwibm9uZVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcImZvbnQtc2l6ZVwiLCBmb250U2l6ZSArIFwicHhcIik7XG5cblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBiYiA9IHRleHQubm9kZSgpLmdldEJCb3goKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3ZlcnNpemUgPSB4cG9zICsgYmIud2lkdGggKyBidWZmZXIgPiB4c2NhbGUucmFuZ2UoKVsxXTtcblxuICAgICAgICAgICAgICAgICAgICB0ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcInlcIiwgeWdyb3VwKGQuX2tleSkgKyBmb250U2l6ZSAvIDIgKyB5Z3JvdXAuYmFuZHdpZHRoKCkgLyAyKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIG92ZXJzaXplID8geHBvcyAtIGJ1ZmZlciAtIGJiLndpZHRoIDogeHBvcyArIGJ1ZmZlcilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcImZpbGxcIiwgb3ZlcnNpemUgJiYgaW52ZXJ0ID8gaW52ZXJ0ZWRDb2xvci50b1N0cmluZygpIDogY29sb3Vycy5laWdodGVlbi5kYXJrR3JleSk7XG5cbiAgICAgICAgICAgICAgICAgICAgdGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgLnRyYW5zaXRpb24oXCJsYWJlbHNcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5kZWxheSgoKSA9PiBhbmltYXRlID8gdGhpcy5jYWxjQmFyR3Jvd3RoKHNfaSwgc19ub2Rlcy5sZW5ndGgpIDogMCkgLy8gRGVsYXkgaW4gbG9ja3N0ZXAgd2l0aCBiYXIgZ3Jvd3RoLlxuICAgICAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKHRoaXMuX2R1cmF0aW9uKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJkeFwiLCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAxKVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuXG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHJlbmRlckRhdGFBeGlzTGFiZWwod2lkdGgsIG1hcmdpbnMpIHtcbiAgICAgICAgbGV0IHN2ZyA9IGQzLnNlbGVjdCh0aGlzLl9lbGVtZW50KS5zZWxlY3QoJ3N2ZycpO1xuICAgICAgICBzdmcuc2VsZWN0QWxsKFwiLmRhdGEtbGFiZWxzXCIpLnJlbW92ZSgpO1xuXG4gICAgICAgIGlmICghdGhpcy5fZGF0YUF4aXNMYWJlbCkgcmV0dXJuO1xuICAgICAgICBsZXQgdGV4dCA9IHRoaXMuX2RhdGFBeGlzTGFiZWw7XG4gICAgICAgIGlmICh0ZXh0LmxvbmcpIHRleHQgPSB0ZXh0Lmxvbmc7XG5cbiAgICAgICAgbGV0IHggPSAobWFyZ2lucy5sZWZ0ICsgd2lkdGggLyAyKTtcblxuICAgICAgICBsZXQgbGFiZWwgPSBzdmcuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImRhdGEtbGFiZWxzXCIpXG4gICAgICAgICAgICAuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgICAgICAgLnRleHQodGV4dClcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgeCArIFwiLFwiICsgKHRoaXMuX2hlaWdodCAtIG1hcmdpbnMuYm90dG9tICsgNTApICsgXCIpXCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIGNvbG91cnMuZWlnaHRlZW4uZGFya0dyZXkpO1xuXG4gICAgICAgIGxldCB0ZXh0V2lkdGggPSBsYWJlbC5ub2RlKCkuZ2V0QkJveCgpLndpZHRoO1xuICAgICAgICBpZiAodGV4dFdpZHRoID49IHdpZHRoICYmIHRoaXMuX2RhdGFBeGlzTGFiZWwuc2hvcnQpIHtcbiAgICAgICAgICAgIGxhYmVsLnRleHQodGhpcy5fZGF0YUF4aXNMYWJlbC5zaG9ydCk7XG4gICAgICAgICAgICB0ZXh0V2lkdGggPSBsYWJlbC5ub2RlKCkuZ2V0QkJveCgpLndpZHRoO1xuICAgICAgICB9XG5cbiAgICAgICAgbGFiZWwuYXR0cihcImR4XCIsIC10ZXh0V2lkdGggLyAyKTtcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cblxuICAgIGdyaWQoc2VsZWN0aW9uLCBoZWlnaHQsIGF4aXMpIHtcbiAgICAgICAgc2VsZWN0aW9uLnNlbGVjdChcIi5ncmlkXCIpLnJlbW92ZSgpO1xuXG4gICAgICAgIGxldCBncmlkID0gc2VsZWN0aW9uLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJncmlkXCIpXG4gICAgICAgICAgICAuY2FsbChheGlzXG4gICAgICAgICAgICAgICAgLnRpY2tTaXplKGhlaWdodClcbiAgICAgICAgICAgICAgICAudGlja0Zvcm1hdChcIlwiKVxuICAgICAgICAgICAgKTtcblxuICAgICAgICBncmlkLnNlbGVjdEFsbChcImxpbmVcIilcbiAgICAgICAgICAgIC5zdHlsZShcInN0cm9rZVwiLCBjb2xvdXJzLmVpZ2h0ZWVuLmxpZ2h0R3JleSk7XG4gICAgICAgIGdyaWQuc2VsZWN0QWxsKFwiLmRvbWFpblwiKS5yZW1vdmUoKTtcblxuICAgICAgICBncmlkXG4gICAgICAgICAgICAubG93ZXIoKSAvLyBBbHdheXMgZW5zdXJlIHRoYXQgdGhpcyBpcyBlYXJsaWVyIGluIHRoZSBkb20uIFRoaW5ncyBtdXN0IGJlIGRyYXduIG9uIHRvcCBvZiBpdC5cbiAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMClcbiAgICAgICAgICAgIC50cmFuc2l0aW9uKClcbiAgICAgICAgICAgIC5kZWxheSg1MDApXG4gICAgICAgICAgICAuZHVyYXRpb24oNTAwKVxuICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAxKTtcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgbGFiZWxBeGlzKHNlbGVjdGlvbiwgYXhpc19vYmplY3QpIHtcbiAgICAgICAgc2VsZWN0aW9uLnNlbGVjdChcIi5sYWJlbC1heGlzXCIpLnJlbW92ZSgpO1xuICAgICAgICBsZXQgYXhpcyA9IHNlbGVjdGlvbi5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwibGFiZWwtYXhpc1wiKVxuICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAwKVxuICAgICAgICAgICAgLmNhbGwoYXhpc19vYmplY3QpO1xuXG4gICAgICAgIGF4aXMuc2VsZWN0KFwiLmRvbWFpblwiKS5yZW1vdmUoKTtcblxuICAgICAgICBsZXQgbWF4ID0gMDtcbiAgICAgICAgYXhpcy5zZWxlY3RBbGwoXCJ0ZXh0XCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJmb250LXNpemVcIiwgdGhpcy5fZm9udF9zaXplICsgXCJweFwiKVxuICAgICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBjb2xvdXJzLmVpZ2h0ZWVuLmRhcmtHcmV5KVxuICAgICAgICAgICAgLm5vZGVzKClcbiAgICAgICAgICAgIC5mb3JFYWNoKHRleHQgPT4gbWF4ID0gTWF0aC5tYXgobWF4LCB0ZXh0LmdldEJCb3goKS53aWR0aCkpO1xuXG4gICAgICAgIGF4aXNcbiAgICAgICAgICAgIC50cmFuc2l0aW9uKClcbiAgICAgICAgICAgIC5kdXJhdGlvbigxMDAwKVxuICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAxKTtcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgZGF0YUF4aXMoc2VsZWN0aW9uLCBoZWlnaHQsIGF4aXNfb2JqZWN0KSB7XG4gICAgICAgIHNlbGVjdGlvbi5zZWxlY3QoXCIuZGF0YS1heGlzXCIpLnJlbW92ZSgpO1xuICAgICAgICBsZXQgYXhpcyA9IHNlbGVjdGlvbi5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImRhdGEtYXhpc1wiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKDAsXCIgKyBoZWlnaHQgKyBcIilcIilcbiAgICAgICAgICAgIC5jYWxsKGF4aXNfb2JqZWN0LnRpY2tTaXplKDApLnRpY2tQYWRkaW5nKDEwKSlcbiAgICAgICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDApXG4gICAgICAgICAgICAudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAuZHVyYXRpb24oMTAwMClcbiAgICAgICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDEpO1xuXG4gICAgICAgIGF4aXMuc2VsZWN0QWxsKFwidGV4dFwiKVxuICAgICAgICAgICAgICAgIC5zdHlsZShcImZpbGxcIiwgY29sb3Vycy5laWdodGVlbi5kYXJrR3JleSlcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgY2FsY0Jhckdyb3d0aChpLCBtYXgpIHtcbiAgICAgICAgaWYgKG1heCA8IDEwKSByZXR1cm4gaSAqIHRoaXMuX0JBUl9HUk9XVEggLyAyO1xuICAgICAgICBpZiAobWF4IDwgMzUpIHJldHVybiBpICogdGhpcy5fQkFSX0dST1dUSCAvIDQ7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIGdldFNlcmllc0NvbG91cihpKSB7XG4gICAgICAgIGlmIChpIDwgMCB8fCAhdGhpcy5fY29sb3VycykgcmV0dXJuIGNvbG91cnMuZWlnaHRlZW4ubWlkR3JleTtcblxuICAgICAgICBpID0gaSAlIHRoaXMuX2NvbG91cnMubGVuZ3RoO1xuICAgICAgICByZXR1cm4gdGhpcy5fY29sb3Vyc1tpXTtcbiAgICB9XG5cbiAgICBnZXRTb3J0ZWREYXRhKCkge1xuICAgICAgICBsZXQgZGF0YSA9IHRoaXMuX2RhdGE7XG4gICAgICAgIGlmICghZGF0YSB8fCAhZGF0YS5sZW5ndGgpIHJldHVybiBbXTtcblxuICAgICAgICBkYXRhID0gdGhpcy5fZGF0YS5zb3J0KChsaHMsIHJocykgPT4ge1xuICAgICAgICAgICAgbGhzID0gbGhzLmtleS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgcmhzID0gcmhzLmtleS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgICAgICBpZiAobGhzID09PSByaHMpIHJldHVybiAwO1xuICAgICAgICAgICAgaWYgKGxocyA8IHJocykgcmV0dXJuIC0xO1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIGdldFRyYW5zZm9ybWVkRGF0YSgpIHtcbiAgICAgICAgbGV0IGRhdGEgPSB0aGlzLmdldFNvcnRlZERhdGEoKTtcbiAgICAgICAgaWYgKCFkYXRhIHx8ICFkYXRhLmxlbmd0aCkgcmV0dXJuIFtdO1xuXG4gICAgICAgIGxldCByZXN1bHRzID0gW107XG5cbiAgICAgICAgY29uc3QgZ2V0WCA9IGQgPT4gdGhpcy5feEF4aXNPdmVycmlkZSA/IHRoaXMuX3hBeGlzT3ZlcnJpZGVbdGhpcy5feChkKV0gOiB0aGlzLl94KGQpO1xuXG4gICAgICAgIGRhdGEuZm9yRWFjaCgoc2VyaWVzLCBzX2kpID0+IHtcbiAgICAgICAgICAgIHNlcmllcy52YWx1ZXMuZm9yRWFjaCgoZCwgZF9pKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGZpZWxkID0gcmVzdWx0cy5maW5kKGJ1Y2tldCA9PiBidWNrZXQua2V5ID09PSBnZXRYKGQpKTtcbiAgICAgICAgICAgICAgICBpZiAoIWZpZWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6IGdldFgoZClcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGZpZWxkKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmaWVsZC5kYXRhLnB1c2goT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICAgICAgICAgIF9zZXJpZXM6IHNlcmllcyxcbiAgICAgICAgICAgICAgICAgICAgX3NfaTogc19pLFxuICAgICAgICAgICAgICAgICAgICBfa2V5OiBzZXJpZXMua2V5LFxuICAgICAgICAgICAgICAgICAgICBfeTogdGhpcy5feShkKVxuICAgICAgICAgICAgICAgIH0sIGQpKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cblxuICAgIGdldEtleXMoKSB7XG4gICAgICAgIGxldCBkYXRhID0gdGhpcy5fZGF0YTtcbiAgICAgICAgaWYgKCFkYXRhIHx8ICFkYXRhLmxlbmd0aCkgcmV0dXJuIFtdO1xuXG4gICAgICAgIHJldHVybiBbLi4ubmV3IFNldChkYXRhLm1hcChkID0+IGQua2V5KSldXG4gICAgfVxufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/BarChart.js\n')},"./src/Chart.js":
/*!**********************!*\
  !*** ./src/Chart.js ***!
  \**********************/
/*! exports provided: Chart */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Chart", function() { return Chart; });\n/* harmony import */ var _Colours__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Colours */ "./src/Colours.js");\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers */ "./src/helpers.js");\n// Copyright (C) 2013-2014, 2018 BrandsEye (PTY) LTD\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this\n// software and associated documentation files (the "Software"), to deal in the Software\n// without restriction, including without limitation the rights to use, copy, modify,\n//     merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following\n// conditions:\n//\n//     The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n//     INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n// CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n\n\n\nclass Chart {\n    constructor() {\n        this._x = (d) => d.x;\n        this._y = (d) => d.y;\n        this._height = 420;\n        this._width = 420;\n        this._BAR_GROWTH = 100;\n        this._duration = 300;\n        this._dispatch = d3.dispatch(\'elementClick\', \'elementMiddleClick\', \'elementRightClick\',\n            \'tooltipShow\', \'tooltipHide\');\n        this._xAxisTickFormat = this._tickFormat = this._labelFormat = d => d.toString();\n        this._colours = [ _Colours__WEBPACK_IMPORTED_MODULE_0__["colours"].eighteen.midGrey, _Colours__WEBPACK_IMPORTED_MODULE_0__["colours"].eighteen.lightGrey, _Colours__WEBPACK_IMPORTED_MODULE_0__["colours"].eighteen.darkGrey ];\n        this._backgroundColour = "#FFF";\n        this._interbarProportion = null;\n    }\n\n    renderLegend(svg, data, min, width, height, getter) {\n        svg = svg || d3.select(this._element).select("svg");\n        svg.selectAll(".legend").remove();\n        if (!this._show_legend) return 0;\n\n        min = min || 2;\n        data = data || this.getSortedData();\n        width = width || this._width;\n        height = height || this._height;\n        getter = getter || (d => d.key);\n\n        // Only if we have multiple series.\n        if (!data || data.length < min) return 0;\n\n        let maxWidth = Object(_helpers__WEBPACK_IMPORTED_MODULE_1__["maxBounding"])(svg, data.map(getter)).width;\n\n        const legend = svg.append("g")\n            .attr("class", "legend");\n\n        let elements = legend.selectAll(".legend-element")\n            .data(data);\n\n        const position_start = 20;\n        let position = position_start;\n        let position_height = 0;\n\n        elements.enter()\n            .append("g")\n            .attr("class", (d, i) => "legend-element series series-" + i)\n            .style("cursor", "default")\n            .each((d, i, nodes) => {\n                let element = d3.select(nodes[i]);\n\n                element.append("rect")\n                    .attr("width", 10)\n                    .attr("height", 10)\n                    .attr("rx", 2)\n                    .attr("ry", 2)\n                    .attr("y", -10)\n                    .style("fill", () => this.getSeriesColour(i));\n\n                element.append("text")\n                    .text(getter)\n                    .attr("dx", 12)\n                    .style("font-family", "Open Sans, sans-serif")\n                    .style("font-weight", "normal")\n                    .style("font-size", "12px")\n                    .style("fill", _Colours__WEBPACK_IMPORTED_MODULE_0__["colours"].eighteen.darkGrey);\n\n                element.append("title")\n                    .text(getter);\n\n                element.attr("transform", "translate(" + position + "," + position_height +")");\n                const positionDelta = maxWidth + 20; // element.node().getBBox().width + 10;\n                position += positionDelta;\n\n                if (position >= width) {\n                    position = position_start;\n                    position_height += 15;\n                    element.attr("transform", "translate(" + position + "," + position_height + ")");\n                    position += positionDelta;\n                }\n\n            })\n            .on("mouseover", (d, i, nodes) => {\n                svg.selectAll(".series:not(.series-" + i + ")")\n                    .interrupt("legend:highlight")\n                    .transition("legend:highlight")\n                    .style("opacity", 0.3);\n            })\n            .on("mouseout", (d, i, nodes) => {\n                svg.selectAll(".series")\n                    .interrupt("legend:highlight")\n                    .transition("legend:highlight")\n                    .style("opacity", 1);\n            })\n            .style("opacity", 0)\n            .transition()\n            .duration(1000)\n            .style("opacity", 1);\n\n        const legendHeight = legend.node().getBBox().height;\n        legend.attr("transform", "translate(0," + (height - legendHeight) + ")");\n        return legendHeight;\n    }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvQ2hhcnQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9iM2pzLy4vc3JjL0NoYXJ0LmpzPzYyYWUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChDKSAyMDEzLTIwMTQsIDIwMTggQnJhbmRzRXllIChQVFkpIExURFxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpc1xuLy8gc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlXG4vLyB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksXG4vLyAgICAgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0b1xuLy8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcbi8vIGNvbmRpdGlvbnM6XG4vL1xuLy8gICAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuLy8gY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyAgICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUiBJTVBMSUVELFxuLy8gICAgIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBXG4vLyBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUXG4vLyBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0Zcbi8vIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRVxuLy8gT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCB7Y29sb3Vyc30gZnJvbSAnLi9Db2xvdXJzJztcbmltcG9ydCB7IG1heEJvdW5kaW5nIH0gZnJvbSBcIi4vaGVscGVyc1wiO1xuXG5cblxuZXhwb3J0IGNsYXNzIENoYXJ0IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5feCA9IChkKSA9PiBkLng7XG4gICAgICAgIHRoaXMuX3kgPSAoZCkgPT4gZC55O1xuICAgICAgICB0aGlzLl9oZWlnaHQgPSA0MjA7XG4gICAgICAgIHRoaXMuX3dpZHRoID0gNDIwO1xuICAgICAgICB0aGlzLl9CQVJfR1JPV1RIID0gMTAwO1xuICAgICAgICB0aGlzLl9kdXJhdGlvbiA9IDMwMDtcbiAgICAgICAgdGhpcy5fZGlzcGF0Y2ggPSBkMy5kaXNwYXRjaCgnZWxlbWVudENsaWNrJywgJ2VsZW1lbnRNaWRkbGVDbGljaycsICdlbGVtZW50UmlnaHRDbGljaycsXG4gICAgICAgICAgICAndG9vbHRpcFNob3cnLCAndG9vbHRpcEhpZGUnKTtcbiAgICAgICAgdGhpcy5feEF4aXNUaWNrRm9ybWF0ID0gdGhpcy5fdGlja0Zvcm1hdCA9IHRoaXMuX2xhYmVsRm9ybWF0ID0gZCA9PiBkLnRvU3RyaW5nKCk7XG4gICAgICAgIHRoaXMuX2NvbG91cnMgPSBbIGNvbG91cnMuZWlnaHRlZW4ubWlkR3JleSwgY29sb3Vycy5laWdodGVlbi5saWdodEdyZXksIGNvbG91cnMuZWlnaHRlZW4uZGFya0dyZXkgXTtcbiAgICAgICAgdGhpcy5fYmFja2dyb3VuZENvbG91ciA9IFwiI0ZGRlwiO1xuICAgICAgICB0aGlzLl9pbnRlcmJhclByb3BvcnRpb24gPSBudWxsO1xuICAgIH1cblxuICAgIHJlbmRlckxlZ2VuZChzdmcsIGRhdGEsIG1pbiwgd2lkdGgsIGhlaWdodCwgZ2V0dGVyKSB7XG4gICAgICAgIHN2ZyA9IHN2ZyB8fCBkMy5zZWxlY3QodGhpcy5fZWxlbWVudCkuc2VsZWN0KFwic3ZnXCIpO1xuICAgICAgICBzdmcuc2VsZWN0QWxsKFwiLmxlZ2VuZFwiKS5yZW1vdmUoKTtcbiAgICAgICAgaWYgKCF0aGlzLl9zaG93X2xlZ2VuZCkgcmV0dXJuIDA7XG5cbiAgICAgICAgbWluID0gbWluIHx8IDI7XG4gICAgICAgIGRhdGEgPSBkYXRhIHx8IHRoaXMuZ2V0U29ydGVkRGF0YSgpO1xuICAgICAgICB3aWR0aCA9IHdpZHRoIHx8IHRoaXMuX3dpZHRoO1xuICAgICAgICBoZWlnaHQgPSBoZWlnaHQgfHwgdGhpcy5faGVpZ2h0O1xuICAgICAgICBnZXR0ZXIgPSBnZXR0ZXIgfHwgKGQgPT4gZC5rZXkpO1xuXG4gICAgICAgIC8vIE9ubHkgaWYgd2UgaGF2ZSBtdWx0aXBsZSBzZXJpZXMuXG4gICAgICAgIGlmICghZGF0YSB8fCBkYXRhLmxlbmd0aCA8IG1pbikgcmV0dXJuIDA7XG5cbiAgICAgICAgbGV0IG1heFdpZHRoID0gbWF4Qm91bmRpbmcoc3ZnLCBkYXRhLm1hcChnZXR0ZXIpKS53aWR0aDtcblxuICAgICAgICBjb25zdCBsZWdlbmQgPSBzdmcuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImxlZ2VuZFwiKTtcblxuICAgICAgICBsZXQgZWxlbWVudHMgPSBsZWdlbmQuc2VsZWN0QWxsKFwiLmxlZ2VuZC1lbGVtZW50XCIpXG4gICAgICAgICAgICAuZGF0YShkYXRhKTtcblxuICAgICAgICBjb25zdCBwb3NpdGlvbl9zdGFydCA9IDIwO1xuICAgICAgICBsZXQgcG9zaXRpb24gPSBwb3NpdGlvbl9zdGFydDtcbiAgICAgICAgbGV0IHBvc2l0aW9uX2hlaWdodCA9IDA7XG5cbiAgICAgICAgZWxlbWVudHMuZW50ZXIoKVxuICAgICAgICAgICAgLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgKGQsIGkpID0+IFwibGVnZW5kLWVsZW1lbnQgc2VyaWVzIHNlcmllcy1cIiArIGkpXG4gICAgICAgICAgICAuc3R5bGUoXCJjdXJzb3JcIiwgXCJkZWZhdWx0XCIpXG4gICAgICAgICAgICAuZWFjaCgoZCwgaSwgbm9kZXMpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgZWxlbWVudCA9IGQzLnNlbGVjdChub2Rlc1tpXSk7XG5cbiAgICAgICAgICAgICAgICBlbGVtZW50LmFwcGVuZChcInJlY3RcIilcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCAxMClcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgMTApXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFwicnhcIiwgMilcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJyeVwiLCAyKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcInlcIiwgLTEwKVxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJmaWxsXCIsICgpID0+IHRoaXMuZ2V0U2VyaWVzQ29sb3VyKGkpKTtcblxuICAgICAgICAgICAgICAgIGVsZW1lbnQuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgICAgICAgICAgICAgICAudGV4dChnZXR0ZXIpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiZHhcIiwgMTIpXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZShcImZvbnQtZmFtaWx5XCIsIFwiT3BlbiBTYW5zLCBzYW5zLXNlcmlmXCIpXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZShcImZvbnQtd2VpZ2h0XCIsIFwibm9ybWFsXCIpXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZShcImZvbnQtc2l6ZVwiLCBcIjEycHhcIilcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBjb2xvdXJzLmVpZ2h0ZWVuLmRhcmtHcmV5KTtcblxuICAgICAgICAgICAgICAgIGVsZW1lbnQuYXBwZW5kKFwidGl0bGVcIilcbiAgICAgICAgICAgICAgICAgICAgLnRleHQoZ2V0dGVyKTtcblxuICAgICAgICAgICAgICAgIGVsZW1lbnQuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIHBvc2l0aW9uICsgXCIsXCIgKyBwb3NpdGlvbl9oZWlnaHQgK1wiKVwiKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwb3NpdGlvbkRlbHRhID0gbWF4V2lkdGggKyAyMDsgLy8gZWxlbWVudC5ub2RlKCkuZ2V0QkJveCgpLndpZHRoICsgMTA7XG4gICAgICAgICAgICAgICAgcG9zaXRpb24gKz0gcG9zaXRpb25EZWx0YTtcblxuICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA+PSB3aWR0aCkge1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IHBvc2l0aW9uX3N0YXJ0O1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbl9oZWlnaHQgKz0gMTU7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIHBvc2l0aW9uICsgXCIsXCIgKyBwb3NpdGlvbl9oZWlnaHQgKyBcIilcIik7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uICs9IHBvc2l0aW9uRGVsdGE7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLm9uKFwibW91c2VvdmVyXCIsIChkLCBpLCBub2RlcykgPT4ge1xuICAgICAgICAgICAgICAgIHN2Zy5zZWxlY3RBbGwoXCIuc2VyaWVzOm5vdCguc2VyaWVzLVwiICsgaSArIFwiKVwiKVxuICAgICAgICAgICAgICAgICAgICAuaW50ZXJydXB0KFwibGVnZW5kOmhpZ2hsaWdodFwiKVxuICAgICAgICAgICAgICAgICAgICAudHJhbnNpdGlvbihcImxlZ2VuZDpoaWdobGlnaHRcIilcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAwLjMpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbihcIm1vdXNlb3V0XCIsIChkLCBpLCBub2RlcykgPT4ge1xuICAgICAgICAgICAgICAgIHN2Zy5zZWxlY3RBbGwoXCIuc2VyaWVzXCIpXG4gICAgICAgICAgICAgICAgICAgIC5pbnRlcnJ1cHQoXCJsZWdlbmQ6aGlnaGxpZ2h0XCIpXG4gICAgICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKFwibGVnZW5kOmhpZ2hsaWdodFwiKVxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDEpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMClcbiAgICAgICAgICAgIC50cmFuc2l0aW9uKClcbiAgICAgICAgICAgIC5kdXJhdGlvbigxMDAwKVxuICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAxKTtcblxuICAgICAgICBjb25zdCBsZWdlbmRIZWlnaHQgPSBsZWdlbmQubm9kZSgpLmdldEJCb3goKS5oZWlnaHQ7XG4gICAgICAgIGxlZ2VuZC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKDAsXCIgKyAoaGVpZ2h0IC0gbGVnZW5kSGVpZ2h0KSArIFwiKVwiKTtcbiAgICAgICAgcmV0dXJuIGxlZ2VuZEhlaWdodDtcbiAgICB9XG59Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/Chart.js\n')},"./src/Colours.js":
/*!************************!*\
  !*** ./src/Colours.js ***!
  \************************/
/*! exports provided: colours */function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"colours\", function() { return colours; });\n// Copyright (C) 2013-2014, 2018 BrandsEye (PTY) LTD\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this\n// software and associated documentation files (the \"Software\"), to deal in the Software\n// without restriction, including without limitation the rights to use, copy, modify,\n//     merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following\n// conditions:\n//\n//     The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n//     INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n// CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\nlet colours = {\n  // **brandseye.colours.scheme** is our basic colour scheme.\n    scheme: [\n        '#58B6FF',\n        '#5473BD',\n        '#DF71FC',\n        '#9856B0',\n        '#ff58a3',\n        '#D22D6F',\n        '#fc6a4b',\n        '#E53E39',\n        '#FFD658',\n        '#E8AF44',\n        '#43C278',\n        '#318F58'\n    ],\n    // And **brandseye.colours.allColours** defines a large number of colours.\n    allColours: [\n        '#f0f8ff', '#faebd7', '#00ffff', '#7fffd4', '#f0ffff', '#f5f5dc', '#ffe4c4', '#000000', '#ffebcd', '#0000ff', '#8a2be2',\n        '#a52a2a', '#deb887', '#5f9ea0', '#7fff00', '#d2691e', '#ff7f50', '#6495ed', '#fff8dc', '#dc143c', '#00ffff', '#00008b',\n        '#008b8b', '#b8860b', '#a9a9a9', '#006400', '#bdb76b', '#8b008b', '#556b2f', '#ff8c00', '#9932cc', '#8b0000', '#e9967a',\n        '#8fbc8f', '#483d8b', '#2f4f4f', '#00ced1', '#9400d3', '#ff1493', '#00bfff', '#696969', '#1e90ff', '#d19275', '#b22222',\n        '#fffaf0', '#228b22', '#ff00ff', '#dcdcdc', '#f8f8ff', '#ffd700', '#daa520', '#808080', '#008000', '#adff2f', '#f0fff0',\n        '#ff69b4', '#cd5c5c', '#4b0082', '#fffff0', '#f0e68c', '#e6e6fa', '#fff0f5', '#7cfc00', '#fffacd', '#add8e6', '#f08080',\n        '#e0ffff', '#fafad2', '#d3d3d3', '#90ee90', '#ffb6c1', '#ffa07a', '#20b2aa', '#87cefa', '#8470ff', '#778899', '#b0c4de',\n        '#ffffe0', '#00ff00', '#32cd32', '#faf0e6', '#ff00ff', '#800000', '#66cdaa', '#0000cd', '#ba55d3', '#9370d8', '#3cb371',\n        '#7b68ee', '#00fa9a', '#48d1cc', '#c71585', '#191970', '#f5fffa', '#ffe4e1', '#ffe4b5', '#ffdead', '#000080', '#fdf5e6',\n        '#808000', '#6b8e23', '#ffa500', '#ff4500', '#da70d6', '#eee8aa', '#98fb98', '#afeeee', '#d87093', '#ffefd5', '#ffdab9',\n        '#cd853f', '#ffc0cb', '#dda0dd', '#b0e0e6', '#800080', '#ff0000', '#bc8f8f', '#4169e1', '#8b4513', '#fa8072', '#f4a460',\n        '#2e8b57', '#fff5ee', '#a0522d', '#c0c0c0', '#87ceeb', '#6a5acd', '#708090', '#fffafa', '#00ff7f', '#4682b4', '#d2b48c',\n        '#008080', '#d8bfd8', '#ff6347', '#40e0d0', '#ee82ee', '#d02090', '#f5deb3', '#ffffff', '#f5f5f5', '#ffff00', '#9acd32'\n    ],\n\n    // These are the new brandseye colours for 2018, defined in reporting v.4.5.8\n    eighteen: {\n      good: \"#00c9a0\",       // Bright Green\n      series: [\n        \"#eba25d\",           // Muted orange\n        \"#9cd261\",           // Green\n        \"#958cb5\",           // Purple\n      ],\n      lightGrey: \"#e9e9e9\",  // gridlines, bars and columns, neutral sentiment\n      midGrey: \"#c0c0c0\",    // table borders, bars and columns if light grey is too lightGrey\n      darkGrey: \"#444444\",   // All text\n      sentiment: {\n        positive: \"#00b0b9\", // blue\n        neutral: \"#e9e9e9\",  // light grey\n        negative: \"#ee2737\", // Red\n        net: \"#1c1f2a\"       // Elite\n      }\n    }\n\n\n\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvQ29sb3Vycy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2IzanMvLi9zcmMvQ29sb3Vycy5qcz8yY2RhIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoQykgMjAxMy0yMDE0LCAyMDE4IEJyYW5kc0V5ZSAoUFRZKSBMVERcbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXNcbi8vIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZVxuLy8gd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LFxuLy8gICAgIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG9cbi8vIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nXG4vLyBjb25kaXRpb25zOlxuLy9cbi8vICAgICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbi8vIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gICAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1IgSU1QTElFRCxcbi8vICAgICBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQVxuLy8gUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxuLy8gSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GXG4vLyBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkVcbi8vIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5cbmV4cG9ydCBsZXQgY29sb3VycyA9IHtcbiAgLy8gKipicmFuZHNleWUuY29sb3Vycy5zY2hlbWUqKiBpcyBvdXIgYmFzaWMgY29sb3VyIHNjaGVtZS5cbiAgICBzY2hlbWU6IFtcbiAgICAgICAgJyM1OEI2RkYnLFxuICAgICAgICAnIzU0NzNCRCcsXG4gICAgICAgICcjREY3MUZDJyxcbiAgICAgICAgJyM5ODU2QjAnLFxuICAgICAgICAnI2ZmNThhMycsXG4gICAgICAgICcjRDIyRDZGJyxcbiAgICAgICAgJyNmYzZhNGInLFxuICAgICAgICAnI0U1M0UzOScsXG4gICAgICAgICcjRkZENjU4JyxcbiAgICAgICAgJyNFOEFGNDQnLFxuICAgICAgICAnIzQzQzI3OCcsXG4gICAgICAgICcjMzE4RjU4J1xuICAgIF0sXG4gICAgLy8gQW5kICoqYnJhbmRzZXllLmNvbG91cnMuYWxsQ29sb3VycyoqIGRlZmluZXMgYSBsYXJnZSBudW1iZXIgb2YgY29sb3Vycy5cbiAgICBhbGxDb2xvdXJzOiBbXG4gICAgICAgICcjZjBmOGZmJywgJyNmYWViZDcnLCAnIzAwZmZmZicsICcjN2ZmZmQ0JywgJyNmMGZmZmYnLCAnI2Y1ZjVkYycsICcjZmZlNGM0JywgJyMwMDAwMDAnLCAnI2ZmZWJjZCcsICcjMDAwMGZmJywgJyM4YTJiZTInLFxuICAgICAgICAnI2E1MmEyYScsICcjZGViODg3JywgJyM1ZjllYTAnLCAnIzdmZmYwMCcsICcjZDI2OTFlJywgJyNmZjdmNTAnLCAnIzY0OTVlZCcsICcjZmZmOGRjJywgJyNkYzE0M2MnLCAnIzAwZmZmZicsICcjMDAwMDhiJyxcbiAgICAgICAgJyMwMDhiOGInLCAnI2I4ODYwYicsICcjYTlhOWE5JywgJyMwMDY0MDAnLCAnI2JkYjc2YicsICcjOGIwMDhiJywgJyM1NTZiMmYnLCAnI2ZmOGMwMCcsICcjOTkzMmNjJywgJyM4YjAwMDAnLCAnI2U5OTY3YScsXG4gICAgICAgICcjOGZiYzhmJywgJyM0ODNkOGInLCAnIzJmNGY0ZicsICcjMDBjZWQxJywgJyM5NDAwZDMnLCAnI2ZmMTQ5MycsICcjMDBiZmZmJywgJyM2OTY5NjknLCAnIzFlOTBmZicsICcjZDE5Mjc1JywgJyNiMjIyMjInLFxuICAgICAgICAnI2ZmZmFmMCcsICcjMjI4YjIyJywgJyNmZjAwZmYnLCAnI2RjZGNkYycsICcjZjhmOGZmJywgJyNmZmQ3MDAnLCAnI2RhYTUyMCcsICcjODA4MDgwJywgJyMwMDgwMDAnLCAnI2FkZmYyZicsICcjZjBmZmYwJyxcbiAgICAgICAgJyNmZjY5YjQnLCAnI2NkNWM1YycsICcjNGIwMDgyJywgJyNmZmZmZjAnLCAnI2YwZTY4YycsICcjZTZlNmZhJywgJyNmZmYwZjUnLCAnIzdjZmMwMCcsICcjZmZmYWNkJywgJyNhZGQ4ZTYnLCAnI2YwODA4MCcsXG4gICAgICAgICcjZTBmZmZmJywgJyNmYWZhZDInLCAnI2QzZDNkMycsICcjOTBlZTkwJywgJyNmZmI2YzEnLCAnI2ZmYTA3YScsICcjMjBiMmFhJywgJyM4N2NlZmEnLCAnIzg0NzBmZicsICcjNzc4ODk5JywgJyNiMGM0ZGUnLFxuICAgICAgICAnI2ZmZmZlMCcsICcjMDBmZjAwJywgJyMzMmNkMzInLCAnI2ZhZjBlNicsICcjZmYwMGZmJywgJyM4MDAwMDAnLCAnIzY2Y2RhYScsICcjMDAwMGNkJywgJyNiYTU1ZDMnLCAnIzkzNzBkOCcsICcjM2NiMzcxJyxcbiAgICAgICAgJyM3YjY4ZWUnLCAnIzAwZmE5YScsICcjNDhkMWNjJywgJyNjNzE1ODUnLCAnIzE5MTk3MCcsICcjZjVmZmZhJywgJyNmZmU0ZTEnLCAnI2ZmZTRiNScsICcjZmZkZWFkJywgJyMwMDAwODAnLCAnI2ZkZjVlNicsXG4gICAgICAgICcjODA4MDAwJywgJyM2YjhlMjMnLCAnI2ZmYTUwMCcsICcjZmY0NTAwJywgJyNkYTcwZDYnLCAnI2VlZThhYScsICcjOThmYjk4JywgJyNhZmVlZWUnLCAnI2Q4NzA5MycsICcjZmZlZmQ1JywgJyNmZmRhYjknLFxuICAgICAgICAnI2NkODUzZicsICcjZmZjMGNiJywgJyNkZGEwZGQnLCAnI2IwZTBlNicsICcjODAwMDgwJywgJyNmZjAwMDAnLCAnI2JjOGY4ZicsICcjNDE2OWUxJywgJyM4YjQ1MTMnLCAnI2ZhODA3MicsICcjZjRhNDYwJyxcbiAgICAgICAgJyMyZThiNTcnLCAnI2ZmZjVlZScsICcjYTA1MjJkJywgJyNjMGMwYzAnLCAnIzg3Y2VlYicsICcjNmE1YWNkJywgJyM3MDgwOTAnLCAnI2ZmZmFmYScsICcjMDBmZjdmJywgJyM0NjgyYjQnLCAnI2QyYjQ4YycsXG4gICAgICAgICcjMDA4MDgwJywgJyNkOGJmZDgnLCAnI2ZmNjM0NycsICcjNDBlMGQwJywgJyNlZTgyZWUnLCAnI2QwMjA5MCcsICcjZjVkZWIzJywgJyNmZmZmZmYnLCAnI2Y1ZjVmNScsICcjZmZmZjAwJywgJyM5YWNkMzInXG4gICAgXSxcblxuICAgIC8vIFRoZXNlIGFyZSB0aGUgbmV3IGJyYW5kc2V5ZSBjb2xvdXJzIGZvciAyMDE4LCBkZWZpbmVkIGluIHJlcG9ydGluZyB2LjQuNS44XG4gICAgZWlnaHRlZW46IHtcbiAgICAgIGdvb2Q6IFwiIzAwYzlhMFwiLCAgICAgICAvLyBCcmlnaHQgR3JlZW5cbiAgICAgIHNlcmllczogW1xuICAgICAgICBcIiNlYmEyNWRcIiwgICAgICAgICAgIC8vIE11dGVkIG9yYW5nZVxuICAgICAgICBcIiM5Y2QyNjFcIiwgICAgICAgICAgIC8vIEdyZWVuXG4gICAgICAgIFwiIzk1OGNiNVwiLCAgICAgICAgICAgLy8gUHVycGxlXG4gICAgICBdLFxuICAgICAgbGlnaHRHcmV5OiBcIiNlOWU5ZTlcIiwgIC8vIGdyaWRsaW5lcywgYmFycyBhbmQgY29sdW1ucywgbmV1dHJhbCBzZW50aW1lbnRcbiAgICAgIG1pZEdyZXk6IFwiI2MwYzBjMFwiLCAgICAvLyB0YWJsZSBib3JkZXJzLCBiYXJzIGFuZCBjb2x1bW5zIGlmIGxpZ2h0IGdyZXkgaXMgdG9vIGxpZ2h0R3JleVxuICAgICAgZGFya0dyZXk6IFwiIzQ0NDQ0NFwiLCAgIC8vIEFsbCB0ZXh0XG4gICAgICBzZW50aW1lbnQ6IHtcbiAgICAgICAgcG9zaXRpdmU6IFwiIzAwYjBiOVwiLCAvLyBibHVlXG4gICAgICAgIG5ldXRyYWw6IFwiI2U5ZTllOVwiLCAgLy8gbGlnaHQgZ3JleVxuICAgICAgICBuZWdhdGl2ZTogXCIjZWUyNzM3XCIsIC8vIFJlZFxuICAgICAgICBuZXQ6IFwiIzFjMWYyYVwiICAgICAgIC8vIEVsaXRlXG4gICAgICB9XG4gICAgfVxuXG5cblxufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/Colours.js\n")},"./src/ColumnChart.js":
/*!****************************!*\
  !*** ./src/ColumnChart.js ***!
  \****************************/
/*! exports provided: ColumnChart */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ColumnChart", function() { return ColumnChart; });\n/* harmony import */ var _Colours__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Colours */ "./src/Colours.js");\n/* harmony import */ var _Chart__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Chart */ "./src/Chart.js");\n// Copyright (C) 2013-2014, 2018 BrandsEye (PTY) LTD\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this\n// software and associated documentation files (the "Software"), to deal in the Software\n// without restriction, including without limitation the rights to use, copy, modify,\n//     merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following\n// conditions:\n//\n//     The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n//     INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n// CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n\n\nclass ColumnChart extends _Chart__WEBPACK_IMPORTED_MODULE_1__["Chart"] {\n\n    //------------------------------------------------------\n\n    data(data) {\n        if (!arguments.length) return this._data;\n        if (data && data[0].key === undefined) {\n            data = [\n                {\n                    key: "series 1",\n                    values: data\n                }\n            ];\n        }\n        this._data = data;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    element(element) {\n        if (!arguments.length) return this._element;\n        this._element = element;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    showLabels(show) {\n        if (!arguments.length) return this._show_labels;\n        this._show_labels = show;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    // todo dispatch\n    showLegend(show) {\n        if (!arguments.length) return this._show_legend;\n        this._show_legend = show;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    x(x) {\n        if (!arguments.length) return this._x;\n        this._x = x;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    y(y) {\n        if (!arguments.length) return this._y;\n        this._y = y;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    width(width) {\n        if (!arguments.length) return this._width;\n        this._width = width;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    height(height) {\n        if (!arguments.length) return this._height;\n        this._height = height;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    colours(colours) {\n        if (!arguments.length) return this._colours;\n        this._colours = colours;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    backgroundColour(colour) {\n        if (!arguments.length) return this._backgroundColour;\n        this._backgroundColour = colour || "#FFF"; // never set it to null.\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    tickFormat(format) {\n        if (!arguments.length) return this._tickFormat;\n        this._tickFormat = format;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    xAxisTickFormat(format) {\n        if (!arguments.length) return this._xAxisTickFormat;\n        this._xAxisTickFormat = format || (d => d.toString());\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    labelFormat(format) {\n        if (!arguments.length) return this._labelFormat;\n        this._labelFormat = format || (d => d.toString());\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    // todo missing\n    labelCompression(compression) {\n        if (!arguments.length) return this._compression;\n        this._compression = compression;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    //todo missing\n    dataAxisLabel(label) {\n        if (!arguments.length) return this._dataAxisLabel;\n        this._dataAxisLabel = label;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    tooltip(tooltip) {\n        if (!arguments.length) return this._tooltip;\n        this._tooltip = tooltip;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    forceY(force) {\n        if (!arguments.length) return this._forceY;\n        this._forceY = force;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n// todo missing\n    duration(duration) {\n        if (!arguments.length) return this._duration;\n        this._duration = duration;\n        return this;\n    }\n\n// todo missing\n    coarseness(coarseness) {\n        if (!arguments.length) return this._coarseness;\n        this._coarseness = coarseness;\n        return this;\n    }\n\n    // todo missing\n    padding(padding) {\n        if (!arguments.length) return this._padding;\n        this._padding = padding;\n        return this;\n    }\n\n    // todo missing\n    xAxisTooltips(tooltips) {\n        if (!arguments.length) return this._xAxisTooltips;\n        this._xAxisTooltips = tooltips;\n        return this;\n    }\n\n    xAxisOverride(override) {\n        if (!arguments.length) return this._xAxisOverride;\n        this._xAxisOverride = override;\n        return this;\n    }\n\n    interbarProportion(proportion) {\n        if (!arguments.length) return this._interbarProportion;\n        this._interbarProportion = proportion;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    dispatch() {\n        return this._dispatch;\n    }\n\n    //------------------------------------------------------\n\n    render() {\n        if (!this._element) throw new Error("No element set for ColumnChart. See #element()");\n        if (!this._data) {\n            console.warn("No data set for ColumnChart. See #data()");\n            return;\n        }\n\n        const data = this.getTransformedData();\n        const keys = this.getKeys();\n\n        //------------------------------------------------\n        // Set up the SVG area\n\n        let topLevel = d3.select(this._element).select("svg");\n        if (topLevel.empty()) {\n            topLevel = d3.select(this._element).append("svg");\n        }\n\n        topLevel\n            .style("width", this._width + "px")\n            .style("height", this._height + "px");\n\n\n        // ---------------------------------\n        // Layout the showLegend.\n        //\n        // We do this now because we need to know how much space the legend\n        // takes up in order to finish calculating the margins.\n\n        const legendHeight = this.renderLegend();\n\n        //----------------------------------\n        // Calculate margins.\n\n        const margin = {top: 20, right: 20, bottom: 40, left: 40};\n        margin.bottom += legendHeight ? legendHeight + 20 : 0;\n\n        if (this._dataAxisLabel) margin.left += 20 + 12;\n        if (data) {\n            let maxLabelLength = 0;\n            data.forEach(d => {\n                d.data.forEach(d => {\n                    let length = this._xAxisTickFormat(this._x(d)).length;\n                    if (length > maxLabelLength) maxLabelLength = length;\n                })\n            });\n            margin.bottom += maxLabelLength * 2 + 10;    // space for axes labels.\n        }\n\n        const width = this._width - margin.left - margin.right,\n            height = this._height - margin.top - margin.bottom;\n\n        //----------------------------------\n        // Calculate scales and so on.\n\n        const x = d3.scaleBand()\n            .rangeRound([0, width])\n            .padding(this._interbarProportion !== null ? this._interbarProportion : (this._data.length > 1 ? 0.08 : 0.1));\n\n        const xGroup = d3.scaleBand()\n            .padding(0);\n\n        const y = d3.scaleLinear()\n            .rangeRound([height, 0])\n            .nice();\n        this._xscale = x;\n        this._xgroupscale = xGroup;\n        this._yscale = y;\n\n        // Scale the range of the data in the domains\n        x.domain(data.map(d => d.key));\n        xGroup.rangeRound([0, x.bandwidth()]).domain(keys);\n        y.domain([0, d3.max(data, d => d3.max(d.data, d => d._y))]);\n\n        //------------------------------\n\n        let svg = topLevel.select(\'.main-group\');\n\n        if (svg.empty()) {\n            svg = topLevel\n                .append("g")\n                .attr("class", "main-group");\n        }\n\n        svg.attr("transform", "translate(" + margin.left + "," + margin.top + ")");\n\n        //---------------------------------\n        // Get rid of current labels.\n        svg.select(".chart-labels")\n            .remove();\n\n        //---------------------------------\n        // append the rectangles for the bar chart\n        let groups = svg.select(".bars").selectAll(\'.group\');\n\n        if (groups.empty()) {\n            groups = svg\n                .append("g")\n                .attr("class", "bars")\n                .selectAll(".group");\n        }\n\n        svg.select(".bars")\n            .attr("transform", "translate(0, " + height + "), scale(1, -1)")\n\n        groups = groups.data(data);\n\n        groups.exit().remove();\n\n        // Adding new groups, and hence adding new bars to those groups.\n        groups.enter()\n            .append("g")\n            .attr("class", "group")\n            .attr("transform", d => "translate(" + x(d.key) + ",0)")\n            .attr("width", x.bandwidth())\n            .attr("height", "100%")\n            .merge(groups)\n            .interrupt("groups:move")\n            .transition("groups:move")\n            .attr("transform", d => "translate(" + x(d.key) + ",0)")\n            .attr("width", x.bandwidth())\n            .each((s_d, s_i, nodes) => {\n                let group = d3.select(nodes[s_i])\n\n                let bars = group.selectAll(".bar")\n                    .data(s_d.data);\n\n                bars.exit().remove();\n\n                bars.interrupt("bar:move")     // Animate the bars to their new position.\n                    .transition("bar:move")\n                    .attr("width", xGroup.bandwidth())\n                    .attr("x", d => xGroup(d._key))\n                    .attr("y", 0);\n\n                bars.enter()\n                    .append("rect")\n                    .attr("class", (d, i) => "bar series series-" + i)\n                    .attr("x", d => xGroup(d._key))\n                    .attr("y", 0)\n                    .attr("width", xGroup.bandwidth())\n                    .attr("height", 0)\n                    .style("fill", (d, i) => this.getSeriesColour(i))\n                    .style("cursor", "pointer")\n                    .on("mouseover", (d, i, nodes) => { // Darken the bar on mouse over\n                        d3.select(nodes[i])\n                            .interrupt("hover:colour")\n                            .transition("hover:colour")\n                            .duration(400)\n                            .style("fill", d3.hcl(this.getSeriesColour(i)).darker())\n                        this._dispatch.call("tooltipShow", this, {\n                            e: d3.event,\n                            point: d,\n                            series: s_d,\n                            seriesIndex: s_i,\n                            value: d._y\n                        })\n                    })\n                    .on("mouseout", (d, i, nodes) => { // bar is regular colour on mouse out.\n                        d3.select(nodes[i])\n                            .interrupt("hover:colour")\n                            .transition("hover:colour")\n                            .duration(400)\n                            .style("fill", this.getSeriesColour(i));\n                        this._dispatch.call("tooltipHide", this);\n                    })\n                    .on("click auxclick", (d, i, nodes) => {\n                        this._dispatch.call("elementClick", this, {\n                            e: d3.event,\n                            point: d,\n                            series: d._series,\n                            seriesIndex: s_i,\n                            value: this._y(d)\n                        })\n                    })\n                    .merge(bars)\n                    .interrupt("bar:growth")    // Animate bars growing.\n                    .transition("bar:growth")\n                    .delay((d) => {\n                        return this.calcBarGrowth(s_i, nodes.length);\n                    })\n                    .duration(this._duration)\n                    .style("fill", (d, i) => this.getSeriesColour(i))\n                    .attr("height", d => height - y(d._y));\n\n            })\n\n        // ---------------------------------\n        // Labels loaded after our first bar grows.\n        if (this._show_labels) {\n            svg.transition("bar:growth")\n                .on("end", (d, i, nodes) => {\n                    if (i < nodes.length - 1) return;\n                    this.renderLabels(svg, data, x, xGroup, y);\n                })\n        }\n\n        // ---------------------------------\n        // Draw the y axis data label.\n\n        if (this._dataAxisLabel) {\n            this.renderDataAxisLabel(height, margin);\n        }\n\n        // ---------------------------------\n        // Set the background colour\n\n        d3.select(this._element).select(".background").remove();\n        if (this._backgroundColour) {\n            d3.select(this._element).select("svg")\n                .append("rect")\n                .attr("class", "background")\n                .attr("width", "100%")\n                .attr("height", "100%")\n                .style("fill", this._backgroundColour)\n                .lower();\n        }\n\n        //---------------------------------\n        // add the Y gridlines\n        svg.call(this.grid, width, d3.axisLeft(y).ticks(5));\n\n        //---------------------------------\n        // axes\n        svg.call(this.xaxis, height, x.bandwidth(), d3.axisBottom(x).tickSize(0).tickPadding(5).tickFormat(this._xAxisTickFormat));\n        svg.call(this.yaxis, d3.axisLeft(y).ticks(5).tickFormat(this._tickFormat));\n    }\n\n    //------------------------------------------------------\n\n    /*\n     * Returns an object with two functions, #show() and #hide(),\n     * to show and hide the labels.\n     */\n    labels() {\n        return {\n\n            show: () => {\n                if (this._element) {\n                    let selection = this._element,\n                        data = this.getTransformedData(),\n                        xscale = this._xscale,\n                        xgroup = this._xgroupscale,\n                        yscale = this._yscale;\n\n                    if (selection) selection = d3.select(this._element).select("svg").select("g");\n                    if (!selection.empty() && data && xscale && yscale && xgroup) {\n                        let labels = selection.select(\'.chart-labels\');\n                        if (!labels.empty()) return;\n                        labels.remove()\n                        this.renderLabels(selection, data, xscale, xgroup, yscale, false);\n                    }\n                }\n\n            },\n\n            hide: () => {\n                if (this._element) {\n                    d3.select(this._element)\n                        .select(\'.chart-labels\')\n                        .interrupt("labels")\n                        .interrupt("labels:fade")\n                        .transition("labels:fade")\n                        .style("opacity", 0)\n                        .on("end", (d, i, nodes) => {\n                            d3.select(nodes[i]).remove();\n                        })\n                }\n            }\n        }\n    }\n\n    //------------------------------------------------------\n\n    renderLabels(selection, data, xscale, xgroup, yscale, animate) {\n        animate = animate === undefined ? true : animate;\n        selection.selectAll(".chart-labels").remove();\n\n        let labels = selection.append("g")\n            .attr("class", "chart-labels")\n            // .selectAll(".chart-label")\n            .selectAll(".label-group")\n            .data(data)\n\n        let maxWidth = 0;     // For calculating the max width of text.\n        let fontSize = 12;    // Our initial font size.\n        const buffer = 5;     // Buffer space between words and the top of a bar.\n        const calcDy = (ypos) => ypos < 10 ? fontSize + buffer : -buffer;\n\n        // Want to figure out if the label is too dark / light for the\n        // bar.\n        const getInvertedColor = (i) => {\n            let invertedColor = d3.hcl(this.getSeriesColour(i));\n            invertedColor.l += Math.min(invertedColor.l + 50, 100);\n            return invertedColor;\n        };\n        const shouldInvert = (i) => d3.hcl(this.getSeriesColour(i)).l < 60;\n\n        labels.enter().each((series, s_i, s_nodes) => {\n            let group = d3.select(s_nodes[s_i])\n                .append("g")\n                .attr("class", "label-group")\n                .attr("transform", d => "translate(" + xscale(d.key) + ",0)")\n                .selectAll(".chart-label")\n                .data(series.data)\n                .enter()\n                .each((d, i, nodes) => {\n                    let ypos = yscale(d._y);\n                    let dy = calcDy(ypos);\n                    let text = d3.select(nodes[i])\n                        .append("text")\n                        .text(this._labelFormat(d._y))\n                        .attr("class", "chart-label")\n                        .attr("y", ypos)\n                        .attr("dx", animate ? -15 : 0)\n                        .attr("dy", dy)\n                        .style("opacity", 0)\n                        .style("pointer-events", "none")\n                        // .style("font-family", "Open Sans, sans-serif")\n                        // .style("font-weight", "normal")\n                        // .style("font-size", fontSize + "px")\n                        .style("fill", dy > 0 && shouldInvert(i)? getInvertedColor(i).toString() : _Colours__WEBPACK_IMPORTED_MODULE_0__["colours"].eighteen.darkGrey);\n\n                    // Set the x position, which is based on width.\n                    const width = text.node().getBBox().width;\n                    maxWidth = Math.max(width, maxWidth);\n                    text\n                        .attr("x", xgroup(d._key) + xgroup.bandwidth() / 2 - width / 2);\n\n                    text\n                        .transition("labels")\n                        .delay(() => animate ? this.calcBarGrowth(s_i, s_nodes.length) : 0) // Delay in lockstep with bar growth.\n                        .duration(this._duration)\n                        .attr("dx", 0)\n                        .style("opacity", 1)\n                })\n        })\n\n\n        // Figure out if we don\'t have enough space to show our labels.\n        // We then want to resize, if possible.\n        if (xgroup.bandwidth() < maxWidth * 1.05) {\n            let scale = maxWidth / xgroup.bandwidth() * 1.05;\n            fontSize = Math.floor(fontSize / scale);\n\n            if (fontSize < 8) {\n                // The labels are too small.\n                labels.enter().selectAll("text").remove();\n            } else {\n                labels.enter()\n                    .merge(labels)\n                    .selectAll("text")\n                    .style("font-size", fontSize + "px")\n                    .each((d, i, nodes) => {\n                        const text = d3.select(nodes[i]);\n                        const width = text.node().getBBox().width;\n                        const dy = calcDy(yscale(d._y));\n\n                        text\n                            .attr("x", xgroup(d._key) + xgroup.bandwidth() / 2 - width / 2)\n                            .style("fill", dy > 0 && shouldInvert(i) ? getInvertedColor(i).toString() : _Colours__WEBPACK_IMPORTED_MODULE_0__["colours"].eighteen.darkGrey)\n                            .attr("dy", dy);\n                    })\n            }\n        }\n    }\n\n    //------------------------------------------------------\n\n    renderDataAxisLabel(height, margins) {\n        let svg = d3.select(this._element).select(\'svg\');\n        svg.selectAll(".data-labels").remove();\n\n        if (!this._dataAxisLabel) return;\n        let text = this._dataAxisLabel;\n        if (text.long) text = text.long;\n\n        let x = -(margins.top + height / 2);\n\n        let label = svg.append("g")\n            .attr("class", "data-labels")\n            .append("text")\n            .text(text)\n            .attr("transform", "rotate(-90 0,0) translate(" + x + ", 20)")\n            // .style("font-family", "Open Sans, sans-serif")\n            // .style("font-size", "12px")\n            // .style("font-style", "italic")\n            .style("fill", _Colours__WEBPACK_IMPORTED_MODULE_0__["colours"].eighteen.darkGrey);\n\n        let width = label.node().getBBox().width;\n        if (width >= height && this._dataAxisLabel.short) {\n            label.text(this._dataAxisLabel.short);\n            width = label.node().getBBox().width;\n        }\n\n        label.attr("dx", -width / 2);\n    }\n\n    //------------------------------------------------------\n\n    grid(selection, width, axis) {\n        selection.select(".grid").remove();\n\n        let grid = selection.append("g")\n            .attr("class", "grid")\n            .call(axis\n                .tickSize(-width)\n                .tickFormat("")\n            );\n\n        grid.selectAll("line")\n            .style("stroke", _Colours__WEBPACK_IMPORTED_MODULE_0__["colours"].eighteen.lightGrey);\n        grid.selectAll(".domain").remove();\n\n        grid\n            .lower() // Always ensure that this is earlier in the dom. Things must be drawn on top of it.\n            .style("opacity", 0)\n            .transition()\n            .delay(500)\n            .duration(500)\n            .style("opacity", 1);\n    }\n\n    //------------------------------------------------------\n\n    xaxis(selection, height, width, xaxis) {\n        selection.select(".x-axis").remove();\n        let axis = selection.append("g")\n            .attr("class", "x-axis")\n            .attr("transform", "translate(0," + height + ")")\n            .style("opacity", 0)\n            .call(xaxis);\n\n        axis.select(".domain").remove();\n\n        let max = 0;\n        const fontSize = 12;\n        axis.selectAll("text")\n            // .style("font-family", "Open Sans, sans-serif")\n            // .style("font-size", fontSize + "px")\n            .style("fill", _Colours__WEBPACK_IMPORTED_MODULE_0__["colours"].eighteen.darkGrey)\n            .nodes()\n            .forEach(text => max = Math.max(max, text.getBBox().width));\n\n        if (max >= width - 10) {\n            const bad = max >= width * 2;\n            const angle = bad ? -90 : -30;\n            const fontSize = width <= 13 ? 8 : 12;\n            const x = bad ? -fontSize : 0;\n            const y = bad ? 5 : 2;\n\n            axis.selectAll("text")\n                .style(\'text-anchor\', \'end\')\n                .style("font-size", fontSize + "px")\n                .attr("transform", () => "translate(" + x + "," + y + ") rotate(" + angle + " 0,0)")\n        }\n\n        axis\n            .transition()\n            .duration(1000)\n            .style("opacity", 1);\n    }\n\n    //------------------------------------------------------\n\n    yaxis(selection, axis) {\n        selection.select(".y-axis").remove();\n        let x = selection.append("g")\n            .attr("class", "y-axis")\n            .call(axis.tickSize(0).tickPadding(10))\n            .style("opacity", 0)\n            .transition()\n            .duration(1000)\n            .style("opacity", 1);\n\n        x.selectAll("text")\n            // .style("font-family", "Open Sans, sans-serif")\n            .style("fill", _Colours__WEBPACK_IMPORTED_MODULE_0__["colours"].eighteen.darkGrey)\n    }\n\n    //------------------------------------------------------\n\n    calcBarGrowth(i, max) {\n        if (max < 10) return i * this._BAR_GROWTH / 2;\n        if (max < 35) return i * this._BAR_GROWTH / 4;\n        return 1;\n    }\n\n    getSeriesColour(i) {\n        if (i < 0 || !this._colours) return _Colours__WEBPACK_IMPORTED_MODULE_0__["colours"].eighteen.midGrey;\n\n        i = i % this._colours.length;\n        return this._colours[i];\n    }\n\n    getSortedData() {\n        let data = this._data;\n        if (!data || !data.length) return [];\n\n        data = this._data.sort((lhs, rhs) => {\n            lhs = lhs.key.toLowerCase();\n            rhs = rhs.key.toLowerCase();\n\n            if (lhs === rhs) return 0;\n            if (lhs < rhs) return -1;\n            return 1;\n        });\n\n        return data;\n    }\n\n    getTransformedData() {\n        let data = this.getSortedData();\n        if (!data || !data.length) return [];\n\n        let results = [];\n\n        const getX = d => this._xAxisOverride ? this._xAxisOverride[this._x(d)] : this._x(d);\n\n        data.forEach((series, s_i) => {\n            series.values.forEach((d, d_i) => {\n                let field = results.find(bucket => bucket.key === getX(d));\n                if (!field) {\n                    field = {\n                        data: [],\n                        key: getX(d)\n                    };\n                    results.push(field);\n                }\n\n                field.data.push(Object.assign({\n                    _series: series,\n                    _s_i: s_i,\n                    _key: series.key,\n                    _y: this._y(d)\n                }, d));\n            })\n        });\n\n        return results;\n    }\n\n    getKeys() {\n        let data = this._data;\n        if (!data || !data.length) return [];\n\n        return [...new Set(data.map(d => d.key))]\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvQ29sdW1uQ2hhcnQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9iM2pzLy4vc3JjL0NvbHVtbkNoYXJ0LmpzPzNlNDAiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChDKSAyMDEzLTIwMTQsIDIwMTggQnJhbmRzRXllIChQVFkpIExURFxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpc1xuLy8gc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlXG4vLyB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksXG4vLyAgICAgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0b1xuLy8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcbi8vIGNvbmRpdGlvbnM6XG4vL1xuLy8gICAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuLy8gY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyAgICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUiBJTVBMSUVELFxuLy8gICAgIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBXG4vLyBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUXG4vLyBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0Zcbi8vIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRVxuLy8gT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCB7Y29sb3Vyc30gZnJvbSAnLi9Db2xvdXJzJztcbmltcG9ydCB7Q2hhcnR9IGZyb20gJy4vQ2hhcnQnO1xuXG5cbmV4cG9ydCBjbGFzcyBDb2x1bW5DaGFydCBleHRlbmRzIENoYXJ0IHtcblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBkYXRhKGRhdGEpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fZGF0YTtcbiAgICAgICAgaWYgKGRhdGEgJiYgZGF0YVswXS5rZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZGF0YSA9IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGtleTogXCJzZXJpZXMgMVwiLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZXM6IGRhdGFcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgZWxlbWVudChlbGVtZW50KSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX2VsZW1lbnQ7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgc2hvd0xhYmVscyhzaG93KSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3Nob3dfbGFiZWxzO1xuICAgICAgICB0aGlzLl9zaG93X2xhYmVscyA9IHNob3c7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvLyB0b2RvIGRpc3BhdGNoXG4gICAgc2hvd0xlZ2VuZChzaG93KSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3Nob3dfbGVnZW5kO1xuICAgICAgICB0aGlzLl9zaG93X2xlZ2VuZCA9IHNob3c7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB4KHgpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5feDtcbiAgICAgICAgdGhpcy5feCA9IHg7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB5KHkpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5feTtcbiAgICAgICAgdGhpcy5feSA9IHk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB3aWR0aCh3aWR0aCkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl93aWR0aDtcbiAgICAgICAgdGhpcy5fd2lkdGggPSB3aWR0aDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGhlaWdodChoZWlnaHQpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5faGVpZ2h0O1xuICAgICAgICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBjb2xvdXJzKGNvbG91cnMpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fY29sb3VycztcbiAgICAgICAgdGhpcy5fY29sb3VycyA9IGNvbG91cnM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBiYWNrZ3JvdW5kQ29sb3VyKGNvbG91cikge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9iYWNrZ3JvdW5kQ29sb3VyO1xuICAgICAgICB0aGlzLl9iYWNrZ3JvdW5kQ29sb3VyID0gY29sb3VyIHx8IFwiI0ZGRlwiOyAvLyBuZXZlciBzZXQgaXQgdG8gbnVsbC5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHRpY2tGb3JtYXQoZm9ybWF0KSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3RpY2tGb3JtYXQ7XG4gICAgICAgIHRoaXMuX3RpY2tGb3JtYXQgPSBmb3JtYXQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB4QXhpc1RpY2tGb3JtYXQoZm9ybWF0KSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3hBeGlzVGlja0Zvcm1hdDtcbiAgICAgICAgdGhpcy5feEF4aXNUaWNrRm9ybWF0ID0gZm9ybWF0IHx8IChkID0+IGQudG9TdHJpbmcoKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBsYWJlbEZvcm1hdChmb3JtYXQpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fbGFiZWxGb3JtYXQ7XG4gICAgICAgIHRoaXMuX2xhYmVsRm9ybWF0ID0gZm9ybWF0IHx8IChkID0+IGQudG9TdHJpbmcoKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvLyB0b2RvIG1pc3NpbmdcbiAgICBsYWJlbENvbXByZXNzaW9uKGNvbXByZXNzaW9uKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX2NvbXByZXNzaW9uO1xuICAgICAgICB0aGlzLl9jb21wcmVzc2lvbiA9IGNvbXByZXNzaW9uO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLy90b2RvIG1pc3NpbmdcbiAgICBkYXRhQXhpc0xhYmVsKGxhYmVsKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX2RhdGFBeGlzTGFiZWw7XG4gICAgICAgIHRoaXMuX2RhdGFBeGlzTGFiZWwgPSBsYWJlbDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHRvb2x0aXAodG9vbHRpcCkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl90b29sdGlwO1xuICAgICAgICB0aGlzLl90b29sdGlwID0gdG9vbHRpcDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGZvcmNlWShmb3JjZSkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9mb3JjZVk7XG4gICAgICAgIHRoaXMuX2ZvcmNlWSA9IGZvcmNlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vLyB0b2RvIG1pc3NpbmdcbiAgICBkdXJhdGlvbihkdXJhdGlvbikge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9kdXJhdGlvbjtcbiAgICAgICAgdGhpcy5fZHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4vLyB0b2RvIG1pc3NpbmdcbiAgICBjb2Fyc2VuZXNzKGNvYXJzZW5lc3MpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fY29hcnNlbmVzcztcbiAgICAgICAgdGhpcy5fY29hcnNlbmVzcyA9IGNvYXJzZW5lc3M7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIHRvZG8gbWlzc2luZ1xuICAgIHBhZGRpbmcocGFkZGluZykge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9wYWRkaW5nO1xuICAgICAgICB0aGlzLl9wYWRkaW5nID0gcGFkZGluZztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gdG9kbyBtaXNzaW5nXG4gICAgeEF4aXNUb29sdGlwcyh0b29sdGlwcykge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl94QXhpc1Rvb2x0aXBzO1xuICAgICAgICB0aGlzLl94QXhpc1Rvb2x0aXBzID0gdG9vbHRpcHM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHhBeGlzT3ZlcnJpZGUob3ZlcnJpZGUpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5feEF4aXNPdmVycmlkZTtcbiAgICAgICAgdGhpcy5feEF4aXNPdmVycmlkZSA9IG92ZXJyaWRlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpbnRlcmJhclByb3BvcnRpb24ocHJvcG9ydGlvbikge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9pbnRlcmJhclByb3BvcnRpb247XG4gICAgICAgIHRoaXMuX2ludGVyYmFyUHJvcG9ydGlvbiA9IHByb3BvcnRpb247XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBkaXNwYXRjaCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc3BhdGNoO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGlmICghdGhpcy5fZWxlbWVudCkgdGhyb3cgbmV3IEVycm9yKFwiTm8gZWxlbWVudCBzZXQgZm9yIENvbHVtbkNoYXJ0LiBTZWUgI2VsZW1lbnQoKVwiKTtcbiAgICAgICAgaWYgKCF0aGlzLl9kYXRhKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJObyBkYXRhIHNldCBmb3IgQ29sdW1uQ2hhcnQuIFNlZSAjZGF0YSgpXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMuZ2V0VHJhbnNmb3JtZWREYXRhKCk7XG4gICAgICAgIGNvbnN0IGtleXMgPSB0aGlzLmdldEtleXMoKTtcblxuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBTZXQgdXAgdGhlIFNWRyBhcmVhXG5cbiAgICAgICAgbGV0IHRvcExldmVsID0gZDMuc2VsZWN0KHRoaXMuX2VsZW1lbnQpLnNlbGVjdChcInN2Z1wiKTtcbiAgICAgICAgaWYgKHRvcExldmVsLmVtcHR5KCkpIHtcbiAgICAgICAgICAgIHRvcExldmVsID0gZDMuc2VsZWN0KHRoaXMuX2VsZW1lbnQpLmFwcGVuZChcInN2Z1wiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRvcExldmVsXG4gICAgICAgICAgICAuc3R5bGUoXCJ3aWR0aFwiLCB0aGlzLl93aWR0aCArIFwicHhcIilcbiAgICAgICAgICAgIC5zdHlsZShcImhlaWdodFwiLCB0aGlzLl9oZWlnaHQgKyBcInB4XCIpO1xuXG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIExheW91dCB0aGUgc2hvd0xlZ2VuZC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gV2UgZG8gdGhpcyBub3cgYmVjYXVzZSB3ZSBuZWVkIHRvIGtub3cgaG93IG11Y2ggc3BhY2UgdGhlIGxlZ2VuZFxuICAgICAgICAvLyB0YWtlcyB1cCBpbiBvcmRlciB0byBmaW5pc2ggY2FsY3VsYXRpbmcgdGhlIG1hcmdpbnMuXG5cbiAgICAgICAgY29uc3QgbGVnZW5kSGVpZ2h0ID0gdGhpcy5yZW5kZXJMZWdlbmQoKTtcblxuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gQ2FsY3VsYXRlIG1hcmdpbnMuXG5cbiAgICAgICAgY29uc3QgbWFyZ2luID0ge3RvcDogMjAsIHJpZ2h0OiAyMCwgYm90dG9tOiA0MCwgbGVmdDogNDB9O1xuICAgICAgICBtYXJnaW4uYm90dG9tICs9IGxlZ2VuZEhlaWdodCA/IGxlZ2VuZEhlaWdodCArIDIwIDogMDtcblxuICAgICAgICBpZiAodGhpcy5fZGF0YUF4aXNMYWJlbCkgbWFyZ2luLmxlZnQgKz0gMjAgKyAxMjtcbiAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgIGxldCBtYXhMYWJlbExlbmd0aCA9IDA7XG4gICAgICAgICAgICBkYXRhLmZvckVhY2goZCA9PiB7XG4gICAgICAgICAgICAgICAgZC5kYXRhLmZvckVhY2goZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBsZW5ndGggPSB0aGlzLl94QXhpc1RpY2tGb3JtYXQodGhpcy5feChkKSkubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGVuZ3RoID4gbWF4TGFiZWxMZW5ndGgpIG1heExhYmVsTGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG1hcmdpbi5ib3R0b20gKz0gbWF4TGFiZWxMZW5ndGggKiAyICsgMTA7ICAgIC8vIHNwYWNlIGZvciBheGVzIGxhYmVscy5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHdpZHRoID0gdGhpcy5fd2lkdGggLSBtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodCxcbiAgICAgICAgICAgIGhlaWdodCA9IHRoaXMuX2hlaWdodCAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tO1xuXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBDYWxjdWxhdGUgc2NhbGVzIGFuZCBzbyBvbi5cblxuICAgICAgICBjb25zdCB4ID0gZDMuc2NhbGVCYW5kKClcbiAgICAgICAgICAgIC5yYW5nZVJvdW5kKFswLCB3aWR0aF0pXG4gICAgICAgICAgICAucGFkZGluZyh0aGlzLl9pbnRlcmJhclByb3BvcnRpb24gIT09IG51bGwgPyB0aGlzLl9pbnRlcmJhclByb3BvcnRpb24gOiAodGhpcy5fZGF0YS5sZW5ndGggPiAxID8gMC4wOCA6IDAuMSkpO1xuXG4gICAgICAgIGNvbnN0IHhHcm91cCA9IGQzLnNjYWxlQmFuZCgpXG4gICAgICAgICAgICAucGFkZGluZygwKTtcblxuICAgICAgICBjb25zdCB5ID0gZDMuc2NhbGVMaW5lYXIoKVxuICAgICAgICAgICAgLnJhbmdlUm91bmQoW2hlaWdodCwgMF0pXG4gICAgICAgICAgICAubmljZSgpO1xuICAgICAgICB0aGlzLl94c2NhbGUgPSB4O1xuICAgICAgICB0aGlzLl94Z3JvdXBzY2FsZSA9IHhHcm91cDtcbiAgICAgICAgdGhpcy5feXNjYWxlID0geTtcblxuICAgICAgICAvLyBTY2FsZSB0aGUgcmFuZ2Ugb2YgdGhlIGRhdGEgaW4gdGhlIGRvbWFpbnNcbiAgICAgICAgeC5kb21haW4oZGF0YS5tYXAoZCA9PiBkLmtleSkpO1xuICAgICAgICB4R3JvdXAucmFuZ2VSb3VuZChbMCwgeC5iYW5kd2lkdGgoKV0pLmRvbWFpbihrZXlzKTtcbiAgICAgICAgeS5kb21haW4oWzAsIGQzLm1heChkYXRhLCBkID0+IGQzLm1heChkLmRhdGEsIGQgPT4gZC5feSkpXSk7XG5cbiAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICBsZXQgc3ZnID0gdG9wTGV2ZWwuc2VsZWN0KCcubWFpbi1ncm91cCcpO1xuXG4gICAgICAgIGlmIChzdmcuZW1wdHkoKSkge1xuICAgICAgICAgICAgc3ZnID0gdG9wTGV2ZWxcbiAgICAgICAgICAgICAgICAuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJtYWluLWdyb3VwXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3ZnLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyBtYXJnaW4ubGVmdCArIFwiLFwiICsgbWFyZ2luLnRvcCArIFwiKVwiKTtcblxuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBHZXQgcmlkIG9mIGN1cnJlbnQgbGFiZWxzLlxuICAgICAgICBzdmcuc2VsZWN0KFwiLmNoYXJ0LWxhYmVsc1wiKVxuICAgICAgICAgICAgLnJlbW92ZSgpO1xuXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIGFwcGVuZCB0aGUgcmVjdGFuZ2xlcyBmb3IgdGhlIGJhciBjaGFydFxuICAgICAgICBsZXQgZ3JvdXBzID0gc3ZnLnNlbGVjdChcIi5iYXJzXCIpLnNlbGVjdEFsbCgnLmdyb3VwJyk7XG5cbiAgICAgICAgaWYgKGdyb3Vwcy5lbXB0eSgpKSB7XG4gICAgICAgICAgICBncm91cHMgPSBzdmdcbiAgICAgICAgICAgICAgICAuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJiYXJzXCIpXG4gICAgICAgICAgICAgICAgLnNlbGVjdEFsbChcIi5ncm91cFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN2Zy5zZWxlY3QoXCIuYmFyc1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoMCwgXCIgKyBoZWlnaHQgKyBcIiksIHNjYWxlKDEsIC0xKVwiKVxuXG4gICAgICAgIGdyb3VwcyA9IGdyb3Vwcy5kYXRhKGRhdGEpO1xuXG4gICAgICAgIGdyb3Vwcy5leGl0KCkucmVtb3ZlKCk7XG5cbiAgICAgICAgLy8gQWRkaW5nIG5ldyBncm91cHMsIGFuZCBoZW5jZSBhZGRpbmcgbmV3IGJhcnMgdG8gdGhvc2UgZ3JvdXBzLlxuICAgICAgICBncm91cHMuZW50ZXIoKVxuICAgICAgICAgICAgLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJncm91cFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgZCA9PiBcInRyYW5zbGF0ZShcIiArIHgoZC5rZXkpICsgXCIsMClcIilcbiAgICAgICAgICAgIC5hdHRyKFwid2lkdGhcIiwgeC5iYW5kd2lkdGgoKSlcbiAgICAgICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIFwiMTAwJVwiKVxuICAgICAgICAgICAgLm1lcmdlKGdyb3VwcylcbiAgICAgICAgICAgIC5pbnRlcnJ1cHQoXCJncm91cHM6bW92ZVwiKVxuICAgICAgICAgICAgLnRyYW5zaXRpb24oXCJncm91cHM6bW92ZVwiKVxuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgZCA9PiBcInRyYW5zbGF0ZShcIiArIHgoZC5rZXkpICsgXCIsMClcIilcbiAgICAgICAgICAgIC5hdHRyKFwid2lkdGhcIiwgeC5iYW5kd2lkdGgoKSlcbiAgICAgICAgICAgIC5lYWNoKChzX2QsIHNfaSwgbm9kZXMpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgZ3JvdXAgPSBkMy5zZWxlY3Qobm9kZXNbc19pXSlcblxuICAgICAgICAgICAgICAgIGxldCBiYXJzID0gZ3JvdXAuc2VsZWN0QWxsKFwiLmJhclwiKVxuICAgICAgICAgICAgICAgICAgICAuZGF0YShzX2QuZGF0YSk7XG5cbiAgICAgICAgICAgICAgICBiYXJzLmV4aXQoKS5yZW1vdmUoKTtcblxuICAgICAgICAgICAgICAgIGJhcnMuaW50ZXJydXB0KFwiYmFyOm1vdmVcIikgICAgIC8vIEFuaW1hdGUgdGhlIGJhcnMgdG8gdGhlaXIgbmV3IHBvc2l0aW9uLlxuICAgICAgICAgICAgICAgICAgICAudHJhbnNpdGlvbihcImJhcjptb3ZlXCIpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFwid2lkdGhcIiwgeEdyb3VwLmJhbmR3aWR0aCgpKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcInhcIiwgZCA9PiB4R3JvdXAoZC5fa2V5KSlcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ5XCIsIDApO1xuXG4gICAgICAgICAgICAgICAgYmFycy5lbnRlcigpXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoXCJyZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgKGQsIGkpID0+IFwiYmFyIHNlcmllcyBzZXJpZXMtXCIgKyBpKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcInhcIiwgZCA9PiB4R3JvdXAoZC5fa2V5KSlcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ5XCIsIDApXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFwid2lkdGhcIiwgeEdyb3VwLmJhbmR3aWR0aCgpKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcImhlaWdodFwiLCAwKVxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIChkLCBpKSA9PiB0aGlzLmdldFNlcmllc0NvbG91cihpKSlcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwiY3Vyc29yXCIsIFwicG9pbnRlclwiKVxuICAgICAgICAgICAgICAgICAgICAub24oXCJtb3VzZW92ZXJcIiwgKGQsIGksIG5vZGVzKSA9PiB7IC8vIERhcmtlbiB0aGUgYmFyIG9uIG1vdXNlIG92ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGQzLnNlbGVjdChub2Rlc1tpXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuaW50ZXJydXB0KFwiaG92ZXI6Y29sb3VyXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRyYW5zaXRpb24oXCJob3Zlcjpjb2xvdXJcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24oNDAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcImZpbGxcIiwgZDMuaGNsKHRoaXMuZ2V0U2VyaWVzQ29sb3VyKGkpKS5kYXJrZXIoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3BhdGNoLmNhbGwoXCJ0b29sdGlwU2hvd1wiLCB0aGlzLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZTogZDMuZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQ6IGQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzOiBzX2QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzSW5kZXg6IHNfaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZC5feVxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLm9uKFwibW91c2VvdXRcIiwgKGQsIGksIG5vZGVzKSA9PiB7IC8vIGJhciBpcyByZWd1bGFyIGNvbG91ciBvbiBtb3VzZSBvdXQuXG4gICAgICAgICAgICAgICAgICAgICAgICBkMy5zZWxlY3Qobm9kZXNbaV0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmludGVycnVwdChcImhvdmVyOmNvbG91clwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKFwiaG92ZXI6Y29sb3VyXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKDQwMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIHRoaXMuZ2V0U2VyaWVzQ29sb3VyKGkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3BhdGNoLmNhbGwoXCJ0b29sdGlwSGlkZVwiLCB0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLm9uKFwiY2xpY2sgYXV4Y2xpY2tcIiwgKGQsIGksIG5vZGVzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXNwYXRjaC5jYWxsKFwiZWxlbWVudENsaWNrXCIsIHRoaXMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlOiBkMy5ldmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludDogZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXM6IGQuX3NlcmllcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXNJbmRleDogc19pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLl95KGQpXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAubWVyZ2UoYmFycylcbiAgICAgICAgICAgICAgICAgICAgLmludGVycnVwdChcImJhcjpncm93dGhcIikgICAgLy8gQW5pbWF0ZSBiYXJzIGdyb3dpbmcuXG4gICAgICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKFwiYmFyOmdyb3d0aFwiKVxuICAgICAgICAgICAgICAgICAgICAuZGVsYXkoKGQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNhbGNCYXJHcm93dGgoc19pLCBub2Rlcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24odGhpcy5fZHVyYXRpb24pXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZShcImZpbGxcIiwgKGQsIGkpID0+IHRoaXMuZ2V0U2VyaWVzQ29sb3VyKGkpKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcImhlaWdodFwiLCBkID0+IGhlaWdodCAtIHkoZC5feSkpO1xuXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBMYWJlbHMgbG9hZGVkIGFmdGVyIG91ciBmaXJzdCBiYXIgZ3Jvd3MuXG4gICAgICAgIGlmICh0aGlzLl9zaG93X2xhYmVscykge1xuICAgICAgICAgICAgc3ZnLnRyYW5zaXRpb24oXCJiYXI6Z3Jvd3RoXCIpXG4gICAgICAgICAgICAgICAgLm9uKFwiZW5kXCIsIChkLCBpLCBub2RlcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA8IG5vZGVzLmxlbmd0aCAtIDEpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJMYWJlbHMoc3ZnLCBkYXRhLCB4LCB4R3JvdXAsIHkpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gRHJhdyB0aGUgeSBheGlzIGRhdGEgbGFiZWwuXG5cbiAgICAgICAgaWYgKHRoaXMuX2RhdGFBeGlzTGFiZWwpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyRGF0YUF4aXNMYWJlbChoZWlnaHQsIG1hcmdpbik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gU2V0IHRoZSBiYWNrZ3JvdW5kIGNvbG91clxuXG4gICAgICAgIGQzLnNlbGVjdCh0aGlzLl9lbGVtZW50KS5zZWxlY3QoXCIuYmFja2dyb3VuZFwiKS5yZW1vdmUoKTtcbiAgICAgICAgaWYgKHRoaXMuX2JhY2tncm91bmRDb2xvdXIpIHtcbiAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzLl9lbGVtZW50KS5zZWxlY3QoXCJzdmdcIilcbiAgICAgICAgICAgICAgICAuYXBwZW5kKFwicmVjdFwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJiYWNrZ3JvdW5kXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCBcIjEwMCVcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcImhlaWdodFwiLCBcIjEwMCVcIilcbiAgICAgICAgICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIHRoaXMuX2JhY2tncm91bmRDb2xvdXIpXG4gICAgICAgICAgICAgICAgLmxvd2VyKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBhZGQgdGhlIFkgZ3JpZGxpbmVzXG4gICAgICAgIHN2Zy5jYWxsKHRoaXMuZ3JpZCwgd2lkdGgsIGQzLmF4aXNMZWZ0KHkpLnRpY2tzKDUpKTtcblxuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBheGVzXG4gICAgICAgIHN2Zy5jYWxsKHRoaXMueGF4aXMsIGhlaWdodCwgeC5iYW5kd2lkdGgoKSwgZDMuYXhpc0JvdHRvbSh4KS50aWNrU2l6ZSgwKS50aWNrUGFkZGluZyg1KS50aWNrRm9ybWF0KHRoaXMuX3hBeGlzVGlja0Zvcm1hdCkpO1xuICAgICAgICBzdmcuY2FsbCh0aGlzLnlheGlzLCBkMy5heGlzTGVmdCh5KS50aWNrcyg1KS50aWNrRm9ybWF0KHRoaXMuX3RpY2tGb3JtYXQpKTtcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLypcbiAgICAgKiBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIHR3byBmdW5jdGlvbnMsICNzaG93KCkgYW5kICNoaWRlKCksXG4gICAgICogdG8gc2hvdyBhbmQgaGlkZSB0aGUgbGFiZWxzLlxuICAgICAqL1xuICAgIGxhYmVscygpIHtcbiAgICAgICAgcmV0dXJuIHtcblxuICAgICAgICAgICAgc2hvdzogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9lbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzZWxlY3Rpb24gPSB0aGlzLl9lbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHRoaXMuZ2V0VHJhbnNmb3JtZWREYXRhKCksXG4gICAgICAgICAgICAgICAgICAgICAgICB4c2NhbGUgPSB0aGlzLl94c2NhbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB4Z3JvdXAgPSB0aGlzLl94Z3JvdXBzY2FsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHlzY2FsZSA9IHRoaXMuX3lzY2FsZTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uKSBzZWxlY3Rpb24gPSBkMy5zZWxlY3QodGhpcy5fZWxlbWVudCkuc2VsZWN0KFwic3ZnXCIpLnNlbGVjdChcImdcIik7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2VsZWN0aW9uLmVtcHR5KCkgJiYgZGF0YSAmJiB4c2NhbGUgJiYgeXNjYWxlICYmIHhncm91cCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGxhYmVscyA9IHNlbGVjdGlvbi5zZWxlY3QoJy5jaGFydC1sYWJlbHMnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbGFiZWxzLmVtcHR5KCkpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVscy5yZW1vdmUoKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJMYWJlbHMoc2VsZWN0aW9uLCBkYXRhLCB4c2NhbGUsIHhncm91cCwgeXNjYWxlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGhpZGU6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBkMy5zZWxlY3QodGhpcy5fZWxlbWVudClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZWxlY3QoJy5jaGFydC1sYWJlbHMnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmludGVycnVwdChcImxhYmVsc1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmludGVycnVwdChcImxhYmVsczpmYWRlXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAudHJhbnNpdGlvbihcImxhYmVsczpmYWRlXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDApXG4gICAgICAgICAgICAgICAgICAgICAgICAub24oXCJlbmRcIiwgKGQsIGksIG5vZGVzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZDMuc2VsZWN0KG5vZGVzW2ldKS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHJlbmRlckxhYmVscyhzZWxlY3Rpb24sIGRhdGEsIHhzY2FsZSwgeGdyb3VwLCB5c2NhbGUsIGFuaW1hdGUpIHtcbiAgICAgICAgYW5pbWF0ZSA9IGFuaW1hdGUgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBhbmltYXRlO1xuICAgICAgICBzZWxlY3Rpb24uc2VsZWN0QWxsKFwiLmNoYXJ0LWxhYmVsc1wiKS5yZW1vdmUoKTtcblxuICAgICAgICBsZXQgbGFiZWxzID0gc2VsZWN0aW9uLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJjaGFydC1sYWJlbHNcIilcbiAgICAgICAgICAgIC8vIC5zZWxlY3RBbGwoXCIuY2hhcnQtbGFiZWxcIilcbiAgICAgICAgICAgIC5zZWxlY3RBbGwoXCIubGFiZWwtZ3JvdXBcIilcbiAgICAgICAgICAgIC5kYXRhKGRhdGEpXG5cbiAgICAgICAgbGV0IG1heFdpZHRoID0gMDsgICAgIC8vIEZvciBjYWxjdWxhdGluZyB0aGUgbWF4IHdpZHRoIG9mIHRleHQuXG4gICAgICAgIGxldCBmb250U2l6ZSA9IDEyOyAgICAvLyBPdXIgaW5pdGlhbCBmb250IHNpemUuXG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IDU7ICAgICAvLyBCdWZmZXIgc3BhY2UgYmV0d2VlbiB3b3JkcyBhbmQgdGhlIHRvcCBvZiBhIGJhci5cbiAgICAgICAgY29uc3QgY2FsY0R5ID0gKHlwb3MpID0+IHlwb3MgPCAxMCA/IGZvbnRTaXplICsgYnVmZmVyIDogLWJ1ZmZlcjtcblxuICAgICAgICAvLyBXYW50IHRvIGZpZ3VyZSBvdXQgaWYgdGhlIGxhYmVsIGlzIHRvbyBkYXJrIC8gbGlnaHQgZm9yIHRoZVxuICAgICAgICAvLyBiYXIuXG4gICAgICAgIGNvbnN0IGdldEludmVydGVkQ29sb3IgPSAoaSkgPT4ge1xuICAgICAgICAgICAgbGV0IGludmVydGVkQ29sb3IgPSBkMy5oY2wodGhpcy5nZXRTZXJpZXNDb2xvdXIoaSkpO1xuICAgICAgICAgICAgaW52ZXJ0ZWRDb2xvci5sICs9IE1hdGgubWluKGludmVydGVkQ29sb3IubCArIDUwLCAxMDApO1xuICAgICAgICAgICAgcmV0dXJuIGludmVydGVkQ29sb3I7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHNob3VsZEludmVydCA9IChpKSA9PiBkMy5oY2wodGhpcy5nZXRTZXJpZXNDb2xvdXIoaSkpLmwgPCA2MDtcblxuICAgICAgICBsYWJlbHMuZW50ZXIoKS5lYWNoKChzZXJpZXMsIHNfaSwgc19ub2RlcykgPT4ge1xuICAgICAgICAgICAgbGV0IGdyb3VwID0gZDMuc2VsZWN0KHNfbm9kZXNbc19pXSlcbiAgICAgICAgICAgICAgICAuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJsYWJlbC1ncm91cFwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIGQgPT4gXCJ0cmFuc2xhdGUoXCIgKyB4c2NhbGUoZC5rZXkpICsgXCIsMClcIilcbiAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKFwiLmNoYXJ0LWxhYmVsXCIpXG4gICAgICAgICAgICAgICAgLmRhdGEoc2VyaWVzLmRhdGEpXG4gICAgICAgICAgICAgICAgLmVudGVyKClcbiAgICAgICAgICAgICAgICAuZWFjaCgoZCwgaSwgbm9kZXMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHlwb3MgPSB5c2NhbGUoZC5feSk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkeSA9IGNhbGNEeSh5cG9zKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRleHQgPSBkMy5zZWxlY3Qobm9kZXNbaV0pXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRleHQodGhpcy5fbGFiZWxGb3JtYXQoZC5feSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwiY2hhcnQtbGFiZWxcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwieVwiLCB5cG9zKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJkeFwiLCBhbmltYXRlID8gLTE1IDogMClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiZHlcIiwgZHkpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDApXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJwb2ludGVyLWV2ZW50c1wiLCBcIm5vbmVcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIC5zdHlsZShcImZvbnQtZmFtaWx5XCIsIFwiT3BlbiBTYW5zLCBzYW5zLXNlcmlmXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAuc3R5bGUoXCJmb250LXdlaWdodFwiLCBcIm5vcm1hbFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gLnN0eWxlKFwiZm9udC1zaXplXCIsIGZvbnRTaXplICsgXCJweFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBkeSA+IDAgJiYgc2hvdWxkSW52ZXJ0KGkpPyBnZXRJbnZlcnRlZENvbG9yKGkpLnRvU3RyaW5nKCkgOiBjb2xvdXJzLmVpZ2h0ZWVuLmRhcmtHcmV5KTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBTZXQgdGhlIHggcG9zaXRpb24sIHdoaWNoIGlzIGJhc2VkIG9uIHdpZHRoLlxuICAgICAgICAgICAgICAgICAgICBjb25zdCB3aWR0aCA9IHRleHQubm9kZSgpLmdldEJCb3goKS53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgbWF4V2lkdGggPSBNYXRoLm1heCh3aWR0aCwgbWF4V2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICB0ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcInhcIiwgeGdyb3VwKGQuX2tleSkgKyB4Z3JvdXAuYmFuZHdpZHRoKCkgLyAyIC0gd2lkdGggLyAyKTtcblxuICAgICAgICAgICAgICAgICAgICB0ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICAudHJhbnNpdGlvbihcImxhYmVsc1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmRlbGF5KCgpID0+IGFuaW1hdGUgPyB0aGlzLmNhbGNCYXJHcm93dGgoc19pLCBzX25vZGVzLmxlbmd0aCkgOiAwKSAvLyBEZWxheSBpbiBsb2Nrc3RlcCB3aXRoIGJhciBncm93dGguXG4gICAgICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24odGhpcy5fZHVyYXRpb24pXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcImR4XCIsIDApXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDEpXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgfSlcblxuXG4gICAgICAgIC8vIEZpZ3VyZSBvdXQgaWYgd2UgZG9uJ3QgaGF2ZSBlbm91Z2ggc3BhY2UgdG8gc2hvdyBvdXIgbGFiZWxzLlxuICAgICAgICAvLyBXZSB0aGVuIHdhbnQgdG8gcmVzaXplLCBpZiBwb3NzaWJsZS5cbiAgICAgICAgaWYgKHhncm91cC5iYW5kd2lkdGgoKSA8IG1heFdpZHRoICogMS4wNSkge1xuICAgICAgICAgICAgbGV0IHNjYWxlID0gbWF4V2lkdGggLyB4Z3JvdXAuYmFuZHdpZHRoKCkgKiAxLjA1O1xuICAgICAgICAgICAgZm9udFNpemUgPSBNYXRoLmZsb29yKGZvbnRTaXplIC8gc2NhbGUpO1xuXG4gICAgICAgICAgICBpZiAoZm9udFNpemUgPCA4KSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGxhYmVscyBhcmUgdG9vIHNtYWxsLlxuICAgICAgICAgICAgICAgIGxhYmVscy5lbnRlcigpLnNlbGVjdEFsbChcInRleHRcIikucmVtb3ZlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxhYmVscy5lbnRlcigpXG4gICAgICAgICAgICAgICAgICAgIC5tZXJnZShsYWJlbHMpXG4gICAgICAgICAgICAgICAgICAgIC5zZWxlY3RBbGwoXCJ0ZXh0XCIpXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZShcImZvbnQtc2l6ZVwiLCBmb250U2l6ZSArIFwicHhcIilcbiAgICAgICAgICAgICAgICAgICAgLmVhY2goKGQsIGksIG5vZGVzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXh0ID0gZDMuc2VsZWN0KG5vZGVzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gdGV4dC5ub2RlKCkuZ2V0QkJveCgpLndpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZHkgPSBjYWxjRHkoeXNjYWxlKGQuX3kpKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwieFwiLCB4Z3JvdXAoZC5fa2V5KSArIHhncm91cC5iYW5kd2lkdGgoKSAvIDIgLSB3aWR0aCAvIDIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBkeSA+IDAgJiYgc2hvdWxkSW52ZXJ0KGkpID8gZ2V0SW52ZXJ0ZWRDb2xvcihpKS50b1N0cmluZygpIDogY29sb3Vycy5laWdodGVlbi5kYXJrR3JleSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcImR5XCIsIGR5KTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICByZW5kZXJEYXRhQXhpc0xhYmVsKGhlaWdodCwgbWFyZ2lucykge1xuICAgICAgICBsZXQgc3ZnID0gZDMuc2VsZWN0KHRoaXMuX2VsZW1lbnQpLnNlbGVjdCgnc3ZnJyk7XG4gICAgICAgIHN2Zy5zZWxlY3RBbGwoXCIuZGF0YS1sYWJlbHNcIikucmVtb3ZlKCk7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9kYXRhQXhpc0xhYmVsKSByZXR1cm47XG4gICAgICAgIGxldCB0ZXh0ID0gdGhpcy5fZGF0YUF4aXNMYWJlbDtcbiAgICAgICAgaWYgKHRleHQubG9uZykgdGV4dCA9IHRleHQubG9uZztcblxuICAgICAgICBsZXQgeCA9IC0obWFyZ2lucy50b3AgKyBoZWlnaHQgLyAyKTtcblxuICAgICAgICBsZXQgbGFiZWwgPSBzdmcuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImRhdGEtbGFiZWxzXCIpXG4gICAgICAgICAgICAuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgICAgICAgLnRleHQodGV4dClcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwicm90YXRlKC05MCAwLDApIHRyYW5zbGF0ZShcIiArIHggKyBcIiwgMjApXCIpXG4gICAgICAgICAgICAvLyAuc3R5bGUoXCJmb250LWZhbWlseVwiLCBcIk9wZW4gU2Fucywgc2Fucy1zZXJpZlwiKVxuICAgICAgICAgICAgLy8gLnN0eWxlKFwiZm9udC1zaXplXCIsIFwiMTJweFwiKVxuICAgICAgICAgICAgLy8gLnN0eWxlKFwiZm9udC1zdHlsZVwiLCBcIml0YWxpY1wiKVxuICAgICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBjb2xvdXJzLmVpZ2h0ZWVuLmRhcmtHcmV5KTtcblxuICAgICAgICBsZXQgd2lkdGggPSBsYWJlbC5ub2RlKCkuZ2V0QkJveCgpLndpZHRoO1xuICAgICAgICBpZiAod2lkdGggPj0gaGVpZ2h0ICYmIHRoaXMuX2RhdGFBeGlzTGFiZWwuc2hvcnQpIHtcbiAgICAgICAgICAgIGxhYmVsLnRleHQodGhpcy5fZGF0YUF4aXNMYWJlbC5zaG9ydCk7XG4gICAgICAgICAgICB3aWR0aCA9IGxhYmVsLm5vZGUoKS5nZXRCQm94KCkud2lkdGg7XG4gICAgICAgIH1cblxuICAgICAgICBsYWJlbC5hdHRyKFwiZHhcIiwgLXdpZHRoIC8gMik7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGdyaWQoc2VsZWN0aW9uLCB3aWR0aCwgYXhpcykge1xuICAgICAgICBzZWxlY3Rpb24uc2VsZWN0KFwiLmdyaWRcIikucmVtb3ZlKCk7XG5cbiAgICAgICAgbGV0IGdyaWQgPSBzZWxlY3Rpb24uYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImdyaWRcIilcbiAgICAgICAgICAgIC5jYWxsKGF4aXNcbiAgICAgICAgICAgICAgICAudGlja1NpemUoLXdpZHRoKVxuICAgICAgICAgICAgICAgIC50aWNrRm9ybWF0KFwiXCIpXG4gICAgICAgICAgICApO1xuXG4gICAgICAgIGdyaWQuc2VsZWN0QWxsKFwibGluZVwiKVxuICAgICAgICAgICAgLnN0eWxlKFwic3Ryb2tlXCIsIGNvbG91cnMuZWlnaHRlZW4ubGlnaHRHcmV5KTtcbiAgICAgICAgZ3JpZC5zZWxlY3RBbGwoXCIuZG9tYWluXCIpLnJlbW92ZSgpO1xuXG4gICAgICAgIGdyaWRcbiAgICAgICAgICAgIC5sb3dlcigpIC8vIEFsd2F5cyBlbnN1cmUgdGhhdCB0aGlzIGlzIGVhcmxpZXIgaW4gdGhlIGRvbS4gVGhpbmdzIG11c3QgYmUgZHJhd24gb24gdG9wIG9mIGl0LlxuICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAwKVxuICAgICAgICAgICAgLnRyYW5zaXRpb24oKVxuICAgICAgICAgICAgLmRlbGF5KDUwMClcbiAgICAgICAgICAgIC5kdXJhdGlvbig1MDApXG4gICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDEpO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB4YXhpcyhzZWxlY3Rpb24sIGhlaWdodCwgd2lkdGgsIHhheGlzKSB7XG4gICAgICAgIHNlbGVjdGlvbi5zZWxlY3QoXCIueC1heGlzXCIpLnJlbW92ZSgpO1xuICAgICAgICBsZXQgYXhpcyA9IHNlbGVjdGlvbi5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwieC1heGlzXCIpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZSgwLFwiICsgaGVpZ2h0ICsgXCIpXCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDApXG4gICAgICAgICAgICAuY2FsbCh4YXhpcyk7XG5cbiAgICAgICAgYXhpcy5zZWxlY3QoXCIuZG9tYWluXCIpLnJlbW92ZSgpO1xuXG4gICAgICAgIGxldCBtYXggPSAwO1xuICAgICAgICBjb25zdCBmb250U2l6ZSA9IDEyO1xuICAgICAgICBheGlzLnNlbGVjdEFsbChcInRleHRcIilcbiAgICAgICAgICAgIC8vIC5zdHlsZShcImZvbnQtZmFtaWx5XCIsIFwiT3BlbiBTYW5zLCBzYW5zLXNlcmlmXCIpXG4gICAgICAgICAgICAvLyAuc3R5bGUoXCJmb250LXNpemVcIiwgZm9udFNpemUgKyBcInB4XCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIGNvbG91cnMuZWlnaHRlZW4uZGFya0dyZXkpXG4gICAgICAgICAgICAubm9kZXMoKVxuICAgICAgICAgICAgLmZvckVhY2godGV4dCA9PiBtYXggPSBNYXRoLm1heChtYXgsIHRleHQuZ2V0QkJveCgpLndpZHRoKSk7XG5cbiAgICAgICAgaWYgKG1heCA+PSB3aWR0aCAtIDEwKSB7XG4gICAgICAgICAgICBjb25zdCBiYWQgPSBtYXggPj0gd2lkdGggKiAyO1xuICAgICAgICAgICAgY29uc3QgYW5nbGUgPSBiYWQgPyAtOTAgOiAtMzA7XG4gICAgICAgICAgICBjb25zdCBmb250U2l6ZSA9IHdpZHRoIDw9IDEzID8gOCA6IDEyO1xuICAgICAgICAgICAgY29uc3QgeCA9IGJhZCA/IC1mb250U2l6ZSA6IDA7XG4gICAgICAgICAgICBjb25zdCB5ID0gYmFkID8gNSA6IDI7XG5cbiAgICAgICAgICAgIGF4aXMuc2VsZWN0QWxsKFwidGV4dFwiKVxuICAgICAgICAgICAgICAgIC5zdHlsZSgndGV4dC1hbmNob3InLCAnZW5kJylcbiAgICAgICAgICAgICAgICAuc3R5bGUoXCJmb250LXNpemVcIiwgZm9udFNpemUgKyBcInB4XCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgKCkgPT4gXCJ0cmFuc2xhdGUoXCIgKyB4ICsgXCIsXCIgKyB5ICsgXCIpIHJvdGF0ZShcIiArIGFuZ2xlICsgXCIgMCwwKVwiKVxuICAgICAgICB9XG5cbiAgICAgICAgYXhpc1xuICAgICAgICAgICAgLnRyYW5zaXRpb24oKVxuICAgICAgICAgICAgLmR1cmF0aW9uKDEwMDApXG4gICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDEpO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB5YXhpcyhzZWxlY3Rpb24sIGF4aXMpIHtcbiAgICAgICAgc2VsZWN0aW9uLnNlbGVjdChcIi55LWF4aXNcIikucmVtb3ZlKCk7XG4gICAgICAgIGxldCB4ID0gc2VsZWN0aW9uLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJ5LWF4aXNcIilcbiAgICAgICAgICAgIC5jYWxsKGF4aXMudGlja1NpemUoMCkudGlja1BhZGRpbmcoMTApKVxuICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAwKVxuICAgICAgICAgICAgLnRyYW5zaXRpb24oKVxuICAgICAgICAgICAgLmR1cmF0aW9uKDEwMDApXG4gICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDEpO1xuXG4gICAgICAgIHguc2VsZWN0QWxsKFwidGV4dFwiKVxuICAgICAgICAgICAgLy8gLnN0eWxlKFwiZm9udC1mYW1pbHlcIiwgXCJPcGVuIFNhbnMsIHNhbnMtc2VyaWZcIilcbiAgICAgICAgICAgIC5zdHlsZShcImZpbGxcIiwgY29sb3Vycy5laWdodGVlbi5kYXJrR3JleSlcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgY2FsY0Jhckdyb3d0aChpLCBtYXgpIHtcbiAgICAgICAgaWYgKG1heCA8IDEwKSByZXR1cm4gaSAqIHRoaXMuX0JBUl9HUk9XVEggLyAyO1xuICAgICAgICBpZiAobWF4IDwgMzUpIHJldHVybiBpICogdGhpcy5fQkFSX0dST1dUSCAvIDQ7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIGdldFNlcmllc0NvbG91cihpKSB7XG4gICAgICAgIGlmIChpIDwgMCB8fCAhdGhpcy5fY29sb3VycykgcmV0dXJuIGNvbG91cnMuZWlnaHRlZW4ubWlkR3JleTtcblxuICAgICAgICBpID0gaSAlIHRoaXMuX2NvbG91cnMubGVuZ3RoO1xuICAgICAgICByZXR1cm4gdGhpcy5fY29sb3Vyc1tpXTtcbiAgICB9XG5cbiAgICBnZXRTb3J0ZWREYXRhKCkge1xuICAgICAgICBsZXQgZGF0YSA9IHRoaXMuX2RhdGE7XG4gICAgICAgIGlmICghZGF0YSB8fCAhZGF0YS5sZW5ndGgpIHJldHVybiBbXTtcblxuICAgICAgICBkYXRhID0gdGhpcy5fZGF0YS5zb3J0KChsaHMsIHJocykgPT4ge1xuICAgICAgICAgICAgbGhzID0gbGhzLmtleS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgcmhzID0gcmhzLmtleS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgICAgICBpZiAobGhzID09PSByaHMpIHJldHVybiAwO1xuICAgICAgICAgICAgaWYgKGxocyA8IHJocykgcmV0dXJuIC0xO1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIGdldFRyYW5zZm9ybWVkRGF0YSgpIHtcbiAgICAgICAgbGV0IGRhdGEgPSB0aGlzLmdldFNvcnRlZERhdGEoKTtcbiAgICAgICAgaWYgKCFkYXRhIHx8ICFkYXRhLmxlbmd0aCkgcmV0dXJuIFtdO1xuXG4gICAgICAgIGxldCByZXN1bHRzID0gW107XG5cbiAgICAgICAgY29uc3QgZ2V0WCA9IGQgPT4gdGhpcy5feEF4aXNPdmVycmlkZSA/IHRoaXMuX3hBeGlzT3ZlcnJpZGVbdGhpcy5feChkKV0gOiB0aGlzLl94KGQpO1xuXG4gICAgICAgIGRhdGEuZm9yRWFjaCgoc2VyaWVzLCBzX2kpID0+IHtcbiAgICAgICAgICAgIHNlcmllcy52YWx1ZXMuZm9yRWFjaCgoZCwgZF9pKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGZpZWxkID0gcmVzdWx0cy5maW5kKGJ1Y2tldCA9PiBidWNrZXQua2V5ID09PSBnZXRYKGQpKTtcbiAgICAgICAgICAgICAgICBpZiAoIWZpZWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6IGdldFgoZClcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGZpZWxkKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmaWVsZC5kYXRhLnB1c2goT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICAgICAgICAgIF9zZXJpZXM6IHNlcmllcyxcbiAgICAgICAgICAgICAgICAgICAgX3NfaTogc19pLFxuICAgICAgICAgICAgICAgICAgICBfa2V5OiBzZXJpZXMua2V5LFxuICAgICAgICAgICAgICAgICAgICBfeTogdGhpcy5feShkKVxuICAgICAgICAgICAgICAgIH0sIGQpKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cblxuICAgIGdldEtleXMoKSB7XG4gICAgICAgIGxldCBkYXRhID0gdGhpcy5fZGF0YTtcbiAgICAgICAgaWYgKCFkYXRhIHx8ICFkYXRhLmxlbmd0aCkgcmV0dXJuIFtdO1xuXG4gICAgICAgIHJldHVybiBbLi4ubmV3IFNldChkYXRhLm1hcChkID0+IGQua2V5KSldXG4gICAgfVxufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/ColumnChart.js\n')},"./src/Legend.js":
/*!***********************!*\
  !*** ./src/Legend.js ***!
  \***********************/
/*! exports provided: removeLegend, renderLegend, getColour, buckets, toColourKey */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeLegend", function() { return removeLegend; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "renderLegend", function() { return renderLegend; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getColour", function() { return getColour; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "buckets", function() { return buckets; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toColourKey", function() { return toColourKey; });\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers */ "./src/helpers.js");\n/* harmony import */ var _Colours__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Colours */ "./src/Colours.js");\n// Copyright (C) 2013-2014, 2018 BrandsEye (PTY) LTD\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this\n// software and associated documentation files (the "Software"), to deal in the Software\n// without restriction, including without limitation the rights to use, copy, modify,\n//     merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following\n// conditions:\n//\n//     The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n//     INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n// CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n\nfunction removeLegend(element) {\n    element.selectAll(".legend").remove();\n}\n\nfunction renderLegend(element, buckets, colourScale, width, height, min, options) {\n    if (!options) options = { }\n    let fontSize = options.fontSize || 12\n\n    min = min || 2;\n    removeLegend(element);\n\n    // Only if we have multiple series.\n    if (!buckets || !buckets.colours.size) return 0;\n\n    const colours = Array.from(buckets.colours);\n    if (colours.length < min) return 0;\n\n    const boundings = Object(_helpers__WEBPACK_IMPORTED_MODULE_0__["getBoundings"])(element, colours);\n\n    const legend = element.append("g")\n                          .attr("class", "legend");\n\n    let elements = legend.selectAll(".legend-element")\n                         .data(colours);\n\n    const position_start = 20;\n    let position = position_start;\n    let position_height = 0;\n\n    elements.enter()\n            .append("g")\n            .attr("class", (d, i) => "legend-element series series-" + toColourKey(d))\n            .style("cursor", "default")\n            .each((d, i, nodes) => {\n                let element = d3.select(nodes[i]);\n\n                element.append("rect")\n                       .attr("width", 10)\n                       .attr("height", 10)\n                       .attr("rx", 2)\n                       .attr("ry", 2)\n                       .attr("y", -10)\n                       .style("fill", d => colourScale(d));\n\n                element.append("text")\n                       .text(d => d)\n                       .attr("dx", 12)\n                       .style("font-size", fontSize + "px")\n                       .style("fill", _Colours__WEBPACK_IMPORTED_MODULE_1__["colours"].eighteen.darkGrey);\n\n                element.append("title")\n                       .text(d => d);\n\n                element.attr("transform", "translate(" + position + "," + position_height +")");\n                const positionDelta = boundings[d].width + 25;\n                position += positionDelta;\n\n                if (position >= width) {\n                    position = position_start;\n                    position_height += 15;\n                    element.attr("transform", "translate(" + position + "," + position_height + ")");\n                    position += positionDelta;\n                }\n\n            })\n            .on("mouseover", (d, i, nodes) => {\n                element.selectAll(".series:not(.series-" + toColourKey(d) + ")")\n                   .interrupt("legend:highlight")\n                   .transition("legend:highlight")\n                   .style("opacity", 0.3);\n            })\n            .on("mouseout", (d, i, nodes) => {\n                element.selectAll(".series")\n                   .interrupt("legend:highlight")\n                   .transition("legend:highlight")\n                   .style("opacity", 1);\n            })\n            .style("opacity", 0)\n            .transition()\n            .duration(1000)\n            .style("opacity", 1);\n\n    const legendHeight = legend.node().getBBox().height;\n    legend.attr("transform", "translate(0," + (height - legendHeight) + ")");\n    return legendHeight;\n}\n\n/**\n * Given a data point, this determines its colours.\n * @param d\n * @param individualColours\n * @param colourScale\n * @returns {*}\n */\nfunction getColour(d, individualColours, colourScale) {\n    return individualColours(d) || colourScale(d._colour);\n}\n\n/**\n * Figures out what buckets we may be using in our data set, based on\n * colour and size differentiation. This may have to be run for each\n * geom and merged.\n * @param data\n * @param colour\n * @param size\n * @returns {{colours: Set, sizes: Set}}\n */\nfunction buckets(data, colour, individualColour, size) {\n    if (!data || !data.length) return { colours: new Set(), sizes: new Set()};\n\n    const byColour = new Set(),\n          bySize = new Set(),\n          bucketColour = {};\n\n    data.forEach(d => {\n        const c = colour(d);\n        byColour.add(c);\n        bySize.add(size(d));\n\n        if (individualColour && individualColour(d, -1) !== -1) {\n            bucketColour[c] = individualColour(d);\n        }\n    });\n\n    return {\n        colours: byColour,\n        sizes: bySize,\n        bucketColour: bucketColour\n    }\n}\n\nfunction toColourKey(colour) {\n    // TODO this is not internationalised, and may break on things like brand names.\n    colour = colour || "unknown-element";\n    return "colour-" + colour.toString().toLowerCase().replace(/\\s+/g, \'-\').replace(/[^a-z0-9]/g, \'\');\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvTGVnZW5kLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYjNqcy8uL3NyYy9MZWdlbmQuanM/OTIwNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKEMpIDIwMTMtMjAxNCwgMjAxOCBCcmFuZHNFeWUgKFBUWSkgTFREXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZiB0aGlzXG4vLyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmVcbi8vIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSxcbi8vICAgICBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvXG4vLyBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZ1xuLy8gY29uZGl0aW9uczpcbi8vXG4vLyAgICAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4vLyBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vICAgICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SIElNUExJRUQsXG4vLyAgICAgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEFcbi8vIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFRcbi8vIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRlxuLy8gQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFXG4vLyBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IHsgZ2V0Qm91bmRpbmdzIH0gZnJvbSBcIi4vaGVscGVyc1wiO1xuaW1wb3J0IHsgY29sb3VycyBhcyBzY2hlbWEgfSBmcm9tIFwiLi9Db2xvdXJzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVMZWdlbmQoZWxlbWVudCkge1xuICAgIGVsZW1lbnQuc2VsZWN0QWxsKFwiLmxlZ2VuZFwiKS5yZW1vdmUoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbmRlckxlZ2VuZChlbGVtZW50LCBidWNrZXRzLCBjb2xvdXJTY2FsZSwgd2lkdGgsIGhlaWdodCwgbWluLCBvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0geyB9XG4gICAgbGV0IGZvbnRTaXplID0gb3B0aW9ucy5mb250U2l6ZSB8fCAxMlxuXG4gICAgbWluID0gbWluIHx8IDI7XG4gICAgcmVtb3ZlTGVnZW5kKGVsZW1lbnQpO1xuXG4gICAgLy8gT25seSBpZiB3ZSBoYXZlIG11bHRpcGxlIHNlcmllcy5cbiAgICBpZiAoIWJ1Y2tldHMgfHwgIWJ1Y2tldHMuY29sb3Vycy5zaXplKSByZXR1cm4gMDtcblxuICAgIGNvbnN0IGNvbG91cnMgPSBBcnJheS5mcm9tKGJ1Y2tldHMuY29sb3Vycyk7XG4gICAgaWYgKGNvbG91cnMubGVuZ3RoIDwgbWluKSByZXR1cm4gMDtcblxuICAgIGNvbnN0IGJvdW5kaW5ncyA9IGdldEJvdW5kaW5ncyhlbGVtZW50LCBjb2xvdXJzKTtcblxuICAgIGNvbnN0IGxlZ2VuZCA9IGVsZW1lbnQuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwibGVnZW5kXCIpO1xuXG4gICAgbGV0IGVsZW1lbnRzID0gbGVnZW5kLnNlbGVjdEFsbChcIi5sZWdlbmQtZWxlbWVudFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgIC5kYXRhKGNvbG91cnMpO1xuXG4gICAgY29uc3QgcG9zaXRpb25fc3RhcnQgPSAyMDtcbiAgICBsZXQgcG9zaXRpb24gPSBwb3NpdGlvbl9zdGFydDtcbiAgICBsZXQgcG9zaXRpb25faGVpZ2h0ID0gMDtcblxuICAgIGVsZW1lbnRzLmVudGVyKClcbiAgICAgICAgICAgIC5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIChkLCBpKSA9PiBcImxlZ2VuZC1lbGVtZW50IHNlcmllcyBzZXJpZXMtXCIgKyB0b0NvbG91cktleShkKSlcbiAgICAgICAgICAgIC5zdHlsZShcImN1cnNvclwiLCBcImRlZmF1bHRcIilcbiAgICAgICAgICAgIC5lYWNoKChkLCBpLCBub2RlcykgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBlbGVtZW50ID0gZDMuc2VsZWN0KG5vZGVzW2ldKTtcblxuICAgICAgICAgICAgICAgIGVsZW1lbnQuYXBwZW5kKFwicmVjdFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcIndpZHRoXCIsIDEwKVxuICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcImhlaWdodFwiLCAxMClcbiAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJyeFwiLCAyKVxuICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcInJ5XCIsIDIpXG4gICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwieVwiLCAtMTApXG4gICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcImZpbGxcIiwgZCA9PiBjb2xvdXJTY2FsZShkKSk7XG5cbiAgICAgICAgICAgICAgICBlbGVtZW50LmFwcGVuZChcInRleHRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgLnRleHQoZCA9PiBkKVxuICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcImR4XCIsIDEyKVxuICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJmb250LXNpemVcIiwgZm9udFNpemUgKyBcInB4XCIpXG4gICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcImZpbGxcIiwgc2NoZW1hLmVpZ2h0ZWVuLmRhcmtHcmV5KTtcblxuICAgICAgICAgICAgICAgIGVsZW1lbnQuYXBwZW5kKFwidGl0bGVcIilcbiAgICAgICAgICAgICAgICAgICAgICAgLnRleHQoZCA9PiBkKTtcblxuICAgICAgICAgICAgICAgIGVsZW1lbnQuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIHBvc2l0aW9uICsgXCIsXCIgKyBwb3NpdGlvbl9oZWlnaHQgK1wiKVwiKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwb3NpdGlvbkRlbHRhID0gYm91bmRpbmdzW2RdLndpZHRoICsgMjU7XG4gICAgICAgICAgICAgICAgcG9zaXRpb24gKz0gcG9zaXRpb25EZWx0YTtcblxuICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA+PSB3aWR0aCkge1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IHBvc2l0aW9uX3N0YXJ0O1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbl9oZWlnaHQgKz0gMTU7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIHBvc2l0aW9uICsgXCIsXCIgKyBwb3NpdGlvbl9oZWlnaHQgKyBcIilcIik7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uICs9IHBvc2l0aW9uRGVsdGE7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLm9uKFwibW91c2VvdmVyXCIsIChkLCBpLCBub2RlcykgPT4ge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuc2VsZWN0QWxsKFwiLnNlcmllczpub3QoLnNlcmllcy1cIiArIHRvQ29sb3VyS2V5KGQpICsgXCIpXCIpXG4gICAgICAgICAgICAgICAgICAgLmludGVycnVwdChcImxlZ2VuZDpoaWdobGlnaHRcIilcbiAgICAgICAgICAgICAgICAgICAudHJhbnNpdGlvbihcImxlZ2VuZDpoaWdobGlnaHRcIilcbiAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDAuMyk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLm9uKFwibW91c2VvdXRcIiwgKGQsIGksIG5vZGVzKSA9PiB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5zZWxlY3RBbGwoXCIuc2VyaWVzXCIpXG4gICAgICAgICAgICAgICAgICAgLmludGVycnVwdChcImxlZ2VuZDpoaWdobGlnaHRcIilcbiAgICAgICAgICAgICAgICAgICAudHJhbnNpdGlvbihcImxlZ2VuZDpoaWdobGlnaHRcIilcbiAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDEpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMClcbiAgICAgICAgICAgIC50cmFuc2l0aW9uKClcbiAgICAgICAgICAgIC5kdXJhdGlvbigxMDAwKVxuICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAxKTtcblxuICAgIGNvbnN0IGxlZ2VuZEhlaWdodCA9IGxlZ2VuZC5ub2RlKCkuZ2V0QkJveCgpLmhlaWdodDtcbiAgICBsZWdlbmQuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZSgwLFwiICsgKGhlaWdodCAtIGxlZ2VuZEhlaWdodCkgKyBcIilcIik7XG4gICAgcmV0dXJuIGxlZ2VuZEhlaWdodDtcbn1cblxuLyoqXG4gKiBHaXZlbiBhIGRhdGEgcG9pbnQsIHRoaXMgZGV0ZXJtaW5lcyBpdHMgY29sb3Vycy5cbiAqIEBwYXJhbSBkXG4gKiBAcGFyYW0gaW5kaXZpZHVhbENvbG91cnNcbiAqIEBwYXJhbSBjb2xvdXJTY2FsZVxuICogQHJldHVybnMgeyp9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDb2xvdXIoZCwgaW5kaXZpZHVhbENvbG91cnMsIGNvbG91clNjYWxlKSB7XG4gICAgcmV0dXJuIGluZGl2aWR1YWxDb2xvdXJzKGQpIHx8IGNvbG91clNjYWxlKGQuX2NvbG91cik7XG59XG5cbi8qKlxuICogRmlndXJlcyBvdXQgd2hhdCBidWNrZXRzIHdlIG1heSBiZSB1c2luZyBpbiBvdXIgZGF0YSBzZXQsIGJhc2VkIG9uXG4gKiBjb2xvdXIgYW5kIHNpemUgZGlmZmVyZW50aWF0aW9uLiBUaGlzIG1heSBoYXZlIHRvIGJlIHJ1biBmb3IgZWFjaFxuICogZ2VvbSBhbmQgbWVyZ2VkLlxuICogQHBhcmFtIGRhdGFcbiAqIEBwYXJhbSBjb2xvdXJcbiAqIEBwYXJhbSBzaXplXG4gKiBAcmV0dXJucyB7e2NvbG91cnM6IFNldCwgc2l6ZXM6IFNldH19XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBidWNrZXRzKGRhdGEsIGNvbG91ciwgaW5kaXZpZHVhbENvbG91ciwgc2l6ZSkge1xuICAgIGlmICghZGF0YSB8fCAhZGF0YS5sZW5ndGgpIHJldHVybiB7IGNvbG91cnM6IG5ldyBTZXQoKSwgc2l6ZXM6IG5ldyBTZXQoKX07XG5cbiAgICBjb25zdCBieUNvbG91ciA9IG5ldyBTZXQoKSxcbiAgICAgICAgICBieVNpemUgPSBuZXcgU2V0KCksXG4gICAgICAgICAgYnVja2V0Q29sb3VyID0ge307XG5cbiAgICBkYXRhLmZvckVhY2goZCA9PiB7XG4gICAgICAgIGNvbnN0IGMgPSBjb2xvdXIoZCk7XG4gICAgICAgIGJ5Q29sb3VyLmFkZChjKTtcbiAgICAgICAgYnlTaXplLmFkZChzaXplKGQpKTtcblxuICAgICAgICBpZiAoaW5kaXZpZHVhbENvbG91ciAmJiBpbmRpdmlkdWFsQ29sb3VyKGQsIC0xKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIGJ1Y2tldENvbG91cltjXSA9IGluZGl2aWR1YWxDb2xvdXIoZCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGNvbG91cnM6IGJ5Q29sb3VyLFxuICAgICAgICBzaXplczogYnlTaXplLFxuICAgICAgICBidWNrZXRDb2xvdXI6IGJ1Y2tldENvbG91clxuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRvQ29sb3VyS2V5KGNvbG91cikge1xuICAgIC8vIFRPRE8gdGhpcyBpcyBub3QgaW50ZXJuYXRpb25hbGlzZWQsIGFuZCBtYXkgYnJlYWsgb24gdGhpbmdzIGxpa2UgYnJhbmQgbmFtZXMuXG4gICAgY29sb3VyID0gY29sb3VyIHx8IFwidW5rbm93bi1lbGVtZW50XCI7XG4gICAgcmV0dXJuIFwiY29sb3VyLVwiICsgY29sb3VyLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9cXHMrL2csICctJykucmVwbGFjZSgvW15hLXowLTldL2csICcnKTtcbn0iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/Legend.js\n')},"./src/LineChart.js":
/*!**************************!*\
  !*** ./src/LineChart.js ***!
  \**************************/
/*! exports provided: LineChart */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LineChart", function() { return LineChart; });\n/* harmony import */ var _Colours__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Colours */ "./src/Colours.js");\n/* harmony import */ var _Chart__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Chart */ "./src/Chart.js");\n// Copyright (C) 2013-2014, 2018 BrandsEye (PTY) LTD\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this\n// software and associated documentation files (the "Software"), to deal in the Software\n// without restriction, including without limitation the rights to use, copy, modify,\n//     merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following\n// conditions:\n//\n//     The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n//     INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n// CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n\n\nclass LineChart extends _Chart__WEBPACK_IMPORTED_MODULE_1__["Chart"] {\n\n    constructor() {\n        super();\n        this._xAxisTickFormat = d3.timeFormat("%B %d");\n    }\n\n    //------------------------------------------------------\n\n    data(data) {\n        if (!arguments.length) return this._data;\n        if (data && data[0].key === undefined) {\n            data = [\n                {\n                    key: "series 1",\n                    values: data\n                }\n            ];\n        }\n        this._data = data;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    element(element) {\n        if (!arguments.length) return this._element;\n        this._element = element;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    showLabels(show) {\n        if (!arguments.length) return this._show_labels;\n        this._show_labels = show;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    // todo dispatch\n    showLegend(show) {\n        if (!arguments.length) return this._show_legend;\n        this._show_legend = show;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    x(x) {\n        if (!arguments.length) return this._x;\n        this._x = x;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    y(y) {\n        if (!arguments.length) return this._y;\n        this._y = y;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    width(width) {\n        if (!arguments.length) return this._width;\n        this._width = width;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    height(height) {\n        if (!arguments.length) return this._height;\n        this._height = height;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    colours(colours) {\n        if (!arguments.length) return this._colours;\n        this._colours = colours;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    backgroundColour(colour) {\n        if (!arguments.length) return this._backgroundColour;\n        this._backgroundColour = colour || "#FFF"; // never set it to null.\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    tickFormat(format) {\n        if (!arguments.length) return this._tickFormat;\n        this._tickFormat = format;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    xAxisTickFormat(format) {\n        if (!arguments.length) return this._xAxisTickFormat;\n        this._xAxisTickFormat = format || (d => d.toString());\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    labelFormat(format) {\n        if (!arguments.length) return this._labelFormat;\n        this._labelFormat = format || (d => d.toString());\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    // todo missing\n    labelCompression(compression) {\n        if (!arguments.length) return this._compression;\n        this._compression = compression;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    //todo missing\n    dataAxisLabel(label) {\n        if (!arguments.length) return this._dataAxisLabel;\n        this._dataAxisLabel = label;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    tooltip(tooltip) {\n        if (!arguments.length) return this._tooltip;\n        this._tooltip = tooltip;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    forceY(force) {\n        if (!arguments.length) return this._forceY;\n        this._forceY = force;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n// todo missing\n    duration(duration) {\n        if (!arguments.length) return this._duration;\n        this._duration = duration;\n        return this;\n    }\n\n// todo missing\n    coarseness(coarseness) {\n        if (!arguments.length) return this._coarseness;\n        this._coarseness = coarseness;\n        return this;\n    }\n\n    // todo missing\n    padding(padding) {\n        if (!arguments.length) return this._padding;\n        this._padding = padding;\n        return this;\n    }\n\n    // todo missing\n    xAxisTooltips(tooltips) {\n        if (!arguments.length) return this._xAxisTooltips;\n        this._xAxisTooltips = tooltips;\n        return this;\n    }\n\n    xAxisOverride(override) {\n        if (!arguments.length) return this._xAxisOverride;\n        this._xAxisOverride = override;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    dispatch() {\n        return this._dispatch;\n    }\n\n    //------------------------------------------------------\n\n    render() {\n        if (!this._element) throw new Error("No element set for ColumnChart. See #element()");\n        if (!this._data) {\n            console.warn("No data set for ColumnChart. See #data()");\n            return;\n        }\n\n        const data = this.getTransformedData();\n        const keys = this.getKeys();\n\n        //------------------------------------------------\n        // Set up the SVG area\n\n        let topLevel = d3.select(this._element).select("svg");\n        if (topLevel.empty()) {\n            topLevel = d3.select(this._element).append("svg");\n        }\n\n        topLevel\n            .style("width", this._width + "px")\n            .style("height", this._height + "px");\n\n\n        // ---------------------------------\n        // Layout the showLegend.\n        //\n        // We do this now because we need to know how much space the legend\n        // takes up in order to finish calculating the margins.\n\n        const legendHeight = this.renderLegend();\n\n        //----------------------------------\n        // Calculate margins.\n\n        const margin = {top: 20, right: 20, bottom: 40, left: 40};\n        margin.bottom += legendHeight ? legendHeight + 20 : 0;\n\n        if (this._dataAxisLabel) margin.left += 20 + 12;\n        if (data) {\n            let maxLabelLength = 0;\n            data.forEach(d => {\n                d.data.forEach(d => {\n                    let length = this._xAxisTickFormat(this._x(d)).length;\n                    if (length > maxLabelLength) maxLabelLength = length;\n                })\n            });\n            margin.bottom += maxLabelLength * 2 + 10;    // space for axes labels.\n        }\n\n        const width = this._width - margin.left - margin.right,\n            height = this._height - margin.top - margin.bottom;\n\n        //----------------------------------\n        // Calculate scales and so on.\n\n\n        const x = d3.scaleTime()\n            .range([0, width]);\n\n        const y = d3.scaleLinear()\n            .range([height, 0])\n            .nice(5);\n        this._xscale = x;\n        this._yscale = y;\n\n        // Scale the range of the data in the domains\n\n        const allData = data.map(d => d.data).reduce((acc, val) => acc.concat(val));\n        x.domain(d3.extent(allData, d => d._x));\n        y.domain([Math.min(0, d3.min(allData, d => d._y)), d3.max(allData, d => d._y)]);\n\n        //------------------------------\n\n        let svg = topLevel.select(\'.main-group\');\n\n        if (svg.empty()) {\n            svg = topLevel\n                .append("g")\n                .attr("class", "main-group");\n        }\n\n        svg.attr("transform", "translate(" + margin.left + "," + margin.top + ")");\n\n        //---------------------------------\n        // append the lines\n        let lineGroup = svg.select(".lines");\n        lineGroup.selectAll("circle").remove();\n\n        let circle = false;\n        let lastMouse = null;\n        let lastMin = null;\n\n        if (lineGroup.empty()) {\n            lineGroup = svg\n                .append("g")\n                .attr("class", "lines")\n\n            lineGroup\n                .append("rect")\n                .style("opacity", "0")\n                .attr("width", "100%")\n                .attr("height", "100%");\n        }\n\n        lineGroup\n            .on("mousemove", (d, i, nodes) => { // Darken the bar on mouse over\n                const mouse = d3.mouse(nodes[i]);\n\n                const xval = x.invert(mouse[0]);\n                const yval = y.invert(mouse[1]);\n                // let min = this.getClosestPoint(xval, yval, this.getTransformedData()[0].data);\n\n                let mins = data.map(d => this.getClosestPoint(xval, yval, d.data));\n                mins.forEach(d => d._dist =  [x(d._x), y(d._y)])\n\n                mins = mins.filter(min => {\n                    const minScreenDist = Math.sqrt((mouse[0] - min._dist[0]) ** 2 + (mouse[1] - min._dist[1]) ** 2);\n                    min._min_screen = minScreenDist;\n                    return minScreenDist < 100;\n                });\n\n\n                if (!mins || !mins.length) {\n                    lastMouse = null;\n                    lineGroup.selectAll("circle").remove();\n                    return;\n                }\n\n                mins = mins.sort((lhs, rhs) => lhs._min_screen - rhs._min_screen);\n                let min = mins[0];\n\n                if (circle) {\n                    if (lastMin && min._x.getTime() === lastMin._x.getTime()) return;\n                    lineGroup.selectAll("circle").remove();\n                }\n\n                circle = true;\n                lastMouse = mouse;\n                lastMin = min;\n                lineGroup\n                    .append("circle")\n                        .attr("cx", x(min._x))\n                        .attr("cy", y(min._y))\n                        .attr("r", 10)\n                        .attr("fill", this.getSeriesColour(min._s_i))\n                        .style("opacity", 0.1)\n                    .on("mouseover", () => {\n                        this._dispatch.call("tooltipShow", this, {\n                            e: d3.event,\n                            point: min,\n                            series: data[min._s_i],\n                            seriesIndex: min._s_i,\n                            value: min._y\n                        })\n                    })\n                    .on("mouseout", (d, i, nodes) => { // bar is regular colour on mouse out.\n                        this._dispatch.call("tooltipHide", this);\n                    })\n                    .transition()\n                        .style("opacity", 0.5)\n\n            });\n\n        let lines = lineGroup.selectAll(\'.line\');\n        lines = lines.data(data);\n\n        lines.exit().remove();\n\n        const line = d3.line()\n            .x(d => x(d._x))\n            .y(d => y(d._y));\n\n        lines\n            .enter()\n            .append("path")\n                .attr("class", "line")\n                .attr("fill", "none")\n                .attr("stroke", (d, i) => this.getSeriesColour(i))\n                .attr("stroke-linejoin", "round")\n                .attr("stroke-linecap", "round")\n                .attr("stroke-width", 1.5)\n                .style("opacity", 0)\n\n            // .transition()\n            // .duration(this._duration)\n                .style("opacity", 1)\n                .attr("d", d => line(d.data));\n\n        lines\n            // .transition()\n            .attr("d", d => line(d.data));\n\n\n        // Adding new groups, and hence adding new bars to those groups.\n        // groups.enter()\n        //     .append("g")\n        //     .attr("class", "group")\n        //     .attr("transform", d => "translate(" + x(d.key) + ",0)")\n        //     .attr("width", x.bandwidth())\n        //     .attr("height", "100%")\n        //     .merge(groups)\n        //     .interrupt("groups:move")\n        //     .transition("groups:move")\n        //     .attr("transform", d => "translate(" + x(d.key) + ",0)")\n        //     .attr("width", x.bandwidth())\n        //     .each((s_d, s_i, nodes) => {\n        //         let group = d3.select(nodes[s_i])\n        //\n        //         let bars = group.selectAll(".bar")\n        //             .data(s_d.data);\n        //\n        //         bars.exit().remove();\n        //\n        //         bars.interrupt("bar:move")     // Animate the bars to their new position.\n        //             .transition("bar:move")\n        //             .attr("width", xGroup.bandwidth())\n        //             .attr("x", d => xGroup(d._key))\n        //             .attr("y", 0);\n        //\n        //         bars.enter()\n        //             .append("rect")\n        //             .attr("class", (d, i) => "bar series series-" + i)\n        //             .attr("x", d => xGroup(d._key))\n        //             .attr("y", 0)\n        //             .attr("width", xGroup.bandwidth())\n        //             .attr("height", 0)\n        //             .style("fill", (d, i) => this.getSeriesColour(i))\n        //             .style("cursor", "pointer")\n        //             .on("mouseover", (d, i, nodes) => { // Darken the bar on mouse over\n        //                 d3.select(nodes[i])\n        //                     .interrupt("hover:colour")\n        //                     .transition("hover:colour")\n        //                     .duration(400)\n        //                     .style("fill", d3.hcl(this.getSeriesColour(i)).darker())\n        //                 this._dispatch.call("tooltipShow", this, {\n        //                     e: d3.event,\n        //                     point: d,\n        //                     series: s_d,\n        //                     seriesIndex: s_i,\n        //                     value: d._y\n        //                 })\n        //             })\n        //             .on("mouseout", (d, i, nodes) => { // bar is regular colour on mouse out.\n        //                 d3.select(nodes[i])\n        //                     .interrupt("hover:colour")\n        //                     .transition("hover:colour")\n        //                     .duration(400)\n        //                     .style("fill", this.getSeriesColour(i));\n        //                 this._dispatch.call("tooltipHide", this);\n        //             })\n        //             .on("click auxclick", (d, i, nodes) => {\n        //                 this._dispatch.call("elementClick", this, {\n        //                     e: d3.event,\n        //                     point: d,\n        //                     series: d._series,\n        //                     seriesIndex: s_i,\n        //                     value: this._y(d)\n        //                 })\n        //             })\n        //             .merge(bars)\n        //             .interrupt("bar:growth")    // Animate bars growing.\n        //             .transition("bar:growth")\n        //             .delay((d) => {\n        //                 return this.calcBarGrowth(s_i, nodes.length);\n        //             })\n        //             .duration(this._duration)\n        //             .style("fill", (d, i) => this.getSeriesColour(i))\n        //             .attr("height", d => height - y(d._y));\n        //\n        //     })\n\n        // ---------------------------------\n        // Labels loaded after our first bar grows.\n        // if (this._show_labels) {\n        //     svg.transition("bar:growth")\n        //         .on("end", (d, i, nodes) => {\n        //             if (i < nodes.length - 1) return;\n        //             this.renderLabels(svg, data, x, xGroup, y);\n        //         })\n        // }\n\n        // ---------------------------------\n        // Draw the y axis data label.\n\n        if (this._dataAxisLabel) {\n            this.renderDataAxisLabel(height, margin);\n        }\n\n        // ---------------------------------\n        // Set the background colour\n\n        d3.select(this._element).select(".background").remove();\n        if (this._backgroundColour) {\n            d3.select(this._element).select("svg")\n                .append("rect")\n                .attr("class", "background")\n                .attr("width", "100%")\n                .attr("height", "100%")\n                .style("fill", this._backgroundColour)\n                .lower();\n        }\n\n        //---------------------------------\n        // add the Y gridlines\n        svg.call(this.grid, width, d3.axisLeft(y).ticks(5));\n\n        //---------------------------------\n        // axes\n        svg.call(this.xaxis, height, d3.axisBottom(x).tickSize(0).tickPadding(5).tickFormat(this._xAxisTickFormat)); //); //\n        svg.call(this.yaxis, d3.axisLeft(y).ticks(5).tickFormat(this._tickFormat));\n    }\n\n    //------------------------------------------------------\n\n    /*\n     * Returns an object with two functions, #show() and #hide(),\n     * to show and hide the labels.\n     */\n    labels() {\n        return {\n\n            show: () => {\n                if (this._element) {\n                    let selection = this._element,\n                        data = this.getTransformedData(),\n                        xscale = this._xscale,\n                        xgroup = this._xgroupscale,\n                        yscale = this._yscale;\n\n                    if (selection) selection = d3.select(this._element).select("svg").select("g");\n                    if (!selection.empty() && data && xscale && yscale && xgroup) {\n                        let labels = selection.select(\'.chart-labels\');\n                        if (!labels.empty()) return;\n                        labels.remove()\n                        this.renderLabels(selection, data, xscale, xgroup, yscale, false);\n                    }\n                }\n\n            },\n\n            hide: () => {\n                if (this._element) {\n                    d3.select(this._element)\n                        .select(\'.chart-labels\')\n                        .interrupt("labels")\n                        .interrupt("labels:fade")\n                        .transition("labels:fade")\n                        .style("opacity", 0)\n                        .on("end", (d, i, nodes) => {\n                            d3.select(nodes[i]).remove();\n                        })\n                }\n            }\n        }\n    }\n\n    //------------------------------------------------------\n\n    renderLabels(selection, data, xscale, xgroup, yscale, animate) {\n        animate = animate === undefined ? true : animate;\n        selection.selectAll(".chart-labels").remove();\n\n        let labels = selection.append("g")\n            .attr("class", "chart-labels")\n            // .selectAll(".chart-label")\n            .selectAll(".label-group")\n            .data(data)\n\n        let maxWidth = 0;     // For calculating the max width of text.\n        let fontSize = 12;    // Our initial font size.\n        const buffer = 5;     // Buffer space between words and the top of a bar.\n        const calcDy = (ypos) => ypos < 10 ? fontSize + buffer : -buffer;\n\n        labels.enter().each((series, s_i, s_nodes) => {\n            let group = d3.select(s_nodes[s_i])\n                .append("g")\n                .attr("class", "label-group")\n                .attr("transform", d => "translate(" + xscale(d.key) + ",0)")\n                .selectAll(".chart-label")\n                .data(series.data)\n                .enter()\n                .each((d, i, nodes) => {\n\n                    // Want to figure out if the label is too dark / light for the\n                    // bar.\n                    let invertedColor = d3.hcl(this.getSeriesColour(i));\n                    invertedColor.l += Math.min(invertedColor.l + 50, 100);\n                    let invert = d3.hcl(this.getSeriesColour(i)).l < 60;\n\n                    let ypos = yscale(d._y);\n                    let dy = calcDy(ypos);\n                    let text = d3.select(nodes[i])\n                        .append("text")\n                        .text(this._labelFormat(d._y))\n                        .attr("class", "chart-label")\n                        .attr("y", ypos)\n                        .attr("dx", animate ? -15 : 0)\n                        .attr("dy", dy)\n                        .style("opacity", 0)\n                        .style("pointer-events", "none")\n                        // .style("font-family", "Open Sans, sans-serif")\n                        // .style("font-weight", "normal")\n                        // .style("font-size", fontSize + "px")\n                        .style("fill", dy > 0 && invert ? invertedColor.toString() : _Colours__WEBPACK_IMPORTED_MODULE_0__["colours"].eighteen.darkGrey);\n\n                    // Set the x position, which is based on width.\n                    const width = text.node().getBBox().width;\n                    maxWidth = Math.max(width, maxWidth);\n                    text\n                        .attr("x", xgroup(d._key) + xgroup.bandwidth() / 2 - width / 2);\n\n                    text\n                        .transition("labels")\n                        .delay(() => animate ? this.calcBarGrowth(s_i, s_nodes.length) : 0) // Delay in lockstep with bar growth.\n                        .duration(this._duration)\n                        .attr("dx", 0)\n                        .style("opacity", 1)\n                })\n        })\n\n\n        // Figure out if we don\'t have enough space to show our labels.\n        // We then want to resize, if possible.\n        if (xgroup.bandwidth() < maxWidth * 1.05) {\n            let scale = maxWidth / xgroup.bandwidth() * 1.05;\n            fontSize = Math.floor(fontSize / scale);\n\n            if (fontSize < 8) {\n                // The labels are too small.\n                labels.enter().selectAll("text").remove();\n            } else {\n                labels.enter()\n                    .merge(labels)\n                    .selectAll("text")\n                    .style("font-size", fontSize + "px")\n                    .each((d, i, nodes) => {\n                        const text = d3.select(nodes[i]);\n                        const width = text.node().getBBox().width;\n                        text\n                            .attr("x", xgroup(d._key) + xgroup.bandwidth() / 2 - width / 2)\n                            .attr("dy", calcDy(d._y));\n                    })\n            }\n        }\n    }\n\n    //------------------------------------------------------\n\n    renderDataAxisLabel(height, margins) {\n        let svg = d3.select(this._element).select(\'svg\');\n        svg.selectAll(".data-labels").remove();\n\n        if (!this._dataAxisLabel) return;\n        let text = this._dataAxisLabel;\n        if (text.long) text = text.long;\n\n        let x = -(margins.top + height / 2);\n\n        let label = svg.append("g")\n            .attr("class", "data-labels")\n            .append("text")\n            .text(text)\n            .attr("transform", "rotate(-90 0,0) translate(" + x + ", 20)")\n            // .style("font-family", "Open Sans, sans-serif")\n            // .style("font-size", "12px")\n            // .style("font-style", "italic")\n            .style("fill", _Colours__WEBPACK_IMPORTED_MODULE_0__["colours"].eighteen.darkGrey);\n\n        let width = label.node().getBBox().width;\n        if (width >= height && this._dataAxisLabel.short) {\n            label.text(this._dataAxisLabel.short);\n            width = label.node().getBBox().width;\n        }\n\n        label.attr("dx", -width / 2);\n    }\n\n    //------------------------------------------------------\n\n    grid(selection, width, axis) {\n        selection.select(".grid").remove();\n\n        let grid = selection.append("g")\n            .attr("class", "grid")\n            .call(axis\n                .tickSize(-width)\n                .tickFormat("")\n            );\n\n        grid.selectAll("line")\n            .style("stroke", _Colours__WEBPACK_IMPORTED_MODULE_0__["colours"].eighteen.lightGrey);\n        grid.selectAll(".domain").remove();\n\n        grid\n            .lower() // Always ensure that this is earlier in the dom. Things must be drawn on top of it.\n            .style("opacity", 0)\n            .transition()\n            .delay(500)\n            .duration(500)\n            .style("opacity", 1);\n    }\n\n    //------------------------------------------------------\n\n    xaxis(selection, height, xaxis) {\n        selection.select(".x-axis").remove();\n        let axis = selection.append("g")\n            .attr("class", "x-axis")\n            .attr("transform", "translate(0," + height + ")")\n            .style("opacity", 0)\n            .call(xaxis);\n\n        axis.select(".domain").remove();\n\n        axis\n            .selectAll("text")\n            .style(\'text-anchor\', \'end\')\n            .attr(\'transform\', \'rotate(-30, 0,0)\');\n\n        axis\n            .transition()\n            .duration(1000)\n            .style("opacity", 1);\n    }\n\n    //------------------------------------------------------\n\n    yaxis(selection, axis) {\n        selection.select(".y-axis").remove();\n        let x = selection.append("g")\n            .attr("class", "y-axis")\n            .call(axis.tickSize(0).tickPadding(10))\n            .style("opacity", 0)\n            .transition()\n            .duration(1000)\n            .style("opacity", 1);\n\n        x.selectAll("text")\n            // .style("font-family", "Open Sans, sans-serif")\n            .style("fill", _Colours__WEBPACK_IMPORTED_MODULE_0__["colours"].eighteen.darkGrey)\n    }\n\n    //------------------------------------------------------\n\n    calcBarGrowth(i, max) {\n        if (max < 10) return i * this._BAR_GROWTH / 2;\n        if (max < 35) return i * this._BAR_GROWTH / 4;\n        return 1;\n    }\n\n    getSeriesColour(i) {\n        if (i < 0 || !this._colours) return _Colours__WEBPACK_IMPORTED_MODULE_0__["colours"].eighteen.midGrey;\n\n        i = i % this._colours.length;\n        return this._colours[i];\n    }\n\n    getSortedData() {\n        let data = this._data;\n        if (!data || !data.length) return [];\n\n        data = this._data.sort((lhs, rhs) => {\n            lhs = lhs.key.toLowerCase();\n            rhs = rhs.key.toLowerCase();\n\n            if (lhs === rhs) return 0;\n            if (lhs < rhs) return -1;\n            return 1;\n        });\n\n        return data;\n    }\n\n    getTransformedData() {\n        let data = this.getSortedData();\n        if (!data || !data.length) return [];\n\n        let results = [];\n\n        data.forEach((series, s_i) => {\n            let s = Object.assign({}, series);\n            results.push(s);\n\n            let data = [];\n            s.values.forEach((d) => {\n                data.push(Object.assign({\n                    _x: new Date(this._xAxisOverride ? this._xAxisOverride[this._x(d)] : this._x(d)),\n                    _series: series,\n                    _s_i: s_i,\n                    _key: series.key,\n                    _y: this._y(d)\n                }, d));\n            });\n\n            s.data = data;\n            delete s.values;\n        });\n\n        return results;\n    }\n\n    getKeys() {\n        let data = this._data;\n        if (!data || !data.length) return [];\n\n        return [...new Set(data.map(d => d.key))]\n    }\n\n    getClosestPoint(xval, yval, data) {\n        let calcDist = d => Math.sqrt(Math.abs(d._x - xval) ** 2 + (d._y - yval) ** 2);\n        let min = data[0];\n        let minDist = calcDist(min);\n\n        data.forEach(d => {\n            let dist = calcDist(d);\n            if (dist < minDist) {\n                minDist = dist;\n                min = d;\n            }\n        });\n\n        return min;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvTGluZUNoYXJ0LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYjNqcy8uL3NyYy9MaW5lQ2hhcnQuanM/ODk0ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKEMpIDIwMTMtMjAxNCwgMjAxOCBCcmFuZHNFeWUgKFBUWSkgTFREXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZiB0aGlzXG4vLyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmVcbi8vIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSxcbi8vICAgICBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvXG4vLyBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZ1xuLy8gY29uZGl0aW9uczpcbi8vXG4vLyAgICAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4vLyBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vICAgICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SIElNUExJRUQsXG4vLyAgICAgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEFcbi8vIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFRcbi8vIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRlxuLy8gQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFXG4vLyBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IHtjb2xvdXJzfSBmcm9tICcuL0NvbG91cnMnO1xuaW1wb3J0IHtDaGFydH0gZnJvbSAnLi9DaGFydCc7XG5cblxuZXhwb3J0IGNsYXNzIExpbmVDaGFydCBleHRlbmRzIENoYXJ0IHtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl94QXhpc1RpY2tGb3JtYXQgPSBkMy50aW1lRm9ybWF0KFwiJUIgJWRcIik7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGRhdGEoZGF0YSkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9kYXRhO1xuICAgICAgICBpZiAoZGF0YSAmJiBkYXRhWzBdLmtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBkYXRhID0gW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAga2V5OiBcInNlcmllcyAxXCIsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlczogZGF0YVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZGF0YSA9IGRhdGE7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBlbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fZWxlbWVudDtcbiAgICAgICAgdGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBzaG93TGFiZWxzKHNob3cpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fc2hvd19sYWJlbHM7XG4gICAgICAgIHRoaXMuX3Nob3dfbGFiZWxzID0gc2hvdztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8vIHRvZG8gZGlzcGF0Y2hcbiAgICBzaG93TGVnZW5kKHNob3cpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fc2hvd19sZWdlbmQ7XG4gICAgICAgIHRoaXMuX3Nob3dfbGVnZW5kID0gc2hvdztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHgoeCkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl94O1xuICAgICAgICB0aGlzLl94ID0geDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHkoeSkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl95O1xuICAgICAgICB0aGlzLl95ID0geTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHdpZHRoKHdpZHRoKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3dpZHRoO1xuICAgICAgICB0aGlzLl93aWR0aCA9IHdpZHRoO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgaGVpZ2h0KGhlaWdodCkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9oZWlnaHQ7XG4gICAgICAgIHRoaXMuX2hlaWdodCA9IGhlaWdodDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGNvbG91cnMoY29sb3Vycykge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9jb2xvdXJzO1xuICAgICAgICB0aGlzLl9jb2xvdXJzID0gY29sb3VycztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGJhY2tncm91bmRDb2xvdXIoY29sb3VyKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX2JhY2tncm91bmRDb2xvdXI7XG4gICAgICAgIHRoaXMuX2JhY2tncm91bmRDb2xvdXIgPSBjb2xvdXIgfHwgXCIjRkZGXCI7IC8vIG5ldmVyIHNldCBpdCB0byBudWxsLlxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgdGlja0Zvcm1hdChmb3JtYXQpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fdGlja0Zvcm1hdDtcbiAgICAgICAgdGhpcy5fdGlja0Zvcm1hdCA9IGZvcm1hdDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHhBeGlzVGlja0Zvcm1hdChmb3JtYXQpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5feEF4aXNUaWNrRm9ybWF0O1xuICAgICAgICB0aGlzLl94QXhpc1RpY2tGb3JtYXQgPSBmb3JtYXQgfHwgKGQgPT4gZC50b1N0cmluZygpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGxhYmVsRm9ybWF0KGZvcm1hdCkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9sYWJlbEZvcm1hdDtcbiAgICAgICAgdGhpcy5fbGFiZWxGb3JtYXQgPSBmb3JtYXQgfHwgKGQgPT4gZC50b1N0cmluZygpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8vIHRvZG8gbWlzc2luZ1xuICAgIGxhYmVsQ29tcHJlc3Npb24oY29tcHJlc3Npb24pIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fY29tcHJlc3Npb247XG4gICAgICAgIHRoaXMuX2NvbXByZXNzaW9uID0gY29tcHJlc3Npb247XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvL3RvZG8gbWlzc2luZ1xuICAgIGRhdGFBeGlzTGFiZWwobGFiZWwpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fZGF0YUF4aXNMYWJlbDtcbiAgICAgICAgdGhpcy5fZGF0YUF4aXNMYWJlbCA9IGxhYmVsO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgdG9vbHRpcCh0b29sdGlwKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3Rvb2x0aXA7XG4gICAgICAgIHRoaXMuX3Rvb2x0aXAgPSB0b29sdGlwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgZm9yY2VZKGZvcmNlKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX2ZvcmNlWTtcbiAgICAgICAgdGhpcy5fZm9yY2VZID0gZm9yY2U7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8vIHRvZG8gbWlzc2luZ1xuICAgIGR1cmF0aW9uKGR1cmF0aW9uKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX2R1cmF0aW9uO1xuICAgICAgICB0aGlzLl9kdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbi8vIHRvZG8gbWlzc2luZ1xuICAgIGNvYXJzZW5lc3MoY29hcnNlbmVzcykge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9jb2Fyc2VuZXNzO1xuICAgICAgICB0aGlzLl9jb2Fyc2VuZXNzID0gY29hcnNlbmVzcztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gdG9kbyBtaXNzaW5nXG4gICAgcGFkZGluZyhwYWRkaW5nKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3BhZGRpbmc7XG4gICAgICAgIHRoaXMuX3BhZGRpbmcgPSBwYWRkaW5nO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyB0b2RvIG1pc3NpbmdcbiAgICB4QXhpc1Rvb2x0aXBzKHRvb2x0aXBzKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3hBeGlzVG9vbHRpcHM7XG4gICAgICAgIHRoaXMuX3hBeGlzVG9vbHRpcHMgPSB0b29sdGlwcztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgeEF4aXNPdmVycmlkZShvdmVycmlkZSkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl94QXhpc092ZXJyaWRlO1xuICAgICAgICB0aGlzLl94QXhpc092ZXJyaWRlID0gb3ZlcnJpZGU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBkaXNwYXRjaCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc3BhdGNoO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGlmICghdGhpcy5fZWxlbWVudCkgdGhyb3cgbmV3IEVycm9yKFwiTm8gZWxlbWVudCBzZXQgZm9yIENvbHVtbkNoYXJ0LiBTZWUgI2VsZW1lbnQoKVwiKTtcbiAgICAgICAgaWYgKCF0aGlzLl9kYXRhKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJObyBkYXRhIHNldCBmb3IgQ29sdW1uQ2hhcnQuIFNlZSAjZGF0YSgpXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMuZ2V0VHJhbnNmb3JtZWREYXRhKCk7XG4gICAgICAgIGNvbnN0IGtleXMgPSB0aGlzLmdldEtleXMoKTtcblxuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBTZXQgdXAgdGhlIFNWRyBhcmVhXG5cbiAgICAgICAgbGV0IHRvcExldmVsID0gZDMuc2VsZWN0KHRoaXMuX2VsZW1lbnQpLnNlbGVjdChcInN2Z1wiKTtcbiAgICAgICAgaWYgKHRvcExldmVsLmVtcHR5KCkpIHtcbiAgICAgICAgICAgIHRvcExldmVsID0gZDMuc2VsZWN0KHRoaXMuX2VsZW1lbnQpLmFwcGVuZChcInN2Z1wiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRvcExldmVsXG4gICAgICAgICAgICAuc3R5bGUoXCJ3aWR0aFwiLCB0aGlzLl93aWR0aCArIFwicHhcIilcbiAgICAgICAgICAgIC5zdHlsZShcImhlaWdodFwiLCB0aGlzLl9oZWlnaHQgKyBcInB4XCIpO1xuXG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIExheW91dCB0aGUgc2hvd0xlZ2VuZC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gV2UgZG8gdGhpcyBub3cgYmVjYXVzZSB3ZSBuZWVkIHRvIGtub3cgaG93IG11Y2ggc3BhY2UgdGhlIGxlZ2VuZFxuICAgICAgICAvLyB0YWtlcyB1cCBpbiBvcmRlciB0byBmaW5pc2ggY2FsY3VsYXRpbmcgdGhlIG1hcmdpbnMuXG5cbiAgICAgICAgY29uc3QgbGVnZW5kSGVpZ2h0ID0gdGhpcy5yZW5kZXJMZWdlbmQoKTtcblxuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gQ2FsY3VsYXRlIG1hcmdpbnMuXG5cbiAgICAgICAgY29uc3QgbWFyZ2luID0ge3RvcDogMjAsIHJpZ2h0OiAyMCwgYm90dG9tOiA0MCwgbGVmdDogNDB9O1xuICAgICAgICBtYXJnaW4uYm90dG9tICs9IGxlZ2VuZEhlaWdodCA/IGxlZ2VuZEhlaWdodCArIDIwIDogMDtcblxuICAgICAgICBpZiAodGhpcy5fZGF0YUF4aXNMYWJlbCkgbWFyZ2luLmxlZnQgKz0gMjAgKyAxMjtcbiAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgIGxldCBtYXhMYWJlbExlbmd0aCA9IDA7XG4gICAgICAgICAgICBkYXRhLmZvckVhY2goZCA9PiB7XG4gICAgICAgICAgICAgICAgZC5kYXRhLmZvckVhY2goZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBsZW5ndGggPSB0aGlzLl94QXhpc1RpY2tGb3JtYXQodGhpcy5feChkKSkubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGVuZ3RoID4gbWF4TGFiZWxMZW5ndGgpIG1heExhYmVsTGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG1hcmdpbi5ib3R0b20gKz0gbWF4TGFiZWxMZW5ndGggKiAyICsgMTA7ICAgIC8vIHNwYWNlIGZvciBheGVzIGxhYmVscy5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHdpZHRoID0gdGhpcy5fd2lkdGggLSBtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodCxcbiAgICAgICAgICAgIGhlaWdodCA9IHRoaXMuX2hlaWdodCAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tO1xuXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBDYWxjdWxhdGUgc2NhbGVzIGFuZCBzbyBvbi5cblxuXG4gICAgICAgIGNvbnN0IHggPSBkMy5zY2FsZVRpbWUoKVxuICAgICAgICAgICAgLnJhbmdlKFswLCB3aWR0aF0pO1xuXG4gICAgICAgIGNvbnN0IHkgPSBkMy5zY2FsZUxpbmVhcigpXG4gICAgICAgICAgICAucmFuZ2UoW2hlaWdodCwgMF0pXG4gICAgICAgICAgICAubmljZSg1KTtcbiAgICAgICAgdGhpcy5feHNjYWxlID0geDtcbiAgICAgICAgdGhpcy5feXNjYWxlID0geTtcblxuICAgICAgICAvLyBTY2FsZSB0aGUgcmFuZ2Ugb2YgdGhlIGRhdGEgaW4gdGhlIGRvbWFpbnNcblxuICAgICAgICBjb25zdCBhbGxEYXRhID0gZGF0YS5tYXAoZCA9PiBkLmRhdGEpLnJlZHVjZSgoYWNjLCB2YWwpID0+IGFjYy5jb25jYXQodmFsKSk7XG4gICAgICAgIHguZG9tYWluKGQzLmV4dGVudChhbGxEYXRhLCBkID0+IGQuX3gpKTtcbiAgICAgICAgeS5kb21haW4oW01hdGgubWluKDAsIGQzLm1pbihhbGxEYXRhLCBkID0+IGQuX3kpKSwgZDMubWF4KGFsbERhdGEsIGQgPT4gZC5feSldKTtcblxuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgIGxldCBzdmcgPSB0b3BMZXZlbC5zZWxlY3QoJy5tYWluLWdyb3VwJyk7XG5cbiAgICAgICAgaWYgKHN2Zy5lbXB0eSgpKSB7XG4gICAgICAgICAgICBzdmcgPSB0b3BMZXZlbFxuICAgICAgICAgICAgICAgIC5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcIm1haW4tZ3JvdXBcIik7XG4gICAgICAgIH1cblxuICAgICAgICBzdmcuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIG1hcmdpbi5sZWZ0ICsgXCIsXCIgKyBtYXJnaW4udG9wICsgXCIpXCIpO1xuXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIGFwcGVuZCB0aGUgbGluZXNcbiAgICAgICAgbGV0IGxpbmVHcm91cCA9IHN2Zy5zZWxlY3QoXCIubGluZXNcIik7XG4gICAgICAgIGxpbmVHcm91cC5zZWxlY3RBbGwoXCJjaXJjbGVcIikucmVtb3ZlKCk7XG5cbiAgICAgICAgbGV0IGNpcmNsZSA9IGZhbHNlO1xuICAgICAgICBsZXQgbGFzdE1vdXNlID0gbnVsbDtcbiAgICAgICAgbGV0IGxhc3RNaW4gPSBudWxsO1xuXG4gICAgICAgIGlmIChsaW5lR3JvdXAuZW1wdHkoKSkge1xuICAgICAgICAgICAgbGluZUdyb3VwID0gc3ZnXG4gICAgICAgICAgICAgICAgLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwibGluZXNcIilcblxuICAgICAgICAgICAgbGluZUdyb3VwXG4gICAgICAgICAgICAgICAgLmFwcGVuZChcInJlY3RcIilcbiAgICAgICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMFwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwid2lkdGhcIiwgXCIxMDAlXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgXCIxMDAlXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGluZUdyb3VwXG4gICAgICAgICAgICAub24oXCJtb3VzZW1vdmVcIiwgKGQsIGksIG5vZGVzKSA9PiB7IC8vIERhcmtlbiB0aGUgYmFyIG9uIG1vdXNlIG92ZXJcbiAgICAgICAgICAgICAgICBjb25zdCBtb3VzZSA9IGQzLm1vdXNlKG5vZGVzW2ldKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHh2YWwgPSB4LmludmVydChtb3VzZVswXSk7XG4gICAgICAgICAgICAgICAgY29uc3QgeXZhbCA9IHkuaW52ZXJ0KG1vdXNlWzFdKTtcbiAgICAgICAgICAgICAgICAvLyBsZXQgbWluID0gdGhpcy5nZXRDbG9zZXN0UG9pbnQoeHZhbCwgeXZhbCwgdGhpcy5nZXRUcmFuc2Zvcm1lZERhdGEoKVswXS5kYXRhKTtcblxuICAgICAgICAgICAgICAgIGxldCBtaW5zID0gZGF0YS5tYXAoZCA9PiB0aGlzLmdldENsb3Nlc3RQb2ludCh4dmFsLCB5dmFsLCBkLmRhdGEpKTtcbiAgICAgICAgICAgICAgICBtaW5zLmZvckVhY2goZCA9PiBkLl9kaXN0ID0gIFt4KGQuX3gpLCB5KGQuX3kpXSlcblxuICAgICAgICAgICAgICAgIG1pbnMgPSBtaW5zLmZpbHRlcihtaW4gPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtaW5TY3JlZW5EaXN0ID0gTWF0aC5zcXJ0KChtb3VzZVswXSAtIG1pbi5fZGlzdFswXSkgKiogMiArIChtb3VzZVsxXSAtIG1pbi5fZGlzdFsxXSkgKiogMik7XG4gICAgICAgICAgICAgICAgICAgIG1pbi5fbWluX3NjcmVlbiA9IG1pblNjcmVlbkRpc3Q7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtaW5TY3JlZW5EaXN0IDwgMTAwO1xuICAgICAgICAgICAgICAgIH0pO1xuXG5cbiAgICAgICAgICAgICAgICBpZiAoIW1pbnMgfHwgIW1pbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RNb3VzZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVHcm91cC5zZWxlY3RBbGwoXCJjaXJjbGVcIikucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtaW5zID0gbWlucy5zb3J0KChsaHMsIHJocykgPT4gbGhzLl9taW5fc2NyZWVuIC0gcmhzLl9taW5fc2NyZWVuKTtcbiAgICAgICAgICAgICAgICBsZXQgbWluID0gbWluc1swXTtcblxuICAgICAgICAgICAgICAgIGlmIChjaXJjbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3RNaW4gJiYgbWluLl94LmdldFRpbWUoKSA9PT0gbGFzdE1pbi5feC5nZXRUaW1lKCkpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgbGluZUdyb3VwLnNlbGVjdEFsbChcImNpcmNsZVwiKS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjaXJjbGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGxhc3RNb3VzZSA9IG1vdXNlO1xuICAgICAgICAgICAgICAgIGxhc3RNaW4gPSBtaW47XG4gICAgICAgICAgICAgICAgbGluZUdyb3VwXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoXCJjaXJjbGVcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiY3hcIiwgeChtaW4uX3gpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJjeVwiLCB5KG1pbi5feSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcInJcIiwgMTApXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcImZpbGxcIiwgdGhpcy5nZXRTZXJpZXNDb2xvdXIobWluLl9zX2kpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAwLjEpXG4gICAgICAgICAgICAgICAgICAgIC5vbihcIm1vdXNlb3ZlclwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXNwYXRjaC5jYWxsKFwidG9vbHRpcFNob3dcIiwgdGhpcywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGU6IGQzLmV2ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50OiBtaW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzOiBkYXRhW21pbi5fc19pXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXNJbmRleDogbWluLl9zX2ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG1pbi5feVxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLm9uKFwibW91c2VvdXRcIiwgKGQsIGksIG5vZGVzKSA9PiB7IC8vIGJhciBpcyByZWd1bGFyIGNvbG91ciBvbiBtb3VzZSBvdXQuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXNwYXRjaC5jYWxsKFwidG9vbHRpcEhpZGVcIiwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMC41KVxuXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICBsZXQgbGluZXMgPSBsaW5lR3JvdXAuc2VsZWN0QWxsKCcubGluZScpO1xuICAgICAgICBsaW5lcyA9IGxpbmVzLmRhdGEoZGF0YSk7XG5cbiAgICAgICAgbGluZXMuZXhpdCgpLnJlbW92ZSgpO1xuXG4gICAgICAgIGNvbnN0IGxpbmUgPSBkMy5saW5lKClcbiAgICAgICAgICAgIC54KGQgPT4geChkLl94KSlcbiAgICAgICAgICAgIC55KGQgPT4geShkLl95KSk7XG5cbiAgICAgICAgbGluZXNcbiAgICAgICAgICAgIC5lbnRlcigpXG4gICAgICAgICAgICAuYXBwZW5kKFwicGF0aFwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJsaW5lXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJmaWxsXCIsIFwibm9uZVwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwic3Ryb2tlXCIsIChkLCBpKSA9PiB0aGlzLmdldFNlcmllc0NvbG91cihpKSlcbiAgICAgICAgICAgICAgICAuYXR0cihcInN0cm9rZS1saW5lam9pblwiLCBcInJvdW5kXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJzdHJva2UtbGluZWNhcFwiLCBcInJvdW5kXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJzdHJva2Utd2lkdGhcIiwgMS41KVxuICAgICAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMClcblxuICAgICAgICAgICAgLy8gLnRyYW5zaXRpb24oKVxuICAgICAgICAgICAgLy8gLmR1cmF0aW9uKHRoaXMuX2R1cmF0aW9uKVxuICAgICAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMSlcbiAgICAgICAgICAgICAgICAuYXR0cihcImRcIiwgZCA9PiBsaW5lKGQuZGF0YSkpO1xuXG4gICAgICAgIGxpbmVzXG4gICAgICAgICAgICAvLyAudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAuYXR0cihcImRcIiwgZCA9PiBsaW5lKGQuZGF0YSkpO1xuXG5cbiAgICAgICAgLy8gQWRkaW5nIG5ldyBncm91cHMsIGFuZCBoZW5jZSBhZGRpbmcgbmV3IGJhcnMgdG8gdGhvc2UgZ3JvdXBzLlxuICAgICAgICAvLyBncm91cHMuZW50ZXIoKVxuICAgICAgICAvLyAgICAgLmFwcGVuZChcImdcIilcbiAgICAgICAgLy8gICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJncm91cFwiKVxuICAgICAgICAvLyAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgZCA9PiBcInRyYW5zbGF0ZShcIiArIHgoZC5rZXkpICsgXCIsMClcIilcbiAgICAgICAgLy8gICAgIC5hdHRyKFwid2lkdGhcIiwgeC5iYW5kd2lkdGgoKSlcbiAgICAgICAgLy8gICAgIC5hdHRyKFwiaGVpZ2h0XCIsIFwiMTAwJVwiKVxuICAgICAgICAvLyAgICAgLm1lcmdlKGdyb3VwcylcbiAgICAgICAgLy8gICAgIC5pbnRlcnJ1cHQoXCJncm91cHM6bW92ZVwiKVxuICAgICAgICAvLyAgICAgLnRyYW5zaXRpb24oXCJncm91cHM6bW92ZVwiKVxuICAgICAgICAvLyAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgZCA9PiBcInRyYW5zbGF0ZShcIiArIHgoZC5rZXkpICsgXCIsMClcIilcbiAgICAgICAgLy8gICAgIC5hdHRyKFwid2lkdGhcIiwgeC5iYW5kd2lkdGgoKSlcbiAgICAgICAgLy8gICAgIC5lYWNoKChzX2QsIHNfaSwgbm9kZXMpID0+IHtcbiAgICAgICAgLy8gICAgICAgICBsZXQgZ3JvdXAgPSBkMy5zZWxlY3Qobm9kZXNbc19pXSlcbiAgICAgICAgLy9cbiAgICAgICAgLy8gICAgICAgICBsZXQgYmFycyA9IGdyb3VwLnNlbGVjdEFsbChcIi5iYXJcIilcbiAgICAgICAgLy8gICAgICAgICAgICAgLmRhdGEoc19kLmRhdGEpO1xuICAgICAgICAvL1xuICAgICAgICAvLyAgICAgICAgIGJhcnMuZXhpdCgpLnJlbW92ZSgpO1xuICAgICAgICAvL1xuICAgICAgICAvLyAgICAgICAgIGJhcnMuaW50ZXJydXB0KFwiYmFyOm1vdmVcIikgICAgIC8vIEFuaW1hdGUgdGhlIGJhcnMgdG8gdGhlaXIgbmV3IHBvc2l0aW9uLlxuICAgICAgICAvLyAgICAgICAgICAgICAudHJhbnNpdGlvbihcImJhcjptb3ZlXCIpXG4gICAgICAgIC8vICAgICAgICAgICAgIC5hdHRyKFwid2lkdGhcIiwgeEdyb3VwLmJhbmR3aWR0aCgpKVxuICAgICAgICAvLyAgICAgICAgICAgICAuYXR0cihcInhcIiwgZCA9PiB4R3JvdXAoZC5fa2V5KSlcbiAgICAgICAgLy8gICAgICAgICAgICAgLmF0dHIoXCJ5XCIsIDApO1xuICAgICAgICAvL1xuICAgICAgICAvLyAgICAgICAgIGJhcnMuZW50ZXIoKVxuICAgICAgICAvLyAgICAgICAgICAgICAuYXBwZW5kKFwicmVjdFwiKVxuICAgICAgICAvLyAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIChkLCBpKSA9PiBcImJhciBzZXJpZXMgc2VyaWVzLVwiICsgaSlcbiAgICAgICAgLy8gICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIGQgPT4geEdyb3VwKGQuX2tleSkpXG4gICAgICAgIC8vICAgICAgICAgICAgIC5hdHRyKFwieVwiLCAwKVxuICAgICAgICAvLyAgICAgICAgICAgICAuYXR0cihcIndpZHRoXCIsIHhHcm91cC5iYW5kd2lkdGgoKSlcbiAgICAgICAgLy8gICAgICAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgMClcbiAgICAgICAgLy8gICAgICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCAoZCwgaSkgPT4gdGhpcy5nZXRTZXJpZXNDb2xvdXIoaSkpXG4gICAgICAgIC8vICAgICAgICAgICAgIC5zdHlsZShcImN1cnNvclwiLCBcInBvaW50ZXJcIilcbiAgICAgICAgLy8gICAgICAgICAgICAgLm9uKFwibW91c2VvdmVyXCIsIChkLCBpLCBub2RlcykgPT4geyAvLyBEYXJrZW4gdGhlIGJhciBvbiBtb3VzZSBvdmVyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICBkMy5zZWxlY3Qobm9kZXNbaV0pXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgLmludGVycnVwdChcImhvdmVyOmNvbG91clwiKVxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKFwiaG92ZXI6Y29sb3VyXCIpXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKDQwMClcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIGQzLmhjbCh0aGlzLmdldFNlcmllc0NvbG91cihpKSkuZGFya2VyKCkpXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICB0aGlzLl9kaXNwYXRjaC5jYWxsKFwidG9vbHRpcFNob3dcIiwgdGhpcywge1xuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgIGU6IGQzLmV2ZW50LFxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgIHBvaW50OiBkLFxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgIHNlcmllczogc19kLFxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgIHNlcmllc0luZGV4OiBzX2ksXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGQuX3lcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgIH0pXG4gICAgICAgIC8vICAgICAgICAgICAgIH0pXG4gICAgICAgIC8vICAgICAgICAgICAgIC5vbihcIm1vdXNlb3V0XCIsIChkLCBpLCBub2RlcykgPT4geyAvLyBiYXIgaXMgcmVndWxhciBjb2xvdXIgb24gbW91c2Ugb3V0LlxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgZDMuc2VsZWN0KG5vZGVzW2ldKVxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgIC5pbnRlcnJ1cHQoXCJob3Zlcjpjb2xvdXJcIilcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAudHJhbnNpdGlvbihcImhvdmVyOmNvbG91clwiKVxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbig0MDApXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCB0aGlzLmdldFNlcmllc0NvbG91cihpKSk7XG4gICAgICAgIC8vICAgICAgICAgICAgICAgICB0aGlzLl9kaXNwYXRjaC5jYWxsKFwidG9vbHRpcEhpZGVcIiwgdGhpcyk7XG4gICAgICAgIC8vICAgICAgICAgICAgIH0pXG4gICAgICAgIC8vICAgICAgICAgICAgIC5vbihcImNsaWNrIGF1eGNsaWNrXCIsIChkLCBpLCBub2RlcykgPT4ge1xuICAgICAgICAvLyAgICAgICAgICAgICAgICAgdGhpcy5fZGlzcGF0Y2guY2FsbChcImVsZW1lbnRDbGlja1wiLCB0aGlzLCB7XG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgZTogZDMuZXZlbnQsXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgcG9pbnQ6IGQsXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgc2VyaWVzOiBkLl9zZXJpZXMsXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgc2VyaWVzSW5kZXg6IHNfaSxcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy5feShkKVxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgLy8gICAgICAgICAgICAgfSlcbiAgICAgICAgLy8gICAgICAgICAgICAgLm1lcmdlKGJhcnMpXG4gICAgICAgIC8vICAgICAgICAgICAgIC5pbnRlcnJ1cHQoXCJiYXI6Z3Jvd3RoXCIpICAgIC8vIEFuaW1hdGUgYmFycyBncm93aW5nLlxuICAgICAgICAvLyAgICAgICAgICAgICAudHJhbnNpdGlvbihcImJhcjpncm93dGhcIilcbiAgICAgICAgLy8gICAgICAgICAgICAgLmRlbGF5KChkKSA9PiB7XG4gICAgICAgIC8vICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jYWxjQmFyR3Jvd3RoKHNfaSwgbm9kZXMubGVuZ3RoKTtcbiAgICAgICAgLy8gICAgICAgICAgICAgfSlcbiAgICAgICAgLy8gICAgICAgICAgICAgLmR1cmF0aW9uKHRoaXMuX2R1cmF0aW9uKVxuICAgICAgICAvLyAgICAgICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIChkLCBpKSA9PiB0aGlzLmdldFNlcmllc0NvbG91cihpKSlcbiAgICAgICAgLy8gICAgICAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgZCA9PiBoZWlnaHQgLSB5KGQuX3kpKTtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gICAgIH0pXG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIExhYmVscyBsb2FkZWQgYWZ0ZXIgb3VyIGZpcnN0IGJhciBncm93cy5cbiAgICAgICAgLy8gaWYgKHRoaXMuX3Nob3dfbGFiZWxzKSB7XG4gICAgICAgIC8vICAgICBzdmcudHJhbnNpdGlvbihcImJhcjpncm93dGhcIilcbiAgICAgICAgLy8gICAgICAgICAub24oXCJlbmRcIiwgKGQsIGksIG5vZGVzKSA9PiB7XG4gICAgICAgIC8vICAgICAgICAgICAgIGlmIChpIDwgbm9kZXMubGVuZ3RoIC0gMSkgcmV0dXJuO1xuICAgICAgICAvLyAgICAgICAgICAgICB0aGlzLnJlbmRlckxhYmVscyhzdmcsIGRhdGEsIHgsIHhHcm91cCwgeSk7XG4gICAgICAgIC8vICAgICAgICAgfSlcbiAgICAgICAgLy8gfVxuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBEcmF3IHRoZSB5IGF4aXMgZGF0YSBsYWJlbC5cblxuICAgICAgICBpZiAodGhpcy5fZGF0YUF4aXNMYWJlbCkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJEYXRhQXhpc0xhYmVsKGhlaWdodCwgbWFyZ2luKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBTZXQgdGhlIGJhY2tncm91bmQgY29sb3VyXG5cbiAgICAgICAgZDMuc2VsZWN0KHRoaXMuX2VsZW1lbnQpLnNlbGVjdChcIi5iYWNrZ3JvdW5kXCIpLnJlbW92ZSgpO1xuICAgICAgICBpZiAodGhpcy5fYmFja2dyb3VuZENvbG91cikge1xuICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMuX2VsZW1lbnQpLnNlbGVjdChcInN2Z1wiKVxuICAgICAgICAgICAgICAgIC5hcHBlbmQoXCJyZWN0XCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImJhY2tncm91bmRcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcIndpZHRoXCIsIFwiMTAwJVwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIFwiMTAwJVwiKVxuICAgICAgICAgICAgICAgIC5zdHlsZShcImZpbGxcIiwgdGhpcy5fYmFja2dyb3VuZENvbG91cilcbiAgICAgICAgICAgICAgICAubG93ZXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIGFkZCB0aGUgWSBncmlkbGluZXNcbiAgICAgICAgc3ZnLmNhbGwodGhpcy5ncmlkLCB3aWR0aCwgZDMuYXhpc0xlZnQoeSkudGlja3MoNSkpO1xuXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIGF4ZXNcbiAgICAgICAgc3ZnLmNhbGwodGhpcy54YXhpcywgaGVpZ2h0LCBkMy5heGlzQm90dG9tKHgpLnRpY2tTaXplKDApLnRpY2tQYWRkaW5nKDUpLnRpY2tGb3JtYXQodGhpcy5feEF4aXNUaWNrRm9ybWF0KSk7IC8vKTsgLy9cbiAgICAgICAgc3ZnLmNhbGwodGhpcy55YXhpcywgZDMuYXhpc0xlZnQoeSkudGlja3MoNSkudGlja0Zvcm1hdCh0aGlzLl90aWNrRm9ybWF0KSk7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8qXG4gICAgICogUmV0dXJucyBhbiBvYmplY3Qgd2l0aCB0d28gZnVuY3Rpb25zLCAjc2hvdygpIGFuZCAjaGlkZSgpLFxuICAgICAqIHRvIHNob3cgYW5kIGhpZGUgdGhlIGxhYmVscy5cbiAgICAgKi9cbiAgICBsYWJlbHMoKSB7XG4gICAgICAgIHJldHVybiB7XG5cbiAgICAgICAgICAgIHNob3c6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgc2VsZWN0aW9uID0gdGhpcy5fZWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSB0aGlzLmdldFRyYW5zZm9ybWVkRGF0YSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgeHNjYWxlID0gdGhpcy5feHNjYWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgeGdyb3VwID0gdGhpcy5feGdyb3Vwc2NhbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB5c2NhbGUgPSB0aGlzLl95c2NhbGU7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvbikgc2VsZWN0aW9uID0gZDMuc2VsZWN0KHRoaXMuX2VsZW1lbnQpLnNlbGVjdChcInN2Z1wiKS5zZWxlY3QoXCJnXCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNlbGVjdGlvbi5lbXB0eSgpICYmIGRhdGEgJiYgeHNjYWxlICYmIHlzY2FsZSAmJiB4Z3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBsYWJlbHMgPSBzZWxlY3Rpb24uc2VsZWN0KCcuY2hhcnQtbGFiZWxzJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWxhYmVscy5lbXB0eSgpKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbHMucmVtb3ZlKClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyTGFiZWxzKHNlbGVjdGlvbiwgZGF0YSwgeHNjYWxlLCB4Z3JvdXAsIHlzY2FsZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBoaWRlOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2VsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMuX2VsZW1lbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc2VsZWN0KCcuY2hhcnQtbGFiZWxzJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5pbnRlcnJ1cHQoXCJsYWJlbHNcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5pbnRlcnJ1cHQoXCJsYWJlbHM6ZmFkZVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRyYW5zaXRpb24oXCJsYWJlbHM6ZmFkZVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm9uKFwiZW5kXCIsIChkLCBpLCBub2RlcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQzLnNlbGVjdChub2Rlc1tpXSkucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICByZW5kZXJMYWJlbHMoc2VsZWN0aW9uLCBkYXRhLCB4c2NhbGUsIHhncm91cCwgeXNjYWxlLCBhbmltYXRlKSB7XG4gICAgICAgIGFuaW1hdGUgPSBhbmltYXRlID09PSB1bmRlZmluZWQgPyB0cnVlIDogYW5pbWF0ZTtcbiAgICAgICAgc2VsZWN0aW9uLnNlbGVjdEFsbChcIi5jaGFydC1sYWJlbHNcIikucmVtb3ZlKCk7XG5cbiAgICAgICAgbGV0IGxhYmVscyA9IHNlbGVjdGlvbi5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwiY2hhcnQtbGFiZWxzXCIpXG4gICAgICAgICAgICAvLyAuc2VsZWN0QWxsKFwiLmNoYXJ0LWxhYmVsXCIpXG4gICAgICAgICAgICAuc2VsZWN0QWxsKFwiLmxhYmVsLWdyb3VwXCIpXG4gICAgICAgICAgICAuZGF0YShkYXRhKVxuXG4gICAgICAgIGxldCBtYXhXaWR0aCA9IDA7ICAgICAvLyBGb3IgY2FsY3VsYXRpbmcgdGhlIG1heCB3aWR0aCBvZiB0ZXh0LlxuICAgICAgICBsZXQgZm9udFNpemUgPSAxMjsgICAgLy8gT3VyIGluaXRpYWwgZm9udCBzaXplLlxuICAgICAgICBjb25zdCBidWZmZXIgPSA1OyAgICAgLy8gQnVmZmVyIHNwYWNlIGJldHdlZW4gd29yZHMgYW5kIHRoZSB0b3Agb2YgYSBiYXIuXG4gICAgICAgIGNvbnN0IGNhbGNEeSA9ICh5cG9zKSA9PiB5cG9zIDwgMTAgPyBmb250U2l6ZSArIGJ1ZmZlciA6IC1idWZmZXI7XG5cbiAgICAgICAgbGFiZWxzLmVudGVyKCkuZWFjaCgoc2VyaWVzLCBzX2ksIHNfbm9kZXMpID0+IHtcbiAgICAgICAgICAgIGxldCBncm91cCA9IGQzLnNlbGVjdChzX25vZGVzW3NfaV0pXG4gICAgICAgICAgICAgICAgLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwibGFiZWwtZ3JvdXBcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBkID0+IFwidHJhbnNsYXRlKFwiICsgeHNjYWxlKGQua2V5KSArIFwiLDApXCIpXG4gICAgICAgICAgICAgICAgLnNlbGVjdEFsbChcIi5jaGFydC1sYWJlbFwiKVxuICAgICAgICAgICAgICAgIC5kYXRhKHNlcmllcy5kYXRhKVxuICAgICAgICAgICAgICAgIC5lbnRlcigpXG4gICAgICAgICAgICAgICAgLmVhY2goKGQsIGksIG5vZGVzKSA9PiB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gV2FudCB0byBmaWd1cmUgb3V0IGlmIHRoZSBsYWJlbCBpcyB0b28gZGFyayAvIGxpZ2h0IGZvciB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gYmFyLlxuICAgICAgICAgICAgICAgICAgICBsZXQgaW52ZXJ0ZWRDb2xvciA9IGQzLmhjbCh0aGlzLmdldFNlcmllc0NvbG91cihpKSk7XG4gICAgICAgICAgICAgICAgICAgIGludmVydGVkQ29sb3IubCArPSBNYXRoLm1pbihpbnZlcnRlZENvbG9yLmwgKyA1MCwgMTAwKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGludmVydCA9IGQzLmhjbCh0aGlzLmdldFNlcmllc0NvbG91cihpKSkubCA8IDYwO1xuXG4gICAgICAgICAgICAgICAgICAgIGxldCB5cG9zID0geXNjYWxlKGQuX3kpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZHkgPSBjYWxjRHkoeXBvcyk7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0ZXh0ID0gZDMuc2VsZWN0KG5vZGVzW2ldKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC50ZXh0KHRoaXMuX2xhYmVsRm9ybWF0KGQuX3kpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImNoYXJ0LWxhYmVsXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcInlcIiwgeXBvcylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiZHhcIiwgYW5pbWF0ZSA/IC0xNSA6IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcImR5XCIsIGR5KVxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwicG9pbnRlci1ldmVudHNcIiwgXCJub25lXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAuc3R5bGUoXCJmb250LWZhbWlseVwiLCBcIk9wZW4gU2Fucywgc2Fucy1zZXJpZlwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gLnN0eWxlKFwiZm9udC13ZWlnaHRcIiwgXCJub3JtYWxcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIC5zdHlsZShcImZvbnQtc2l6ZVwiLCBmb250U2l6ZSArIFwicHhcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcImZpbGxcIiwgZHkgPiAwICYmIGludmVydCA/IGludmVydGVkQ29sb3IudG9TdHJpbmcoKSA6IGNvbG91cnMuZWlnaHRlZW4uZGFya0dyZXkpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFNldCB0aGUgeCBwb3NpdGlvbiwgd2hpY2ggaXMgYmFzZWQgb24gd2lkdGguXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gdGV4dC5ub2RlKCkuZ2V0QkJveCgpLndpZHRoO1xuICAgICAgICAgICAgICAgICAgICBtYXhXaWR0aCA9IE1hdGgubWF4KHdpZHRoLCBtYXhXaWR0aCk7XG4gICAgICAgICAgICAgICAgICAgIHRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwieFwiLCB4Z3JvdXAoZC5fa2V5KSArIHhncm91cC5iYW5kd2lkdGgoKSAvIDIgLSB3aWR0aCAvIDIpO1xuXG4gICAgICAgICAgICAgICAgICAgIHRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKFwibGFiZWxzXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAuZGVsYXkoKCkgPT4gYW5pbWF0ZSA/IHRoaXMuY2FsY0Jhckdyb3d0aChzX2ksIHNfbm9kZXMubGVuZ3RoKSA6IDApIC8vIERlbGF5IGluIGxvY2tzdGVwIHdpdGggYmFyIGdyb3d0aC5cbiAgICAgICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbih0aGlzLl9kdXJhdGlvbilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiZHhcIiwgMClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMSlcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICB9KVxuXG5cbiAgICAgICAgLy8gRmlndXJlIG91dCBpZiB3ZSBkb24ndCBoYXZlIGVub3VnaCBzcGFjZSB0byBzaG93IG91ciBsYWJlbHMuXG4gICAgICAgIC8vIFdlIHRoZW4gd2FudCB0byByZXNpemUsIGlmIHBvc3NpYmxlLlxuICAgICAgICBpZiAoeGdyb3VwLmJhbmR3aWR0aCgpIDwgbWF4V2lkdGggKiAxLjA1KSB7XG4gICAgICAgICAgICBsZXQgc2NhbGUgPSBtYXhXaWR0aCAvIHhncm91cC5iYW5kd2lkdGgoKSAqIDEuMDU7XG4gICAgICAgICAgICBmb250U2l6ZSA9IE1hdGguZmxvb3IoZm9udFNpemUgLyBzY2FsZSk7XG5cbiAgICAgICAgICAgIGlmIChmb250U2l6ZSA8IDgpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgbGFiZWxzIGFyZSB0b28gc21hbGwuXG4gICAgICAgICAgICAgICAgbGFiZWxzLmVudGVyKCkuc2VsZWN0QWxsKFwidGV4dFwiKS5yZW1vdmUoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGFiZWxzLmVudGVyKClcbiAgICAgICAgICAgICAgICAgICAgLm1lcmdlKGxhYmVscylcbiAgICAgICAgICAgICAgICAgICAgLnNlbGVjdEFsbChcInRleHRcIilcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwiZm9udC1zaXplXCIsIGZvbnRTaXplICsgXCJweFwiKVxuICAgICAgICAgICAgICAgICAgICAuZWFjaCgoZCwgaSwgbm9kZXMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRleHQgPSBkMy5zZWxlY3Qobm9kZXNbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgd2lkdGggPSB0ZXh0Lm5vZGUoKS5nZXRCQm94KCkud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIHhncm91cChkLl9rZXkpICsgeGdyb3VwLmJhbmR3aWR0aCgpIC8gMiAtIHdpZHRoIC8gMilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcImR5XCIsIGNhbGNEeShkLl95KSk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgcmVuZGVyRGF0YUF4aXNMYWJlbChoZWlnaHQsIG1hcmdpbnMpIHtcbiAgICAgICAgbGV0IHN2ZyA9IGQzLnNlbGVjdCh0aGlzLl9lbGVtZW50KS5zZWxlY3QoJ3N2ZycpO1xuICAgICAgICBzdmcuc2VsZWN0QWxsKFwiLmRhdGEtbGFiZWxzXCIpLnJlbW92ZSgpO1xuXG4gICAgICAgIGlmICghdGhpcy5fZGF0YUF4aXNMYWJlbCkgcmV0dXJuO1xuICAgICAgICBsZXQgdGV4dCA9IHRoaXMuX2RhdGFBeGlzTGFiZWw7XG4gICAgICAgIGlmICh0ZXh0LmxvbmcpIHRleHQgPSB0ZXh0Lmxvbmc7XG5cbiAgICAgICAgbGV0IHggPSAtKG1hcmdpbnMudG9wICsgaGVpZ2h0IC8gMik7XG5cbiAgICAgICAgbGV0IGxhYmVsID0gc3ZnLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJkYXRhLWxhYmVsc1wiKVxuICAgICAgICAgICAgLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgICAgIC50ZXh0KHRleHQpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInJvdGF0ZSgtOTAgMCwwKSB0cmFuc2xhdGUoXCIgKyB4ICsgXCIsIDIwKVwiKVxuICAgICAgICAgICAgLy8gLnN0eWxlKFwiZm9udC1mYW1pbHlcIiwgXCJPcGVuIFNhbnMsIHNhbnMtc2VyaWZcIilcbiAgICAgICAgICAgIC8vIC5zdHlsZShcImZvbnQtc2l6ZVwiLCBcIjEycHhcIilcbiAgICAgICAgICAgIC8vIC5zdHlsZShcImZvbnQtc3R5bGVcIiwgXCJpdGFsaWNcIilcbiAgICAgICAgICAgIC5zdHlsZShcImZpbGxcIiwgY29sb3Vycy5laWdodGVlbi5kYXJrR3JleSk7XG5cbiAgICAgICAgbGV0IHdpZHRoID0gbGFiZWwubm9kZSgpLmdldEJCb3goKS53aWR0aDtcbiAgICAgICAgaWYgKHdpZHRoID49IGhlaWdodCAmJiB0aGlzLl9kYXRhQXhpc0xhYmVsLnNob3J0KSB7XG4gICAgICAgICAgICBsYWJlbC50ZXh0KHRoaXMuX2RhdGFBeGlzTGFiZWwuc2hvcnQpO1xuICAgICAgICAgICAgd2lkdGggPSBsYWJlbC5ub2RlKCkuZ2V0QkJveCgpLndpZHRoO1xuICAgICAgICB9XG5cbiAgICAgICAgbGFiZWwuYXR0cihcImR4XCIsIC13aWR0aCAvIDIpO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBncmlkKHNlbGVjdGlvbiwgd2lkdGgsIGF4aXMpIHtcbiAgICAgICAgc2VsZWN0aW9uLnNlbGVjdChcIi5ncmlkXCIpLnJlbW92ZSgpO1xuXG4gICAgICAgIGxldCBncmlkID0gc2VsZWN0aW9uLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJncmlkXCIpXG4gICAgICAgICAgICAuY2FsbChheGlzXG4gICAgICAgICAgICAgICAgLnRpY2tTaXplKC13aWR0aClcbiAgICAgICAgICAgICAgICAudGlja0Zvcm1hdChcIlwiKVxuICAgICAgICAgICAgKTtcblxuICAgICAgICBncmlkLnNlbGVjdEFsbChcImxpbmVcIilcbiAgICAgICAgICAgIC5zdHlsZShcInN0cm9rZVwiLCBjb2xvdXJzLmVpZ2h0ZWVuLmxpZ2h0R3JleSk7XG4gICAgICAgIGdyaWQuc2VsZWN0QWxsKFwiLmRvbWFpblwiKS5yZW1vdmUoKTtcblxuICAgICAgICBncmlkXG4gICAgICAgICAgICAubG93ZXIoKSAvLyBBbHdheXMgZW5zdXJlIHRoYXQgdGhpcyBpcyBlYXJsaWVyIGluIHRoZSBkb20uIFRoaW5ncyBtdXN0IGJlIGRyYXduIG9uIHRvcCBvZiBpdC5cbiAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMClcbiAgICAgICAgICAgIC50cmFuc2l0aW9uKClcbiAgICAgICAgICAgIC5kZWxheSg1MDApXG4gICAgICAgICAgICAuZHVyYXRpb24oNTAwKVxuICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAxKTtcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgeGF4aXMoc2VsZWN0aW9uLCBoZWlnaHQsIHhheGlzKSB7XG4gICAgICAgIHNlbGVjdGlvbi5zZWxlY3QoXCIueC1heGlzXCIpLnJlbW92ZSgpO1xuICAgICAgICBsZXQgYXhpcyA9IHNlbGVjdGlvbi5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwieC1heGlzXCIpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZSgwLFwiICsgaGVpZ2h0ICsgXCIpXCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDApXG4gICAgICAgICAgICAuY2FsbCh4YXhpcyk7XG5cbiAgICAgICAgYXhpcy5zZWxlY3QoXCIuZG9tYWluXCIpLnJlbW92ZSgpO1xuXG4gICAgICAgIGF4aXNcbiAgICAgICAgICAgIC5zZWxlY3RBbGwoXCJ0ZXh0XCIpXG4gICAgICAgICAgICAuc3R5bGUoJ3RleHQtYW5jaG9yJywgJ2VuZCcpXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3JvdGF0ZSgtMzAsIDAsMCknKTtcblxuICAgICAgICBheGlzXG4gICAgICAgICAgICAudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAuZHVyYXRpb24oMTAwMClcbiAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMSk7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHlheGlzKHNlbGVjdGlvbiwgYXhpcykge1xuICAgICAgICBzZWxlY3Rpb24uc2VsZWN0KFwiLnktYXhpc1wiKS5yZW1vdmUoKTtcbiAgICAgICAgbGV0IHggPSBzZWxlY3Rpb24uYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcInktYXhpc1wiKVxuICAgICAgICAgICAgLmNhbGwoYXhpcy50aWNrU2l6ZSgwKS50aWNrUGFkZGluZygxMCkpXG4gICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDApXG4gICAgICAgICAgICAudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAuZHVyYXRpb24oMTAwMClcbiAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMSk7XG5cbiAgICAgICAgeC5zZWxlY3RBbGwoXCJ0ZXh0XCIpXG4gICAgICAgICAgICAvLyAuc3R5bGUoXCJmb250LWZhbWlseVwiLCBcIk9wZW4gU2Fucywgc2Fucy1zZXJpZlwiKVxuICAgICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBjb2xvdXJzLmVpZ2h0ZWVuLmRhcmtHcmV5KVxuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBjYWxjQmFyR3Jvd3RoKGksIG1heCkge1xuICAgICAgICBpZiAobWF4IDwgMTApIHJldHVybiBpICogdGhpcy5fQkFSX0dST1dUSCAvIDI7XG4gICAgICAgIGlmIChtYXggPCAzNSkgcmV0dXJuIGkgKiB0aGlzLl9CQVJfR1JPV1RIIC8gNDtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuXG4gICAgZ2V0U2VyaWVzQ29sb3VyKGkpIHtcbiAgICAgICAgaWYgKGkgPCAwIHx8ICF0aGlzLl9jb2xvdXJzKSByZXR1cm4gY29sb3Vycy5laWdodGVlbi5taWRHcmV5O1xuXG4gICAgICAgIGkgPSBpICUgdGhpcy5fY29sb3Vycy5sZW5ndGg7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb2xvdXJzW2ldO1xuICAgIH1cblxuICAgIGdldFNvcnRlZERhdGEoKSB7XG4gICAgICAgIGxldCBkYXRhID0gdGhpcy5fZGF0YTtcbiAgICAgICAgaWYgKCFkYXRhIHx8ICFkYXRhLmxlbmd0aCkgcmV0dXJuIFtdO1xuXG4gICAgICAgIGRhdGEgPSB0aGlzLl9kYXRhLnNvcnQoKGxocywgcmhzKSA9PiB7XG4gICAgICAgICAgICBsaHMgPSBsaHMua2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICByaHMgPSByaHMua2V5LnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgICAgIGlmIChsaHMgPT09IHJocykgcmV0dXJuIDA7XG4gICAgICAgICAgICBpZiAobGhzIDwgcmhzKSByZXR1cm4gLTE7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgZ2V0VHJhbnNmb3JtZWREYXRhKCkge1xuICAgICAgICBsZXQgZGF0YSA9IHRoaXMuZ2V0U29ydGVkRGF0YSgpO1xuICAgICAgICBpZiAoIWRhdGEgfHwgIWRhdGEubGVuZ3RoKSByZXR1cm4gW107XG5cbiAgICAgICAgbGV0IHJlc3VsdHMgPSBbXTtcblxuICAgICAgICBkYXRhLmZvckVhY2goKHNlcmllcywgc19pKSA9PiB7XG4gICAgICAgICAgICBsZXQgcyA9IE9iamVjdC5hc3NpZ24oe30sIHNlcmllcyk7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2gocyk7XG5cbiAgICAgICAgICAgIGxldCBkYXRhID0gW107XG4gICAgICAgICAgICBzLnZhbHVlcy5mb3JFYWNoKChkKSA9PiB7XG4gICAgICAgICAgICAgICAgZGF0YS5wdXNoKE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgICAgICAgICBfeDogbmV3IERhdGUodGhpcy5feEF4aXNPdmVycmlkZSA/IHRoaXMuX3hBeGlzT3ZlcnJpZGVbdGhpcy5feChkKV0gOiB0aGlzLl94KGQpKSxcbiAgICAgICAgICAgICAgICAgICAgX3Nlcmllczogc2VyaWVzLFxuICAgICAgICAgICAgICAgICAgICBfc19pOiBzX2ksXG4gICAgICAgICAgICAgICAgICAgIF9rZXk6IHNlcmllcy5rZXksXG4gICAgICAgICAgICAgICAgICAgIF95OiB0aGlzLl95KGQpXG4gICAgICAgICAgICAgICAgfSwgZCkpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHMuZGF0YSA9IGRhdGE7XG4gICAgICAgICAgICBkZWxldGUgcy52YWx1ZXM7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cblxuICAgIGdldEtleXMoKSB7XG4gICAgICAgIGxldCBkYXRhID0gdGhpcy5fZGF0YTtcbiAgICAgICAgaWYgKCFkYXRhIHx8ICFkYXRhLmxlbmd0aCkgcmV0dXJuIFtdO1xuXG4gICAgICAgIHJldHVybiBbLi4ubmV3IFNldChkYXRhLm1hcChkID0+IGQua2V5KSldXG4gICAgfVxuXG4gICAgZ2V0Q2xvc2VzdFBvaW50KHh2YWwsIHl2YWwsIGRhdGEpIHtcbiAgICAgICAgbGV0IGNhbGNEaXN0ID0gZCA9PiBNYXRoLnNxcnQoTWF0aC5hYnMoZC5feCAtIHh2YWwpICoqIDIgKyAoZC5feSAtIHl2YWwpICoqIDIpO1xuICAgICAgICBsZXQgbWluID0gZGF0YVswXTtcbiAgICAgICAgbGV0IG1pbkRpc3QgPSBjYWxjRGlzdChtaW4pO1xuXG4gICAgICAgIGRhdGEuZm9yRWFjaChkID0+IHtcbiAgICAgICAgICAgIGxldCBkaXN0ID0gY2FsY0Rpc3QoZCk7XG4gICAgICAgICAgICBpZiAoZGlzdCA8IG1pbkRpc3QpIHtcbiAgICAgICAgICAgICAgICBtaW5EaXN0ID0gZGlzdDtcbiAgICAgICAgICAgICAgICBtaW4gPSBkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gbWluO1xuICAgIH1cbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/LineChart.js\n')},"./src/PieChart.js":
/*!*************************!*\
  !*** ./src/PieChart.js ***!
  \*************************/
/*! exports provided: PieChart */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PieChart", function() { return PieChart; });\n/* harmony import */ var _Colours__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Colours */ "./src/Colours.js");\n/* harmony import */ var _Chart__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Chart */ "./src/Chart.js");\n// Copyright (C) 2013-2014, 2018 BrandsEye (PTY) LTD\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this\n// software and associated documentation files (the "Software"), to deal in the Software\n// without restriction, including without limitation the rights to use, copy, modify,\n//     merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following\n// conditions:\n//\n//     The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n//     INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n// CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n\nclass PieChart extends _Chart__WEBPACK_IMPORTED_MODULE_1__["Chart"] {\n    constructor() {\n        super();\n        this._colours = ["#98abc5", "#8a89a6", "#7b6888", "#6b486b", "#a05d56", "#d0743c", "#ff8c00"];\n    }\n\n    //------------------------------------------------------\n\n    data(data) {\n        if (!arguments.length) return this._data;\n        if (data && data[0].key === undefined) {\n            data = [\n                {\n                    key: "series 1",\n                    values: data\n                }\n            ];\n        }\n        this._data = data;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    element(element) {\n        if (!arguments.length) return this._element;\n        this._element = element;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    showLabels(show) {\n        if (!arguments.length) return this._show_labels;\n        this._show_labels = show;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    // todo dispatch\n    showLegend(show) {\n        if (!arguments.length) return this._show_legend;\n        this._show_legend = show;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    x(x) {\n        if (!arguments.length) return this._x;\n        this._x = x;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    y(y) {\n        if (!arguments.length) return this._y;\n        this._y = y;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    width(width) {\n        if (!arguments.length) return this._width;\n        this._width = width;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    height(height) {\n        if (!arguments.length) return this._height;\n        this._height = height;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    colours(colours) {\n        if (!arguments.length) return this._colours;\n        this._colours = colours;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    backgroundColour(colour) {\n        if (!arguments.length) return this._backgroundColour;\n        this._backgroundColour = colour || "#FFF"; // never set it to null.\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    tickFormat(format) {\n        if (!arguments.length) return this._tickFormat;\n        this._tickFormat = format;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    xAxisTickFormat(format) {\n        if (!arguments.length) return this._xAxisTickFormat;\n        this._xAxisTickFormat = format || (d => d.toString());\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    labelFormat(format) {\n        if (!arguments.length) return this._labelFormat;\n        this._labelFormat = format || (d => d.toString());\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    // todo missing\n    labelCompression(compression) {\n        if (!arguments.length) return this._compression;\n        this._compression = compression;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    //todo missing\n    dataAxisLabel(label) {\n        if (!arguments.length) return this._dataAxisLabel;\n        this._dataAxisLabel = label;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    tooltip(tooltip) {\n        if (!arguments.length) return this._tooltip;\n        this._tooltip = tooltip;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    forceY(force) {\n        if (!arguments.length) return this._forceY;\n        this._forceY = force;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n// todo missing\n    duration(duration) {\n        if (!arguments.length) return this._duration;\n        this._duration = duration;\n        return this;\n    }\n\n// todo missing\n    coarseness(coarseness) {\n        if (!arguments.length) return this._coarseness;\n        this._coarseness = coarseness;\n        return this;\n    }\n\n    // todo missing\n    padding(padding) {\n        if (!arguments.length) return this._padding;\n        this._padding = padding;\n        return this;\n    }\n\n    // todo missing\n    xAxisTooltips(tooltips) {\n        if (!arguments.length) return this._xAxisTooltips;\n        this._xAxisTooltips = tooltips;\n        return this;\n    }\n\n    xAxisOverride(override) {\n        if (!arguments.length) return this._xAxisOverride;\n        this._xAxisOverride = override;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    dispatch() {\n        return this._dispatch;\n    }\n\n    //------------------------------------------------------\n\n    render() {\n        if (!this._element) throw new Error("No element set for ColumnChart. See #element()");\n        if (!this._data) {\n            console.warn("No data set for ColumnChart. See #data()");\n            return;\n        }\n\n        const data = this.getTransformedData();\n\n        //------------------------------------------------\n        // Set up the SVG area\n\n        let topLevel = d3.select(this._element).select("svg");\n        if (topLevel.empty()) topLevel = d3.select(this._element).append("svg");\n\n        topLevel\n            .style("width", this._width + "px")\n            .style("height", this._height + "px");\n\n        // ---------------------------------\n        // Layout the showLegend.\n        //\n        // We do this now because we need to know how much space the legend\n        // takes up in order to finish calculating the margins.\n\n        const legendHeight = this.renderLegend(topLevel, data, 0, this._width, this._height, d => d._key);\n\n        //----------------------------------\n        // Calculate margins.\n\n        const margin = {top: 20, right: 20, bottom: 40, left: 40};\n        margin.bottom += legendHeight ? legendHeight + 20 : 0;\n\n        // if (this._dataAxisLabel) margin.left += 20 + 12;\n        // if (data) {\n        //     let maxLabelLength = 0;\n        //     data.forEach(d => {\n        //         d.data.forEach(d => {\n        //             let length = this._xAxisTickFormat(this._x(d)).length;\n        //             if (length > maxLabelLength) maxLabelLength = length;\n        //         })\n        //     });\n        //     margin.bottom += maxLabelLength * 2 + 10;    // space for axes labels.\n        // }\n\n        const width = this._width - margin.left - margin.right,\n              height = this._height - margin.top - margin.bottom;\n        const radius = Math.min(width, height) / 2;\n        this._radius = radius;\n\n        //----------------------------------\n        // Calculate scales and so on.\n\n        let colour = d3.scaleOrdinal(["#98abc5", "#8a89a6", "#7b6888", "#6b486b", "#a05d56", "#d0743c", "#ff8c00"]);\n\n        //------------------------------\n\n        let svg = topLevel.select(\'.main-group\');\n\n        if (svg.empty()) {\n            svg = topLevel\n                .append("g")\n                .attr("class", "main-group");\n        }\n\n        svg.attr("transform", "translate(" + (margin.left + width / 2) + "," + (margin.top + height / 2) + ")");\n\n        //---------------------------------\n        // Get rid of current labels.\n        svg.select(".chart-labels")\n            .remove();\n\n        //---------------------------------\n        // append the arcs for the pie chart\n\n        let pie = d3.pie()\n            .sort(null)\n            .value(d => d._y);\n        this._pie = pie;\n\n        let path = d3.arc()\n            .outerRadius(radius - 10)\n            .innerRadius(0);\n\n        let arcs = svg.select(".slices").selectAll(\'.arc\');\n\n        if (arcs.empty()) {\n            arcs = svg\n                .append("g")\n                .attr("class", "slices")\n                .selectAll(".arc");\n        }\n\n        let pieData = pie(data);\n        arcs = arcs.data(pieData);\n        arcs.exit().remove();\n\n        function arcTween(d, i) {\n            this._current = this._current || (i <= 0 ? { startAngle: 0, endAngle: 0} : pieData[i - 1]);\n            let interpolator = d3.interpolate(this._current, d);\n            this._current = interpolator(0);\n\n            return function(t) {\n                return path(interpolator(t))\n            }\n        }\n\n        arcs.enter()\n            .append("path")\n                .attr("class", (d, i) => "arc " + "series series-" + i)\n                .style("cursor", "pointer")\n            .on("mouseover", (d, i, nodes) => { // Darken the pie on mouse over\n                // We want to shift the pie out a bit on mouseover.\n                // So we want to find the direction to move the pie in.\n                // We can just ask the path helper to give us the centroid,\n                // normalise it, and that is the direction to move in.\n                const centre = path.centroid(d);\n                const norm = Math.sqrt(centre[0] ** 2 + centre[1] ** 2);\n                centre[0] = centre[0] / norm;\n                centre[1] = centre[1] / norm;\n\n                d3.select(nodes[i])\n                    .interrupt("hover:colour")\n                    .transition("hover:colour")\n                    .duration(300)\n                        .attr("transform", "translate(" + (centre[0] * 10) + "," + (centre[1] * 10) + "), scale(1.1)")\n                        .style("fill", d3.hcl(this.getSeriesColour(i)).darker());\n                this._dispatch.call("tooltipShow", this, {\n                    e: d3.event,\n                    point: d.data,\n                    series: d.data._series,\n                    seriesIndex: d.data._s_i,\n                    value: d.data._y\n                })\n            })\n            .on("mouseout", (d, i, nodes) => { // pie is regular colour on mouse out.\n                d3.select(nodes[i])\n                    .interrupt("hover:colour")\n                    .transition("hover:colour")\n                    .duration(300)\n                        .attr("transform", "translate(0,0)")\n                        .style("fill", this.getSeriesColour(i));\n                this._dispatch.call("tooltipHide", this);\n            })\n            .on("click auxclick", (d, i, nodes) => {\n                this._dispatch.call("elementClick", this, {\n                    e: d3.event,\n                    point: d.data,\n                    series: d.data._series,\n                    seriesIndex: d.data._s_i,\n                    value: d.data._y\n                })\n            })\n            .merge(arcs)\n            .transition()\n                .attrTween("d", arcTween)\n                .attr("fill", (d, i) => this.getSeriesColour(i) );\n\n        // arcs.append("text")\n        //     .attr("transform", function(d) { return "translate(" + label.centroid(d) + ")"; })\n        //     .attr("dy", "0.35em")\n        //     .text(d => {console.log("d is", d); return d.data._y; });\n\n\n        // ---------------------------------\n        // Labels loaded after our first bar grows.\n        if (this._show_labels) {\n            svg.transition("bar:growth")\n                .on("end", (d, i, nodes) => {\n                    if (i < nodes.length - 1) return;\n                    this.renderLabels(svg, data);\n                })\n        }\n\n        // ---------------------------------\n        // Set the background colour\n\n        d3.select(this._element).select(".background").remove();\n        if (this._backgroundColour) {\n            d3.select(this._element).select("svg")\n                .append("rect")\n                    .attr("class", "background")\n                    .attr("width", "100%")\n                    .attr("height", "100%")\n                    .style("fill", this._backgroundColour)\n                .lower();\n        }\n\n    }\n\n    //------------------------------------------------------\n\n    /*\n     * Returns an object with two functions, #show() and #hide(),\n     * to show and hide the labels.\n     */\n    labels() {\n        return {\n\n            show: () => {\n                if (this._element) {\n                    let selection = this._element,\n                        data = this.getTransformedData();\n\n                    if (selection) selection = d3.select(this._element).select("svg").select(".main-group");\n                    if (!selection.empty() && data) {\n                        let labels = selection.select(\'.chart-labels\');\n                        if (!labels.empty()) return;\n                        labels.remove();\n                        this.renderLabels(selection, data);\n                    }\n                }\n\n            },\n\n            hide: () => {\n                if (this._element) {\n                    d3.select(this._element)\n                        .select(\'.chart-labels\')\n                        .interrupt("labels")\n                        .interrupt("labels:fade")\n                        .transition("labels:fade")\n                        .style("opacity", 0)\n                        .on("end", (d, i, nodes) => {\n                            d3.select(nodes[i]).remove();\n                        })\n                }\n            }\n        }\n    }\n\n    //------------------------------------------------------\n\n    renderLabels(selection, data, animate) {\n        selection.selectAll(".chart-labels").remove();\n\n        const radius = this._radius + 15;\n\n        let arc = d3.arc()\n            .outerRadius(radius)\n            .innerRadius(radius);\n\n        let labels = selection.append("g")\n            .attr("class", "chart-labels")\n            .selectAll(".label-group")\n            .data(this._pie(data));\n\n        labels.enter()\n            .each((d, i, nodes) => {\n                const centroid = arc.centroid(d);\n                const radians = d.endAngle - d.startAngle;\n                const arcLength = radians * radius;\n\n                let label = d3.select(nodes[i])\n                    .append("text")\n                    .text(d => this._labelFormat(d.data._y))\n                        // .style("font-family", "Open Sans, sans-serif")\n                        // .style("font-size", "12px")\n                        .style("fill", _Colours__WEBPACK_IMPORTED_MODULE_0__["colours"].eighteen.darkGrey)\n                        .style("opacity", 0)\n                        .attr("transform", "translate(" + centroid + ")");\n\n                const bounding = label.node().getBBox();\n                if (bounding.width < arcLength) {\n                    // label.attr("dx", (bounding.width / 2) * (direction[0] < 0 ? -1 : 1));\n                    // label.attr("dy", (bounding.height / 2) * (direction[1] < 0 ? -1 : 1));\n                    label.attr("dx", -(bounding.width / 2));\n                    label.attr("dy", (bounding.height / 2));\n\n                    label\n                        .transition()\n                        .duration(this._duration)\n                        .style("opacity", 1)\n                }\n\n            })\n    }\n\n    //------------------------------------------------------\n\n    getSeriesColour(i) {\n        if (i < 0 || !this._colours) return _Colours__WEBPACK_IMPORTED_MODULE_0__["colours"].eighteen.midGrey;\n\n        i = i % this._colours.length;\n        return this._colours[i];\n    }\n\n    getSortedData() {\n        let data = this._data;\n        if (!data || !data.length) return [];\n\n        data = this._data.sort((lhs, rhs) => {\n            lhs = lhs.key.toLowerCase();\n            rhs = rhs.key.toLowerCase();\n\n            if (lhs === rhs) return 0;\n            if (lhs < rhs) return -1;\n            return 1;\n        });\n\n        return data;\n    }\n\n    getTransformedData() {\n        let data = this.getSortedData();\n        if (!data || !data.length) return [];\n\n        let results = [];\n\n        let series = data[0];\n        series.values.forEach((d, d_i) => {\n\n            results.push(Object.assign({\n                _y: this._y(d),\n                _series_key: series.key,\n                _s_i: 0,\n                _series: series,\n                _key: this._xAxisOverride ? this._xAxisOverride[this._x(d)] : this._x(d)\n            }, d));\n        });\n\n        return results;\n    }\n\n    getKeys() {\n        let data = this._data;\n        if (!data || !data.length) return [];\n\n        return [...new Set(data.map(d => d.key))]\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvUGllQ2hhcnQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9iM2pzLy4vc3JjL1BpZUNoYXJ0LmpzPzczZGQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChDKSAyMDEzLTIwMTQsIDIwMTggQnJhbmRzRXllIChQVFkpIExURFxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpc1xuLy8gc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlXG4vLyB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksXG4vLyAgICAgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0b1xuLy8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcbi8vIGNvbmRpdGlvbnM6XG4vL1xuLy8gICAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuLy8gY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyAgICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUiBJTVBMSUVELFxuLy8gICAgIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBXG4vLyBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUXG4vLyBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0Zcbi8vIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRVxuLy8gT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCB7Y29sb3Vyc30gZnJvbSAnLi9Db2xvdXJzJztcbmltcG9ydCB7Q2hhcnR9IGZyb20gJy4vQ2hhcnQnO1xuXG5leHBvcnQgY2xhc3MgUGllQ2hhcnQgZXh0ZW5kcyBDaGFydCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX2NvbG91cnMgPSBbXCIjOThhYmM1XCIsIFwiIzhhODlhNlwiLCBcIiM3YjY4ODhcIiwgXCIjNmI0ODZiXCIsIFwiI2EwNWQ1NlwiLCBcIiNkMDc0M2NcIiwgXCIjZmY4YzAwXCJdO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBkYXRhKGRhdGEpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fZGF0YTtcbiAgICAgICAgaWYgKGRhdGEgJiYgZGF0YVswXS5rZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZGF0YSA9IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGtleTogXCJzZXJpZXMgMVwiLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZXM6IGRhdGFcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgZWxlbWVudChlbGVtZW50KSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX2VsZW1lbnQ7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgc2hvd0xhYmVscyhzaG93KSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3Nob3dfbGFiZWxzO1xuICAgICAgICB0aGlzLl9zaG93X2xhYmVscyA9IHNob3c7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvLyB0b2RvIGRpc3BhdGNoXG4gICAgc2hvd0xlZ2VuZChzaG93KSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3Nob3dfbGVnZW5kO1xuICAgICAgICB0aGlzLl9zaG93X2xlZ2VuZCA9IHNob3c7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB4KHgpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5feDtcbiAgICAgICAgdGhpcy5feCA9IHg7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB5KHkpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5feTtcbiAgICAgICAgdGhpcy5feSA9IHk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB3aWR0aCh3aWR0aCkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl93aWR0aDtcbiAgICAgICAgdGhpcy5fd2lkdGggPSB3aWR0aDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGhlaWdodChoZWlnaHQpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5faGVpZ2h0O1xuICAgICAgICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBjb2xvdXJzKGNvbG91cnMpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fY29sb3VycztcbiAgICAgICAgdGhpcy5fY29sb3VycyA9IGNvbG91cnM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBiYWNrZ3JvdW5kQ29sb3VyKGNvbG91cikge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9iYWNrZ3JvdW5kQ29sb3VyO1xuICAgICAgICB0aGlzLl9iYWNrZ3JvdW5kQ29sb3VyID0gY29sb3VyIHx8IFwiI0ZGRlwiOyAvLyBuZXZlciBzZXQgaXQgdG8gbnVsbC5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHRpY2tGb3JtYXQoZm9ybWF0KSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3RpY2tGb3JtYXQ7XG4gICAgICAgIHRoaXMuX3RpY2tGb3JtYXQgPSBmb3JtYXQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB4QXhpc1RpY2tGb3JtYXQoZm9ybWF0KSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3hBeGlzVGlja0Zvcm1hdDtcbiAgICAgICAgdGhpcy5feEF4aXNUaWNrRm9ybWF0ID0gZm9ybWF0IHx8IChkID0+IGQudG9TdHJpbmcoKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBsYWJlbEZvcm1hdChmb3JtYXQpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fbGFiZWxGb3JtYXQ7XG4gICAgICAgIHRoaXMuX2xhYmVsRm9ybWF0ID0gZm9ybWF0IHx8IChkID0+IGQudG9TdHJpbmcoKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvLyB0b2RvIG1pc3NpbmdcbiAgICBsYWJlbENvbXByZXNzaW9uKGNvbXByZXNzaW9uKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX2NvbXByZXNzaW9uO1xuICAgICAgICB0aGlzLl9jb21wcmVzc2lvbiA9IGNvbXByZXNzaW9uO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLy90b2RvIG1pc3NpbmdcbiAgICBkYXRhQXhpc0xhYmVsKGxhYmVsKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX2RhdGFBeGlzTGFiZWw7XG4gICAgICAgIHRoaXMuX2RhdGFBeGlzTGFiZWwgPSBsYWJlbDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHRvb2x0aXAodG9vbHRpcCkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl90b29sdGlwO1xuICAgICAgICB0aGlzLl90b29sdGlwID0gdG9vbHRpcDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGZvcmNlWShmb3JjZSkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9mb3JjZVk7XG4gICAgICAgIHRoaXMuX2ZvcmNlWSA9IGZvcmNlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vLyB0b2RvIG1pc3NpbmdcbiAgICBkdXJhdGlvbihkdXJhdGlvbikge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9kdXJhdGlvbjtcbiAgICAgICAgdGhpcy5fZHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4vLyB0b2RvIG1pc3NpbmdcbiAgICBjb2Fyc2VuZXNzKGNvYXJzZW5lc3MpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fY29hcnNlbmVzcztcbiAgICAgICAgdGhpcy5fY29hcnNlbmVzcyA9IGNvYXJzZW5lc3M7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIHRvZG8gbWlzc2luZ1xuICAgIHBhZGRpbmcocGFkZGluZykge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9wYWRkaW5nO1xuICAgICAgICB0aGlzLl9wYWRkaW5nID0gcGFkZGluZztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gdG9kbyBtaXNzaW5nXG4gICAgeEF4aXNUb29sdGlwcyh0b29sdGlwcykge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl94QXhpc1Rvb2x0aXBzO1xuICAgICAgICB0aGlzLl94QXhpc1Rvb2x0aXBzID0gdG9vbHRpcHM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHhBeGlzT3ZlcnJpZGUob3ZlcnJpZGUpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5feEF4aXNPdmVycmlkZTtcbiAgICAgICAgdGhpcy5feEF4aXNPdmVycmlkZSA9IG92ZXJyaWRlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgZGlzcGF0Y2goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaXNwYXRjaDtcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2VsZW1lbnQpIHRocm93IG5ldyBFcnJvcihcIk5vIGVsZW1lbnQgc2V0IGZvciBDb2x1bW5DaGFydC4gU2VlICNlbGVtZW50KClcIik7XG4gICAgICAgIGlmICghdGhpcy5fZGF0YSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiTm8gZGF0YSBzZXQgZm9yIENvbHVtbkNoYXJ0LiBTZWUgI2RhdGEoKVwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLmdldFRyYW5zZm9ybWVkRGF0YSgpO1xuXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIFNldCB1cCB0aGUgU1ZHIGFyZWFcblxuICAgICAgICBsZXQgdG9wTGV2ZWwgPSBkMy5zZWxlY3QodGhpcy5fZWxlbWVudCkuc2VsZWN0KFwic3ZnXCIpO1xuICAgICAgICBpZiAodG9wTGV2ZWwuZW1wdHkoKSkgdG9wTGV2ZWwgPSBkMy5zZWxlY3QodGhpcy5fZWxlbWVudCkuYXBwZW5kKFwic3ZnXCIpO1xuXG4gICAgICAgIHRvcExldmVsXG4gICAgICAgICAgICAuc3R5bGUoXCJ3aWR0aFwiLCB0aGlzLl93aWR0aCArIFwicHhcIilcbiAgICAgICAgICAgIC5zdHlsZShcImhlaWdodFwiLCB0aGlzLl9oZWlnaHQgKyBcInB4XCIpO1xuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBMYXlvdXQgdGhlIHNob3dMZWdlbmQuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFdlIGRvIHRoaXMgbm93IGJlY2F1c2Ugd2UgbmVlZCB0byBrbm93IGhvdyBtdWNoIHNwYWNlIHRoZSBsZWdlbmRcbiAgICAgICAgLy8gdGFrZXMgdXAgaW4gb3JkZXIgdG8gZmluaXNoIGNhbGN1bGF0aW5nIHRoZSBtYXJnaW5zLlxuXG4gICAgICAgIGNvbnN0IGxlZ2VuZEhlaWdodCA9IHRoaXMucmVuZGVyTGVnZW5kKHRvcExldmVsLCBkYXRhLCAwLCB0aGlzLl93aWR0aCwgdGhpcy5faGVpZ2h0LCBkID0+IGQuX2tleSk7XG5cbiAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIENhbGN1bGF0ZSBtYXJnaW5zLlxuXG4gICAgICAgIGNvbnN0IG1hcmdpbiA9IHt0b3A6IDIwLCByaWdodDogMjAsIGJvdHRvbTogNDAsIGxlZnQ6IDQwfTtcbiAgICAgICAgbWFyZ2luLmJvdHRvbSArPSBsZWdlbmRIZWlnaHQgPyBsZWdlbmRIZWlnaHQgKyAyMCA6IDA7XG5cbiAgICAgICAgLy8gaWYgKHRoaXMuX2RhdGFBeGlzTGFiZWwpIG1hcmdpbi5sZWZ0ICs9IDIwICsgMTI7XG4gICAgICAgIC8vIGlmIChkYXRhKSB7XG4gICAgICAgIC8vICAgICBsZXQgbWF4TGFiZWxMZW5ndGggPSAwO1xuICAgICAgICAvLyAgICAgZGF0YS5mb3JFYWNoKGQgPT4ge1xuICAgICAgICAvLyAgICAgICAgIGQuZGF0YS5mb3JFYWNoKGQgPT4ge1xuICAgICAgICAvLyAgICAgICAgICAgICBsZXQgbGVuZ3RoID0gdGhpcy5feEF4aXNUaWNrRm9ybWF0KHRoaXMuX3goZCkpLmxlbmd0aDtcbiAgICAgICAgLy8gICAgICAgICAgICAgaWYgKGxlbmd0aCA+IG1heExhYmVsTGVuZ3RoKSBtYXhMYWJlbExlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgLy8gICAgICAgICB9KVxuICAgICAgICAvLyAgICAgfSk7XG4gICAgICAgIC8vICAgICBtYXJnaW4uYm90dG9tICs9IG1heExhYmVsTGVuZ3RoICogMiArIDEwOyAgICAvLyBzcGFjZSBmb3IgYXhlcyBsYWJlbHMuXG4gICAgICAgIC8vIH1cblxuICAgICAgICBjb25zdCB3aWR0aCA9IHRoaXMuX3dpZHRoIC0gbWFyZ2luLmxlZnQgLSBtYXJnaW4ucmlnaHQsXG4gICAgICAgICAgICAgIGhlaWdodCA9IHRoaXMuX2hlaWdodCAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tO1xuICAgICAgICBjb25zdCByYWRpdXMgPSBNYXRoLm1pbih3aWR0aCwgaGVpZ2h0KSAvIDI7XG4gICAgICAgIHRoaXMuX3JhZGl1cyA9IHJhZGl1cztcblxuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHNjYWxlcyBhbmQgc28gb24uXG5cbiAgICAgICAgbGV0IGNvbG91ciA9IGQzLnNjYWxlT3JkaW5hbChbXCIjOThhYmM1XCIsIFwiIzhhODlhNlwiLCBcIiM3YjY4ODhcIiwgXCIjNmI0ODZiXCIsIFwiI2EwNWQ1NlwiLCBcIiNkMDc0M2NcIiwgXCIjZmY4YzAwXCJdKTtcblxuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgIGxldCBzdmcgPSB0b3BMZXZlbC5zZWxlY3QoJy5tYWluLWdyb3VwJyk7XG5cbiAgICAgICAgaWYgKHN2Zy5lbXB0eSgpKSB7XG4gICAgICAgICAgICBzdmcgPSB0b3BMZXZlbFxuICAgICAgICAgICAgICAgIC5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcIm1haW4tZ3JvdXBcIik7XG4gICAgICAgIH1cblxuICAgICAgICBzdmcuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIChtYXJnaW4ubGVmdCArIHdpZHRoIC8gMikgKyBcIixcIiArIChtYXJnaW4udG9wICsgaGVpZ2h0IC8gMikgKyBcIilcIik7XG5cbiAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gR2V0IHJpZCBvZiBjdXJyZW50IGxhYmVscy5cbiAgICAgICAgc3ZnLnNlbGVjdChcIi5jaGFydC1sYWJlbHNcIilcbiAgICAgICAgICAgIC5yZW1vdmUoKTtcblxuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBhcHBlbmQgdGhlIGFyY3MgZm9yIHRoZSBwaWUgY2hhcnRcblxuICAgICAgICBsZXQgcGllID0gZDMucGllKClcbiAgICAgICAgICAgIC5zb3J0KG51bGwpXG4gICAgICAgICAgICAudmFsdWUoZCA9PiBkLl95KTtcbiAgICAgICAgdGhpcy5fcGllID0gcGllO1xuXG4gICAgICAgIGxldCBwYXRoID0gZDMuYXJjKClcbiAgICAgICAgICAgIC5vdXRlclJhZGl1cyhyYWRpdXMgLSAxMClcbiAgICAgICAgICAgIC5pbm5lclJhZGl1cygwKTtcblxuICAgICAgICBsZXQgYXJjcyA9IHN2Zy5zZWxlY3QoXCIuc2xpY2VzXCIpLnNlbGVjdEFsbCgnLmFyYycpO1xuXG4gICAgICAgIGlmIChhcmNzLmVtcHR5KCkpIHtcbiAgICAgICAgICAgIGFyY3MgPSBzdmdcbiAgICAgICAgICAgICAgICAuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJzbGljZXNcIilcbiAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKFwiLmFyY1wiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBwaWVEYXRhID0gcGllKGRhdGEpO1xuICAgICAgICBhcmNzID0gYXJjcy5kYXRhKHBpZURhdGEpO1xuICAgICAgICBhcmNzLmV4aXQoKS5yZW1vdmUoKTtcblxuICAgICAgICBmdW5jdGlvbiBhcmNUd2VlbihkLCBpKSB7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50ID0gdGhpcy5fY3VycmVudCB8fCAoaSA8PSAwID8geyBzdGFydEFuZ2xlOiAwLCBlbmRBbmdsZTogMH0gOiBwaWVEYXRhW2kgLSAxXSk7XG4gICAgICAgICAgICBsZXQgaW50ZXJwb2xhdG9yID0gZDMuaW50ZXJwb2xhdGUodGhpcy5fY3VycmVudCwgZCk7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50ID0gaW50ZXJwb2xhdG9yKDApO1xuXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXRoKGludGVycG9sYXRvcih0KSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGFyY3MuZW50ZXIoKVxuICAgICAgICAgICAgLmFwcGVuZChcInBhdGhcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIChkLCBpKSA9PiBcImFyYyBcIiArIFwic2VyaWVzIHNlcmllcy1cIiArIGkpXG4gICAgICAgICAgICAgICAgLnN0eWxlKFwiY3Vyc29yXCIsIFwicG9pbnRlclwiKVxuICAgICAgICAgICAgLm9uKFwibW91c2VvdmVyXCIsIChkLCBpLCBub2RlcykgPT4geyAvLyBEYXJrZW4gdGhlIHBpZSBvbiBtb3VzZSBvdmVyXG4gICAgICAgICAgICAgICAgLy8gV2Ugd2FudCB0byBzaGlmdCB0aGUgcGllIG91dCBhIGJpdCBvbiBtb3VzZW92ZXIuXG4gICAgICAgICAgICAgICAgLy8gU28gd2Ugd2FudCB0byBmaW5kIHRoZSBkaXJlY3Rpb24gdG8gbW92ZSB0aGUgcGllIGluLlxuICAgICAgICAgICAgICAgIC8vIFdlIGNhbiBqdXN0IGFzayB0aGUgcGF0aCBoZWxwZXIgdG8gZ2l2ZSB1cyB0aGUgY2VudHJvaWQsXG4gICAgICAgICAgICAgICAgLy8gbm9ybWFsaXNlIGl0LCBhbmQgdGhhdCBpcyB0aGUgZGlyZWN0aW9uIHRvIG1vdmUgaW4uXG4gICAgICAgICAgICAgICAgY29uc3QgY2VudHJlID0gcGF0aC5jZW50cm9pZChkKTtcbiAgICAgICAgICAgICAgICBjb25zdCBub3JtID0gTWF0aC5zcXJ0KGNlbnRyZVswXSAqKiAyICsgY2VudHJlWzFdICoqIDIpO1xuICAgICAgICAgICAgICAgIGNlbnRyZVswXSA9IGNlbnRyZVswXSAvIG5vcm07XG4gICAgICAgICAgICAgICAgY2VudHJlWzFdID0gY2VudHJlWzFdIC8gbm9ybTtcblxuICAgICAgICAgICAgICAgIGQzLnNlbGVjdChub2Rlc1tpXSlcbiAgICAgICAgICAgICAgICAgICAgLmludGVycnVwdChcImhvdmVyOmNvbG91clwiKVxuICAgICAgICAgICAgICAgICAgICAudHJhbnNpdGlvbihcImhvdmVyOmNvbG91clwiKVxuICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24oMzAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyAoY2VudHJlWzBdICogMTApICsgXCIsXCIgKyAoY2VudHJlWzFdICogMTApICsgXCIpLCBzY2FsZSgxLjEpXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIGQzLmhjbCh0aGlzLmdldFNlcmllc0NvbG91cihpKSkuZGFya2VyKCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3BhdGNoLmNhbGwoXCJ0b29sdGlwU2hvd1wiLCB0aGlzLCB7XG4gICAgICAgICAgICAgICAgICAgIGU6IGQzLmV2ZW50LFxuICAgICAgICAgICAgICAgICAgICBwb2ludDogZC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICBzZXJpZXM6IGQuZGF0YS5fc2VyaWVzLFxuICAgICAgICAgICAgICAgICAgICBzZXJpZXNJbmRleDogZC5kYXRhLl9zX2ksXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBkLmRhdGEuX3lcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbihcIm1vdXNlb3V0XCIsIChkLCBpLCBub2RlcykgPT4geyAvLyBwaWUgaXMgcmVndWxhciBjb2xvdXIgb24gbW91c2Ugb3V0LlxuICAgICAgICAgICAgICAgIGQzLnNlbGVjdChub2Rlc1tpXSlcbiAgICAgICAgICAgICAgICAgICAgLmludGVycnVwdChcImhvdmVyOmNvbG91clwiKVxuICAgICAgICAgICAgICAgICAgICAudHJhbnNpdGlvbihcImhvdmVyOmNvbG91clwiKVxuICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24oMzAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoMCwwKVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCB0aGlzLmdldFNlcmllc0NvbG91cihpKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGlzcGF0Y2guY2FsbChcInRvb2x0aXBIaWRlXCIsIHRoaXMpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbihcImNsaWNrIGF1eGNsaWNrXCIsIChkLCBpLCBub2RlcykgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3BhdGNoLmNhbGwoXCJlbGVtZW50Q2xpY2tcIiwgdGhpcywge1xuICAgICAgICAgICAgICAgICAgICBlOiBkMy5ldmVudCxcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQ6IGQuZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgc2VyaWVzOiBkLmRhdGEuX3NlcmllcyxcbiAgICAgICAgICAgICAgICAgICAgc2VyaWVzSW5kZXg6IGQuZGF0YS5fc19pLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZC5kYXRhLl95XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAubWVyZ2UoYXJjcylcbiAgICAgICAgICAgIC50cmFuc2l0aW9uKClcbiAgICAgICAgICAgICAgICAuYXR0clR3ZWVuKFwiZFwiLCBhcmNUd2VlbilcbiAgICAgICAgICAgICAgICAuYXR0cihcImZpbGxcIiwgKGQsIGkpID0+IHRoaXMuZ2V0U2VyaWVzQ29sb3VyKGkpICk7XG5cbiAgICAgICAgLy8gYXJjcy5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgICAgIC8vICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBmdW5jdGlvbihkKSB7IHJldHVybiBcInRyYW5zbGF0ZShcIiArIGxhYmVsLmNlbnRyb2lkKGQpICsgXCIpXCI7IH0pXG4gICAgICAgIC8vICAgICAuYXR0cihcImR5XCIsIFwiMC4zNWVtXCIpXG4gICAgICAgIC8vICAgICAudGV4dChkID0+IHtjb25zb2xlLmxvZyhcImQgaXNcIiwgZCk7IHJldHVybiBkLmRhdGEuX3k7IH0pO1xuXG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIExhYmVscyBsb2FkZWQgYWZ0ZXIgb3VyIGZpcnN0IGJhciBncm93cy5cbiAgICAgICAgaWYgKHRoaXMuX3Nob3dfbGFiZWxzKSB7XG4gICAgICAgICAgICBzdmcudHJhbnNpdGlvbihcImJhcjpncm93dGhcIilcbiAgICAgICAgICAgICAgICAub24oXCJlbmRcIiwgKGQsIGksIG5vZGVzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpIDwgbm9kZXMubGVuZ3RoIC0gMSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckxhYmVscyhzdmcsIGRhdGEpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gU2V0IHRoZSBiYWNrZ3JvdW5kIGNvbG91clxuXG4gICAgICAgIGQzLnNlbGVjdCh0aGlzLl9lbGVtZW50KS5zZWxlY3QoXCIuYmFja2dyb3VuZFwiKS5yZW1vdmUoKTtcbiAgICAgICAgaWYgKHRoaXMuX2JhY2tncm91bmRDb2xvdXIpIHtcbiAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzLl9lbGVtZW50KS5zZWxlY3QoXCJzdmdcIilcbiAgICAgICAgICAgICAgICAuYXBwZW5kKFwicmVjdFwiKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwiYmFja2dyb3VuZFwiKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcIndpZHRoXCIsIFwiMTAwJVwiKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcImhlaWdodFwiLCBcIjEwMCVcIilcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCB0aGlzLl9iYWNrZ3JvdW5kQ29sb3VyKVxuICAgICAgICAgICAgICAgIC5sb3dlcigpO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLypcbiAgICAgKiBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIHR3byBmdW5jdGlvbnMsICNzaG93KCkgYW5kICNoaWRlKCksXG4gICAgICogdG8gc2hvdyBhbmQgaGlkZSB0aGUgbGFiZWxzLlxuICAgICAqL1xuICAgIGxhYmVscygpIHtcbiAgICAgICAgcmV0dXJuIHtcblxuICAgICAgICAgICAgc2hvdzogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9lbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzZWxlY3Rpb24gPSB0aGlzLl9lbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHRoaXMuZ2V0VHJhbnNmb3JtZWREYXRhKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvbikgc2VsZWN0aW9uID0gZDMuc2VsZWN0KHRoaXMuX2VsZW1lbnQpLnNlbGVjdChcInN2Z1wiKS5zZWxlY3QoXCIubWFpbi1ncm91cFwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzZWxlY3Rpb24uZW1wdHkoKSAmJiBkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbGFiZWxzID0gc2VsZWN0aW9uLnNlbGVjdCgnLmNoYXJ0LWxhYmVscycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFsYWJlbHMuZW1wdHkoKSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWxzLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJMYWJlbHMoc2VsZWN0aW9uLCBkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgaGlkZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9lbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzLl9lbGVtZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgLnNlbGVjdCgnLmNoYXJ0LWxhYmVscycpXG4gICAgICAgICAgICAgICAgICAgICAgICAuaW50ZXJydXB0KFwibGFiZWxzXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAuaW50ZXJydXB0KFwibGFiZWxzOmZhZGVcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKFwibGFiZWxzOmZhZGVcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5vbihcImVuZFwiLCAoZCwgaSwgbm9kZXMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkMy5zZWxlY3Qobm9kZXNbaV0pLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgcmVuZGVyTGFiZWxzKHNlbGVjdGlvbiwgZGF0YSwgYW5pbWF0ZSkge1xuICAgICAgICBzZWxlY3Rpb24uc2VsZWN0QWxsKFwiLmNoYXJ0LWxhYmVsc1wiKS5yZW1vdmUoKTtcblxuICAgICAgICBjb25zdCByYWRpdXMgPSB0aGlzLl9yYWRpdXMgKyAxNTtcblxuICAgICAgICBsZXQgYXJjID0gZDMuYXJjKClcbiAgICAgICAgICAgIC5vdXRlclJhZGl1cyhyYWRpdXMpXG4gICAgICAgICAgICAuaW5uZXJSYWRpdXMocmFkaXVzKTtcblxuICAgICAgICBsZXQgbGFiZWxzID0gc2VsZWN0aW9uLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJjaGFydC1sYWJlbHNcIilcbiAgICAgICAgICAgIC5zZWxlY3RBbGwoXCIubGFiZWwtZ3JvdXBcIilcbiAgICAgICAgICAgIC5kYXRhKHRoaXMuX3BpZShkYXRhKSk7XG5cbiAgICAgICAgbGFiZWxzLmVudGVyKClcbiAgICAgICAgICAgIC5lYWNoKChkLCBpLCBub2RlcykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNlbnRyb2lkID0gYXJjLmNlbnRyb2lkKGQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJhZGlhbnMgPSBkLmVuZEFuZ2xlIC0gZC5zdGFydEFuZ2xlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFyY0xlbmd0aCA9IHJhZGlhbnMgKiByYWRpdXM7XG5cbiAgICAgICAgICAgICAgICBsZXQgbGFiZWwgPSBkMy5zZWxlY3Qobm9kZXNbaV0pXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgICAgICAgICAgICAgICAgIC50ZXh0KGQgPT4gdGhpcy5fbGFiZWxGb3JtYXQoZC5kYXRhLl95KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIC5zdHlsZShcImZvbnQtZmFtaWx5XCIsIFwiT3BlbiBTYW5zLCBzYW5zLXNlcmlmXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAuc3R5bGUoXCJmb250LXNpemVcIiwgXCIxMnB4XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIGNvbG91cnMuZWlnaHRlZW4uZGFya0dyZXkpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDApXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIGNlbnRyb2lkICsgXCIpXCIpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgYm91bmRpbmcgPSBsYWJlbC5ub2RlKCkuZ2V0QkJveCgpO1xuICAgICAgICAgICAgICAgIGlmIChib3VuZGluZy53aWR0aCA8IGFyY0xlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBsYWJlbC5hdHRyKFwiZHhcIiwgKGJvdW5kaW5nLndpZHRoIC8gMikgKiAoZGlyZWN0aW9uWzBdIDwgMCA/IC0xIDogMSkpO1xuICAgICAgICAgICAgICAgICAgICAvLyBsYWJlbC5hdHRyKFwiZHlcIiwgKGJvdW5kaW5nLmhlaWdodCAvIDIpICogKGRpcmVjdGlvblsxXSA8IDAgPyAtMSA6IDEpKTtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWwuYXR0cihcImR4XCIsIC0oYm91bmRpbmcud2lkdGggLyAyKSk7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsLmF0dHIoXCJkeVwiLCAoYm91bmRpbmcuaGVpZ2h0IC8gMikpO1xuXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsXG4gICAgICAgICAgICAgICAgICAgICAgICAudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24odGhpcy5fZHVyYXRpb24pXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDEpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9KVxuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBnZXRTZXJpZXNDb2xvdXIoaSkge1xuICAgICAgICBpZiAoaSA8IDAgfHwgIXRoaXMuX2NvbG91cnMpIHJldHVybiBjb2xvdXJzLmVpZ2h0ZWVuLm1pZEdyZXk7XG5cbiAgICAgICAgaSA9IGkgJSB0aGlzLl9jb2xvdXJzLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbG91cnNbaV07XG4gICAgfVxuXG4gICAgZ2V0U29ydGVkRGF0YSgpIHtcbiAgICAgICAgbGV0IGRhdGEgPSB0aGlzLl9kYXRhO1xuICAgICAgICBpZiAoIWRhdGEgfHwgIWRhdGEubGVuZ3RoKSByZXR1cm4gW107XG5cbiAgICAgICAgZGF0YSA9IHRoaXMuX2RhdGEuc29ydCgobGhzLCByaHMpID0+IHtcbiAgICAgICAgICAgIGxocyA9IGxocy5rZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIHJocyA9IHJocy5rZXkudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICAgICAgaWYgKGxocyA9PT0gcmhzKSByZXR1cm4gMDtcbiAgICAgICAgICAgIGlmIChsaHMgPCByaHMpIHJldHVybiAtMTtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICBnZXRUcmFuc2Zvcm1lZERhdGEoKSB7XG4gICAgICAgIGxldCBkYXRhID0gdGhpcy5nZXRTb3J0ZWREYXRhKCk7XG4gICAgICAgIGlmICghZGF0YSB8fCAhZGF0YS5sZW5ndGgpIHJldHVybiBbXTtcblxuICAgICAgICBsZXQgcmVzdWx0cyA9IFtdO1xuXG4gICAgICAgIGxldCBzZXJpZXMgPSBkYXRhWzBdO1xuICAgICAgICBzZXJpZXMudmFsdWVzLmZvckVhY2goKGQsIGRfaSkgPT4ge1xuXG4gICAgICAgICAgICByZXN1bHRzLnB1c2goT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICAgICAgX3k6IHRoaXMuX3koZCksXG4gICAgICAgICAgICAgICAgX3Nlcmllc19rZXk6IHNlcmllcy5rZXksXG4gICAgICAgICAgICAgICAgX3NfaTogMCxcbiAgICAgICAgICAgICAgICBfc2VyaWVzOiBzZXJpZXMsXG4gICAgICAgICAgICAgICAgX2tleTogdGhpcy5feEF4aXNPdmVycmlkZSA/IHRoaXMuX3hBeGlzT3ZlcnJpZGVbdGhpcy5feChkKV0gOiB0aGlzLl94KGQpXG4gICAgICAgICAgICB9LCBkKSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cblxuICAgIGdldEtleXMoKSB7XG4gICAgICAgIGxldCBkYXRhID0gdGhpcy5fZGF0YTtcbiAgICAgICAgaWYgKCFkYXRhIHx8ICFkYXRhLmxlbmd0aCkgcmV0dXJuIFtdO1xuXG4gICAgICAgIHJldHVybiBbLi4ubmV3IFNldChkYXRhLm1hcChkID0+IGQua2V5KSldXG4gICAgfVxufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/PieChart.js\n')},"./src/Statistics.js":
/*!***************************!*\
  !*** ./src/Statistics.js ***!
  \***************************/
/*! exports provided: freedmanDiaconis */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "freedmanDiaconis", function() { return freedmanDiaconis; });\n/* harmony import */ var compute_iqr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! compute-iqr */ "./node_modules/compute-iqr/lib/index.js");\n/* harmony import */ var compute_iqr__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(compute_iqr__WEBPACK_IMPORTED_MODULE_0__);\n// Copyright (C) 2013-2014, 2018 BrandsEye (PTY) LTD\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this\n// software and associated documentation files (the "Software"), to deal in the Software\n// without restriction, including without limitation the rights to use, copy, modify,\n//     merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following\n// conditions:\n//\n//     The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n//     INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n// CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n\n/**\n * Calculates the number of buckets to split a real value domain\n * in to when calculating a histogram.\n *\n * https://en.wikipedia.org/wiki/Histogram\n *\n * @return {number}\n */\nfunction freedmanDiaconis(data) {\n    return 2 * compute_iqr__WEBPACK_IMPORTED_MODULE_0___default()(data) / Math.pow(data.length, 1/3);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvU3RhdGlzdGljcy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2IzanMvLi9zcmMvU3RhdGlzdGljcy5qcz9kNThlIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoQykgMjAxMy0yMDE0LCAyMDE4IEJyYW5kc0V5ZSAoUFRZKSBMVERcbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXNcbi8vIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZVxuLy8gd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LFxuLy8gICAgIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG9cbi8vIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nXG4vLyBjb25kaXRpb25zOlxuLy9cbi8vICAgICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbi8vIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gICAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1IgSU1QTElFRCxcbi8vICAgICBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQVxuLy8gUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxuLy8gSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GXG4vLyBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkVcbi8vIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5pbXBvcnQgaXFyIGZyb20gJ2NvbXB1dGUtaXFyJztcblxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIG51bWJlciBvZiBidWNrZXRzIHRvIHNwbGl0IGEgcmVhbCB2YWx1ZSBkb21haW5cbiAqIGluIHRvIHdoZW4gY2FsY3VsYXRpbmcgYSBoaXN0b2dyYW0uXG4gKlxuICogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSGlzdG9ncmFtXG4gKlxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJlZWRtYW5EaWFjb25pcyhkYXRhKSB7XG4gICAgcmV0dXJuIDIgKiBpcXIoZGF0YSkgLyBNYXRoLnBvdyhkYXRhLmxlbmd0aCwgMS8zKTtcbn0iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/Statistics.js\n')},"./src/Strings.js":
/*!************************!*\
  !*** ./src/Strings.js ***!
  \************************/
/*! exports provided: restrictLength */function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"restrictLength\", function() { return restrictLength; });\n// Copyright (C) 2013-2014, 2018 BrandsEye (PTY) LTD\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this\n// software and associated documentation files (the \"Software\"), to deal in the Software\n// without restriction, including without limitation the rights to use, copy, modify,\n//     merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following\n// conditions:\n//\n//     The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n//     INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n// CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n/**\n * Limits the length of a string, and places ellipses if this happens.\n * @param text\n * @param length\n * @returns {*}\n */\nfunction restrictLength(text, length) {\n    if (!text) return text;\n    text = \"\" + text;\n    if (text.length <= length) return text;\n\n    var result = [];\n    var word = [];\n    for (let i = 0; i < length - 1; i++) {\n        var character = text.charAt(i);\n        if (character === ' ' || character === '\\n') {\n            if (result.length === 0) result = result.concat(word);\n            else {\n                result.push(' ');\n                result = result.concat(word);\n            }\n            word = [];\n        } else {\n            word.push(character)\n        }\n    }\n\n    if (text.length !== 0 && result.length === 0) result = text; // Can happen if the string is a single word longer than length.\n    else result.push('…');\n\n    if (result.length > length) {\n        return result.substring(0, length - 1) + '…';\n    }\n\n    return result.join('');\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvU3RyaW5ncy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2IzanMvLi9zcmMvU3RyaW5ncy5qcz8xMTZhIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoQykgMjAxMy0yMDE0LCAyMDE4IEJyYW5kc0V5ZSAoUFRZKSBMVERcbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXNcbi8vIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZVxuLy8gd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LFxuLy8gICAgIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG9cbi8vIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nXG4vLyBjb25kaXRpb25zOlxuLy9cbi8vICAgICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbi8vIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gICAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1IgSU1QTElFRCxcbi8vICAgICBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQVxuLy8gUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxuLy8gSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GXG4vLyBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkVcbi8vIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vKipcbiAqIExpbWl0cyB0aGUgbGVuZ3RoIG9mIGEgc3RyaW5nLCBhbmQgcGxhY2VzIGVsbGlwc2VzIGlmIHRoaXMgaGFwcGVucy5cbiAqIEBwYXJhbSB0ZXh0XG4gKiBAcGFyYW0gbGVuZ3RoXG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc3RyaWN0TGVuZ3RoKHRleHQsIGxlbmd0aCkge1xuICAgIGlmICghdGV4dCkgcmV0dXJuIHRleHQ7XG4gICAgdGV4dCA9IFwiXCIgKyB0ZXh0O1xuICAgIGlmICh0ZXh0Lmxlbmd0aCA8PSBsZW5ndGgpIHJldHVybiB0ZXh0O1xuXG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciB3b3JkID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgdmFyIGNoYXJhY3RlciA9IHRleHQuY2hhckF0KGkpO1xuICAgICAgICBpZiAoY2hhcmFjdGVyID09PSAnICcgfHwgY2hhcmFjdGVyID09PSAnXFxuJykge1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPT09IDApIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQod29yZCk7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnICcpO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQod29yZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3b3JkID0gW107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3b3JkLnB1c2goY2hhcmFjdGVyKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRleHQubGVuZ3RoICE9PSAwICYmIHJlc3VsdC5sZW5ndGggPT09IDApIHJlc3VsdCA9IHRleHQ7IC8vIENhbiBoYXBwZW4gaWYgdGhlIHN0cmluZyBpcyBhIHNpbmdsZSB3b3JkIGxvbmdlciB0aGFuIGxlbmd0aC5cbiAgICBlbHNlIHJlc3VsdC5wdXNoKCfigKYnKTtcblxuICAgIGlmIChyZXN1bHQubGVuZ3RoID4gbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQuc3Vic3RyaW5nKDAsIGxlbmd0aCAtIDEpICsgJ+KApic7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdC5qb2luKCcnKTtcbn0iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/Strings.js\n")},"./src/chart/Axes.js":
/*!***************************!*\
  !*** ./src/chart/Axes.js ***!
  \***************************/
/*! exports provided: xaxis, yaxis, yGrid, xGrid, yAxisLabel, xAxisLabel */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "xaxis", function() { return xaxis; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "yaxis", function() { return yaxis; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "yGrid", function() { return yGrid; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "xGrid", function() { return xGrid; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "yAxisLabel", function() { return yAxisLabel; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "xAxisLabel", function() { return xAxisLabel; });\n/* harmony import */ var _Colours__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Colours */ "./src/Colours.js");\n// Copyright (C) 2013-2014, 2018 BrandsEye (PTY) LTD\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this\n// software and associated documentation files (the "Software"), to deal in the Software\n// without restriction, including without limitation the rights to use, copy, modify,\n//     merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following\n// conditions:\n//\n//     The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n//     INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n// CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nconst AXIS_ANIMATION_DURATION = 1000;\nconst AXIS_DELAY = 250;\n\nfunction ensureOptions(o) {\n    return Object.assign({\n        fontSize: 12,\n        gridLineOpacity: 0.2\n    }, o)\n}\n\nfunction getMaxWidth(sel) {\n    let max = 0\n    sel.nodes().forEach(node => max = Math.max(max, node.getBBox().width))\n    return max\n}\n\nfunction removeOverlappingXTicks(axis, labelWidth) {\n    let a = axis.selectAll("g.tick").nodes()\n    if (!a.length) return\n    let px = a[0].getBoundingClientRect().x + labelWidth\n    for (let i = 1; i < a.length; i++) {\n        let node = a[i]\n        let x = node.getBoundingClientRect().x\n        if (x < px) node.parentNode.removeChild(node)\n        else px = x + labelWidth // there is space for the label\n    }\n}\n\nfunction adjustFirstXTickLabel(axis) {\n    // move the first tick label right if it extends too far to the left as it might overlap the y-axis zero\n    let tick = axis.select("g.tick")\n    if (tick.empty()) return\n    let t = tick.attr("transform")  // e.g. translate(8.327586206896552,0)\n    let i = t.indexOf(\'(\')\n    let j = t.indexOf(\',\', i + 1)\n    let x = parseFloat(t.substring(i + 1, j))\n    let text = tick.select("text")\n    x -= text.node().getComputedTextLength() / 2\n    if (x < -8) text.attr("x", Math.abs(x + 6))\n}\n\nfunction xaxis(selection, height, width, axisObject, importance, options) {\n    options = ensureOptions(options)\n    let { fontSize, gridLineOpacity } = options\n\n    selection.select(".x-axis").remove();\n    let axis = selection.append("g").attr("class", "x-axis").style("opacity", 0).call(axisObject)\n\n    axis.select(".domain").remove();\n\n    const regularText = d3.hcl(_Colours__WEBPACK_IMPORTED_MODULE_0__["colours"].eighteen.darkGrey).brighter();\n\n    let text = axis.selectAll("text")\n    text.style("font-size", fontSize + "px")\n        .style("fill", regularText)\n\n    let tv = axisObject.tickValues()\n    if (tv) width *= axisObject.scale().domain().length / (tv.length + 1)\n\n    let labelWidth = getMaxWidth(text) + 4\n    if (labelWidth > width) {\n        if (options.xLabelAngle !== 0) {\n            const bad = labelWidth >= width * 2;\n            const angle = bad ? -90 : -30;\n            const x = bad ? -(fontSize * 0.78) : 0;\n            const y = bad ? 5 : 2;\n\n            text.style(\'text-anchor\', \'end\')\n                .attr("transform", () => "translate(" + x + "," + y + ") rotate(" + angle + " 0,0)")\n\n            labelWidth = fontSize * 1.2  // getBoundingClientRect doesn\'t seem to consider the rotation?\n        } else {\n            adjustFirstXTickLabel(axis)\n        }\n        if (labelWidth > width) removeOverlappingXTicks(axis, labelWidth)\n    } else {\n        adjustFirstXTickLabel(axis)\n        if (tv) removeOverlappingXTicks(axis, labelWidth) // ticks might not be evenly spaced\n    }\n\n    axis.selectAll("line").style("opacity", gridLineOpacity)\n\n    let tickSize = axisObject.tickSize();\n    if (tickSize && options.axisBox) {\n        let x = axisObject.scale().range()[1]\n        axis.append("line").attr("x1", x).attr("x2", x).attr("y2", tickSize)\n            .attr("opacity", gridLineOpacity).attr("stroke", "currentColor")\n    }\n\n    axis.transition().duration(AXIS_ANIMATION_DURATION).delay(AXIS_DELAY).style("opacity", 1)\n\n    return axis.node().getBBox().height;\n}\n\nfunction removeOverlappingYTicks(axis, labelHeight) {\n    let a = axis.selectAll("g.tick").nodes()\n    if (!a.length) return\n    let py = a[0].getBoundingClientRect().y - labelHeight\n    for (let i = 1; i < a.length; i++) {\n        let node = a[i]\n        let y = node.getBoundingClientRect().y\n        if (y > py) node.parentNode.removeChild(node)\n        else py = y - labelHeight // there is space for the label\n    }\n}\n\nfunction yaxis(selection, axis, options) {\n    options = ensureOptions(options)\n    let { fontSize, gridLineOpacity } = ensureOptions(options)\n\n    selection.select(".y-axis").remove();\n    let y = selection.append("g")\n                     .attr("class", "y-axis")\n                     .call(axis)\n                     .style("opacity", 0)\n    y.select(".domain").remove() // this doubles up on the 0 tick line making it darker so nuke it\n\n    if (options.axisBox) y.append("line").attr("y2", axis.scale().range()[0]).attr("stroke", "currentColor")\n\n    let tickSize = axis.tickSize()\n    if (tickSize && options.axisBox) y.append("line").attr("x2", -tickSize).attr("stroke", "currentColor")\n\n    y.selectAll("text").style("font-size", fontSize + "px").style("fill", d3.hcl(_Colours__WEBPACK_IMPORTED_MODULE_0__["colours"].eighteen.darkGrey).brighter());\n    y.selectAll("path").style("opacity", gridLineOpacity)\n    y.selectAll("line").style("opacity", gridLineOpacity)\n\n    if (!axis.scale().bandwidth) removeOverlappingYTicks(y, fontSize * 1.2)\n\n    y.transition()\n        .duration(AXIS_ANIMATION_DURATION)\n        .delay(AXIS_DELAY)\n        .style("opacity", 1);\n\n    return y.node().getBBox().width + 20;\n}\n\nfunction yGrid(selection, width, show, axis) {\n    selection.select(".yGrid").remove();\n\n    if (!show) return;\n\n    let grid = selection.append("g")\n                        .attr("class", "yGrid")\n                        .call(axis\n                            .tickSize(-width)\n                            .tickFormat("")\n                        );\n\n    grid.selectAll("line")\n        .style("stroke", _Colours__WEBPACK_IMPORTED_MODULE_0__["colours"].eighteen.lightGrey);\n    grid.selectAll(".domain").remove();\n\n    grid\n        .lower() // Always ensure that this is earlier in the dom. Things must be drawn on top of it.\n        .style("opacity", 0)\n        .transition()\n        .delay(AXIS_DELAY)\n        .duration(AXIS_ANIMATION_DURATION)\n        .style("opacity", 1);\n}\n\nfunction xGrid(selection, height, show, axis) {\n    selection.select(".xGrid").remove();\n\n    if (!show) return;\n\n    let grid = selection.append("g")\n                        .attr("class", "xGrid")\n                        .call(axis\n                            .tickSize(height)\n                            .tickFormat("")\n                        );\n\n    grid.selectAll("line")\n        .style("stroke", _Colours__WEBPACK_IMPORTED_MODULE_0__["colours"].eighteen.lightGrey);\n    grid.selectAll(".domain").remove();\n\n    grid\n        .lower()\n        .style("opacity", 0)\n        .transition()\n        .delay(AXIS_DELAY)\n        .duration(AXIS_ANIMATION_DURATION)\n        .style("opacity", 1);\n}\n\nfunction yAxisLabel(element, height, margins, label, options) {\n    let { fontSize } = ensureOptions(options)\n\n    element.selectAll(".y-axis-label").remove();\n\n    if (!label) return;\n    let text = label;\n    if (text.long) text = text.long;\n\n    let x = -(margins.top + height / 2);\n\n    let labelElement = element.append("g")\n        .attr("class", "y-axis-label")\n        .append("text")\n        .style("font-size", fontSize + "px")\n        .text(text)\n        .attr("transform", "rotate(-90 0,0) translate(" + x + ", 20)")\n        .style("fill", d3.hcl(_Colours__WEBPACK_IMPORTED_MODULE_0__["colours"].eighteen.darkGrey).brighter());\n\n    let width = labelElement.node().getBBox().width;\n    if (width >= height && label.short) {\n        labelElement.text(label.short);\n        width = labelElement.node().getBBox().width;\n    }\n\n    labelElement.attr("dx", -width / 2)\n                .style("opacity", 0)\n                .transition()\n                .delay(AXIS_DELAY)\n                .duration(AXIS_ANIMATION_DURATION)\n                .style("opacity", 1)\n}\n\nfunction xAxisLabel(element, width, height, margins, label, options) {\n    let { fontSize } = ensureOptions(options)\n\n    element.selectAll(".x-axis-label").remove();\n\n    if (!label) return;\n    let text = label;\n    if (text.long) text = text.long;\n\n    let x = margins.left + width / 2;\n    let y = margins.top + height + 40;\n\n    let labelElement = element.append("g")\n        .attr("class", "x-axis-label")\n        .append("text")\n        .style("font-size", fontSize + "px")\n        .text(text)\n        .attr("transform", "translate(" + x + ", " + y + ")")\n        .style("fill", d3.hcl(_Colours__WEBPACK_IMPORTED_MODULE_0__["colours"].eighteen.darkGrey).brighter());\n\n    let textWidth = labelElement.node().getBBox().width;\n    if (textWidth >= height && label.short) {\n        labelElement.text(label.short);\n        textWidth = labelElement.node().getBBox().width;\n    }\n\n    labelElement.attr("dx", -textWidth / 2)\n                .style("opacity", 0)\n                .transition()\n                .delay(AXIS_DELAY)\n                .duration(AXIS_ANIMATION_DURATION)\n                .style("opacity", 1)\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY2hhcnQvQXhlcy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2IzanMvLi9zcmMvY2hhcnQvQXhlcy5qcz9iNDYxIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoQykgMjAxMy0yMDE0LCAyMDE4IEJyYW5kc0V5ZSAoUFRZKSBMVERcbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXNcbi8vIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZVxuLy8gd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LFxuLy8gICAgIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG9cbi8vIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nXG4vLyBjb25kaXRpb25zOlxuLy9cbi8vICAgICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbi8vIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gICAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1IgSU1QTElFRCxcbi8vICAgICBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQVxuLy8gUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxuLy8gSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GXG4vLyBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkVcbi8vIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5pbXBvcnQge2NvbG91cnN9IGZyb20gXCIuLi9Db2xvdXJzXCI7XG5cbmNvbnN0IEFYSVNfQU5JTUFUSU9OX0RVUkFUSU9OID0gMTAwMDtcbmNvbnN0IEFYSVNfREVMQVkgPSAyNTA7XG5cbmZ1bmN0aW9uIGVuc3VyZU9wdGlvbnMobykge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgZm9udFNpemU6IDEyLFxuICAgICAgICBncmlkTGluZU9wYWNpdHk6IDAuMlxuICAgIH0sIG8pXG59XG5cbmZ1bmN0aW9uIGdldE1heFdpZHRoKHNlbCkge1xuICAgIGxldCBtYXggPSAwXG4gICAgc2VsLm5vZGVzKCkuZm9yRWFjaChub2RlID0+IG1heCA9IE1hdGgubWF4KG1heCwgbm9kZS5nZXRCQm94KCkud2lkdGgpKVxuICAgIHJldHVybiBtYXhcbn1cblxuZnVuY3Rpb24gcmVtb3ZlT3ZlcmxhcHBpbmdYVGlja3MoYXhpcywgbGFiZWxXaWR0aCkge1xuICAgIGxldCBhID0gYXhpcy5zZWxlY3RBbGwoXCJnLnRpY2tcIikubm9kZXMoKVxuICAgIGlmICghYS5sZW5ndGgpIHJldHVyblxuICAgIGxldCBweCA9IGFbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkueCArIGxhYmVsV2lkdGhcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IG5vZGUgPSBhW2ldXG4gICAgICAgIGxldCB4ID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS54XG4gICAgICAgIGlmICh4IDwgcHgpIG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKVxuICAgICAgICBlbHNlIHB4ID0geCArIGxhYmVsV2lkdGggLy8gdGhlcmUgaXMgc3BhY2UgZm9yIHRoZSBsYWJlbFxuICAgIH1cbn1cblxuZnVuY3Rpb24gYWRqdXN0Rmlyc3RYVGlja0xhYmVsKGF4aXMpIHtcbiAgICAvLyBtb3ZlIHRoZSBmaXJzdCB0aWNrIGxhYmVsIHJpZ2h0IGlmIGl0IGV4dGVuZHMgdG9vIGZhciB0byB0aGUgbGVmdCBhcyBpdCBtaWdodCBvdmVybGFwIHRoZSB5LWF4aXMgemVyb1xuICAgIGxldCB0aWNrID0gYXhpcy5zZWxlY3QoXCJnLnRpY2tcIilcbiAgICBpZiAodGljay5lbXB0eSgpKSByZXR1cm5cbiAgICBsZXQgdCA9IHRpY2suYXR0cihcInRyYW5zZm9ybVwiKSAgLy8gZS5nLiB0cmFuc2xhdGUoOC4zMjc1ODYyMDY4OTY1NTIsMClcbiAgICBsZXQgaSA9IHQuaW5kZXhPZignKCcpXG4gICAgbGV0IGogPSB0LmluZGV4T2YoJywnLCBpICsgMSlcbiAgICBsZXQgeCA9IHBhcnNlRmxvYXQodC5zdWJzdHJpbmcoaSArIDEsIGopKVxuICAgIGxldCB0ZXh0ID0gdGljay5zZWxlY3QoXCJ0ZXh0XCIpXG4gICAgeCAtPSB0ZXh0Lm5vZGUoKS5nZXRDb21wdXRlZFRleHRMZW5ndGgoKSAvIDJcbiAgICBpZiAoeCA8IC04KSB0ZXh0LmF0dHIoXCJ4XCIsIE1hdGguYWJzKHggKyA2KSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHhheGlzKHNlbGVjdGlvbiwgaGVpZ2h0LCB3aWR0aCwgYXhpc09iamVjdCwgaW1wb3J0YW5jZSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBlbnN1cmVPcHRpb25zKG9wdGlvbnMpXG4gICAgbGV0IHsgZm9udFNpemUsIGdyaWRMaW5lT3BhY2l0eSB9ID0gb3B0aW9uc1xuXG4gICAgc2VsZWN0aW9uLnNlbGVjdChcIi54LWF4aXNcIikucmVtb3ZlKCk7XG4gICAgbGV0IGF4aXMgPSBzZWxlY3Rpb24uYXBwZW5kKFwiZ1wiKS5hdHRyKFwiY2xhc3NcIiwgXCJ4LWF4aXNcIikuc3R5bGUoXCJvcGFjaXR5XCIsIDApLmNhbGwoYXhpc09iamVjdClcblxuICAgIGF4aXMuc2VsZWN0KFwiLmRvbWFpblwiKS5yZW1vdmUoKTtcblxuICAgIGNvbnN0IHJlZ3VsYXJUZXh0ID0gZDMuaGNsKGNvbG91cnMuZWlnaHRlZW4uZGFya0dyZXkpLmJyaWdodGVyKCk7XG5cbiAgICBsZXQgdGV4dCA9IGF4aXMuc2VsZWN0QWxsKFwidGV4dFwiKVxuICAgIHRleHQuc3R5bGUoXCJmb250LXNpemVcIiwgZm9udFNpemUgKyBcInB4XCIpXG4gICAgICAgIC5zdHlsZShcImZpbGxcIiwgcmVndWxhclRleHQpXG5cbiAgICBsZXQgdHYgPSBheGlzT2JqZWN0LnRpY2tWYWx1ZXMoKVxuICAgIGlmICh0dikgd2lkdGggKj0gYXhpc09iamVjdC5zY2FsZSgpLmRvbWFpbigpLmxlbmd0aCAvICh0di5sZW5ndGggKyAxKVxuXG4gICAgbGV0IGxhYmVsV2lkdGggPSBnZXRNYXhXaWR0aCh0ZXh0KSArIDRcbiAgICBpZiAobGFiZWxXaWR0aCA+IHdpZHRoKSB7XG4gICAgICAgIGlmIChvcHRpb25zLnhMYWJlbEFuZ2xlICE9PSAwKSB7XG4gICAgICAgICAgICBjb25zdCBiYWQgPSBsYWJlbFdpZHRoID49IHdpZHRoICogMjtcbiAgICAgICAgICAgIGNvbnN0IGFuZ2xlID0gYmFkID8gLTkwIDogLTMwO1xuICAgICAgICAgICAgY29uc3QgeCA9IGJhZCA/IC0oZm9udFNpemUgKiAwLjc4KSA6IDA7XG4gICAgICAgICAgICBjb25zdCB5ID0gYmFkID8gNSA6IDI7XG5cbiAgICAgICAgICAgIHRleHQuc3R5bGUoJ3RleHQtYW5jaG9yJywgJ2VuZCcpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgKCkgPT4gXCJ0cmFuc2xhdGUoXCIgKyB4ICsgXCIsXCIgKyB5ICsgXCIpIHJvdGF0ZShcIiArIGFuZ2xlICsgXCIgMCwwKVwiKVxuXG4gICAgICAgICAgICBsYWJlbFdpZHRoID0gZm9udFNpemUgKiAxLjIgIC8vIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBkb2Vzbid0IHNlZW0gdG8gY29uc2lkZXIgdGhlIHJvdGF0aW9uP1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWRqdXN0Rmlyc3RYVGlja0xhYmVsKGF4aXMpXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhYmVsV2lkdGggPiB3aWR0aCkgcmVtb3ZlT3ZlcmxhcHBpbmdYVGlja3MoYXhpcywgbGFiZWxXaWR0aClcbiAgICB9IGVsc2Uge1xuICAgICAgICBhZGp1c3RGaXJzdFhUaWNrTGFiZWwoYXhpcylcbiAgICAgICAgaWYgKHR2KSByZW1vdmVPdmVybGFwcGluZ1hUaWNrcyhheGlzLCBsYWJlbFdpZHRoKSAvLyB0aWNrcyBtaWdodCBub3QgYmUgZXZlbmx5IHNwYWNlZFxuICAgIH1cblxuICAgIGF4aXMuc2VsZWN0QWxsKFwibGluZVwiKS5zdHlsZShcIm9wYWNpdHlcIiwgZ3JpZExpbmVPcGFjaXR5KVxuXG4gICAgbGV0IHRpY2tTaXplID0gYXhpc09iamVjdC50aWNrU2l6ZSgpO1xuICAgIGlmICh0aWNrU2l6ZSAmJiBvcHRpb25zLmF4aXNCb3gpIHtcbiAgICAgICAgbGV0IHggPSBheGlzT2JqZWN0LnNjYWxlKCkucmFuZ2UoKVsxXVxuICAgICAgICBheGlzLmFwcGVuZChcImxpbmVcIikuYXR0cihcIngxXCIsIHgpLmF0dHIoXCJ4MlwiLCB4KS5hdHRyKFwieTJcIiwgdGlja1NpemUpXG4gICAgICAgICAgICAuYXR0cihcIm9wYWNpdHlcIiwgZ3JpZExpbmVPcGFjaXR5KS5hdHRyKFwic3Ryb2tlXCIsIFwiY3VycmVudENvbG9yXCIpXG4gICAgfVxuXG4gICAgYXhpcy50cmFuc2l0aW9uKCkuZHVyYXRpb24oQVhJU19BTklNQVRJT05fRFVSQVRJT04pLmRlbGF5KEFYSVNfREVMQVkpLnN0eWxlKFwib3BhY2l0eVwiLCAxKVxuXG4gICAgcmV0dXJuIGF4aXMubm9kZSgpLmdldEJCb3goKS5oZWlnaHQ7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZU92ZXJsYXBwaW5nWVRpY2tzKGF4aXMsIGxhYmVsSGVpZ2h0KSB7XG4gICAgbGV0IGEgPSBheGlzLnNlbGVjdEFsbChcImcudGlja1wiKS5ub2RlcygpXG4gICAgaWYgKCFhLmxlbmd0aCkgcmV0dXJuXG4gICAgbGV0IHB5ID0gYVswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS55IC0gbGFiZWxIZWlnaHRcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IG5vZGUgPSBhW2ldXG4gICAgICAgIGxldCB5ID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS55XG4gICAgICAgIGlmICh5ID4gcHkpIG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKVxuICAgICAgICBlbHNlIHB5ID0geSAtIGxhYmVsSGVpZ2h0IC8vIHRoZXJlIGlzIHNwYWNlIGZvciB0aGUgbGFiZWxcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB5YXhpcyhzZWxlY3Rpb24sIGF4aXMsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gZW5zdXJlT3B0aW9ucyhvcHRpb25zKVxuICAgIGxldCB7IGZvbnRTaXplLCBncmlkTGluZU9wYWNpdHkgfSA9IGVuc3VyZU9wdGlvbnMob3B0aW9ucylcblxuICAgIHNlbGVjdGlvbi5zZWxlY3QoXCIueS1heGlzXCIpLnJlbW92ZSgpO1xuICAgIGxldCB5ID0gc2VsZWN0aW9uLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJ5LWF4aXNcIilcbiAgICAgICAgICAgICAgICAgICAgIC5jYWxsKGF4aXMpXG4gICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDApXG4gICAgeS5zZWxlY3QoXCIuZG9tYWluXCIpLnJlbW92ZSgpIC8vIHRoaXMgZG91YmxlcyB1cCBvbiB0aGUgMCB0aWNrIGxpbmUgbWFraW5nIGl0IGRhcmtlciBzbyBudWtlIGl0XG5cbiAgICBpZiAob3B0aW9ucy5heGlzQm94KSB5LmFwcGVuZChcImxpbmVcIikuYXR0cihcInkyXCIsIGF4aXMuc2NhbGUoKS5yYW5nZSgpWzBdKS5hdHRyKFwic3Ryb2tlXCIsIFwiY3VycmVudENvbG9yXCIpXG5cbiAgICBsZXQgdGlja1NpemUgPSBheGlzLnRpY2tTaXplKClcbiAgICBpZiAodGlja1NpemUgJiYgb3B0aW9ucy5heGlzQm94KSB5LmFwcGVuZChcImxpbmVcIikuYXR0cihcIngyXCIsIC10aWNrU2l6ZSkuYXR0cihcInN0cm9rZVwiLCBcImN1cnJlbnRDb2xvclwiKVxuXG4gICAgeS5zZWxlY3RBbGwoXCJ0ZXh0XCIpLnN0eWxlKFwiZm9udC1zaXplXCIsIGZvbnRTaXplICsgXCJweFwiKS5zdHlsZShcImZpbGxcIiwgZDMuaGNsKGNvbG91cnMuZWlnaHRlZW4uZGFya0dyZXkpLmJyaWdodGVyKCkpO1xuICAgIHkuc2VsZWN0QWxsKFwicGF0aFwiKS5zdHlsZShcIm9wYWNpdHlcIiwgZ3JpZExpbmVPcGFjaXR5KVxuICAgIHkuc2VsZWN0QWxsKFwibGluZVwiKS5zdHlsZShcIm9wYWNpdHlcIiwgZ3JpZExpbmVPcGFjaXR5KVxuXG4gICAgaWYgKCFheGlzLnNjYWxlKCkuYmFuZHdpZHRoKSByZW1vdmVPdmVybGFwcGluZ1lUaWNrcyh5LCBmb250U2l6ZSAqIDEuMilcblxuICAgIHkudHJhbnNpdGlvbigpXG4gICAgICAgIC5kdXJhdGlvbihBWElTX0FOSU1BVElPTl9EVVJBVElPTilcbiAgICAgICAgLmRlbGF5KEFYSVNfREVMQVkpXG4gICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMSk7XG5cbiAgICByZXR1cm4geS5ub2RlKCkuZ2V0QkJveCgpLndpZHRoICsgMjA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB5R3JpZChzZWxlY3Rpb24sIHdpZHRoLCBzaG93LCBheGlzKSB7XG4gICAgc2VsZWN0aW9uLnNlbGVjdChcIi55R3JpZFwiKS5yZW1vdmUoKTtcblxuICAgIGlmICghc2hvdykgcmV0dXJuO1xuXG4gICAgbGV0IGdyaWQgPSBzZWxlY3Rpb24uYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcInlHcmlkXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAuY2FsbChheGlzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRpY2tTaXplKC13aWR0aClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGlja0Zvcm1hdChcIlwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgIGdyaWQuc2VsZWN0QWxsKFwibGluZVwiKVxuICAgICAgICAuc3R5bGUoXCJzdHJva2VcIiwgY29sb3Vycy5laWdodGVlbi5saWdodEdyZXkpO1xuICAgIGdyaWQuc2VsZWN0QWxsKFwiLmRvbWFpblwiKS5yZW1vdmUoKTtcblxuICAgIGdyaWRcbiAgICAgICAgLmxvd2VyKCkgLy8gQWx3YXlzIGVuc3VyZSB0aGF0IHRoaXMgaXMgZWFybGllciBpbiB0aGUgZG9tLiBUaGluZ3MgbXVzdCBiZSBkcmF3biBvbiB0b3Agb2YgaXQuXG4gICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMClcbiAgICAgICAgLnRyYW5zaXRpb24oKVxuICAgICAgICAuZGVsYXkoQVhJU19ERUxBWSlcbiAgICAgICAgLmR1cmF0aW9uKEFYSVNfQU5JTUFUSU9OX0RVUkFUSU9OKVxuICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDEpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24geEdyaWQoc2VsZWN0aW9uLCBoZWlnaHQsIHNob3csIGF4aXMpIHtcbiAgICBzZWxlY3Rpb24uc2VsZWN0KFwiLnhHcmlkXCIpLnJlbW92ZSgpO1xuXG4gICAgaWYgKCFzaG93KSByZXR1cm47XG5cbiAgICBsZXQgZ3JpZCA9IHNlbGVjdGlvbi5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwieEdyaWRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jYWxsKGF4aXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGlja1NpemUoaGVpZ2h0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aWNrRm9ybWF0KFwiXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgZ3JpZC5zZWxlY3RBbGwoXCJsaW5lXCIpXG4gICAgICAgIC5zdHlsZShcInN0cm9rZVwiLCBjb2xvdXJzLmVpZ2h0ZWVuLmxpZ2h0R3JleSk7XG4gICAgZ3JpZC5zZWxlY3RBbGwoXCIuZG9tYWluXCIpLnJlbW92ZSgpO1xuXG4gICAgZ3JpZFxuICAgICAgICAubG93ZXIoKVxuICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDApXG4gICAgICAgIC50cmFuc2l0aW9uKClcbiAgICAgICAgLmRlbGF5KEFYSVNfREVMQVkpXG4gICAgICAgIC5kdXJhdGlvbihBWElTX0FOSU1BVElPTl9EVVJBVElPTilcbiAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAxKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHlBeGlzTGFiZWwoZWxlbWVudCwgaGVpZ2h0LCBtYXJnaW5zLCBsYWJlbCwgb3B0aW9ucykge1xuICAgIGxldCB7IGZvbnRTaXplIH0gPSBlbnN1cmVPcHRpb25zKG9wdGlvbnMpXG5cbiAgICBlbGVtZW50LnNlbGVjdEFsbChcIi55LWF4aXMtbGFiZWxcIikucmVtb3ZlKCk7XG5cbiAgICBpZiAoIWxhYmVsKSByZXR1cm47XG4gICAgbGV0IHRleHQgPSBsYWJlbDtcbiAgICBpZiAodGV4dC5sb25nKSB0ZXh0ID0gdGV4dC5sb25nO1xuXG4gICAgbGV0IHggPSAtKG1hcmdpbnMudG9wICsgaGVpZ2h0IC8gMik7XG5cbiAgICBsZXQgbGFiZWxFbGVtZW50ID0gZWxlbWVudC5hcHBlbmQoXCJnXCIpXG4gICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJ5LWF4aXMtbGFiZWxcIilcbiAgICAgICAgLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgLnN0eWxlKFwiZm9udC1zaXplXCIsIGZvbnRTaXplICsgXCJweFwiKVxuICAgICAgICAudGV4dCh0ZXh0KVxuICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInJvdGF0ZSgtOTAgMCwwKSB0cmFuc2xhdGUoXCIgKyB4ICsgXCIsIDIwKVwiKVxuICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIGQzLmhjbChjb2xvdXJzLmVpZ2h0ZWVuLmRhcmtHcmV5KS5icmlnaHRlcigpKTtcblxuICAgIGxldCB3aWR0aCA9IGxhYmVsRWxlbWVudC5ub2RlKCkuZ2V0QkJveCgpLndpZHRoO1xuICAgIGlmICh3aWR0aCA+PSBoZWlnaHQgJiYgbGFiZWwuc2hvcnQpIHtcbiAgICAgICAgbGFiZWxFbGVtZW50LnRleHQobGFiZWwuc2hvcnQpO1xuICAgICAgICB3aWR0aCA9IGxhYmVsRWxlbWVudC5ub2RlKCkuZ2V0QkJveCgpLndpZHRoO1xuICAgIH1cblxuICAgIGxhYmVsRWxlbWVudC5hdHRyKFwiZHhcIiwgLXdpZHRoIC8gMilcbiAgICAgICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDApXG4gICAgICAgICAgICAgICAgLnRyYW5zaXRpb24oKVxuICAgICAgICAgICAgICAgIC5kZWxheShBWElTX0RFTEFZKVxuICAgICAgICAgICAgICAgIC5kdXJhdGlvbihBWElTX0FOSU1BVElPTl9EVVJBVElPTilcbiAgICAgICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDEpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB4QXhpc0xhYmVsKGVsZW1lbnQsIHdpZHRoLCBoZWlnaHQsIG1hcmdpbnMsIGxhYmVsLCBvcHRpb25zKSB7XG4gICAgbGV0IHsgZm9udFNpemUgfSA9IGVuc3VyZU9wdGlvbnMob3B0aW9ucylcblxuICAgIGVsZW1lbnQuc2VsZWN0QWxsKFwiLngtYXhpcy1sYWJlbFwiKS5yZW1vdmUoKTtcblxuICAgIGlmICghbGFiZWwpIHJldHVybjtcbiAgICBsZXQgdGV4dCA9IGxhYmVsO1xuICAgIGlmICh0ZXh0LmxvbmcpIHRleHQgPSB0ZXh0Lmxvbmc7XG5cbiAgICBsZXQgeCA9IG1hcmdpbnMubGVmdCArIHdpZHRoIC8gMjtcbiAgICBsZXQgeSA9IG1hcmdpbnMudG9wICsgaGVpZ2h0ICsgNDA7XG5cbiAgICBsZXQgbGFiZWxFbGVtZW50ID0gZWxlbWVudC5hcHBlbmQoXCJnXCIpXG4gICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJ4LWF4aXMtbGFiZWxcIilcbiAgICAgICAgLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgLnN0eWxlKFwiZm9udC1zaXplXCIsIGZvbnRTaXplICsgXCJweFwiKVxuICAgICAgICAudGV4dCh0ZXh0KVxuICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIHggKyBcIiwgXCIgKyB5ICsgXCIpXCIpXG4gICAgICAgIC5zdHlsZShcImZpbGxcIiwgZDMuaGNsKGNvbG91cnMuZWlnaHRlZW4uZGFya0dyZXkpLmJyaWdodGVyKCkpO1xuXG4gICAgbGV0IHRleHRXaWR0aCA9IGxhYmVsRWxlbWVudC5ub2RlKCkuZ2V0QkJveCgpLndpZHRoO1xuICAgIGlmICh0ZXh0V2lkdGggPj0gaGVpZ2h0ICYmIGxhYmVsLnNob3J0KSB7XG4gICAgICAgIGxhYmVsRWxlbWVudC50ZXh0KGxhYmVsLnNob3J0KTtcbiAgICAgICAgdGV4dFdpZHRoID0gbGFiZWxFbGVtZW50Lm5vZGUoKS5nZXRCQm94KCkud2lkdGg7XG4gICAgfVxuXG4gICAgbGFiZWxFbGVtZW50LmF0dHIoXCJkeFwiLCAtdGV4dFdpZHRoIC8gMilcbiAgICAgICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDApXG4gICAgICAgICAgICAgICAgLnRyYW5zaXRpb24oKVxuICAgICAgICAgICAgICAgIC5kZWxheShBWElTX0RFTEFZKVxuICAgICAgICAgICAgICAgIC5kdXJhdGlvbihBWElTX0FOSU1BVElPTl9EVVJBVElPTilcbiAgICAgICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDEpXG59Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/chart/Axes.js\n')},"./src/chart/BarChart.js":
/*!*******************************!*\
  !*** ./src/chart/BarChart.js ***!
  \*******************************/
/*! exports provided: barChart */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "barChart", function() { return barChart; });\n/* harmony import */ var _Geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Geometry */ "./src/chart/Geometry.js");\n/* harmony import */ var _Colours__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Colours */ "./src/Colours.js");\n/* harmony import */ var _Legend__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Legend */ "./src/Legend.js");\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../helpers */ "./src/helpers.js");\n// Copyright (C) 2013-2014, 2018 BrandsEye (PTY) LTD\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this\n// software and associated documentation files (the "Software"), to deal in the Software\n// without restriction, including without limitation the rights to use, copy, modify,\n//     merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following\n// conditions:\n//\n//     The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n//     INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n// CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n\n\n\n\nclass BarHistogram extends _Geometry__WEBPACK_IMPORTED_MODULE_0__["Geometry"] {\n\n    constructor(name, padding) {\n        super(name || "BAR_HISTOGRAM");\n        this._BAR_GROWTH = 100;\n        this._padding = padding || 0;\n    }\n\n    /**\n     * Set the padding between bar groups. 0 padding is a standard histogram.\n     */\n    padding(padding) {\n        if (arguments.length === 0) return this._padding;\n        this._padding = padding;\n        return this;\n    }\n\n    render() {\n        const element = this._element;\n        const data = this.prepareData(null, true);\n        const allData = this.prepareData(null, false);\n        const width = this._width,\n              height = this._height;\n\n        element.classed("histogram", true);\n\n        const x = this.getD3XScale(allData, width);\n        const y = this.getD3YScale(data, height);\n        const yGroup = this.getD3GroupScale(data, y);\n        const colours = this.d3ColourScale();\n\n        let groups = element.select(".bars").selectAll(\'.group\');\n\n        //----------------------------------------------\n        // Get rid of current labels\n\n        element.select(".chart-labels")\n               .remove();\n\n        //----------------------------------------------\n\n        if (groups.empty()) {\n            groups = element\n                .append("g")\n                .attr("class", "bars")\n                .selectAll(".group");\n        }\n\n        // Ensure that we\'re always using the correct height.\n        element.select(".bars")\n               .attr("transform", "translate(0,0)");\n\n        groups = groups.data(data, d => d._key);\n\n        groups.exit().remove();\n\n        groups.enter()\n              .append("g")\n              .attr("class", "group")\n              .attr("transform", d => "translate(0," + y(d._key) +")")\n              .attr("width", "100%")\n              .attr("height", y.bandwidth())\n              .merge(groups)\n              .interrupt("groups:move")\n              .transition("groups:move")\n              .attr("transform", d => "translate(0," + y(d._key) +")")\n              .attr("height", y.bandwidth())\n              .each((s_d, s_i, nodes) => {\n                  let group = d3.select(nodes[s_i]);\n\n                  let bars = group.selectAll(".bar")\n                                  .data(s_d.data, d => d._y);\n\n                  bars.exit().remove();\n\n                  bars.interrupt("bar:move")     // Animate the bars to their new position.\n                      .transition("bar:move")\n                      .attr("width", d => (Math.abs(x(0) - x(d._x))))\n                      .attr("y", d => yGroup(d._key));\n\n                  bars.enter()\n                      .append("rect")\n                      .attr("y", d => yGroup(d._key))\n                      // .attr("y", d => height - y(Math.min(0, d._y)))\n                      .attr("x", x(0))\n                      .attr("width", 0)\n                      .attr("height", yGroup.bandwidth())\n                      .style("cursor", "pointer")\n                      .style("fill", d => this.getD3Colour(d)) // colours(d._colour))\n                      .style("stroke", d => d3.hcl(this.getD3Colour(d)).darker())\n                      .style("stroke-width", this.strokeWidth())\n                      .on("contextmenu", () => d3.event.preventDefault()) // No right click.\n                      .merge(bars)\n                      .attr("class", d => "bar series series-" + Object(_Legend__WEBPACK_IMPORTED_MODULE_2__["toColourKey"])(d._colour))\n                      .on("click auxclick", (d, i, nodes) => {\n                          this._dispatch.call("elementClick", this, {\n                              e: d3.event,\n                              point: d,\n                              series: d._series,\n                              seriesIndex: s_i,\n                              value: d._y\n                          })\n                      })\n                      .on("mouseover", (d, i, nodes) => { // Darken the bar on mouse over\n                          d3.select(nodes[i])\n                            .interrupt("hover:colour")\n                            .transition("hover:colour")\n                            .duration(400)\n                            .style("fill", d3.hcl(this.getD3Colour(d)).darker());\n                          this._dispatch.call("tooltipShow", this, {\n                              e: d3.event,\n                              point: d,\n                              series: s_d,\n                              seriesIndex: s_i,\n                              value: d._y\n                          })\n                      })\n                      .on("mouseout", (d, i, nodes) => { // bar is regular colour on mouse out.\n                          d3.select(nodes[i])\n                            .interrupt("hover:colour")\n                            .transition("hover:colour")\n                            .duration(400)\n                            .style("fill", d => this.getD3Colour(d));\n                          this._dispatch.call("tooltipHide", this);\n                      })\n                      .interrupt("bar:growth")    // Animate bars growing.\n                      .transition("bar:growth")\n                      .delay(() => this.calcBarGrowth(s_i, nodes.length))\n                      .style("fill", d => this.getD3Colour(d)) //colours(d._colour))\n                      .style("stroke", d => d3.hcl(this.getD3Colour(d)).darker())\n                      .attr("x", d => x(Math.min(0, d._x)))\n                      .attr("height", yGroup.bandwidth())\n                      .attr("width", d => (Math.abs(x(0) - x(d._x))));\n              });\n\n        // Labels loaded after our last bar grows.\n        if (this.showLabels()) {\n            element.transition("bar:growth")\n                   .on("end", (d, i, nodes) => {\n                       if (i < nodes.length - 1) return;\n                       this.renderLabels(element, data, x, yGroup, y, colours);\n                   })\n        }\n    }\n\n    calcBarGrowth(i, max) {\n        if (max < 10) return i * this._BAR_GROWTH / 2;\n        if (max < 35) return i * this._BAR_GROWTH / 4;\n        return 1;\n    }\n\n    prepareData(data, faceted) {\n        data = _Geometry__WEBPACK_IMPORTED_MODULE_0__["Geometry"].prototype.prepareData.call(this, data, faceted);\n\n        const sortOrder = {};\n        this.yValues().forEach((d, i) => {\n            sortOrder[d] = sortOrder[d] || ("" + i);\n        });\n\n        let results = {};\n\n        // We want to calculate what bucket each bit of data belongs to.\n        const buckets = this.scaleY()\n                            .buckets(Object\n                                .values(data)\n                                .map(d => d.data)\n                                .reduce((acc, cur) => acc.concat(cur))\n                                .map(d => d._y));\n\n        // Sort data in to their appropriate buckets. This may be\n        // specific date buckets, or general buckets for continuous data.\n        Object.keys(data).forEach(key => {\n            let values = data[key].data;\n            values.forEach(d => {\n                d._bucket = buckets.bucket(d._y);\n                let bucket = results[d._bucket] || { _key: d._bucket, data: [] };\n                bucket.data.push(d);\n                results[d._bucket] = bucket;\n            })\n        });\n\n        return buckets.consolidateBuckets(Object.values(results))\n                      .sort((lhs, rhs) => {\n                          return sortOrder["" + lhs._key] - sortOrder["" + rhs._key];\n                      });\n    }\n\n    getKeys(data) {\n        if (!data || !data.length) return [];\n\n        let keys = new Set();\n\n        // todo calculate buckets\n        Object.keys(data).forEach(key => {\n            let values = data[key].data;\n            values.forEach(d => keys.add(d._key))\n        });\n\n\n        return [...keys]\n    }\n\n    getD3XScale(data, width) {\n        data = data || this.prepareData(null, false);\n        width = width || this.width();\n\n\n        const max = Math.max(d3.max(data, d => d3.max(d.data, d => d._x)), 0);\n        const min = Math.min(0, d3.min(data, d => d3.min(d.data, d => d._x)));\n        return d3.scaleLinear()\n                 .rangeRound([0, width])\n                 .nice()\n                 .domain([min, max]);\n    }\n\n    getD3YScale(data, height) {\n        data = data || this.prepareData(null, true);\n        height = height || this.height();\n\n        return d3.scaleBand()\n                 .rangeRound([0, height])\n                 .padding((data[0].data.length > 1 ? 0.2 : 0) + this._padding)\n                 .domain(data.map(d => d._key));\n    }\n\n    getD3GroupScale(data, yscale) {\n        return d3.scaleBand()\n                 .padding(0)\n                 .domain(this.getKeys(data))\n                 .rangeRound([0, yscale.bandwidth()]);\n    }\n\n    renderLabels(selection, data, xscale, yGroup, yscale, colourScale, animate) {\n        animate = animate === undefined ? true : animate;\n        selection.selectAll(".chart-labels").remove();\n\n        let labels = selection.append("g")\n                              .attr("class", "chart-labels")\n                              .selectAll(".label-group")\n                              .data(data);\n\n        let maxHeight = 0;    // For calculating the max height of text.\n        let maxWidth = 0;     // For calculating the max width of the text.\n        let fontSize = this._font_size;    // Our initial font size.\n        const buffer = 5;     // Buffer space between words and the top of a bar.\n\n        // Want to figure out if the label is too dark / light for the\n        // bar.\n        const getInvertedColor = d => {\n            let invertedColor = d3.hcl(this.getD3Colour(d));\n            invertedColor.l += Math.min(invertedColor.l + 50, 100);\n            return invertedColor;\n        };\n        const shouldInvert = d => d3.hcl(this.getD3Colour(d)).l < 60;\n        const fillColour = d3.hcl(_Colours__WEBPACK_IMPORTED_MODULE_1__["colours"].eighteen.darkGrey).brighter();\n        const lighterFillColour = d3.hcl(_Colours__WEBPACK_IMPORTED_MODULE_1__["colours"].eighteen.midGrey);\n        const findColour = (d, onBar, labelText) => {\n            return onBar && shouldInvert(d)\n                ? getInvertedColor(d).toString()\n                : (Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["labelIsZero"])(labelText)\n                    ? lighterFillColour\n                    : (onBar ? d3.hcl(fillColour).darker() : fillColour));\n        };\n\n        labels.enter().each((series, s_i, s_nodes) => {\n            // We want to determine which groups may have missing values, and provide them.\n            const requiredGroups = {};\n            yGroup.domain().map(_Geometry__WEBPACK_IMPORTED_MODULE_0__["fromKey"]).forEach(d => {\n                requiredGroups[d._colour] = d;\n            });\n\n            series.data.forEach(d => {\n                delete requiredGroups[d._colour]\n            });\n\n            const missingGroups = Object.values(requiredGroups);\n            missingGroups.forEach(d => {\n                d._x = series._key;\n                d._y = 0;\n            });\n\n            d3.select(s_nodes[s_i])\n              .append("g")\n              .attr("class", "label-group")\n              .attr("transform", d => "translate(0," + yscale(d._key) + ")")\n              .selectAll(".chart-label")\n              .data(series.data.concat(Object.values(missingGroups)))\n              .enter()\n              .each((d, i, nodes) => {\n                  const labelText = this.formatLabel()(d._x, d);\n                  let ypos = yGroup(d._key) + yGroup.bandwidth() / 2;\n                  let xpos = xscale(d._x);\n                  let text = d3.select(nodes[i])\n                        .append("text")\n                        .style("font-size", fontSize + "px")\n                        .text(labelText)\n                        .attr("class", d => "chart-label series series-" + Object(_Legend__WEBPACK_IMPORTED_MODULE_2__["toColourKey"])(d._colour))\n                        .attr("dx", (animate ? -15 : 0))\n                        .style("opacity", 0)\n                        .style("pointer-events", "none");\n\n                  // Set the x position, which is based on width.\n                  const bb = text.node().getBBox();\n                  const height = bb.height;\n                  const width = bb.width;\n\n                  let effectiveBuffer = buffer;\n                  if (xpos + width >= this._width) {\n                      xpos = Math.max(0, xpos - width);\n                      effectiveBuffer = -buffer;\n                  }\n\n                  maxHeight = Math.max(height, maxHeight);\n                  text\n                      .attr("y", ypos + height / 3) // use a third of the height rather than half because it looks better.\n                      .attr("x", xpos)\n                      .style("fill", d => findColour(d, effectiveBuffer < 0, labelText));\n\n                  text\n                      .transition("labels")\n                      .delay(() => animate ? this.calcBarGrowth(s_i, s_nodes.length) : 0) // Delay in lockstep with bar growth.\n                      .attr("dx", effectiveBuffer)\n                      .style("opacity", 1)\n              });\n\n            if (maxWidth > xscale.range()[1]) {\n                selection.selectAll(".chart-labels").remove();\n            }\n        });\n\n\n        // Figure out if we don\'t have enough space to show our labels.\n        // We then want to resize, if possible.\n        if (yGroup.bandwidth() < maxHeight * 1.10) {\n            let scale = maxHeight / yGroup.bandwidth() * 1.10;\n            fontSize = Math.floor(fontSize / scale);\n\n            if (fontSize < 8) {\n                // The labels are too small.\n                labels.enter().selectAll("text").remove();\n            } else {\n                labels.enter()\n                      .merge(labels)\n                      .selectAll("text")\n                      .style("font-size", fontSize + "px")\n                      .each((d, i, nodes) => {\n                          const text = d3.select(nodes[i]);\n                          const width = text.node().getBBox().width;\n\n                          let xpos = xscale(d._x);\n                          let effectiveBuffer = buffer;\n                          if (xpos + width >= this._width) {\n                              xpos = Math.max(0, xpos - width);\n                              effectiveBuffer = -buffer;\n                          }\n\n                          text\n                              .attr("x", xpos)\n                              .style("fill", d => findColour(d, effectiveBuffer < 0, text.text())) // todo\n                              .attr("dx", effectiveBuffer); // todo\n                      })\n            }\n        }\n    }\n\n\n    immediatelyRenderLabels(show) {\n        const element = this.element();\n        if (!element) return;\n\n        if (!show) { // Hides the labels\n            element\n                .select(\'.chart-labels\')\n                .interrupt("labels")\n                .interrupt("labels:fade")\n                .transition("labels:fade")\n                .style("opacity", 0)\n                .on("end", (d, i, nodes) => {\n                    d3.select(nodes[i]).remove();\n                })\n        } else {\n            let labels = element.select(\'.chart-labels\');\n            if (!labels.empty()) return;\n\n            const data = this.prepareData(null, true);\n            const allData = this.prepareData(null, false);\n\n            const yscale = this.getD3YScale(data),\n                  xscale = this.getD3XScale(data),\n                  xgroup = this.getD3GroupScale(data, yscale),\n                  colourScale = this.d3ColourScale();\n\n            labels.remove();\n            this.renderLabels(element, data, xscale, xgroup, yscale, colourScale, false);\n        }\n\n    }\n\n\n}\n\n\nfunction barChart() {\n    return new BarHistogram("BAR_CHART", 0.1);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY2hhcnQvQmFyQ2hhcnQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9iM2pzLy4vc3JjL2NoYXJ0L0JhckNoYXJ0LmpzPzM3MDMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChDKSAyMDEzLTIwMTQsIDIwMTggQnJhbmRzRXllIChQVFkpIExURFxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpc1xuLy8gc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlXG4vLyB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksXG4vLyAgICAgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0b1xuLy8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcbi8vIGNvbmRpdGlvbnM6XG4vL1xuLy8gICAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuLy8gY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyAgICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUiBJTVBMSUVELFxuLy8gICAgIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBXG4vLyBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUXG4vLyBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0Zcbi8vIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRVxuLy8gT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCB7IEdlb21ldHJ5LCBmcm9tS2V5IH0gZnJvbSAnLi9HZW9tZXRyeSc7XG5pbXBvcnQgeyBjb2xvdXJzIH0gZnJvbSBcIi4uL0NvbG91cnNcIjtcbmltcG9ydCB7IHRvQ29sb3VyS2V5IH0gZnJvbSBcIi4uL0xlZ2VuZFwiO1xuaW1wb3J0IHsgbGFiZWxJc1plcm8gfSBmcm9tIFwiLi4vaGVscGVyc1wiO1xuXG5cbmNsYXNzIEJhckhpc3RvZ3JhbSBleHRlbmRzIEdlb21ldHJ5IHtcblxuICAgIGNvbnN0cnVjdG9yKG5hbWUsIHBhZGRpbmcpIHtcbiAgICAgICAgc3VwZXIobmFtZSB8fCBcIkJBUl9ISVNUT0dSQU1cIik7XG4gICAgICAgIHRoaXMuX0JBUl9HUk9XVEggPSAxMDA7XG4gICAgICAgIHRoaXMuX3BhZGRpbmcgPSBwYWRkaW5nIHx8IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBwYWRkaW5nIGJldHdlZW4gYmFyIGdyb3Vwcy4gMCBwYWRkaW5nIGlzIGEgc3RhbmRhcmQgaGlzdG9ncmFtLlxuICAgICAqL1xuICAgIHBhZGRpbmcocGFkZGluZykge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX3BhZGRpbmc7XG4gICAgICAgIHRoaXMuX3BhZGRpbmcgPSBwYWRkaW5nO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLl9lbGVtZW50O1xuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5wcmVwYXJlRGF0YShudWxsLCB0cnVlKTtcbiAgICAgICAgY29uc3QgYWxsRGF0YSA9IHRoaXMucHJlcGFyZURhdGEobnVsbCwgZmFsc2UpO1xuICAgICAgICBjb25zdCB3aWR0aCA9IHRoaXMuX3dpZHRoLFxuICAgICAgICAgICAgICBoZWlnaHQgPSB0aGlzLl9oZWlnaHQ7XG5cbiAgICAgICAgZWxlbWVudC5jbGFzc2VkKFwiaGlzdG9ncmFtXCIsIHRydWUpO1xuXG4gICAgICAgIGNvbnN0IHggPSB0aGlzLmdldEQzWFNjYWxlKGFsbERhdGEsIHdpZHRoKTtcbiAgICAgICAgY29uc3QgeSA9IHRoaXMuZ2V0RDNZU2NhbGUoZGF0YSwgaGVpZ2h0KTtcbiAgICAgICAgY29uc3QgeUdyb3VwID0gdGhpcy5nZXREM0dyb3VwU2NhbGUoZGF0YSwgeSk7XG4gICAgICAgIGNvbnN0IGNvbG91cnMgPSB0aGlzLmQzQ29sb3VyU2NhbGUoKTtcblxuICAgICAgICBsZXQgZ3JvdXBzID0gZWxlbWVudC5zZWxlY3QoXCIuYmFyc1wiKS5zZWxlY3RBbGwoJy5ncm91cCcpO1xuXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBHZXQgcmlkIG9mIGN1cnJlbnQgbGFiZWxzXG5cbiAgICAgICAgZWxlbWVudC5zZWxlY3QoXCIuY2hhcnQtbGFiZWxzXCIpXG4gICAgICAgICAgICAgICAucmVtb3ZlKCk7XG5cbiAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgaWYgKGdyb3Vwcy5lbXB0eSgpKSB7XG4gICAgICAgICAgICBncm91cHMgPSBlbGVtZW50XG4gICAgICAgICAgICAgICAgLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwiYmFyc1wiKVxuICAgICAgICAgICAgICAgIC5zZWxlY3RBbGwoXCIuZ3JvdXBcIik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBFbnN1cmUgdGhhdCB3ZSdyZSBhbHdheXMgdXNpbmcgdGhlIGNvcnJlY3QgaGVpZ2h0LlxuICAgICAgICBlbGVtZW50LnNlbGVjdChcIi5iYXJzXCIpXG4gICAgICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZSgwLDApXCIpO1xuXG4gICAgICAgIGdyb3VwcyA9IGdyb3Vwcy5kYXRhKGRhdGEsIGQgPT4gZC5fa2V5KTtcblxuICAgICAgICBncm91cHMuZXhpdCgpLnJlbW92ZSgpO1xuXG4gICAgICAgIGdyb3Vwcy5lbnRlcigpXG4gICAgICAgICAgICAgIC5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJncm91cFwiKVxuICAgICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBkID0+IFwidHJhbnNsYXRlKDAsXCIgKyB5KGQuX2tleSkgK1wiKVwiKVxuICAgICAgICAgICAgICAuYXR0cihcIndpZHRoXCIsIFwiMTAwJVwiKVxuICAgICAgICAgICAgICAuYXR0cihcImhlaWdodFwiLCB5LmJhbmR3aWR0aCgpKVxuICAgICAgICAgICAgICAubWVyZ2UoZ3JvdXBzKVxuICAgICAgICAgICAgICAuaW50ZXJydXB0KFwiZ3JvdXBzOm1vdmVcIilcbiAgICAgICAgICAgICAgLnRyYW5zaXRpb24oXCJncm91cHM6bW92ZVwiKVxuICAgICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBkID0+IFwidHJhbnNsYXRlKDAsXCIgKyB5KGQuX2tleSkgK1wiKVwiKVxuICAgICAgICAgICAgICAuYXR0cihcImhlaWdodFwiLCB5LmJhbmR3aWR0aCgpKVxuICAgICAgICAgICAgICAuZWFjaCgoc19kLCBzX2ksIG5vZGVzKSA9PiB7XG4gICAgICAgICAgICAgICAgICBsZXQgZ3JvdXAgPSBkMy5zZWxlY3Qobm9kZXNbc19pXSk7XG5cbiAgICAgICAgICAgICAgICAgIGxldCBiYXJzID0gZ3JvdXAuc2VsZWN0QWxsKFwiLmJhclwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5kYXRhKHNfZC5kYXRhLCBkID0+IGQuX3kpO1xuXG4gICAgICAgICAgICAgICAgICBiYXJzLmV4aXQoKS5yZW1vdmUoKTtcblxuICAgICAgICAgICAgICAgICAgYmFycy5pbnRlcnJ1cHQoXCJiYXI6bW92ZVwiKSAgICAgLy8gQW5pbWF0ZSB0aGUgYmFycyB0byB0aGVpciBuZXcgcG9zaXRpb24uXG4gICAgICAgICAgICAgICAgICAgICAgLnRyYW5zaXRpb24oXCJiYXI6bW92ZVwiKVxuICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwid2lkdGhcIiwgZCA9PiAoTWF0aC5hYnMoeCgwKSAtIHgoZC5feCkpKSlcbiAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcInlcIiwgZCA9PiB5R3JvdXAoZC5fa2V5KSk7XG5cbiAgICAgICAgICAgICAgICAgIGJhcnMuZW50ZXIoKVxuICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoXCJyZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ5XCIsIGQgPT4geUdyb3VwKGQuX2tleSkpXG4gICAgICAgICAgICAgICAgICAgICAgLy8gLmF0dHIoXCJ5XCIsIGQgPT4gaGVpZ2h0IC0geShNYXRoLm1pbigwLCBkLl95KSkpXG4gICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIHgoMCkpXG4gICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCAwKVxuICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIHlHcm91cC5iYW5kd2lkdGgoKSlcbiAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJjdXJzb3JcIiwgXCJwb2ludGVyXCIpXG4gICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBkID0+IHRoaXMuZ2V0RDNDb2xvdXIoZCkpIC8vIGNvbG91cnMoZC5fY29sb3VyKSlcbiAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJzdHJva2VcIiwgZCA9PiBkMy5oY2wodGhpcy5nZXREM0NvbG91cihkKSkuZGFya2VyKCkpXG4gICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwic3Ryb2tlLXdpZHRoXCIsIHRoaXMuc3Ryb2tlV2lkdGgoKSlcbiAgICAgICAgICAgICAgICAgICAgICAub24oXCJjb250ZXh0bWVudVwiLCAoKSA9PiBkMy5ldmVudC5wcmV2ZW50RGVmYXVsdCgpKSAvLyBObyByaWdodCBjbGljay5cbiAgICAgICAgICAgICAgICAgICAgICAubWVyZ2UoYmFycylcbiAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIGQgPT4gXCJiYXIgc2VyaWVzIHNlcmllcy1cIiArIHRvQ29sb3VyS2V5KGQuX2NvbG91cikpXG4gICAgICAgICAgICAgICAgICAgICAgLm9uKFwiY2xpY2sgYXV4Y2xpY2tcIiwgKGQsIGksIG5vZGVzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3BhdGNoLmNhbGwoXCJlbGVtZW50Q2xpY2tcIiwgdGhpcywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZTogZDMuZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludDogZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllczogZC5fc2VyaWVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzSW5kZXg6IHNfaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBkLl95XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAub24oXCJtb3VzZW92ZXJcIiwgKGQsIGksIG5vZGVzKSA9PiB7IC8vIERhcmtlbiB0aGUgYmFyIG9uIG1vdXNlIG92ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZDMuc2VsZWN0KG5vZGVzW2ldKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5pbnRlcnJ1cHQoXCJob3Zlcjpjb2xvdXJcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudHJhbnNpdGlvbihcImhvdmVyOmNvbG91clwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbig0MDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBkMy5oY2wodGhpcy5nZXREM0NvbG91cihkKSkuZGFya2VyKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXNwYXRjaC5jYWxsKFwidG9vbHRpcFNob3dcIiwgdGhpcywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZTogZDMuZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludDogZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllczogc19kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzSW5kZXg6IHNfaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBkLl95XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAub24oXCJtb3VzZW91dFwiLCAoZCwgaSwgbm9kZXMpID0+IHsgLy8gYmFyIGlzIHJlZ3VsYXIgY29sb3VyIG9uIG1vdXNlIG91dC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgZDMuc2VsZWN0KG5vZGVzW2ldKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5pbnRlcnJ1cHQoXCJob3Zlcjpjb2xvdXJcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudHJhbnNpdGlvbihcImhvdmVyOmNvbG91clwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbig0MDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBkID0+IHRoaXMuZ2V0RDNDb2xvdXIoZCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXNwYXRjaC5jYWxsKFwidG9vbHRpcEhpZGVcIiwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAuaW50ZXJydXB0KFwiYmFyOmdyb3d0aFwiKSAgICAvLyBBbmltYXRlIGJhcnMgZ3Jvd2luZy5cbiAgICAgICAgICAgICAgICAgICAgICAudHJhbnNpdGlvbihcImJhcjpncm93dGhcIilcbiAgICAgICAgICAgICAgICAgICAgICAuZGVsYXkoKCkgPT4gdGhpcy5jYWxjQmFyR3Jvd3RoKHNfaSwgbm9kZXMubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIGQgPT4gdGhpcy5nZXREM0NvbG91cihkKSkgLy9jb2xvdXJzKGQuX2NvbG91cikpXG4gICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwic3Ryb2tlXCIsIGQgPT4gZDMuaGNsKHRoaXMuZ2V0RDNDb2xvdXIoZCkpLmRhcmtlcigpKVxuICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwieFwiLCBkID0+IHgoTWF0aC5taW4oMCwgZC5feCkpKVxuICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIHlHcm91cC5iYW5kd2lkdGgoKSlcbiAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcIndpZHRoXCIsIGQgPT4gKE1hdGguYWJzKHgoMCkgLSB4KGQuX3gpKSkpO1xuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAvLyBMYWJlbHMgbG9hZGVkIGFmdGVyIG91ciBsYXN0IGJhciBncm93cy5cbiAgICAgICAgaWYgKHRoaXMuc2hvd0xhYmVscygpKSB7XG4gICAgICAgICAgICBlbGVtZW50LnRyYW5zaXRpb24oXCJiYXI6Z3Jvd3RoXCIpXG4gICAgICAgICAgICAgICAgICAgLm9uKFwiZW5kXCIsIChkLCBpLCBub2RlcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA8IG5vZGVzLmxlbmd0aCAtIDEpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJMYWJlbHMoZWxlbWVudCwgZGF0YSwgeCwgeUdyb3VwLCB5LCBjb2xvdXJzKTtcbiAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2FsY0Jhckdyb3d0aChpLCBtYXgpIHtcbiAgICAgICAgaWYgKG1heCA8IDEwKSByZXR1cm4gaSAqIHRoaXMuX0JBUl9HUk9XVEggLyAyO1xuICAgICAgICBpZiAobWF4IDwgMzUpIHJldHVybiBpICogdGhpcy5fQkFSX0dST1dUSCAvIDQ7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIHByZXBhcmVEYXRhKGRhdGEsIGZhY2V0ZWQpIHtcbiAgICAgICAgZGF0YSA9IEdlb21ldHJ5LnByb3RvdHlwZS5wcmVwYXJlRGF0YS5jYWxsKHRoaXMsIGRhdGEsIGZhY2V0ZWQpO1xuXG4gICAgICAgIGNvbnN0IHNvcnRPcmRlciA9IHt9O1xuICAgICAgICB0aGlzLnlWYWx1ZXMoKS5mb3JFYWNoKChkLCBpKSA9PiB7XG4gICAgICAgICAgICBzb3J0T3JkZXJbZF0gPSBzb3J0T3JkZXJbZF0gfHwgKFwiXCIgKyBpKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbGV0IHJlc3VsdHMgPSB7fTtcblxuICAgICAgICAvLyBXZSB3YW50IHRvIGNhbGN1bGF0ZSB3aGF0IGJ1Y2tldCBlYWNoIGJpdCBvZiBkYXRhIGJlbG9uZ3MgdG8uXG4gICAgICAgIGNvbnN0IGJ1Y2tldHMgPSB0aGlzLnNjYWxlWSgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmJ1Y2tldHMoT2JqZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC52YWx1ZXMoZGF0YSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChkID0+IGQuZGF0YSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlZHVjZSgoYWNjLCBjdXIpID0+IGFjYy5jb25jYXQoY3VyKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChkID0+IGQuX3kpKTtcblxuICAgICAgICAvLyBTb3J0IGRhdGEgaW4gdG8gdGhlaXIgYXBwcm9wcmlhdGUgYnVja2V0cy4gVGhpcyBtYXkgYmVcbiAgICAgICAgLy8gc3BlY2lmaWMgZGF0ZSBidWNrZXRzLCBvciBnZW5lcmFsIGJ1Y2tldHMgZm9yIGNvbnRpbnVvdXMgZGF0YS5cbiAgICAgICAgT2JqZWN0LmtleXMoZGF0YSkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgbGV0IHZhbHVlcyA9IGRhdGFba2V5XS5kYXRhO1xuICAgICAgICAgICAgdmFsdWVzLmZvckVhY2goZCA9PiB7XG4gICAgICAgICAgICAgICAgZC5fYnVja2V0ID0gYnVja2V0cy5idWNrZXQoZC5feSk7XG4gICAgICAgICAgICAgICAgbGV0IGJ1Y2tldCA9IHJlc3VsdHNbZC5fYnVja2V0XSB8fCB7IF9rZXk6IGQuX2J1Y2tldCwgZGF0YTogW10gfTtcbiAgICAgICAgICAgICAgICBidWNrZXQuZGF0YS5wdXNoKGQpO1xuICAgICAgICAgICAgICAgIHJlc3VsdHNbZC5fYnVja2V0XSA9IGJ1Y2tldDtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBidWNrZXRzLmNvbnNvbGlkYXRlQnVja2V0cyhPYmplY3QudmFsdWVzKHJlc3VsdHMpKVxuICAgICAgICAgICAgICAgICAgICAgIC5zb3J0KChsaHMsIHJocykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc29ydE9yZGVyW1wiXCIgKyBsaHMuX2tleV0gLSBzb3J0T3JkZXJbXCJcIiArIHJocy5fa2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBnZXRLZXlzKGRhdGEpIHtcbiAgICAgICAgaWYgKCFkYXRhIHx8ICFkYXRhLmxlbmd0aCkgcmV0dXJuIFtdO1xuXG4gICAgICAgIGxldCBrZXlzID0gbmV3IFNldCgpO1xuXG4gICAgICAgIC8vIHRvZG8gY2FsY3VsYXRlIGJ1Y2tldHNcbiAgICAgICAgT2JqZWN0LmtleXMoZGF0YSkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgbGV0IHZhbHVlcyA9IGRhdGFba2V5XS5kYXRhO1xuICAgICAgICAgICAgdmFsdWVzLmZvckVhY2goZCA9PiBrZXlzLmFkZChkLl9rZXkpKVxuICAgICAgICB9KTtcblxuXG4gICAgICAgIHJldHVybiBbLi4ua2V5c11cbiAgICB9XG5cbiAgICBnZXREM1hTY2FsZShkYXRhLCB3aWR0aCkge1xuICAgICAgICBkYXRhID0gZGF0YSB8fCB0aGlzLnByZXBhcmVEYXRhKG51bGwsIGZhbHNlKTtcbiAgICAgICAgd2lkdGggPSB3aWR0aCB8fCB0aGlzLndpZHRoKCk7XG5cblxuICAgICAgICBjb25zdCBtYXggPSBNYXRoLm1heChkMy5tYXgoZGF0YSwgZCA9PiBkMy5tYXgoZC5kYXRhLCBkID0+IGQuX3gpKSwgMCk7XG4gICAgICAgIGNvbnN0IG1pbiA9IE1hdGgubWluKDAsIGQzLm1pbihkYXRhLCBkID0+IGQzLm1pbihkLmRhdGEsIGQgPT4gZC5feCkpKTtcbiAgICAgICAgcmV0dXJuIGQzLnNjYWxlTGluZWFyKClcbiAgICAgICAgICAgICAgICAgLnJhbmdlUm91bmQoWzAsIHdpZHRoXSlcbiAgICAgICAgICAgICAgICAgLm5pY2UoKVxuICAgICAgICAgICAgICAgICAuZG9tYWluKFttaW4sIG1heF0pO1xuICAgIH1cblxuICAgIGdldEQzWVNjYWxlKGRhdGEsIGhlaWdodCkge1xuICAgICAgICBkYXRhID0gZGF0YSB8fCB0aGlzLnByZXBhcmVEYXRhKG51bGwsIHRydWUpO1xuICAgICAgICBoZWlnaHQgPSBoZWlnaHQgfHwgdGhpcy5oZWlnaHQoKTtcblxuICAgICAgICByZXR1cm4gZDMuc2NhbGVCYW5kKClcbiAgICAgICAgICAgICAgICAgLnJhbmdlUm91bmQoWzAsIGhlaWdodF0pXG4gICAgICAgICAgICAgICAgIC5wYWRkaW5nKChkYXRhWzBdLmRhdGEubGVuZ3RoID4gMSA/IDAuMiA6IDApICsgdGhpcy5fcGFkZGluZylcbiAgICAgICAgICAgICAgICAgLmRvbWFpbihkYXRhLm1hcChkID0+IGQuX2tleSkpO1xuICAgIH1cblxuICAgIGdldEQzR3JvdXBTY2FsZShkYXRhLCB5c2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGQzLnNjYWxlQmFuZCgpXG4gICAgICAgICAgICAgICAgIC5wYWRkaW5nKDApXG4gICAgICAgICAgICAgICAgIC5kb21haW4odGhpcy5nZXRLZXlzKGRhdGEpKVxuICAgICAgICAgICAgICAgICAucmFuZ2VSb3VuZChbMCwgeXNjYWxlLmJhbmR3aWR0aCgpXSk7XG4gICAgfVxuXG4gICAgcmVuZGVyTGFiZWxzKHNlbGVjdGlvbiwgZGF0YSwgeHNjYWxlLCB5R3JvdXAsIHlzY2FsZSwgY29sb3VyU2NhbGUsIGFuaW1hdGUpIHtcbiAgICAgICAgYW5pbWF0ZSA9IGFuaW1hdGUgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBhbmltYXRlO1xuICAgICAgICBzZWxlY3Rpb24uc2VsZWN0QWxsKFwiLmNoYXJ0LWxhYmVsc1wiKS5yZW1vdmUoKTtcblxuICAgICAgICBsZXQgbGFiZWxzID0gc2VsZWN0aW9uLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJjaGFydC1sYWJlbHNcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zZWxlY3RBbGwoXCIubGFiZWwtZ3JvdXBcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5kYXRhKGRhdGEpO1xuXG4gICAgICAgIGxldCBtYXhIZWlnaHQgPSAwOyAgICAvLyBGb3IgY2FsY3VsYXRpbmcgdGhlIG1heCBoZWlnaHQgb2YgdGV4dC5cbiAgICAgICAgbGV0IG1heFdpZHRoID0gMDsgICAgIC8vIEZvciBjYWxjdWxhdGluZyB0aGUgbWF4IHdpZHRoIG9mIHRoZSB0ZXh0LlxuICAgICAgICBsZXQgZm9udFNpemUgPSB0aGlzLl9mb250X3NpemU7ICAgIC8vIE91ciBpbml0aWFsIGZvbnQgc2l6ZS5cbiAgICAgICAgY29uc3QgYnVmZmVyID0gNTsgICAgIC8vIEJ1ZmZlciBzcGFjZSBiZXR3ZWVuIHdvcmRzIGFuZCB0aGUgdG9wIG9mIGEgYmFyLlxuXG4gICAgICAgIC8vIFdhbnQgdG8gZmlndXJlIG91dCBpZiB0aGUgbGFiZWwgaXMgdG9vIGRhcmsgLyBsaWdodCBmb3IgdGhlXG4gICAgICAgIC8vIGJhci5cbiAgICAgICAgY29uc3QgZ2V0SW52ZXJ0ZWRDb2xvciA9IGQgPT4ge1xuICAgICAgICAgICAgbGV0IGludmVydGVkQ29sb3IgPSBkMy5oY2wodGhpcy5nZXREM0NvbG91cihkKSk7XG4gICAgICAgICAgICBpbnZlcnRlZENvbG9yLmwgKz0gTWF0aC5taW4oaW52ZXJ0ZWRDb2xvci5sICsgNTAsIDEwMCk7XG4gICAgICAgICAgICByZXR1cm4gaW52ZXJ0ZWRDb2xvcjtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgc2hvdWxkSW52ZXJ0ID0gZCA9PiBkMy5oY2wodGhpcy5nZXREM0NvbG91cihkKSkubCA8IDYwO1xuICAgICAgICBjb25zdCBmaWxsQ29sb3VyID0gZDMuaGNsKGNvbG91cnMuZWlnaHRlZW4uZGFya0dyZXkpLmJyaWdodGVyKCk7XG4gICAgICAgIGNvbnN0IGxpZ2h0ZXJGaWxsQ29sb3VyID0gZDMuaGNsKGNvbG91cnMuZWlnaHRlZW4ubWlkR3JleSk7XG4gICAgICAgIGNvbnN0IGZpbmRDb2xvdXIgPSAoZCwgb25CYXIsIGxhYmVsVGV4dCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG9uQmFyICYmIHNob3VsZEludmVydChkKVxuICAgICAgICAgICAgICAgID8gZ2V0SW52ZXJ0ZWRDb2xvcihkKS50b1N0cmluZygpXG4gICAgICAgICAgICAgICAgOiAobGFiZWxJc1plcm8obGFiZWxUZXh0KVxuICAgICAgICAgICAgICAgICAgICA/IGxpZ2h0ZXJGaWxsQ29sb3VyXG4gICAgICAgICAgICAgICAgICAgIDogKG9uQmFyID8gZDMuaGNsKGZpbGxDb2xvdXIpLmRhcmtlcigpIDogZmlsbENvbG91cikpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGxhYmVscy5lbnRlcigpLmVhY2goKHNlcmllcywgc19pLCBzX25vZGVzKSA9PiB7XG4gICAgICAgICAgICAvLyBXZSB3YW50IHRvIGRldGVybWluZSB3aGljaCBncm91cHMgbWF5IGhhdmUgbWlzc2luZyB2YWx1ZXMsIGFuZCBwcm92aWRlIHRoZW0uXG4gICAgICAgICAgICBjb25zdCByZXF1aXJlZEdyb3VwcyA9IHt9O1xuICAgICAgICAgICAgeUdyb3VwLmRvbWFpbigpLm1hcChmcm9tS2V5KS5mb3JFYWNoKGQgPT4ge1xuICAgICAgICAgICAgICAgIHJlcXVpcmVkR3JvdXBzW2QuX2NvbG91cl0gPSBkO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHNlcmllcy5kYXRhLmZvckVhY2goZCA9PiB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHJlcXVpcmVkR3JvdXBzW2QuX2NvbG91cl1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjb25zdCBtaXNzaW5nR3JvdXBzID0gT2JqZWN0LnZhbHVlcyhyZXF1aXJlZEdyb3Vwcyk7XG4gICAgICAgICAgICBtaXNzaW5nR3JvdXBzLmZvckVhY2goZCA9PiB7XG4gICAgICAgICAgICAgICAgZC5feCA9IHNlcmllcy5fa2V5O1xuICAgICAgICAgICAgICAgIGQuX3kgPSAwO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGQzLnNlbGVjdChzX25vZGVzW3NfaV0pXG4gICAgICAgICAgICAgIC5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJsYWJlbC1ncm91cFwiKVxuICAgICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBkID0+IFwidHJhbnNsYXRlKDAsXCIgKyB5c2NhbGUoZC5fa2V5KSArIFwiKVwiKVxuICAgICAgICAgICAgICAuc2VsZWN0QWxsKFwiLmNoYXJ0LWxhYmVsXCIpXG4gICAgICAgICAgICAgIC5kYXRhKHNlcmllcy5kYXRhLmNvbmNhdChPYmplY3QudmFsdWVzKG1pc3NpbmdHcm91cHMpKSlcbiAgICAgICAgICAgICAgLmVudGVyKClcbiAgICAgICAgICAgICAgLmVhY2goKGQsIGksIG5vZGVzKSA9PiB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBsYWJlbFRleHQgPSB0aGlzLmZvcm1hdExhYmVsKCkoZC5feCwgZCk7XG4gICAgICAgICAgICAgICAgICBsZXQgeXBvcyA9IHlHcm91cChkLl9rZXkpICsgeUdyb3VwLmJhbmR3aWR0aCgpIC8gMjtcbiAgICAgICAgICAgICAgICAgIGxldCB4cG9zID0geHNjYWxlKGQuX3gpO1xuICAgICAgICAgICAgICAgICAgbGV0IHRleHQgPSBkMy5zZWxlY3Qobm9kZXNbaV0pXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwiZm9udC1zaXplXCIsIGZvbnRTaXplICsgXCJweFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRleHQobGFiZWxUZXh0KVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBkID0+IFwiY2hhcnQtbGFiZWwgc2VyaWVzIHNlcmllcy1cIiArIHRvQ29sb3VyS2V5KGQuX2NvbG91cikpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcImR4XCIsIChhbmltYXRlID8gLTE1IDogMCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDApXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJwb2ludGVyLWV2ZW50c1wiLCBcIm5vbmVcIik7XG5cbiAgICAgICAgICAgICAgICAgIC8vIFNldCB0aGUgeCBwb3NpdGlvbiwgd2hpY2ggaXMgYmFzZWQgb24gd2lkdGguXG4gICAgICAgICAgICAgICAgICBjb25zdCBiYiA9IHRleHQubm9kZSgpLmdldEJCb3goKTtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGhlaWdodCA9IGJiLmhlaWdodDtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gYmIud2lkdGg7XG5cbiAgICAgICAgICAgICAgICAgIGxldCBlZmZlY3RpdmVCdWZmZXIgPSBidWZmZXI7XG4gICAgICAgICAgICAgICAgICBpZiAoeHBvcyArIHdpZHRoID49IHRoaXMuX3dpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgeHBvcyA9IE1hdGgubWF4KDAsIHhwb3MgLSB3aWR0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgZWZmZWN0aXZlQnVmZmVyID0gLWJ1ZmZlcjtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgbWF4SGVpZ2h0ID0gTWF0aC5tYXgoaGVpZ2h0LCBtYXhIZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgdGV4dFxuICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwieVwiLCB5cG9zICsgaGVpZ2h0IC8gMykgLy8gdXNlIGEgdGhpcmQgb2YgdGhlIGhlaWdodCByYXRoZXIgdGhhbiBoYWxmIGJlY2F1c2UgaXQgbG9va3MgYmV0dGVyLlxuICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwieFwiLCB4cG9zKVxuICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcImZpbGxcIiwgZCA9PiBmaW5kQ29sb3VyKGQsIGVmZmVjdGl2ZUJ1ZmZlciA8IDAsIGxhYmVsVGV4dCkpO1xuXG4gICAgICAgICAgICAgICAgICB0ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgLnRyYW5zaXRpb24oXCJsYWJlbHNcIilcbiAgICAgICAgICAgICAgICAgICAgICAuZGVsYXkoKCkgPT4gYW5pbWF0ZSA/IHRoaXMuY2FsY0Jhckdyb3d0aChzX2ksIHNfbm9kZXMubGVuZ3RoKSA6IDApIC8vIERlbGF5IGluIGxvY2tzdGVwIHdpdGggYmFyIGdyb3d0aC5cbiAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcImR4XCIsIGVmZmVjdGl2ZUJ1ZmZlcilcbiAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDEpXG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAobWF4V2lkdGggPiB4c2NhbGUucmFuZ2UoKVsxXSkge1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbi5zZWxlY3RBbGwoXCIuY2hhcnQtbGFiZWxzXCIpLnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuXG4gICAgICAgIC8vIEZpZ3VyZSBvdXQgaWYgd2UgZG9uJ3QgaGF2ZSBlbm91Z2ggc3BhY2UgdG8gc2hvdyBvdXIgbGFiZWxzLlxuICAgICAgICAvLyBXZSB0aGVuIHdhbnQgdG8gcmVzaXplLCBpZiBwb3NzaWJsZS5cbiAgICAgICAgaWYgKHlHcm91cC5iYW5kd2lkdGgoKSA8IG1heEhlaWdodCAqIDEuMTApIHtcbiAgICAgICAgICAgIGxldCBzY2FsZSA9IG1heEhlaWdodCAvIHlHcm91cC5iYW5kd2lkdGgoKSAqIDEuMTA7XG4gICAgICAgICAgICBmb250U2l6ZSA9IE1hdGguZmxvb3IoZm9udFNpemUgLyBzY2FsZSk7XG5cbiAgICAgICAgICAgIGlmIChmb250U2l6ZSA8IDgpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgbGFiZWxzIGFyZSB0b28gc21hbGwuXG4gICAgICAgICAgICAgICAgbGFiZWxzLmVudGVyKCkuc2VsZWN0QWxsKFwidGV4dFwiKS5yZW1vdmUoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGFiZWxzLmVudGVyKClcbiAgICAgICAgICAgICAgICAgICAgICAubWVyZ2UobGFiZWxzKVxuICAgICAgICAgICAgICAgICAgICAgIC5zZWxlY3RBbGwoXCJ0ZXh0XCIpXG4gICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwiZm9udC1zaXplXCIsIGZvbnRTaXplICsgXCJweFwiKVxuICAgICAgICAgICAgICAgICAgICAgIC5lYWNoKChkLCBpLCBub2RlcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXh0ID0gZDMuc2VsZWN0KG5vZGVzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgd2lkdGggPSB0ZXh0Lm5vZGUoKS5nZXRCQm94KCkud2lkdGg7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHhwb3MgPSB4c2NhbGUoZC5feCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBlZmZlY3RpdmVCdWZmZXIgPSBidWZmZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh4cG9zICsgd2lkdGggPj0gdGhpcy5fd2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhwb3MgPSBNYXRoLm1heCgwLCB4cG9zIC0gd2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWZmZWN0aXZlQnVmZmVyID0gLWJ1ZmZlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwieFwiLCB4cG9zKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBkID0+IGZpbmRDb2xvdXIoZCwgZWZmZWN0aXZlQnVmZmVyIDwgMCwgdGV4dC50ZXh0KCkpKSAvLyB0b2RvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcImR4XCIsIGVmZmVjdGl2ZUJ1ZmZlcik7IC8vIHRvZG9cbiAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICBpbW1lZGlhdGVseVJlbmRlckxhYmVscyhzaG93KSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQoKTtcbiAgICAgICAgaWYgKCFlbGVtZW50KSByZXR1cm47XG5cbiAgICAgICAgaWYgKCFzaG93KSB7IC8vIEhpZGVzIHRoZSBsYWJlbHNcbiAgICAgICAgICAgIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAuc2VsZWN0KCcuY2hhcnQtbGFiZWxzJylcbiAgICAgICAgICAgICAgICAuaW50ZXJydXB0KFwibGFiZWxzXCIpXG4gICAgICAgICAgICAgICAgLmludGVycnVwdChcImxhYmVsczpmYWRlXCIpXG4gICAgICAgICAgICAgICAgLnRyYW5zaXRpb24oXCJsYWJlbHM6ZmFkZVwiKVxuICAgICAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMClcbiAgICAgICAgICAgICAgICAub24oXCJlbmRcIiwgKGQsIGksIG5vZGVzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGQzLnNlbGVjdChub2Rlc1tpXSkucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBsYWJlbHMgPSBlbGVtZW50LnNlbGVjdCgnLmNoYXJ0LWxhYmVscycpO1xuICAgICAgICAgICAgaWYgKCFsYWJlbHMuZW1wdHkoKSkgcmV0dXJuO1xuXG4gICAgICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5wcmVwYXJlRGF0YShudWxsLCB0cnVlKTtcbiAgICAgICAgICAgIGNvbnN0IGFsbERhdGEgPSB0aGlzLnByZXBhcmVEYXRhKG51bGwsIGZhbHNlKTtcblxuICAgICAgICAgICAgY29uc3QgeXNjYWxlID0gdGhpcy5nZXREM1lTY2FsZShkYXRhKSxcbiAgICAgICAgICAgICAgICAgIHhzY2FsZSA9IHRoaXMuZ2V0RDNYU2NhbGUoZGF0YSksXG4gICAgICAgICAgICAgICAgICB4Z3JvdXAgPSB0aGlzLmdldEQzR3JvdXBTY2FsZShkYXRhLCB5c2NhbGUpLFxuICAgICAgICAgICAgICAgICAgY29sb3VyU2NhbGUgPSB0aGlzLmQzQ29sb3VyU2NhbGUoKTtcblxuICAgICAgICAgICAgbGFiZWxzLnJlbW92ZSgpO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJMYWJlbHMoZWxlbWVudCwgZGF0YSwgeHNjYWxlLCB4Z3JvdXAsIHlzY2FsZSwgY29sb3VyU2NhbGUsIGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG5cbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gYmFyQ2hhcnQoKSB7XG4gICAgcmV0dXJuIG5ldyBCYXJIaXN0b2dyYW0oXCJCQVJfQ0hBUlRcIiwgMC4xKTtcbn1cblxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/chart/BarChart.js\n')},"./src/chart/Bucket.js":
/*!*****************************!*\
  !*** ./src/chart/Bucket.js ***!
  \*****************************/
/*! exports provided: DateBucket, DiscreteBucket, ContinuousBucket */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DateBucket", function() { return DateBucket; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DiscreteBucket", function() { return DiscreteBucket; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ContinuousBucket", function() { return ContinuousBucket; });\n/* harmony import */ var _Statistics__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Statistics */ "./src/Statistics.js");\n// Copyright (C) 2013-2014, 2018 BrandsEye (PTY) LTD\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this\n// software and associated documentation files (the "Software"), to deal in the Software\n// without restriction, including without limitation the rights to use, copy, modify,\n//     merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following\n// conditions:\n//\n//     The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n//     INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n// CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n\nclass Bucket {\n    constructor(data) {\n        this._data = data;\n\n        this.getCount = d => d._y;\n        this.setCount = (d, v) => d._y = v;\n    }\n\n    setCountGetter(y) { this.getCount = y; return this; }\n    setCountSetter(y) { this.setCount = y; return this; }\n\n\n    /**\n     * Given a data point, this returns the bucket that the data point is a part of.\n     */\n    bucket(d) { return d; }\n\n    /**\n     * Given data that has had its buckets set up in each item\'s _key field,\n     * this consolidates the data in to a single collection of buckets.\n     */\n    consolidateBuckets(data) { return data; }\n\n}\n\n/**\n * The bucket of a Date object is just itself. We assume that\n * dates are their own buckets.\n */\nclass DateBucket extends Bucket {\n\n    // A noop: each date is its own bucket.\n    bucket(d) {\n        return d;\n    }\n\n    // A noop: our buckets are already consolidated.\n    consolidateBuckets(data) {\n        return data;\n    }\n}\n\nclass DiscreteBucket extends Bucket {\n\n    bucket(d) {\n        return d;\n    }\n\n    consolidateBuckets(data) {\n        data.forEach(bucket => {\n            const counts = {};\n            const examples = {};\n            // Count everything grouped by their keys\n            // (i.e. count individual series\n            bucket.data.forEach(d => {\n                counts[d._key] = (counts[d._key] || 0) + this.getCount(d);\n                examples[d._key] = d;\n            });\n            // Provide one summary per series, but preserve\n            // any extra data, such as colour and so on.\n            bucket.data = Object.keys(counts).map(key => {\n                const example = examples[key];\n                const result =  Object.assign({}, example);\n                this.setCount(result, counts[key])\n                return result;\n            })\n        });\n\n        return data;\n    }\n}\n\n\nclass ContinuousBucket extends Bucket {\n    // We calculate buckets based on the Freedman-Draconis\n    // inter-quartile range method.\n    constructor(data) {\n        super(data);\n        this._bucketWidth = Object(_Statistics__WEBPACK_IMPORTED_MODULE_0__["freedmanDiaconis"])(data);\n    }\n\n    bucket(d) {\n        const b = Math.floor(d / this._bucketWidth);\n        return Math.ceil(b * this._bucketWidth + this._bucketWidth);\n    }\n\n    consolidateBuckets(data) {\n        data.forEach(bucket => {\n            const counts = {};\n            const examples = {};\n            // Count everything grouped by their keys\n            // (i.e. count individual series\n            bucket.data.forEach(d => {\n                counts[d._key] = (counts[d._key] || 0) + 1;\n                examples[d._key] = d;\n            });\n            // Provide one summary per series, but preserve\n            // any extra data, such as colour and so on.\n            bucket.data = Object.keys(counts).map(key => {\n                const example = examples[key];\n                const result = Object.assign({}, example);\n                this.setCount(result, counts[key]);\n                return result;\n            })\n        });\n\n        return data;\n    }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY2hhcnQvQnVja2V0LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYjNqcy8uL3NyYy9jaGFydC9CdWNrZXQuanM/OTUxOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKEMpIDIwMTMtMjAxNCwgMjAxOCBCcmFuZHNFeWUgKFBUWSkgTFREXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZiB0aGlzXG4vLyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmVcbi8vIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSxcbi8vICAgICBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvXG4vLyBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZ1xuLy8gY29uZGl0aW9uczpcbi8vXG4vLyAgICAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4vLyBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vICAgICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SIElNUExJRUQsXG4vLyAgICAgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEFcbi8vIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFRcbi8vIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRlxuLy8gQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFXG4vLyBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IHtmcmVlZG1hbkRpYWNvbmlzfSBmcm9tIFwiLi4vU3RhdGlzdGljc1wiO1xuXG5cbmNsYXNzIEJ1Y2tldCB7XG4gICAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgICAgICB0aGlzLl9kYXRhID0gZGF0YTtcblxuICAgICAgICB0aGlzLmdldENvdW50ID0gZCA9PiBkLl95O1xuICAgICAgICB0aGlzLnNldENvdW50ID0gKGQsIHYpID0+IGQuX3kgPSB2O1xuICAgIH1cblxuICAgIHNldENvdW50R2V0dGVyKHkpIHsgdGhpcy5nZXRDb3VudCA9IHk7IHJldHVybiB0aGlzOyB9XG4gICAgc2V0Q291bnRTZXR0ZXIoeSkgeyB0aGlzLnNldENvdW50ID0geTsgcmV0dXJuIHRoaXM7IH1cblxuXG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBkYXRhIHBvaW50LCB0aGlzIHJldHVybnMgdGhlIGJ1Y2tldCB0aGF0IHRoZSBkYXRhIHBvaW50IGlzIGEgcGFydCBvZi5cbiAgICAgKi9cbiAgICBidWNrZXQoZCkgeyByZXR1cm4gZDsgfVxuXG4gICAgLyoqXG4gICAgICogR2l2ZW4gZGF0YSB0aGF0IGhhcyBoYWQgaXRzIGJ1Y2tldHMgc2V0IHVwIGluIGVhY2ggaXRlbSdzIF9rZXkgZmllbGQsXG4gICAgICogdGhpcyBjb25zb2xpZGF0ZXMgdGhlIGRhdGEgaW4gdG8gYSBzaW5nbGUgY29sbGVjdGlvbiBvZiBidWNrZXRzLlxuICAgICAqL1xuICAgIGNvbnNvbGlkYXRlQnVja2V0cyhkYXRhKSB7IHJldHVybiBkYXRhOyB9XG5cbn1cblxuLyoqXG4gKiBUaGUgYnVja2V0IG9mIGEgRGF0ZSBvYmplY3QgaXMganVzdCBpdHNlbGYuIFdlIGFzc3VtZSB0aGF0XG4gKiBkYXRlcyBhcmUgdGhlaXIgb3duIGJ1Y2tldHMuXG4gKi9cbmV4cG9ydCBjbGFzcyBEYXRlQnVja2V0IGV4dGVuZHMgQnVja2V0IHtcblxuICAgIC8vIEEgbm9vcDogZWFjaCBkYXRlIGlzIGl0cyBvd24gYnVja2V0LlxuICAgIGJ1Y2tldChkKSB7XG4gICAgICAgIHJldHVybiBkO1xuICAgIH1cblxuICAgIC8vIEEgbm9vcDogb3VyIGJ1Y2tldHMgYXJlIGFscmVhZHkgY29uc29saWRhdGVkLlxuICAgIGNvbnNvbGlkYXRlQnVja2V0cyhkYXRhKSB7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIERpc2NyZXRlQnVja2V0IGV4dGVuZHMgQnVja2V0IHtcblxuICAgIGJ1Y2tldChkKSB7XG4gICAgICAgIHJldHVybiBkO1xuICAgIH1cblxuICAgIGNvbnNvbGlkYXRlQnVja2V0cyhkYXRhKSB7XG4gICAgICAgIGRhdGEuZm9yRWFjaChidWNrZXQgPT4ge1xuICAgICAgICAgICAgY29uc3QgY291bnRzID0ge307XG4gICAgICAgICAgICBjb25zdCBleGFtcGxlcyA9IHt9O1xuICAgICAgICAgICAgLy8gQ291bnQgZXZlcnl0aGluZyBncm91cGVkIGJ5IHRoZWlyIGtleXNcbiAgICAgICAgICAgIC8vIChpLmUuIGNvdW50IGluZGl2aWR1YWwgc2VyaWVzXG4gICAgICAgICAgICBidWNrZXQuZGF0YS5mb3JFYWNoKGQgPT4ge1xuICAgICAgICAgICAgICAgIGNvdW50c1tkLl9rZXldID0gKGNvdW50c1tkLl9rZXldIHx8IDApICsgdGhpcy5nZXRDb3VudChkKTtcbiAgICAgICAgICAgICAgICBleGFtcGxlc1tkLl9rZXldID0gZDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gUHJvdmlkZSBvbmUgc3VtbWFyeSBwZXIgc2VyaWVzLCBidXQgcHJlc2VydmVcbiAgICAgICAgICAgIC8vIGFueSBleHRyYSBkYXRhLCBzdWNoIGFzIGNvbG91ciBhbmQgc28gb24uXG4gICAgICAgICAgICBidWNrZXQuZGF0YSA9IE9iamVjdC5rZXlzKGNvdW50cykubWFwKGtleSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXhhbXBsZSA9IGV4YW1wbGVzW2tleV07XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gIE9iamVjdC5hc3NpZ24oe30sIGV4YW1wbGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0Q291bnQocmVzdWx0LCBjb3VudHNba2V5XSlcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxufVxuXG5cbmV4cG9ydCBjbGFzcyBDb250aW51b3VzQnVja2V0IGV4dGVuZHMgQnVja2V0IHtcbiAgICAvLyBXZSBjYWxjdWxhdGUgYnVja2V0cyBiYXNlZCBvbiB0aGUgRnJlZWRtYW4tRHJhY29uaXNcbiAgICAvLyBpbnRlci1xdWFydGlsZSByYW5nZSBtZXRob2QuXG4gICAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgICAgICBzdXBlcihkYXRhKTtcbiAgICAgICAgdGhpcy5fYnVja2V0V2lkdGggPSBmcmVlZG1hbkRpYWNvbmlzKGRhdGEpO1xuICAgIH1cblxuICAgIGJ1Y2tldChkKSB7XG4gICAgICAgIGNvbnN0IGIgPSBNYXRoLmZsb29yKGQgLyB0aGlzLl9idWNrZXRXaWR0aCk7XG4gICAgICAgIHJldHVybiBNYXRoLmNlaWwoYiAqIHRoaXMuX2J1Y2tldFdpZHRoICsgdGhpcy5fYnVja2V0V2lkdGgpO1xuICAgIH1cblxuICAgIGNvbnNvbGlkYXRlQnVja2V0cyhkYXRhKSB7XG4gICAgICAgIGRhdGEuZm9yRWFjaChidWNrZXQgPT4ge1xuICAgICAgICAgICAgY29uc3QgY291bnRzID0ge307XG4gICAgICAgICAgICBjb25zdCBleGFtcGxlcyA9IHt9O1xuICAgICAgICAgICAgLy8gQ291bnQgZXZlcnl0aGluZyBncm91cGVkIGJ5IHRoZWlyIGtleXNcbiAgICAgICAgICAgIC8vIChpLmUuIGNvdW50IGluZGl2aWR1YWwgc2VyaWVzXG4gICAgICAgICAgICBidWNrZXQuZGF0YS5mb3JFYWNoKGQgPT4ge1xuICAgICAgICAgICAgICAgIGNvdW50c1tkLl9rZXldID0gKGNvdW50c1tkLl9rZXldIHx8IDApICsgMTtcbiAgICAgICAgICAgICAgICBleGFtcGxlc1tkLl9rZXldID0gZDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gUHJvdmlkZSBvbmUgc3VtbWFyeSBwZXIgc2VyaWVzLCBidXQgcHJlc2VydmVcbiAgICAgICAgICAgIC8vIGFueSBleHRyYSBkYXRhLCBzdWNoIGFzIGNvbG91ciBhbmQgc28gb24uXG4gICAgICAgICAgICBidWNrZXQuZGF0YSA9IE9iamVjdC5rZXlzKGNvdW50cykubWFwKGtleSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXhhbXBsZSA9IGV4YW1wbGVzW2tleV07XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gT2JqZWN0LmFzc2lnbih7fSwgZXhhbXBsZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRDb3VudChyZXN1bHQsIGNvdW50c1trZXldKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxufSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/chart/Bucket.js\n')},"./src/chart/FantasticChart.js":
/*!*************************************!*\
  !*** ./src/chart/FantasticChart.js ***!
  \*************************************/
/*! exports provided: chart */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "chart", function() { return chart; });\n/* harmony import */ var _Colours__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Colours */ "./src/Colours.js");\n/* harmony import */ var _Scales__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Scales */ "./src/chart/Scales.js");\n/* harmony import */ var _Axes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Axes */ "./src/chart/Axes.js");\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../helpers */ "./src/helpers.js");\n/* harmony import */ var _Legend__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Legend */ "./src/Legend.js");\n/* harmony import */ var _Strings__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../Strings */ "./src/Strings.js");\n// Copyright (C) 2013-2014, 2018 BrandsEye (PTY) LTD\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this\n// software and associated documentation files (the "Software"), to deal in the Software\n// without restriction, including without limitation the rights to use, copy, modify,\n//     merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following\n// conditions:\n//\n//     The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n//     INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n// CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n\n\n\n\n\n\nclass FantasticChart {\n\n    constructor(name) {\n        this._counter = this._counter || 0;\n        this._counter++;\n        this._name = name || ("Chart " + this._counter);\n        this.reset();\n    }\n\n    reset() {\n        this._geometries = [];\n        this._x_getter = d => d.x;\n        this._y_getter = d => d.y;\n        this._data = [];\n        this._element = null;\n        this._width = 900;\n        this._height = 512;\n        this._colour = () => _Colours__WEBPACK_IMPORTED_MODULE_0__["colours"].eighteen.midGrey;\n        this._size = () => 1;\n        this._scale_x = Object(_Scales__WEBPACK_IMPORTED_MODULE_1__["scaleIdentity"])();\n        this._scale_y = Object(_Scales__WEBPACK_IMPORTED_MODULE_1__["scaleIdentity"])();\n        this._colour = () => 1;\n        this._facet_x = null;\n        this._colour_scale = d3.schemeAccent;\n        this._d3_colour_scale = d3.schemeAccent;\n        this._individual_colours = () => null;\n        this._modify_colour = c => c;\n        this._x_formatter = d => "" + d;\n        this._y_formatter = d => d;\n        this._x_importance = () => false;\n        this._dispatch = d3.dispatch(\'elementClick\', \'tooltipShow\', \'tooltipHide\');\n        this._show_labels = true;\n        this._show_legend = true;\n        this._legend_colours = () => null;\n        this._y_axis_label = null;\n        this._x_axis_label = null;\n        this._show_x_axis = true;\n        this._show_y_axis = true;\n        this._label_formatter = null;\n        this._font_size = 12;\n        this._x_grid_lines = false;\n        this._y_grid_lines = false;\n        this._axis_box = false;\n        this._x_label_angle = null;\n        this._grid_line_opacity = 0.15;\n        this._x_tick_values_fn = null;\n        this._y_tick_values_fn = null;\n        return this;\n    }\n\n    /*\n     * A DOM element that we want to render to.\n     * See, for instance, document.getElementById(id), to get\n     * such a dom element.\n     */\n    element(el) {\n        if (arguments.length === 0) return this._element;\n        this._element = el;\n        return this;\n    }\n\n    width(width) {\n        if (arguments.length === 0) return this._width;\n        if (typeof width !== "number" && width > 0) throw new Error("width must be a positive number");\n        this._width = width;\n        return this;\n    }\n\n    height(height) {\n        if (arguments.length === 0) return this._height;\n        if (typeof height !== "number" && height > 0) throw new Error("height must be a positive number");\n        this._height = height;\n        return this;\n    }\n\n    x(getter) {\n        if (arguments.length === 0) return this._x_getter;\n        if (typeof getter !== \'function\') throw new Error("x getter must be a function");\n        this._x_getter = getter;\n        return this;\n    }\n\n    y(getter) {\n        if (arguments.length === 0) return this._y_getter;\n        if (typeof getter !== \'function\') throw new Error("y getter must be a function");\n        this._y_getter = getter;\n        return this;\n    }\n\n    scaleX(scale) {\n        if (arguments.length === 0) return this._scale_x;\n        this._scale_x = scale;\n        if (scale) {\n            scale.setCountGetter(d => d._y);\n            scale.setCountSetter((d, v) => d._y = v);\n        }\n        return this;\n    }\n\n    scaleY(scale) {\n        if (arguments.length === 0) return this._scale_y;\n        this._scale_y = scale;\n        if (scale) {\n            scale.setCountGetter(d => d._x);\n            scale.setCountSetter((d, v) => d._x = v);\n        }\n\n        return this;\n    }\n\n    /**\n     * Add geometry to render. Multiple geometries can be added.\n     */\n    geometry(geom) {\n        if (arguments.length === 0) return this._geometries.slice(0);\n        geom.index(this._geometries.length);\n        this._geometries.push(geom);\n        return this;\n    }\n\n    size(getter) {\n        if (arguments.length === 0) return this._size;\n        if (typeof getter !== \'function\') throw new Error("size getter must be a function");\n        this._size = getter;\n        return this;\n    }\n\n    formatX(formatter) {\n        if (arguments.length === 0) return this._x_formatter;\n        if (typeof formatter !== \'function\') throw new Error("formatter must be a function");\n        this._x_formatter = formatter;\n        return this;\n    }\n\n    importanceX(importance) {\n        if (arguments.length === 0) return this._x_importance;\n        if (typeof importance !== \'function\') throw new Error("importance must be a function");\n        this._x_importance = importance;\n        return this;\n    }\n\n    formatY(formatter) {\n        if (arguments.length === 0) return this._y_formatter;\n        if (typeof formatter !== \'function\') throw new Error("formatter must be a function");\n        this._y_formatter = formatter;\n        return this;\n    }\n\n    formatLabel(formatter) {\n        if (arguments.length === 0) return this._label_formatter;\n        if (typeof formatter !== \'function\') throw new Error("formatter must be a function");\n        this._label_formatter = formatter;\n        return this;\n    }\n\n    yAxisLabel(label) {\n        if (arguments.length === 0) return this._y_axis_label;\n        this._y_axis_label = label;\n        return this;\n    }\n\n    xAxisLabel(label) {\n        if (arguments.length === 0) return this._x_axis_label;\n        this._x_axis_label = label;\n        return this;\n    }\n\n    showXAxis(show) {\n        if (arguments.length === 0) return this._show_x_axis;\n        this._show_x_axis = !!show;\n        return this;\n    }\n\n    showYAxis(show) {\n        if (arguments.length === 0) return this._show_y_axis;\n        this._show_y_axis = !!show;\n        return this;\n    }\n\n    /**\n     * Defines how to separate data visually using colours. It\n     * does not define what colour to use.\n     * @param colour\n     * @returns {*}\n     */\n    colour(colour) {\n        if (arguments.length === 0) return this._colour;\n        if (typeof colour !== \'function\') throw new Error("colour must be a function");\n        this._colour = colour;\n        return this;\n    }\n\n    /**\n     * Defines colours to use.\n     * @param colours\n     */\n    colourScale(colours) {\n        if (arguments.length === 0) return this._colour_scale;\n        if (typeof colours !== \'object\' || !colours.length) throw new Error("colour must be an Array");\n        this._colour_scale = colours;\n        return this;\n    }\n\n    /**\n     * Provide a function mapping x-value fields to a colour. The function is passed\n     * the given data value, after it has been annotated with _x, _y, _colour, and so on.\n     * This overrides\n     * the colour scale. The colour scale will be used for values not defined by this map.\n     * @param colourMap\n     * @returns {*}\n     */\n    individualColours(colourMap) {\n        if (arguments.length === 0) return this._individual_colours;\n        if (typeof colourMap !== \'function\') throw new Error("colourMap must be a function");\n        this._individual_colours = colourMap;\n        return this;\n    }\n\n    modifyColour(modifier) {\n        if (arguments.length === 0) return this._modify_colour;\n        if (typeof colourMap !== \'function\') throw new Error("modifier must be a function");\n        this._modify_colour = modifier;\n        return this;\n    }\n\n    facetX(selector) {\n        if (arguments.length === 0) return this._facet_x;\n        if (selector != null && typeof selector !== \'function\') throw new Error("The facet selector must be a function");\n        this._facet_x = selector;\n        return this;\n    }\n\n    /**\n     * Whether to show labels or not. This is retained mode: it will not show the labels\n     * immediately. Please call #render() again to show the labels.\n     */\n    showLabels(show) {\n        if (arguments.length === 0) return this._show_labels;\n        this._show_labels = !!show;\n        return this;\n    }\n\n    /**\n     * Indicates whether to show the legend or not. This is retained mode: you need to\n     * call render after setting this to see a change.\n     * @param show\n     * @returns {*}\n     */\n    showLegend(show) {\n        if (arguments.length === 0) return this._show_legend;\n        this._show_legend = !!show;\n        return this;\n    }\n\n    /**\n     * Provide a function to override the mapping of legend names to colours.\n     */\n    legendColours(colourMap) {\n        if (arguments.length === 0) return this._legend_colours;\n        if (typeof colourMap !== \'function\') throw new Error("colourMap must be a function");\n        this._legend_colours = colourMap;\n        return this;\n    }\n\n    fontSize(px) {\n        if (arguments.length === 0) return this._font_size;\n        if (typeof px !== "number" && px > 0) throw new Error("fontSize must be a positive number");\n        this._font_size = px;\n        return this;\n    }\n\n    xGridLines(show) {\n        if (arguments.length === 0) return this._x_grid_lines;\n        this._x_grid_lines = !!show;\n        return this;\n    }\n\n    yGridLines(show) {\n        if (arguments.length === 0) return this._y_grid_lines;\n        this._y_grid_lines = !!show;\n        return this;\n    }\n\n    axisBox(show) {\n        if (arguments.length === 0) return this._axis_box;\n        this._axis_box = !!show;\n        return this;\n    }\n\n    xLabelAngle(degrees) {\n        if (arguments.length === 0) return this._x_label_angle;\n        if (degrees !== null && typeof degrees !== "number") throw new Error("degrees must be a number or null");\n        this._x_label_angle = degrees;\n        return this;\n    }\n\n    gridLineOpacity(opacity) {\n        if (arguments.length === 0) return this._grid_line_opacity;\n        if (typeof opacity !== "number") throw new Error("opacity must be a number or null");\n        this._grid_line_opacity = opacity;\n        return this;\n    }\n\n    /**\n     * The function is passed the xScale and must return null or an array of values to use for ticks.\n     */\n    xTickValuesFn(fn) {\n        if (arguments.length === 0) return this._x_tick_values_fn;\n        if (fn && typeof fn !== "function") throw new Error("fn must be an function or null");\n        this._x_tick_values_fn = fn;\n        return this;\n    }\n\n    /**\n     * The function is passed the yScale and must return null or an array of values to use for ticks.\n     */\n    yTickValuesFn(fn) {\n        if (arguments.length === 0) return this._y_tick_values_fn;\n        if (fn && typeof fn !== "function") throw new Error("fn must be an function or null");\n        this._y_tick_values_fn = fn;\n        return this;\n    }\n\n    /**\n     * Renders or hides labels as they are requested.\n     */\n    immediatelyRenderLabels(show) {\n        if (this._geometries) {\n            this._geometries.forEach(geom => geom.immediatelyRenderLabels(!!show))\n        }\n    }\n\n    /**\n     * The event handle for the charts. Supports the following events:\n     *\n     * - elementClick\n     * - tooltipShow\n     * - tooltipHide\n     *\n     * @returns {*|Dispatch}\n     */\n    dispatch() {\n        return this._dispatch;\n    }\n\n    data(data) {\n        if (arguments.length === 0) return this._data.slice();\n        this._data = data;\n        return this;\n    }\n\n    /**\n     * The chart\'s name, as defined in the constructor\n     * @returns {String}\n     */\n    name() {\n        return this._name;\n    }\n\n    render() {\n        //-----------------------------------------------\n        // Create initial svg element\n        let svg = d3.select(this._element).select("svg");\n        if (svg.empty()) svg = d3.select(this._element).append("svg");\n\n        //-----------------------------------------------\n        // Setup initial data\n\n        const bs = Object(_Legend__WEBPACK_IMPORTED_MODULE_4__["buckets"])(this._data, this._colour, this._individual_colours, this._size);\n        const colourScale = this._d3_colour_scale = d3.scaleOrdinal(this.colourScale())\n                                                      .domain(Array.from(bs.colours));\n        const axisOptions = {\n            fontSize: this._font_size,\n            xLabelAngle: this._x_label_angle,\n            gridLineOpacity: this._grid_line_opacity,\n            axisBox: this._axis_box\n        }\n\n        //-----------------------------------------------\n        // Calculate the space that various elements will want to take up. We also\n        // restrict the y axis by a proportion of the width of the metric.\n\n        const yAxisRestriction = Math.max((this._width * 0.07), 25);\n\n        const geometries = this.sortGeometries();\n        geometries.forEach(geom => this.setupGeom(geom));\n\n        let axisWidth = 0;\n        if (this._show_y_axis){\n            axisWidth = geometries.length\n                ? Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["maxBounding"])(svg, geometries[0].yValues()\n                                                .map(geometries[0].formatY())\n                                                .map(d => Object(_Strings__WEBPACK_IMPORTED_MODULE_5__["restrictLength"])(d, yAxisRestriction)), null, this._font_size).width + 15\n                : 0;\n        }\n\n        //-----------------------------------------------\n        // Draw the legend\n        if (!this._show_legend) Object(_Legend__WEBPACK_IMPORTED_MODULE_4__["removeLegend"])(svg);\n        const legendHeight = this._show_legend\n            ? Object(_Legend__WEBPACK_IMPORTED_MODULE_4__["renderLegend"])(svg, bs, (d) => this._legend_colours(d) || bs.bucketColour[d] || colourScale(d), this._width, this._height, null, axisOptions)\n            : 0;\n\n        //-----------------------------------------------\n        // Calculate margins without knowing the final height.\n        // We can only calculate the final height once we can accurately\n        // determine how to lay out the x-axis.\n\n        const outerPadding = 20;\n\n        const margin = {\n            top: outerPadding,\n            right: outerPadding,\n            bottom: outerPadding + legendHeight,\n            left: outerPadding + axisWidth\n        };\n        if (this._show_y_axis && this._y_axis_label) margin.left += 20;\n        if (this._show_x_axis && this._x_axis_label) margin.bottom += 40;\n        const width  = this._width - margin.left - margin.right;\n        const leftOuterPadding = outerPadding + (this._y_axis_label ? 20 : 0);\n\n        //-----------------------------------------------\n        // Determine initial facet / small multiple information\n\n        const facets = getFacets(this._data, this._facet_x);\n        const singleFacet = facets.length === 1;\n\n        const facetBand = d3.scaleBand()\n                            .rangeRound([0, width])\n                            .padding(singleFacet ? 0 : 0.1) // take up full space if the only facet.\n                            .domain(facets);\n\n        //-----------------------------------------------\n        // Determine x-axis height\n        // We do this by rendering the various x-axes offscreen.\n\n        const xTickCount = Math.floor(width / 90);\n\n        geometries.forEach(geom => geom.width(facetBand.bandwidth()));\n        const axisSizeArea = svg.append("g")\n            .attr("transform", "translate(-1000, -1000)");\n\n        const xAxisRestriction = Math.min(25, Math.max(this._height * 0.07, 12));\n        let axisHeight = 0;\n        if (this._show_x_axis){\n            facets.forEach(facet => {\n                const xScale = geometries[0]\n                    .width(facetBand.bandwidth())\n                    .facet(singleFacet ? null : (d => this._facet_x(d) === facet))\n                    .getD3XScale();\n\n                let axis = d3.axisBottom(xScale).ticks(xTickCount).tickSize(0).tickPadding(6)\n                    .tickFormat((d, i) => Object(_Strings__WEBPACK_IMPORTED_MODULE_5__["restrictLength"])(geometries[0].formatX()(d, i), xAxisRestriction))\n                    .tickValues(this._x_tick_values_fn ? this._x_tick_values_fn(xScale) : null)\n                let height = Object(_Axes__WEBPACK_IMPORTED_MODULE_2__["xaxis"])(axisSizeArea, this._height,\n                    xScale.bandwidth ? xScale.bandwidth() : facetBand.bandwidth() / xScale.domain().length,\n                    axis, this.importanceX(), axisOptions);\n\n                axisHeight = Math.max(height, axisHeight);\n            });\n        }\n\n        axisSizeArea.remove();\n\n        //-----------------------------------------------\n        // Update margins and calculate height\n\n        margin.bottom += axisHeight;\n        const height = this._height - margin.top - margin.bottom;\n\n        //-----------------------------------------------\n        // Setup the svg\n\n        svg\n            .style("width", this._width + "px")\n            .style("height", this._height + "px");\n\n        //-----------------------------------------------\n        // An area for us to render the geometries in to.\n\n        let drawingArea = svg.select(\'.drawing-area\');\n\n        if (drawingArea.empty()) {\n            drawingArea = svg\n                .append("g")\n                .attr("class", "drawing-area")\n        }\n\n        drawingArea.attr("transform", "translate(" + margin.left + "," + margin.top + ")");\n\n\n        //-----------------------------------------------\n        // Set up small multiples / facets\n\n        let facetAreas = drawingArea.selectAll(\'.facet\').data(facets);\n        facetAreas.exit().remove();\n\n        //-----------------------------------------------\n        // Setup axes.\n\n        let xAxisArea = svg.select(".x-axis-area");\n\n        xAxisArea.remove();\n        xAxisArea = svg\n            .append("g")\n            .attr("class", "x-axis-area");\n\n        xAxisArea.attr("transform", "translate(" + margin.left + "," + (margin.top + height) +")").lower();\n\n        let yAxisArea = svg.select(".y-axis-area");\n        const yTickCount = Math.floor(height / 90);\n\n        yAxisArea.remove();\n        yAxisArea = svg\n            .append("g")\n            .attr("class", "y-axis-area")\n            .attr("transform", "translate(" + margin.left +"," + margin.top + ")").lower();\n\n        const yScale = geometries.length ? geometries[0].height(height).getD3YScale() : null;\n        if (geometries.length) {\n            // Draw the yaxis.\n\n            let tv = this._y_tick_values_fn ? this._y_tick_values_fn(yScale) : null\n            let tc = Math.floor(height / 30)\n            if (tc <= 2 && !tv) tv = yScale.domain()\n            if (this._show_y_axis) {\n                Object(_Axes__WEBPACK_IMPORTED_MODULE_2__["yaxis"])(yAxisArea,\n                    d3.axisLeft(yScale).ticks(tc)\n                        .tickSize(this._y_grid_lines ? -width : 0)\n                        .tickPadding(6)\n                        .tickValues(tv)\n                        .tickFormat((d, i) => Object(_Strings__WEBPACK_IMPORTED_MODULE_5__["restrictLength"])(geometries[0].formatY()(d, i), yAxisRestriction)), //;.tickFormat(this._tickFormat));\n                    axisOptions);\n            }\n\n            // Draw a little x-axis for every facet.\n            if (this._show_x_axis) {\n                facets.forEach(facet => {\n                    const xScale = geometries[0]\n                        .width(facetBand.bandwidth())\n                        .height(height)\n                        .facet(singleFacet ? null : (d => this._facet_x(d) === facet))\n                        .getD3XScale();\n\n                    const area = xAxisArea\n                        .append("g")\n                        .attr("transform", "translate(" + (facetBand(facet)) + ",0)")// + (this._height - axisHeight) +")")\n                        .attr("width", facetBand.bandwidth());\n\n\n                    Object(_Axes__WEBPACK_IMPORTED_MODULE_2__["xaxis"])(area, this._height,\n                        xScale.bandwidth ? xScale.bandwidth() : facetBand.bandwidth() / xScale.domain().length,\n                        d3.axisBottom(xScale).ticks(xTickCount).tickSize(this._x_grid_lines ? -height : 0).tickPadding(6)\n                            .tickFormat((d, i) => Object(_Strings__WEBPACK_IMPORTED_MODULE_5__["restrictLength"])(geometries[0].formatX()(d, i), xAxisRestriction))\n                            .tickValues(this._x_tick_values_fn ? this._x_tick_values_fn(xScale) : null),\n                        this.importanceX(), axisOptions)\n                });\n            }\n\n        }\n\n        //-----------------------------------------------\n        // Setup labels\n\n        if (this._show_y_axis) {\n            Object(_Axes__WEBPACK_IMPORTED_MODULE_2__["yAxisLabel"])(svg, height, margin, this._y_axis_label, axisOptions);\n        }\n        if (this._show_x_axis) {\n            Object(_Axes__WEBPACK_IMPORTED_MODULE_2__["xAxisLabel"])(svg, width, height, margin, this._x_axis_label, axisOptions);\n        }\n\n        //-----------------------------------------------\n        // Draw individual geometries.\n\n        facetAreas\n            .enter()\n            .append("g")\n            .attr("class", "facet")\n            .merge(facetAreas)\n            .attr("width", facetBand.bandwidth())\n            .attr("transform", facetId => {\n                if (singleFacet) return "translate(0,0)";\n                return "translate(" + facetBand(facetId) + ",0)";\n            })\n            .each((facet, facet_i, facetNodes) => {\n                const area = d3.select(facetNodes[facet_i]);\n\n                let geoms = area.selectAll(".geometry").data(geometries, d => d.key());\n\n                const xscale = geometries[0].getD3XScale();\n                const geom_width  = facetBand.bandwidth(),\n                      geom_height = height;\n\n                //yGrid(area, geom_width, this.scaleY().isShowGrid(), d3.axisLeft(yScale).ticks(yTickCount));\n                //xGrid(area, geom_height, this.scaleX().isShowGrid(), d3.axisBottom(xscale).ticks(xTickCount));\n\n                geoms.exit().remove();\n\n                geoms.enter()\n                     .append("g")\n                     .attr("class", "geometry")\n                     .merge(geoms)\n                     .each((geom, i, nodes) => {\n                         const geom_top  = 0,\n                               geom_left = 0;\n\n                         let node = d3.select(nodes[i]);\n\n                         node\n                             .attr("transform", "translate(" + geom_left + "," + geom_top + ")")\n                             .each((d, i, nodes) => {\n                                 geom.element(d3.select(nodes[i]))\n                                     .facet(singleFacet ? null : (d => this._facet_x(d) === facet))\n                                     .height(geom_height)\n                                     .width(geom_width)\n                                     .render();\n                             })\n                     });\n\n                // Ensure this is rendered on top of other things.\n                area.select(".x-axis").raise();\n            })\n\n    }\n\n\n    /*\n     * Ensures that each geom has the settings that it needs.\n     */\n    setupGeom(geom) {\n        geom.setupX(this._x_getter)\n            .setupY(this._y_getter)\n            .setupColour(this._colour)\n            .setupSize(this._size)\n            .setupScaleX(this._scale_x)\n            .setupScaleY(this._scale_y)\n            .setupFormatX(this._x_formatter)\n            .setupFormatY(this._y_formatter)\n            .setupFormatLabel(this._label_formatter)\n            .setupColourScale(this._colour_scale)\n            .setupIndividualColours(this._individual_colours)\n            .setupModifyColour(this._modify_colour)\n            .setupShowLabels(this._show_labels)\n            .d3ColourScale(this._d3_colour_scale)\n            .setupYAxisLabel(this._y_axis_label)\n            .setupXAxisLabel(this._x_axis_label)\n            .fontSize(this._font_size);\n        geom._dispatch.on("elementClick", (e) => {\n            this._dispatch.call("elementClick", this, e);\n        });\n        geom._dispatch.on("tooltipHide", () => {\n            this._dispatch.call("tooltipHide", this);\n        });\n        geom._dispatch.on("tooltipShow", (e) => {\n            this._dispatch.call("tooltipShow", this, e);\n        });\n        geom.data(this._data);\n    }\n\n\n    /**\n     * We want to ensure that geometries have a particular order to them.\n     * This is important for rendering: lines should be rendered on top of\n     * large histogram rectangles, for instance, otherwise they will be hidden.\n     */\n    sortGeometries() {\n        if (!this._geometries || !this._geometries.length) return [];\n\n        let geometries = this._geometries.slice(0);\n        geometries.sort((lhs, rhs) => {\n            return lhs.priority() - rhs.priority();\n        });\n\n        return geometries;\n    }\n}\n\n\n/*\n * Returns the unique facet choices from the data, given a facet selector.\n */\nfunction getFacets(data, selector) {\n    if (!selector || !data || !data.length) return [1];\n\n    const keys = new Set(data.map(selector));\n    return [...keys];\n}\n\n\n/**\n * Create a new chart object.\n * @param name An optional name for the chart.\n * @returns {FantasticChart}\n */\nfunction chart(name) {\n    return new FantasticChart(name);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY2hhcnQvRmFudGFzdGljQ2hhcnQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9iM2pzLy4vc3JjL2NoYXJ0L0ZhbnRhc3RpY0NoYXJ0LmpzP2VlMTEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChDKSAyMDEzLTIwMTQsIDIwMTggQnJhbmRzRXllIChQVFkpIExURFxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpc1xuLy8gc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlXG4vLyB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksXG4vLyAgICAgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0b1xuLy8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcbi8vIGNvbmRpdGlvbnM6XG4vL1xuLy8gICAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuLy8gY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyAgICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUiBJTVBMSUVELFxuLy8gICAgIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBXG4vLyBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUXG4vLyBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0Zcbi8vIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRVxuLy8gT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCB7Y29sb3Vyc30gZnJvbSAnLi4vQ29sb3Vycyc7XG5pbXBvcnQge3NjYWxlSWRlbnRpdHl9IGZyb20gXCIuL1NjYWxlc1wiO1xuaW1wb3J0IHt4YXhpcywgeEF4aXNMYWJlbCwgeWF4aXMsIHlBeGlzTGFiZWwsIHlHcmlkfSBmcm9tIFwiLi9BeGVzXCI7XG5pbXBvcnQge21heEJvdW5kaW5nfSBmcm9tIFwiLi4vaGVscGVyc1wiO1xuaW1wb3J0IHtidWNrZXRzLCByZW1vdmVMZWdlbmQsIHJlbmRlckxlZ2VuZH0gZnJvbSBcIi4uL0xlZ2VuZFwiO1xuaW1wb3J0IHtyZXN0cmljdExlbmd0aH0gZnJvbSBcIi4uL1N0cmluZ3NcIjtcblxuXG5jbGFzcyBGYW50YXN0aWNDaGFydCB7XG5cbiAgICBjb25zdHJ1Y3RvcihuYW1lKSB7XG4gICAgICAgIHRoaXMuX2NvdW50ZXIgPSB0aGlzLl9jb3VudGVyIHx8IDA7XG4gICAgICAgIHRoaXMuX2NvdW50ZXIrKztcbiAgICAgICAgdGhpcy5fbmFtZSA9IG5hbWUgfHwgKFwiQ2hhcnQgXCIgKyB0aGlzLl9jb3VudGVyKTtcbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgIH1cblxuICAgIHJlc2V0KCkge1xuICAgICAgICB0aGlzLl9nZW9tZXRyaWVzID0gW107XG4gICAgICAgIHRoaXMuX3hfZ2V0dGVyID0gZCA9PiBkLng7XG4gICAgICAgIHRoaXMuX3lfZ2V0dGVyID0gZCA9PiBkLnk7XG4gICAgICAgIHRoaXMuX2RhdGEgPSBbXTtcbiAgICAgICAgdGhpcy5fZWxlbWVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3dpZHRoID0gOTAwO1xuICAgICAgICB0aGlzLl9oZWlnaHQgPSA1MTI7XG4gICAgICAgIHRoaXMuX2NvbG91ciA9ICgpID0+IGNvbG91cnMuZWlnaHRlZW4ubWlkR3JleTtcbiAgICAgICAgdGhpcy5fc2l6ZSA9ICgpID0+IDE7XG4gICAgICAgIHRoaXMuX3NjYWxlX3ggPSBzY2FsZUlkZW50aXR5KCk7XG4gICAgICAgIHRoaXMuX3NjYWxlX3kgPSBzY2FsZUlkZW50aXR5KCk7XG4gICAgICAgIHRoaXMuX2NvbG91ciA9ICgpID0+IDE7XG4gICAgICAgIHRoaXMuX2ZhY2V0X3ggPSBudWxsO1xuICAgICAgICB0aGlzLl9jb2xvdXJfc2NhbGUgPSBkMy5zY2hlbWVBY2NlbnQ7XG4gICAgICAgIHRoaXMuX2QzX2NvbG91cl9zY2FsZSA9IGQzLnNjaGVtZUFjY2VudDtcbiAgICAgICAgdGhpcy5faW5kaXZpZHVhbF9jb2xvdXJzID0gKCkgPT4gbnVsbDtcbiAgICAgICAgdGhpcy5fbW9kaWZ5X2NvbG91ciA9IGMgPT4gYztcbiAgICAgICAgdGhpcy5feF9mb3JtYXR0ZXIgPSBkID0+IFwiXCIgKyBkO1xuICAgICAgICB0aGlzLl95X2Zvcm1hdHRlciA9IGQgPT4gZDtcbiAgICAgICAgdGhpcy5feF9pbXBvcnRhbmNlID0gKCkgPT4gZmFsc2U7XG4gICAgICAgIHRoaXMuX2Rpc3BhdGNoID0gZDMuZGlzcGF0Y2goJ2VsZW1lbnRDbGljaycsICd0b29sdGlwU2hvdycsICd0b29sdGlwSGlkZScpO1xuICAgICAgICB0aGlzLl9zaG93X2xhYmVscyA9IHRydWU7XG4gICAgICAgIHRoaXMuX3Nob3dfbGVnZW5kID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fbGVnZW5kX2NvbG91cnMgPSAoKSA9PiBudWxsO1xuICAgICAgICB0aGlzLl95X2F4aXNfbGFiZWwgPSBudWxsO1xuICAgICAgICB0aGlzLl94X2F4aXNfbGFiZWwgPSBudWxsO1xuICAgICAgICB0aGlzLl9zaG93X3hfYXhpcyA9IHRydWU7XG4gICAgICAgIHRoaXMuX3Nob3dfeV9heGlzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fbGFiZWxfZm9ybWF0dGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZm9udF9zaXplID0gMTI7XG4gICAgICAgIHRoaXMuX3hfZ3JpZF9saW5lcyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl95X2dyaWRfbGluZXMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fYXhpc19ib3ggPSBmYWxzZTtcbiAgICAgICAgdGhpcy5feF9sYWJlbF9hbmdsZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX2dyaWRfbGluZV9vcGFjaXR5ID0gMC4xNTtcbiAgICAgICAgdGhpcy5feF90aWNrX3ZhbHVlc19mbiA9IG51bGw7XG4gICAgICAgIHRoaXMuX3lfdGlja192YWx1ZXNfZm4gPSBudWxsO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIEEgRE9NIGVsZW1lbnQgdGhhdCB3ZSB3YW50IHRvIHJlbmRlciB0by5cbiAgICAgKiBTZWUsIGZvciBpbnN0YW5jZSwgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpLCB0byBnZXRcbiAgICAgKiBzdWNoIGEgZG9tIGVsZW1lbnQuXG4gICAgICovXG4gICAgZWxlbWVudChlbCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX2VsZW1lbnQ7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQgPSBlbDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgd2lkdGgod2lkdGgpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl93aWR0aDtcbiAgICAgICAgaWYgKHR5cGVvZiB3aWR0aCAhPT0gXCJudW1iZXJcIiAmJiB3aWR0aCA+IDApIHRocm93IG5ldyBFcnJvcihcIndpZHRoIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXJcIik7XG4gICAgICAgIHRoaXMuX3dpZHRoID0gd2lkdGg7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGhlaWdodChoZWlnaHQpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl9oZWlnaHQ7XG4gICAgICAgIGlmICh0eXBlb2YgaGVpZ2h0ICE9PSBcIm51bWJlclwiICYmIGhlaWdodCA+IDApIHRocm93IG5ldyBFcnJvcihcImhlaWdodCBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyXCIpO1xuICAgICAgICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHgoZ2V0dGVyKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5feF9nZXR0ZXI7XG4gICAgICAgIGlmICh0eXBlb2YgZ2V0dGVyICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgRXJyb3IoXCJ4IGdldHRlciBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG4gICAgICAgIHRoaXMuX3hfZ2V0dGVyID0gZ2V0dGVyO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB5KGdldHRlcikge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX3lfZ2V0dGVyO1xuICAgICAgICBpZiAodHlwZW9mIGdldHRlciAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IEVycm9yKFwieSBnZXR0ZXIgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICB0aGlzLl95X2dldHRlciA9IGdldHRlcjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgc2NhbGVYKHNjYWxlKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5fc2NhbGVfeDtcbiAgICAgICAgdGhpcy5fc2NhbGVfeCA9IHNjYWxlO1xuICAgICAgICBpZiAoc2NhbGUpIHtcbiAgICAgICAgICAgIHNjYWxlLnNldENvdW50R2V0dGVyKGQgPT4gZC5feSk7XG4gICAgICAgICAgICBzY2FsZS5zZXRDb3VudFNldHRlcigoZCwgdikgPT4gZC5feSA9IHYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHNjYWxlWShzY2FsZSkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX3NjYWxlX3k7XG4gICAgICAgIHRoaXMuX3NjYWxlX3kgPSBzY2FsZTtcbiAgICAgICAgaWYgKHNjYWxlKSB7XG4gICAgICAgICAgICBzY2FsZS5zZXRDb3VudEdldHRlcihkID0+IGQuX3gpO1xuICAgICAgICAgICAgc2NhbGUuc2V0Q291bnRTZXR0ZXIoKGQsIHYpID0+IGQuX3ggPSB2KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCBnZW9tZXRyeSB0byByZW5kZXIuIE11bHRpcGxlIGdlb21ldHJpZXMgY2FuIGJlIGFkZGVkLlxuICAgICAqL1xuICAgIGdlb21ldHJ5KGdlb20pIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl9nZW9tZXRyaWVzLnNsaWNlKDApO1xuICAgICAgICBnZW9tLmluZGV4KHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoKTtcbiAgICAgICAgdGhpcy5fZ2VvbWV0cmllcy5wdXNoKGdlb20pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzaXplKGdldHRlcikge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX3NpemU7XG4gICAgICAgIGlmICh0eXBlb2YgZ2V0dGVyICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgRXJyb3IoXCJzaXplIGdldHRlciBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG4gICAgICAgIHRoaXMuX3NpemUgPSBnZXR0ZXI7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZvcm1hdFgoZm9ybWF0dGVyKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5feF9mb3JtYXR0ZXI7XG4gICAgICAgIGlmICh0eXBlb2YgZm9ybWF0dGVyICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgRXJyb3IoXCJmb3JtYXR0ZXIgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICB0aGlzLl94X2Zvcm1hdHRlciA9IGZvcm1hdHRlcjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaW1wb3J0YW5jZVgoaW1wb3J0YW5jZSkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX3hfaW1wb3J0YW5jZTtcbiAgICAgICAgaWYgKHR5cGVvZiBpbXBvcnRhbmNlICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgRXJyb3IoXCJpbXBvcnRhbmNlIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgdGhpcy5feF9pbXBvcnRhbmNlID0gaW1wb3J0YW5jZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZm9ybWF0WShmb3JtYXR0ZXIpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl95X2Zvcm1hdHRlcjtcbiAgICAgICAgaWYgKHR5cGVvZiBmb3JtYXR0ZXIgIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBFcnJvcihcImZvcm1hdHRlciBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG4gICAgICAgIHRoaXMuX3lfZm9ybWF0dGVyID0gZm9ybWF0dGVyO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmb3JtYXRMYWJlbChmb3JtYXR0ZXIpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl9sYWJlbF9mb3JtYXR0ZXI7XG4gICAgICAgIGlmICh0eXBlb2YgZm9ybWF0dGVyICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgRXJyb3IoXCJmb3JtYXR0ZXIgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICB0aGlzLl9sYWJlbF9mb3JtYXR0ZXIgPSBmb3JtYXR0ZXI7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHlBeGlzTGFiZWwobGFiZWwpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl95X2F4aXNfbGFiZWw7XG4gICAgICAgIHRoaXMuX3lfYXhpc19sYWJlbCA9IGxhYmVsO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB4QXhpc0xhYmVsKGxhYmVsKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5feF9heGlzX2xhYmVsO1xuICAgICAgICB0aGlzLl94X2F4aXNfbGFiZWwgPSBsYWJlbDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgc2hvd1hBeGlzKHNob3cpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl9zaG93X3hfYXhpcztcbiAgICAgICAgdGhpcy5fc2hvd194X2F4aXMgPSAhIXNob3c7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHNob3dZQXhpcyhzaG93KSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5fc2hvd195X2F4aXM7XG4gICAgICAgIHRoaXMuX3Nob3dfeV9heGlzID0gISFzaG93O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIGhvdyB0byBzZXBhcmF0ZSBkYXRhIHZpc3VhbGx5IHVzaW5nIGNvbG91cnMuIEl0XG4gICAgICogZG9lcyBub3QgZGVmaW5lIHdoYXQgY29sb3VyIHRvIHVzZS5cbiAgICAgKiBAcGFyYW0gY29sb3VyXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgY29sb3VyKGNvbG91cikge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX2NvbG91cjtcbiAgICAgICAgaWYgKHR5cGVvZiBjb2xvdXIgIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBFcnJvcihcImNvbG91ciBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG4gICAgICAgIHRoaXMuX2NvbG91ciA9IGNvbG91cjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVmaW5lcyBjb2xvdXJzIHRvIHVzZS5cbiAgICAgKiBAcGFyYW0gY29sb3Vyc1xuICAgICAqL1xuICAgIGNvbG91clNjYWxlKGNvbG91cnMpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl9jb2xvdXJfc2NhbGU7XG4gICAgICAgIGlmICh0eXBlb2YgY29sb3VycyAhPT0gJ29iamVjdCcgfHwgIWNvbG91cnMubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoXCJjb2xvdXIgbXVzdCBiZSBhbiBBcnJheVwiKTtcbiAgICAgICAgdGhpcy5fY29sb3VyX3NjYWxlID0gY29sb3VycztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJvdmlkZSBhIGZ1bmN0aW9uIG1hcHBpbmcgeC12YWx1ZSBmaWVsZHMgdG8gYSBjb2xvdXIuIFRoZSBmdW5jdGlvbiBpcyBwYXNzZWRcbiAgICAgKiB0aGUgZ2l2ZW4gZGF0YSB2YWx1ZSwgYWZ0ZXIgaXQgaGFzIGJlZW4gYW5ub3RhdGVkIHdpdGggX3gsIF95LCBfY29sb3VyLCBhbmQgc28gb24uXG4gICAgICogVGhpcyBvdmVycmlkZXNcbiAgICAgKiB0aGUgY29sb3VyIHNjYWxlLiBUaGUgY29sb3VyIHNjYWxlIHdpbGwgYmUgdXNlZCBmb3IgdmFsdWVzIG5vdCBkZWZpbmVkIGJ5IHRoaXMgbWFwLlxuICAgICAqIEBwYXJhbSBjb2xvdXJNYXBcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBpbmRpdmlkdWFsQ29sb3Vycyhjb2xvdXJNYXApIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl9pbmRpdmlkdWFsX2NvbG91cnM7XG4gICAgICAgIGlmICh0eXBlb2YgY29sb3VyTWFwICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgRXJyb3IoXCJjb2xvdXJNYXAgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICB0aGlzLl9pbmRpdmlkdWFsX2NvbG91cnMgPSBjb2xvdXJNYXA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIG1vZGlmeUNvbG91cihtb2RpZmllcikge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX21vZGlmeV9jb2xvdXI7XG4gICAgICAgIGlmICh0eXBlb2YgY29sb3VyTWFwICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgRXJyb3IoXCJtb2RpZmllciBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG4gICAgICAgIHRoaXMuX21vZGlmeV9jb2xvdXIgPSBtb2RpZmllcjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZmFjZXRYKHNlbGVjdG9yKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5fZmFjZXRfeDtcbiAgICAgICAgaWYgKHNlbGVjdG9yICE9IG51bGwgJiYgdHlwZW9mIHNlbGVjdG9yICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZmFjZXQgc2VsZWN0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICB0aGlzLl9mYWNldF94ID0gc2VsZWN0b3I7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdG8gc2hvdyBsYWJlbHMgb3Igbm90LiBUaGlzIGlzIHJldGFpbmVkIG1vZGU6IGl0IHdpbGwgbm90IHNob3cgdGhlIGxhYmVsc1xuICAgICAqIGltbWVkaWF0ZWx5LiBQbGVhc2UgY2FsbCAjcmVuZGVyKCkgYWdhaW4gdG8gc2hvdyB0aGUgbGFiZWxzLlxuICAgICAqL1xuICAgIHNob3dMYWJlbHMoc2hvdykge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX3Nob3dfbGFiZWxzO1xuICAgICAgICB0aGlzLl9zaG93X2xhYmVscyA9ICEhc2hvdztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdG8gc2hvdyB0aGUgbGVnZW5kIG9yIG5vdC4gVGhpcyBpcyByZXRhaW5lZCBtb2RlOiB5b3UgbmVlZCB0b1xuICAgICAqIGNhbGwgcmVuZGVyIGFmdGVyIHNldHRpbmcgdGhpcyB0byBzZWUgYSBjaGFuZ2UuXG4gICAgICogQHBhcmFtIHNob3dcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBzaG93TGVnZW5kKHNob3cpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl9zaG93X2xlZ2VuZDtcbiAgICAgICAgdGhpcy5fc2hvd19sZWdlbmQgPSAhIXNob3c7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByb3ZpZGUgYSBmdW5jdGlvbiB0byBvdmVycmlkZSB0aGUgbWFwcGluZyBvZiBsZWdlbmQgbmFtZXMgdG8gY29sb3Vycy5cbiAgICAgKi9cbiAgICBsZWdlbmRDb2xvdXJzKGNvbG91ck1hcCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX2xlZ2VuZF9jb2xvdXJzO1xuICAgICAgICBpZiAodHlwZW9mIGNvbG91ck1hcCAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IEVycm9yKFwiY29sb3VyTWFwIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgdGhpcy5fbGVnZW5kX2NvbG91cnMgPSBjb2xvdXJNYXA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZvbnRTaXplKHB4KSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5fZm9udF9zaXplO1xuICAgICAgICBpZiAodHlwZW9mIHB4ICE9PSBcIm51bWJlclwiICYmIHB4ID4gMCkgdGhyb3cgbmV3IEVycm9yKFwiZm9udFNpemUgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlclwiKTtcbiAgICAgICAgdGhpcy5fZm9udF9zaXplID0gcHg7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHhHcmlkTGluZXMoc2hvdykge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX3hfZ3JpZF9saW5lcztcbiAgICAgICAgdGhpcy5feF9ncmlkX2xpbmVzID0gISFzaG93O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB5R3JpZExpbmVzKHNob3cpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl95X2dyaWRfbGluZXM7XG4gICAgICAgIHRoaXMuX3lfZ3JpZF9saW5lcyA9ICEhc2hvdztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgYXhpc0JveChzaG93KSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5fYXhpc19ib3g7XG4gICAgICAgIHRoaXMuX2F4aXNfYm94ID0gISFzaG93O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB4TGFiZWxBbmdsZShkZWdyZWVzKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5feF9sYWJlbF9hbmdsZTtcbiAgICAgICAgaWYgKGRlZ3JlZXMgIT09IG51bGwgJiYgdHlwZW9mIGRlZ3JlZXMgIT09IFwibnVtYmVyXCIpIHRocm93IG5ldyBFcnJvcihcImRlZ3JlZXMgbXVzdCBiZSBhIG51bWJlciBvciBudWxsXCIpO1xuICAgICAgICB0aGlzLl94X2xhYmVsX2FuZ2xlID0gZGVncmVlcztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZ3JpZExpbmVPcGFjaXR5KG9wYWNpdHkpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl9ncmlkX2xpbmVfb3BhY2l0eTtcbiAgICAgICAgaWYgKHR5cGVvZiBvcGFjaXR5ICE9PSBcIm51bWJlclwiKSB0aHJvdyBuZXcgRXJyb3IoXCJvcGFjaXR5IG11c3QgYmUgYSBudW1iZXIgb3IgbnVsbFwiKTtcbiAgICAgICAgdGhpcy5fZ3JpZF9saW5lX29wYWNpdHkgPSBvcGFjaXR5O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZnVuY3Rpb24gaXMgcGFzc2VkIHRoZSB4U2NhbGUgYW5kIG11c3QgcmV0dXJuIG51bGwgb3IgYW4gYXJyYXkgb2YgdmFsdWVzIHRvIHVzZSBmb3IgdGlja3MuXG4gICAgICovXG4gICAgeFRpY2tWYWx1ZXNGbihmbikge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX3hfdGlja192YWx1ZXNfZm47XG4gICAgICAgIGlmIChmbiAmJiB0eXBlb2YgZm4gIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IEVycm9yKFwiZm4gbXVzdCBiZSBhbiBmdW5jdGlvbiBvciBudWxsXCIpO1xuICAgICAgICB0aGlzLl94X3RpY2tfdmFsdWVzX2ZuID0gZm47XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBmdW5jdGlvbiBpcyBwYXNzZWQgdGhlIHlTY2FsZSBhbmQgbXVzdCByZXR1cm4gbnVsbCBvciBhbiBhcnJheSBvZiB2YWx1ZXMgdG8gdXNlIGZvciB0aWNrcy5cbiAgICAgKi9cbiAgICB5VGlja1ZhbHVlc0ZuKGZuKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5feV90aWNrX3ZhbHVlc19mbjtcbiAgICAgICAgaWYgKGZuICYmIHR5cGVvZiBmbiAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgRXJyb3IoXCJmbiBtdXN0IGJlIGFuIGZ1bmN0aW9uIG9yIG51bGxcIik7XG4gICAgICAgIHRoaXMuX3lfdGlja192YWx1ZXNfZm4gPSBmbjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBvciBoaWRlcyBsYWJlbHMgYXMgdGhleSBhcmUgcmVxdWVzdGVkLlxuICAgICAqL1xuICAgIGltbWVkaWF0ZWx5UmVuZGVyTGFiZWxzKHNob3cpIHtcbiAgICAgICAgaWYgKHRoaXMuX2dlb21ldHJpZXMpIHtcbiAgICAgICAgICAgIHRoaXMuX2dlb21ldHJpZXMuZm9yRWFjaChnZW9tID0+IGdlb20uaW1tZWRpYXRlbHlSZW5kZXJMYWJlbHMoISFzaG93KSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBldmVudCBoYW5kbGUgZm9yIHRoZSBjaGFydHMuIFN1cHBvcnRzIHRoZSBmb2xsb3dpbmcgZXZlbnRzOlxuICAgICAqXG4gICAgICogLSBlbGVtZW50Q2xpY2tcbiAgICAgKiAtIHRvb2x0aXBTaG93XG4gICAgICogLSB0b29sdGlwSGlkZVxuICAgICAqXG4gICAgICogQHJldHVybnMgeyp8RGlzcGF0Y2h9XG4gICAgICovXG4gICAgZGlzcGF0Y2goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaXNwYXRjaDtcbiAgICB9XG5cbiAgICBkYXRhKGRhdGEpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl9kYXRhLnNsaWNlKCk7XG4gICAgICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY2hhcnQncyBuYW1lLCBhcyBkZWZpbmVkIGluIHRoZSBjb25zdHJ1Y3RvclxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIENyZWF0ZSBpbml0aWFsIHN2ZyBlbGVtZW50XG4gICAgICAgIGxldCBzdmcgPSBkMy5zZWxlY3QodGhpcy5fZWxlbWVudCkuc2VsZWN0KFwic3ZnXCIpO1xuICAgICAgICBpZiAoc3ZnLmVtcHR5KCkpIHN2ZyA9IGQzLnNlbGVjdCh0aGlzLl9lbGVtZW50KS5hcHBlbmQoXCJzdmdcIik7XG5cbiAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBTZXR1cCBpbml0aWFsIGRhdGFcblxuICAgICAgICBjb25zdCBicyA9IGJ1Y2tldHModGhpcy5fZGF0YSwgdGhpcy5fY29sb3VyLCB0aGlzLl9pbmRpdmlkdWFsX2NvbG91cnMsIHRoaXMuX3NpemUpO1xuICAgICAgICBjb25zdCBjb2xvdXJTY2FsZSA9IHRoaXMuX2QzX2NvbG91cl9zY2FsZSA9IGQzLnNjYWxlT3JkaW5hbCh0aGlzLmNvbG91clNjYWxlKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZG9tYWluKEFycmF5LmZyb20oYnMuY29sb3VycykpO1xuICAgICAgICBjb25zdCBheGlzT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGZvbnRTaXplOiB0aGlzLl9mb250X3NpemUsXG4gICAgICAgICAgICB4TGFiZWxBbmdsZTogdGhpcy5feF9sYWJlbF9hbmdsZSxcbiAgICAgICAgICAgIGdyaWRMaW5lT3BhY2l0eTogdGhpcy5fZ3JpZF9saW5lX29wYWNpdHksXG4gICAgICAgICAgICBheGlzQm94OiB0aGlzLl9heGlzX2JveFxuICAgICAgICB9XG5cbiAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIHNwYWNlIHRoYXQgdmFyaW91cyBlbGVtZW50cyB3aWxsIHdhbnQgdG8gdGFrZSB1cC4gV2UgYWxzb1xuICAgICAgICAvLyByZXN0cmljdCB0aGUgeSBheGlzIGJ5IGEgcHJvcG9ydGlvbiBvZiB0aGUgd2lkdGggb2YgdGhlIG1ldHJpYy5cblxuICAgICAgICBjb25zdCB5QXhpc1Jlc3RyaWN0aW9uID0gTWF0aC5tYXgoKHRoaXMuX3dpZHRoICogMC4wNyksIDI1KTtcblxuICAgICAgICBjb25zdCBnZW9tZXRyaWVzID0gdGhpcy5zb3J0R2VvbWV0cmllcygpO1xuICAgICAgICBnZW9tZXRyaWVzLmZvckVhY2goZ2VvbSA9PiB0aGlzLnNldHVwR2VvbShnZW9tKSk7XG5cbiAgICAgICAgbGV0IGF4aXNXaWR0aCA9IDA7XG4gICAgICAgIGlmICh0aGlzLl9zaG93X3lfYXhpcyl7XG4gICAgICAgICAgICBheGlzV2lkdGggPSBnZW9tZXRyaWVzLmxlbmd0aFxuICAgICAgICAgICAgICAgID8gbWF4Qm91bmRpbmcoc3ZnLCBnZW9tZXRyaWVzWzBdLnlWYWx1ZXMoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChnZW9tZXRyaWVzWzBdLmZvcm1hdFkoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoZCA9PiByZXN0cmljdExlbmd0aChkLCB5QXhpc1Jlc3RyaWN0aW9uKSksIG51bGwsIHRoaXMuX2ZvbnRfc2l6ZSkud2lkdGggKyAxNVxuICAgICAgICAgICAgICAgIDogMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gRHJhdyB0aGUgbGVnZW5kXG4gICAgICAgIGlmICghdGhpcy5fc2hvd19sZWdlbmQpIHJlbW92ZUxlZ2VuZChzdmcpO1xuICAgICAgICBjb25zdCBsZWdlbmRIZWlnaHQgPSB0aGlzLl9zaG93X2xlZ2VuZFxuICAgICAgICAgICAgPyByZW5kZXJMZWdlbmQoc3ZnLCBicywgKGQpID0+IHRoaXMuX2xlZ2VuZF9jb2xvdXJzKGQpIHx8IGJzLmJ1Y2tldENvbG91cltkXSB8fCBjb2xvdXJTY2FsZShkKSwgdGhpcy5fd2lkdGgsIHRoaXMuX2hlaWdodCwgbnVsbCwgYXhpc09wdGlvbnMpXG4gICAgICAgICAgICA6IDA7XG5cbiAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBDYWxjdWxhdGUgbWFyZ2lucyB3aXRob3V0IGtub3dpbmcgdGhlIGZpbmFsIGhlaWdodC5cbiAgICAgICAgLy8gV2UgY2FuIG9ubHkgY2FsY3VsYXRlIHRoZSBmaW5hbCBoZWlnaHQgb25jZSB3ZSBjYW4gYWNjdXJhdGVseVxuICAgICAgICAvLyBkZXRlcm1pbmUgaG93IHRvIGxheSBvdXQgdGhlIHgtYXhpcy5cblxuICAgICAgICBjb25zdCBvdXRlclBhZGRpbmcgPSAyMDtcblxuICAgICAgICBjb25zdCBtYXJnaW4gPSB7XG4gICAgICAgICAgICB0b3A6IG91dGVyUGFkZGluZyxcbiAgICAgICAgICAgIHJpZ2h0OiBvdXRlclBhZGRpbmcsXG4gICAgICAgICAgICBib3R0b206IG91dGVyUGFkZGluZyArIGxlZ2VuZEhlaWdodCxcbiAgICAgICAgICAgIGxlZnQ6IG91dGVyUGFkZGluZyArIGF4aXNXaWR0aFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5fc2hvd195X2F4aXMgJiYgdGhpcy5feV9heGlzX2xhYmVsKSBtYXJnaW4ubGVmdCArPSAyMDtcbiAgICAgICAgaWYgKHRoaXMuX3Nob3dfeF9heGlzICYmIHRoaXMuX3hfYXhpc19sYWJlbCkgbWFyZ2luLmJvdHRvbSArPSA0MDtcbiAgICAgICAgY29uc3Qgd2lkdGggID0gdGhpcy5fd2lkdGggLSBtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodDtcbiAgICAgICAgY29uc3QgbGVmdE91dGVyUGFkZGluZyA9IG91dGVyUGFkZGluZyArICh0aGlzLl95X2F4aXNfbGFiZWwgPyAyMCA6IDApO1xuXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gRGV0ZXJtaW5lIGluaXRpYWwgZmFjZXQgLyBzbWFsbCBtdWx0aXBsZSBpbmZvcm1hdGlvblxuXG4gICAgICAgIGNvbnN0IGZhY2V0cyA9IGdldEZhY2V0cyh0aGlzLl9kYXRhLCB0aGlzLl9mYWNldF94KTtcbiAgICAgICAgY29uc3Qgc2luZ2xlRmFjZXQgPSBmYWNldHMubGVuZ3RoID09PSAxO1xuXG4gICAgICAgIGNvbnN0IGZhY2V0QmFuZCA9IGQzLnNjYWxlQmFuZCgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJhbmdlUm91bmQoWzAsIHdpZHRoXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAucGFkZGluZyhzaW5nbGVGYWNldCA/IDAgOiAwLjEpIC8vIHRha2UgdXAgZnVsbCBzcGFjZSBpZiB0aGUgb25seSBmYWNldC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZG9tYWluKGZhY2V0cyk7XG5cbiAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBEZXRlcm1pbmUgeC1heGlzIGhlaWdodFxuICAgICAgICAvLyBXZSBkbyB0aGlzIGJ5IHJlbmRlcmluZyB0aGUgdmFyaW91cyB4LWF4ZXMgb2Zmc2NyZWVuLlxuXG4gICAgICAgIGNvbnN0IHhUaWNrQ291bnQgPSBNYXRoLmZsb29yKHdpZHRoIC8gOTApO1xuXG4gICAgICAgIGdlb21ldHJpZXMuZm9yRWFjaChnZW9tID0+IGdlb20ud2lkdGgoZmFjZXRCYW5kLmJhbmR3aWR0aCgpKSk7XG4gICAgICAgIGNvbnN0IGF4aXNTaXplQXJlYSA9IHN2Zy5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZSgtMTAwMCwgLTEwMDApXCIpO1xuXG4gICAgICAgIGNvbnN0IHhBeGlzUmVzdHJpY3Rpb24gPSBNYXRoLm1pbigyNSwgTWF0aC5tYXgodGhpcy5faGVpZ2h0ICogMC4wNywgMTIpKTtcbiAgICAgICAgbGV0IGF4aXNIZWlnaHQgPSAwO1xuICAgICAgICBpZiAodGhpcy5fc2hvd194X2F4aXMpe1xuICAgICAgICAgICAgZmFjZXRzLmZvckVhY2goZmFjZXQgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHhTY2FsZSA9IGdlb21ldHJpZXNbMF1cbiAgICAgICAgICAgICAgICAgICAgLndpZHRoKGZhY2V0QmFuZC5iYW5kd2lkdGgoKSlcbiAgICAgICAgICAgICAgICAgICAgLmZhY2V0KHNpbmdsZUZhY2V0ID8gbnVsbCA6IChkID0+IHRoaXMuX2ZhY2V0X3goZCkgPT09IGZhY2V0KSlcbiAgICAgICAgICAgICAgICAgICAgLmdldEQzWFNjYWxlKCk7XG5cbiAgICAgICAgICAgICAgICBsZXQgYXhpcyA9IGQzLmF4aXNCb3R0b20oeFNjYWxlKS50aWNrcyh4VGlja0NvdW50KS50aWNrU2l6ZSgwKS50aWNrUGFkZGluZyg2KVxuICAgICAgICAgICAgICAgICAgICAudGlja0Zvcm1hdCgoZCwgaSkgPT4gcmVzdHJpY3RMZW5ndGgoZ2VvbWV0cmllc1swXS5mb3JtYXRYKCkoZCwgaSksIHhBeGlzUmVzdHJpY3Rpb24pKVxuICAgICAgICAgICAgICAgICAgICAudGlja1ZhbHVlcyh0aGlzLl94X3RpY2tfdmFsdWVzX2ZuID8gdGhpcy5feF90aWNrX3ZhbHVlc19mbih4U2NhbGUpIDogbnVsbClcbiAgICAgICAgICAgICAgICBsZXQgaGVpZ2h0ID0geGF4aXMoYXhpc1NpemVBcmVhLCB0aGlzLl9oZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgIHhTY2FsZS5iYW5kd2lkdGggPyB4U2NhbGUuYmFuZHdpZHRoKCkgOiBmYWNldEJhbmQuYmFuZHdpZHRoKCkgLyB4U2NhbGUuZG9tYWluKCkubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICBheGlzLCB0aGlzLmltcG9ydGFuY2VYKCksIGF4aXNPcHRpb25zKTtcblxuICAgICAgICAgICAgICAgIGF4aXNIZWlnaHQgPSBNYXRoLm1heChoZWlnaHQsIGF4aXNIZWlnaHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBheGlzU2l6ZUFyZWEucmVtb3ZlKCk7XG5cbiAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBVcGRhdGUgbWFyZ2lucyBhbmQgY2FsY3VsYXRlIGhlaWdodFxuXG4gICAgICAgIG1hcmdpbi5ib3R0b20gKz0gYXhpc0hlaWdodDtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gdGhpcy5faGVpZ2h0IC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b207XG5cbiAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBTZXR1cCB0aGUgc3ZnXG5cbiAgICAgICAgc3ZnXG4gICAgICAgICAgICAuc3R5bGUoXCJ3aWR0aFwiLCB0aGlzLl93aWR0aCArIFwicHhcIilcbiAgICAgICAgICAgIC5zdHlsZShcImhlaWdodFwiLCB0aGlzLl9oZWlnaHQgKyBcInB4XCIpO1xuXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gQW4gYXJlYSBmb3IgdXMgdG8gcmVuZGVyIHRoZSBnZW9tZXRyaWVzIGluIHRvLlxuXG4gICAgICAgIGxldCBkcmF3aW5nQXJlYSA9IHN2Zy5zZWxlY3QoJy5kcmF3aW5nLWFyZWEnKTtcblxuICAgICAgICBpZiAoZHJhd2luZ0FyZWEuZW1wdHkoKSkge1xuICAgICAgICAgICAgZHJhd2luZ0FyZWEgPSBzdmdcbiAgICAgICAgICAgICAgICAuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJkcmF3aW5nLWFyZWFcIilcbiAgICAgICAgfVxuXG4gICAgICAgIGRyYXdpbmdBcmVhLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyBtYXJnaW4ubGVmdCArIFwiLFwiICsgbWFyZ2luLnRvcCArIFwiKVwiKTtcblxuXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gU2V0IHVwIHNtYWxsIG11bHRpcGxlcyAvIGZhY2V0c1xuXG4gICAgICAgIGxldCBmYWNldEFyZWFzID0gZHJhd2luZ0FyZWEuc2VsZWN0QWxsKCcuZmFjZXQnKS5kYXRhKGZhY2V0cyk7XG4gICAgICAgIGZhY2V0QXJlYXMuZXhpdCgpLnJlbW92ZSgpO1xuXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gU2V0dXAgYXhlcy5cblxuICAgICAgICBsZXQgeEF4aXNBcmVhID0gc3ZnLnNlbGVjdChcIi54LWF4aXMtYXJlYVwiKTtcblxuICAgICAgICB4QXhpc0FyZWEucmVtb3ZlKCk7XG4gICAgICAgIHhBeGlzQXJlYSA9IHN2Z1xuICAgICAgICAgICAgLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJ4LWF4aXMtYXJlYVwiKTtcblxuICAgICAgICB4QXhpc0FyZWEuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIG1hcmdpbi5sZWZ0ICsgXCIsXCIgKyAobWFyZ2luLnRvcCArIGhlaWdodCkgK1wiKVwiKS5sb3dlcigpO1xuXG4gICAgICAgIGxldCB5QXhpc0FyZWEgPSBzdmcuc2VsZWN0KFwiLnktYXhpcy1hcmVhXCIpO1xuICAgICAgICBjb25zdCB5VGlja0NvdW50ID0gTWF0aC5mbG9vcihoZWlnaHQgLyA5MCk7XG5cbiAgICAgICAgeUF4aXNBcmVhLnJlbW92ZSgpO1xuICAgICAgICB5QXhpc0FyZWEgPSBzdmdcbiAgICAgICAgICAgIC5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwieS1heGlzLWFyZWFcIilcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgbWFyZ2luLmxlZnQgK1wiLFwiICsgbWFyZ2luLnRvcCArIFwiKVwiKS5sb3dlcigpO1xuXG4gICAgICAgIGNvbnN0IHlTY2FsZSA9IGdlb21ldHJpZXMubGVuZ3RoID8gZ2VvbWV0cmllc1swXS5oZWlnaHQoaGVpZ2h0KS5nZXREM1lTY2FsZSgpIDogbnVsbDtcbiAgICAgICAgaWYgKGdlb21ldHJpZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBEcmF3IHRoZSB5YXhpcy5cblxuICAgICAgICAgICAgbGV0IHR2ID0gdGhpcy5feV90aWNrX3ZhbHVlc19mbiA/IHRoaXMuX3lfdGlja192YWx1ZXNfZm4oeVNjYWxlKSA6IG51bGxcbiAgICAgICAgICAgIGxldCB0YyA9IE1hdGguZmxvb3IoaGVpZ2h0IC8gMzApXG4gICAgICAgICAgICBpZiAodGMgPD0gMiAmJiAhdHYpIHR2ID0geVNjYWxlLmRvbWFpbigpXG4gICAgICAgICAgICBpZiAodGhpcy5fc2hvd195X2F4aXMpIHtcbiAgICAgICAgICAgICAgICB5YXhpcyh5QXhpc0FyZWEsXG4gICAgICAgICAgICAgICAgICAgIGQzLmF4aXNMZWZ0KHlTY2FsZSkudGlja3ModGMpXG4gICAgICAgICAgICAgICAgICAgICAgICAudGlja1NpemUodGhpcy5feV9ncmlkX2xpbmVzID8gLXdpZHRoIDogMClcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aWNrUGFkZGluZyg2KVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRpY2tWYWx1ZXModHYpXG4gICAgICAgICAgICAgICAgICAgICAgICAudGlja0Zvcm1hdCgoZCwgaSkgPT4gcmVzdHJpY3RMZW5ndGgoZ2VvbWV0cmllc1swXS5mb3JtYXRZKCkoZCwgaSksIHlBeGlzUmVzdHJpY3Rpb24pKSwgLy87LnRpY2tGb3JtYXQodGhpcy5fdGlja0Zvcm1hdCkpO1xuICAgICAgICAgICAgICAgICAgICBheGlzT3B0aW9ucyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIERyYXcgYSBsaXR0bGUgeC1heGlzIGZvciBldmVyeSBmYWNldC5cbiAgICAgICAgICAgIGlmICh0aGlzLl9zaG93X3hfYXhpcykge1xuICAgICAgICAgICAgICAgIGZhY2V0cy5mb3JFYWNoKGZhY2V0ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeFNjYWxlID0gZ2VvbWV0cmllc1swXVxuICAgICAgICAgICAgICAgICAgICAgICAgLndpZHRoKGZhY2V0QmFuZC5iYW5kd2lkdGgoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5oZWlnaHQoaGVpZ2h0KVxuICAgICAgICAgICAgICAgICAgICAgICAgLmZhY2V0KHNpbmdsZUZhY2V0ID8gbnVsbCA6IChkID0+IHRoaXMuX2ZhY2V0X3goZCkgPT09IGZhY2V0KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5nZXREM1hTY2FsZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFyZWEgPSB4QXhpc0FyZWFcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIChmYWNldEJhbmQoZmFjZXQpKSArIFwiLDApXCIpLy8gKyAodGhpcy5faGVpZ2h0IC0gYXhpc0hlaWdodCkgK1wiKVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCBmYWNldEJhbmQuYmFuZHdpZHRoKCkpO1xuXG5cbiAgICAgICAgICAgICAgICAgICAgeGF4aXMoYXJlYSwgdGhpcy5faGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgeFNjYWxlLmJhbmR3aWR0aCA/IHhTY2FsZS5iYW5kd2lkdGgoKSA6IGZhY2V0QmFuZC5iYW5kd2lkdGgoKSAvIHhTY2FsZS5kb21haW4oKS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBkMy5heGlzQm90dG9tKHhTY2FsZSkudGlja3MoeFRpY2tDb3VudCkudGlja1NpemUodGhpcy5feF9ncmlkX2xpbmVzID8gLWhlaWdodCA6IDApLnRpY2tQYWRkaW5nKDYpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRpY2tGb3JtYXQoKGQsIGkpID0+IHJlc3RyaWN0TGVuZ3RoKGdlb21ldHJpZXNbMF0uZm9ybWF0WCgpKGQsIGkpLCB4QXhpc1Jlc3RyaWN0aW9uKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGlja1ZhbHVlcyh0aGlzLl94X3RpY2tfdmFsdWVzX2ZuID8gdGhpcy5feF90aWNrX3ZhbHVlc19mbih4U2NhbGUpIDogbnVsbCksXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmltcG9ydGFuY2VYKCksIGF4aXNPcHRpb25zKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIFNldHVwIGxhYmVsc1xuXG4gICAgICAgIGlmICh0aGlzLl9zaG93X3lfYXhpcykge1xuICAgICAgICAgICAgeUF4aXNMYWJlbChzdmcsIGhlaWdodCwgbWFyZ2luLCB0aGlzLl95X2F4aXNfbGFiZWwsIGF4aXNPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fc2hvd194X2F4aXMpIHtcbiAgICAgICAgICAgIHhBeGlzTGFiZWwoc3ZnLCB3aWR0aCwgaGVpZ2h0LCBtYXJnaW4sIHRoaXMuX3hfYXhpc19sYWJlbCwgYXhpc09wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBEcmF3IGluZGl2aWR1YWwgZ2VvbWV0cmllcy5cblxuICAgICAgICBmYWNldEFyZWFzXG4gICAgICAgICAgICAuZW50ZXIoKVxuICAgICAgICAgICAgLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJmYWNldFwiKVxuICAgICAgICAgICAgLm1lcmdlKGZhY2V0QXJlYXMpXG4gICAgICAgICAgICAuYXR0cihcIndpZHRoXCIsIGZhY2V0QmFuZC5iYW5kd2lkdGgoKSlcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIGZhY2V0SWQgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChzaW5nbGVGYWNldCkgcmV0dXJuIFwidHJhbnNsYXRlKDAsMClcIjtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJ0cmFuc2xhdGUoXCIgKyBmYWNldEJhbmQoZmFjZXRJZCkgKyBcIiwwKVwiO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5lYWNoKChmYWNldCwgZmFjZXRfaSwgZmFjZXROb2RlcykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFyZWEgPSBkMy5zZWxlY3QoZmFjZXROb2Rlc1tmYWNldF9pXSk7XG5cbiAgICAgICAgICAgICAgICBsZXQgZ2VvbXMgPSBhcmVhLnNlbGVjdEFsbChcIi5nZW9tZXRyeVwiKS5kYXRhKGdlb21ldHJpZXMsIGQgPT4gZC5rZXkoKSk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCB4c2NhbGUgPSBnZW9tZXRyaWVzWzBdLmdldEQzWFNjYWxlKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgZ2VvbV93aWR0aCAgPSBmYWNldEJhbmQuYmFuZHdpZHRoKCksXG4gICAgICAgICAgICAgICAgICAgICAgZ2VvbV9oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICAgICAgICAgICAgICAvL3lHcmlkKGFyZWEsIGdlb21fd2lkdGgsIHRoaXMuc2NhbGVZKCkuaXNTaG93R3JpZCgpLCBkMy5heGlzTGVmdCh5U2NhbGUpLnRpY2tzKHlUaWNrQ291bnQpKTtcbiAgICAgICAgICAgICAgICAvL3hHcmlkKGFyZWEsIGdlb21faGVpZ2h0LCB0aGlzLnNjYWxlWCgpLmlzU2hvd0dyaWQoKSwgZDMuYXhpc0JvdHRvbSh4c2NhbGUpLnRpY2tzKHhUaWNrQ291bnQpKTtcblxuICAgICAgICAgICAgICAgIGdlb21zLmV4aXQoKS5yZW1vdmUoKTtcblxuICAgICAgICAgICAgICAgIGdlb21zLmVudGVyKClcbiAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwiZ2VvbWV0cnlcIilcbiAgICAgICAgICAgICAgICAgICAgIC5tZXJnZShnZW9tcylcbiAgICAgICAgICAgICAgICAgICAgIC5lYWNoKChnZW9tLCBpLCBub2RlcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGdlb21fdG9wICA9IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VvbV9sZWZ0ID0gMDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBub2RlID0gZDMuc2VsZWN0KG5vZGVzW2ldKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyBnZW9tX2xlZnQgKyBcIixcIiArIGdlb21fdG9wICsgXCIpXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5lYWNoKChkLCBpLCBub2RlcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VvbS5lbGVtZW50KGQzLnNlbGVjdChub2Rlc1tpXSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZhY2V0KHNpbmdsZUZhY2V0ID8gbnVsbCA6IChkID0+IHRoaXMuX2ZhY2V0X3goZCkgPT09IGZhY2V0KSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuaGVpZ2h0KGdlb21faGVpZ2h0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC53aWR0aChnZW9tX3dpZHRoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZW5kZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gRW5zdXJlIHRoaXMgaXMgcmVuZGVyZWQgb24gdG9wIG9mIG90aGVyIHRoaW5ncy5cbiAgICAgICAgICAgICAgICBhcmVhLnNlbGVjdChcIi54LWF4aXNcIikucmFpc2UoKTtcbiAgICAgICAgICAgIH0pXG5cbiAgICB9XG5cblxuICAgIC8qXG4gICAgICogRW5zdXJlcyB0aGF0IGVhY2ggZ2VvbSBoYXMgdGhlIHNldHRpbmdzIHRoYXQgaXQgbmVlZHMuXG4gICAgICovXG4gICAgc2V0dXBHZW9tKGdlb20pIHtcbiAgICAgICAgZ2VvbS5zZXR1cFgodGhpcy5feF9nZXR0ZXIpXG4gICAgICAgICAgICAuc2V0dXBZKHRoaXMuX3lfZ2V0dGVyKVxuICAgICAgICAgICAgLnNldHVwQ29sb3VyKHRoaXMuX2NvbG91cilcbiAgICAgICAgICAgIC5zZXR1cFNpemUodGhpcy5fc2l6ZSlcbiAgICAgICAgICAgIC5zZXR1cFNjYWxlWCh0aGlzLl9zY2FsZV94KVxuICAgICAgICAgICAgLnNldHVwU2NhbGVZKHRoaXMuX3NjYWxlX3kpXG4gICAgICAgICAgICAuc2V0dXBGb3JtYXRYKHRoaXMuX3hfZm9ybWF0dGVyKVxuICAgICAgICAgICAgLnNldHVwRm9ybWF0WSh0aGlzLl95X2Zvcm1hdHRlcilcbiAgICAgICAgICAgIC5zZXR1cEZvcm1hdExhYmVsKHRoaXMuX2xhYmVsX2Zvcm1hdHRlcilcbiAgICAgICAgICAgIC5zZXR1cENvbG91clNjYWxlKHRoaXMuX2NvbG91cl9zY2FsZSlcbiAgICAgICAgICAgIC5zZXR1cEluZGl2aWR1YWxDb2xvdXJzKHRoaXMuX2luZGl2aWR1YWxfY29sb3VycylcbiAgICAgICAgICAgIC5zZXR1cE1vZGlmeUNvbG91cih0aGlzLl9tb2RpZnlfY29sb3VyKVxuICAgICAgICAgICAgLnNldHVwU2hvd0xhYmVscyh0aGlzLl9zaG93X2xhYmVscylcbiAgICAgICAgICAgIC5kM0NvbG91clNjYWxlKHRoaXMuX2QzX2NvbG91cl9zY2FsZSlcbiAgICAgICAgICAgIC5zZXR1cFlBeGlzTGFiZWwodGhpcy5feV9heGlzX2xhYmVsKVxuICAgICAgICAgICAgLnNldHVwWEF4aXNMYWJlbCh0aGlzLl94X2F4aXNfbGFiZWwpXG4gICAgICAgICAgICAuZm9udFNpemUodGhpcy5fZm9udF9zaXplKTtcbiAgICAgICAgZ2VvbS5fZGlzcGF0Y2gub24oXCJlbGVtZW50Q2xpY2tcIiwgKGUpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2Rpc3BhdGNoLmNhbGwoXCJlbGVtZW50Q2xpY2tcIiwgdGhpcywgZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBnZW9tLl9kaXNwYXRjaC5vbihcInRvb2x0aXBIaWRlXCIsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2Rpc3BhdGNoLmNhbGwoXCJ0b29sdGlwSGlkZVwiLCB0aGlzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGdlb20uX2Rpc3BhdGNoLm9uKFwidG9vbHRpcFNob3dcIiwgKGUpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2Rpc3BhdGNoLmNhbGwoXCJ0b29sdGlwU2hvd1wiLCB0aGlzLCBlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGdlb20uZGF0YSh0aGlzLl9kYXRhKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFdlIHdhbnQgdG8gZW5zdXJlIHRoYXQgZ2VvbWV0cmllcyBoYXZlIGEgcGFydGljdWxhciBvcmRlciB0byB0aGVtLlxuICAgICAqIFRoaXMgaXMgaW1wb3J0YW50IGZvciByZW5kZXJpbmc6IGxpbmVzIHNob3VsZCBiZSByZW5kZXJlZCBvbiB0b3Agb2ZcbiAgICAgKiBsYXJnZSBoaXN0b2dyYW0gcmVjdGFuZ2xlcywgZm9yIGluc3RhbmNlLCBvdGhlcndpc2UgdGhleSB3aWxsIGJlIGhpZGRlbi5cbiAgICAgKi9cbiAgICBzb3J0R2VvbWV0cmllcygpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9nZW9tZXRyaWVzIHx8ICF0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aCkgcmV0dXJuIFtdO1xuXG4gICAgICAgIGxldCBnZW9tZXRyaWVzID0gdGhpcy5fZ2VvbWV0cmllcy5zbGljZSgwKTtcbiAgICAgICAgZ2VvbWV0cmllcy5zb3J0KChsaHMsIHJocykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGxocy5wcmlvcml0eSgpIC0gcmhzLnByaW9yaXR5KCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBnZW9tZXRyaWVzO1xuICAgIH1cbn1cblxuXG4vKlxuICogUmV0dXJucyB0aGUgdW5pcXVlIGZhY2V0IGNob2ljZXMgZnJvbSB0aGUgZGF0YSwgZ2l2ZW4gYSBmYWNldCBzZWxlY3Rvci5cbiAqL1xuZnVuY3Rpb24gZ2V0RmFjZXRzKGRhdGEsIHNlbGVjdG9yKSB7XG4gICAgaWYgKCFzZWxlY3RvciB8fCAhZGF0YSB8fCAhZGF0YS5sZW5ndGgpIHJldHVybiBbMV07XG5cbiAgICBjb25zdCBrZXlzID0gbmV3IFNldChkYXRhLm1hcChzZWxlY3RvcikpO1xuICAgIHJldHVybiBbLi4ua2V5c107XG59XG5cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgY2hhcnQgb2JqZWN0LlxuICogQHBhcmFtIG5hbWUgQW4gb3B0aW9uYWwgbmFtZSBmb3IgdGhlIGNoYXJ0LlxuICogQHJldHVybnMge0ZhbnRhc3RpY0NoYXJ0fVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2hhcnQobmFtZSkge1xuICAgIHJldHVybiBuZXcgRmFudGFzdGljQ2hhcnQobmFtZSk7XG59Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/chart/FantasticChart.js\n')},"./src/chart/Geometry.js":
/*!*******************************!*\
  !*** ./src/chart/Geometry.js ***!
  \*******************************/
/*! exports provided: Geometry, getColor, getKey, fromKey */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Geometry", function() { return Geometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getColor", function() { return getColor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getKey", function() { return getKey; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromKey", function() { return fromKey; });\n// Copyright (C) 2013-2014, 2018 BrandsEye (PTY) LTD\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this\n// software and associated documentation files (the "Software"), to deal in the Software\n// without restriction, including without limitation the rights to use, copy, modify,\n//     merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following\n// conditions:\n//\n//     The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n//     INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n// CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\nclass Geometry {\n\n    constructor(name, priority) {\n        this._name = name || "[UNNAMED GEOMETRY]";\n        this._chart_x_getter = null;\n        this._chart_y_getter = null;\n        this._x_getter = null;\n        this._y_getter = null;\n        this._colour = null;\n        this._size = null;\n        this._scale_x = null;\n        this._scale_y = null;\n        this._facet_selector = null;\n        this._chart_colour_scale = null;\n        this._colour_scale = null;\n        this._individual_colours = null;\n        this._chart_individual_colours = null;\n        this._modify_colour = null;\n        this._chart_modify_colour = null;\n        this._x_formatter = null;\n        this._y_formatter = null;\n        this._chart_x_formatter = null;\n        this._chart_y_formatter = null;\n        this._y_axis_label = null;\n        this._x_axis_label = null;\n        this._chart_y_axis_label = null;\n        this._chart_x_axis_label = null;\n        this._label_formatter = null;\n        this._chart_label_formatter = null;\n        this._priority = priority || 1;\n        this._dispatch = d3.dispatch(\'elementClick\', \'elementMiddleClick\', \'elementRightClick\',\n            \'tooltipShow\', \'tooltipHide\');\n        this._show_labels = null;\n        this._chart_show_labels = null;\n        this._d3_colour_scale = null;\n        this._stroke_width = null;\n        this._font_size = 12;\n        this._index = 0;  // Used for generating unique keys\n    }\n\n    name() {\n        return this._name;\n    }\n\n    /**\n     * Used for generating a unique key.\n     */\n    index(i) {\n        if (arguments.length === 0) return this._index;\n        this._index = i;\n        return this;\n    }\n\n    key() {\n        return `${this._index}:${this._name}`\n    }\n\n    /**\n     * Provides a sort order priority for metrics. Metrics with a higher priority\n     * are drawn on top of lower priority metrics.\n     */\n    priority() {\n        return this._priority;\n    }\n\n    element(el) {\n        if (arguments.length === 0) return this._element;\n        this._element = el;\n        return this;\n    }\n\n    x(getter) {\n        if (arguments.length === 0) return this._x_getter || this._chart_x_getter;\n        if (typeof getter !== \'function\') throw new Error("x getter must be a function");\n        this._x_getter = getter;\n        return this;\n    }\n\n    y(getter) {\n        if (arguments.length === 0) return this._y_getter || this._chart_y_getter;\n        if (typeof getter !== \'function\') throw new Error("y getter must be a function");\n        this._y_getter = getter;\n        return this;\n    }\n\n    setupX(getter) {\n        if (arguments.length === 0) return this._chart_x_getter;\n        if (typeof getter !== \'function\') throw new Error("x getter must be a function");\n        this._chart_x_getter = getter;\n        return this;\n    }\n\n    setupY(getter) {\n        if (arguments.length === 0) return this._chart_y_getter;\n        if (typeof getter !== \'function\') throw new Error("y getter must be a function");\n        this._chart_y_getter = getter;\n        return this;\n    }\n\n    colour(colour) {\n        if (arguments.length === 0) return this._colour || this._chart_colour;\n        this._colour = colour;\n        return this;\n    }\n\n    setupColour(colour) {\n        if (arguments.length === 0) return this._chart_colour;\n        this._chart_colour = colour;\n        return this;\n    }\n\n    colourScale(colours) {\n        if (arguments.length === 0) return this._chart_colour_scale || this._colour_scale;\n        if (typeof colours !== \'object\' || !colours.length) throw new Error("colour must be an Array");\n        this._colour_scale = colours;\n        return this;\n    }\n\n    setupColourScale(colours) {\n        if (arguments.length === 0) return this._chart_colour_scale;\n        if (typeof colours !== \'object\' || !colours.length) throw new Error("colour must be an Array");\n        this._chart_colour_scale = colours;\n        return this;\n    }\n\n    individualColours(colourMap) {\n        if (arguments.length === 0) return this._individual_colours || this._chart_individual_colours;\n        this._individual_colours = colourMap;\n        return this;\n    }\n\n    setupIndividualColours(colourMap) {\n        if (arguments.length === 0) return this._chart_individual_colours;\n        this._chart_individual_colours = colourMap;\n        return this;\n    }\n\n    modifyColour(modifier) {\n        if (arguments.length === 0) return this._modify_colour || this._chart_modify_colour;\n        this._modify_colour = modifier;\n        return this;\n    }\n\n    setupModifyColour(modifier) {\n        if (arguments.length === 0) return this._chart_modify_colour;\n        this._chart_modify_colour = modifier;\n        return this;\n    }\n\n    d3ColourScale(scale) {\n        if (arguments.length === 0) return this._d3_colour_scale;\n        this._d3_colour_scale = scale;\n        return this;\n    }\n\n    getD3Colour(d) {\n        return getColor(d, this.d3ColourScale(), this.individualColours(), this.modifyColour());\n    }\n\n    size(size) {\n        if (arguments.length === 0) return this._size || this._chart_size;\n        this._size = size;\n        return this;\n    }\n\n    setupSize(size) {\n        if (arguments.length === 0) return this._chart_size;\n        this._chart_size = size;\n        return this;\n    }\n\n    scaleX(scale) {\n        if (arguments.length === 0) return this._scale_x || this._chart_scale_x;\n        this._scale_x = scale;\n        return this;\n    }\n\n    setupScaleX(scale) {\n        if (arguments.length === 0) return this._chart_scale_x;\n        this._chart_scale_x = scale;\n        return this;\n    }\n\n    scaleY(scale) {\n        if (arguments.length === 0) return this._scale_y || this._chart_scale_y;\n        this._scale_y = scale;\n        return this;\n    }\n\n    setupScaleY(scale) {\n        if (arguments.length === 0) return this._chart_scale_y;\n        this._chart_scale_y = scale;\n        return this;\n    }\n\n    formatX(formatter) {\n        if (arguments.length === 0) return this._x_formatter || this._chart_x_formatter;\n        if (typeof formatter !== \'function\') throw new Error("formatter must be a function");\n        this._x_formatter = formatter;\n        return this;\n    }\n\n    setupFormatX(formatter) {\n        if (arguments.length === 0) return this._chart_x_formatter;\n        if (typeof formatter !== \'function\') throw new Error("formatter must be a function");\n        this._chart_x_formatter = formatter;\n        return this;\n    }\n\n    formatY(formatter) {\n        if (arguments.length === 0) return this._y_formatter || this._chart_y_formatter;\n        if (typeof formatter !== \'function\') throw new Error("formatter must be a function");\n        this._y_formatter = formatter;\n        return this;\n    }\n\n    setupFormatY(formatter) {\n        if (arguments.length === 0) return this._chart_y_formatter;\n        if (typeof formatter !== \'function\') throw new Error("formatter must be a function");\n        this._chart_y_formatter = formatter;\n        return this;\n    }\n\n    formatLabel(formatter) {\n        if (arguments.length === 0) return this._label_formatter || this._chart_label_formatter || this.formatY();\n        if (typeof formatter !== \'function\') throw new Error("formatter must be a function");\n        this._label_formatter = formatter;\n        return this;\n    }\n\n    setupFormatLabel(formatter) {\n        if (arguments.length === 0) return this._chart_label_formatter;\n        this._chart_label_formatter = formatter;\n        return this;\n    }\n\n    width(width) {\n        if (arguments.length === 0) return this._width;\n        this._width = width;\n        return this;\n    }\n\n    height(height) {\n        if (arguments.length === 0) return this._height;\n        this._height = height;\n        return this;\n    }\n\n    showLabels(show) {\n        if (arguments.length === 0) return this._chart_show_labels || this._show_labels;\n        this._show_labels = !!show;\n        return this;\n    }\n\n    setupShowLabels(show) {\n        if (arguments.length === 0) return this._chart_show_labels;\n        this._chart_show_labels = !!show;\n        return this;\n    }\n\n    yAxisLabel(label) {\n        if (arguments.length === 0) return this._chart_y_axis_label || this._y_axis_label;\n        this._y_axis_label = label;\n        return this;\n    }\n\n    setupYAxisLabel(label) {\n        if (arguments.length === 0) return this._chart_y_axis_label;\n        this._chart_y_axis_label = label;\n        return this;\n    }\n\n    xAxisLabel(label) {\n        if (arguments.length === 0) return this._chart_x_axis_label || this._x_axis_label;\n        this._y_axis_label = label;\n        return this;\n    }\n\n    setupXAxisLabel(label) {\n        if (arguments.length === 0) return this._chart_x_axis_label;\n        this._chart_x_axis_label = label;\n        return this;\n    }\n\n    immediatelyRenderLabels(show) {\n        console.warn("#immediatelyRenderLabels not implemented for", this.name());\n    }\n\n    data(data) {\n        if (arguments.length === 0) return this._data;\n        this._data = data;\n        return this;\n    }\n\n    facet(selector) {\n        if (arguments.length === 0) return this._facet_selector;\n        if (selector != null && typeof selector !== \'function\' && selector !== null) throw new Error("Facet selector must be a function");\n        this._facet_selector = selector;\n        return this;\n    }\n\n    strokeWidth(pixels) {\n        if (arguments.length === 0) return this._stroke_width;\n        this._stroke_width = pixels;\n        return this;\n    }\n\n    fontSize(px) {\n        if (arguments.length === 0) return this._font_size;\n        if (typeof px !== "number" && px > 0) throw new Error("fontSize must be a positive number");\n        this._font_size = px;\n        return this;\n    }\n\n    /*\n     * This takes our array of data, and determines what elements\n     * are to be mapped to what aesthetic values, such as colour or size.\n     * Data is grouped by these fields.\n     */\n    prepareData(data, faceted) {\n        faceted = !!faceted && this.facet();\n        data = data || this._data;\n        if (!data || !data.length) return [];\n\n        const x = this.x(),\n              y = this.y(),\n              scaleX = this.scaleX(),\n              scaleY = this.scaleY();\n\n        let mapped = {};\n\n        data.forEach(d => {\n            if (faceted && !this.facet()(d)) return;\n            const object = Object.assign({\n                _x: scaleX.transform(x(d)),\n                _y: scaleY.transform(y(d)),\n                _colour: this.colour()(d),\n                _size: this.size()(d)\n            }, d);\n\n            const key = getKey(object);\n            object._key = key;\n\n            let series = mapped[key] || getKeyParameters(object);\n            series.data.push(object);\n            mapped[key] = series;\n        });\n\n        return Object.values(mapped);\n    }\n\n    getD3XScale() {\n        throw new Error("getD3XScale not implemented for " + this.name());\n    }\n\n    getD3YScale() {\n        throw new Error("getD3YScale not implemented for " + this.name());\n    }\n\n    /**\n     * Get all the Y values for this geometry, ignoring faceting.\n     */\n    yValues() {\n        return this.data()\n            .map(d => this.y()(d))\n            .map(d => this.scaleY().transform(d));\n    }\n\n    /**\n     * Get all the X values for this geometry, ignoring faceting.\n     */\n    xValues() {\n        return this.data()\n                   .map(d => this.x()(d))\n                   .map(d => this.scaleX().transform(d));\n    }\n\n\n    /**\n     * Implement your render code here.\n     */\n    render() {\n        throw new Error("RENDER NOT IMPLEMENTED FOR " + this.name());\n    }\n\n\n    /**\n     * Returns the unique values that the colour function\n     * returns.\n     * @param data\n     * @returns {*}\n     */\n    getColourDomain(data) {\n        if (!data || !data.length) return [];\n\n        const colours = new Set();\n\n        // todo calculate buckets\n        data.forEach(series => {\n            series.data.forEach(d => {\n                colours.add(this.colour()(d))\n            });\n        });\n\n        return [...colours]\n    }\n\n}\n\nfunction getColor(d, d3ColourScale, individualColours, modifyColour) {\n        const defaultColour = d3ColourScale(d._colour);\n        return modifyColour(individualColours(d, defaultColour) || defaultColour);\n}\n\nfunction getKey(d) {\n    // TODO we probably need to encode this better so we can split on the :\n    return "" + d._colour;\n}\n\nfunction fromKey(key) {\n    return {\n        _colour: key,\n        _key: key\n    }\n}\n\nfunction getKeyParameters(d) {\n    return {\n        _key: getKey(d),\n        _size: d._size,\n        _colour: d._colour,\n        data: []\n    }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY2hhcnQvR2VvbWV0cnkuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9iM2pzLy4vc3JjL2NoYXJ0L0dlb21ldHJ5LmpzPzc5MDkiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChDKSAyMDEzLTIwMTQsIDIwMTggQnJhbmRzRXllIChQVFkpIExURFxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpc1xuLy8gc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlXG4vLyB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksXG4vLyAgICAgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0b1xuLy8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcbi8vIGNvbmRpdGlvbnM6XG4vL1xuLy8gICAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuLy8gY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyAgICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUiBJTVBMSUVELFxuLy8gICAgIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBXG4vLyBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUXG4vLyBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0Zcbi8vIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRVxuLy8gT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cblxuZXhwb3J0IGNsYXNzIEdlb21ldHJ5IHtcblxuICAgIGNvbnN0cnVjdG9yKG5hbWUsIHByaW9yaXR5KSB7XG4gICAgICAgIHRoaXMuX25hbWUgPSBuYW1lIHx8IFwiW1VOTkFNRUQgR0VPTUVUUlldXCI7XG4gICAgICAgIHRoaXMuX2NoYXJ0X3hfZ2V0dGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5fY2hhcnRfeV9nZXR0ZXIgPSBudWxsO1xuICAgICAgICB0aGlzLl94X2dldHRlciA9IG51bGw7XG4gICAgICAgIHRoaXMuX3lfZ2V0dGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5fY29sb3VyID0gbnVsbDtcbiAgICAgICAgdGhpcy5fc2l6ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3NjYWxlX3ggPSBudWxsO1xuICAgICAgICB0aGlzLl9zY2FsZV95ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZmFjZXRfc2VsZWN0b3IgPSBudWxsO1xuICAgICAgICB0aGlzLl9jaGFydF9jb2xvdXJfc2NhbGUgPSBudWxsO1xuICAgICAgICB0aGlzLl9jb2xvdXJfc2NhbGUgPSBudWxsO1xuICAgICAgICB0aGlzLl9pbmRpdmlkdWFsX2NvbG91cnMgPSBudWxsO1xuICAgICAgICB0aGlzLl9jaGFydF9pbmRpdmlkdWFsX2NvbG91cnMgPSBudWxsO1xuICAgICAgICB0aGlzLl9tb2RpZnlfY29sb3VyID0gbnVsbDtcbiAgICAgICAgdGhpcy5fY2hhcnRfbW9kaWZ5X2NvbG91ciA9IG51bGw7XG4gICAgICAgIHRoaXMuX3hfZm9ybWF0dGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5feV9mb3JtYXR0ZXIgPSBudWxsO1xuICAgICAgICB0aGlzLl9jaGFydF94X2Zvcm1hdHRlciA9IG51bGw7XG4gICAgICAgIHRoaXMuX2NoYXJ0X3lfZm9ybWF0dGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5feV9heGlzX2xhYmVsID0gbnVsbDtcbiAgICAgICAgdGhpcy5feF9heGlzX2xhYmVsID0gbnVsbDtcbiAgICAgICAgdGhpcy5fY2hhcnRfeV9heGlzX2xhYmVsID0gbnVsbDtcbiAgICAgICAgdGhpcy5fY2hhcnRfeF9heGlzX2xhYmVsID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbGFiZWxfZm9ybWF0dGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5fY2hhcnRfbGFiZWxfZm9ybWF0dGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJpb3JpdHkgPSBwcmlvcml0eSB8fCAxO1xuICAgICAgICB0aGlzLl9kaXNwYXRjaCA9IGQzLmRpc3BhdGNoKCdlbGVtZW50Q2xpY2snLCAnZWxlbWVudE1pZGRsZUNsaWNrJywgJ2VsZW1lbnRSaWdodENsaWNrJyxcbiAgICAgICAgICAgICd0b29sdGlwU2hvdycsICd0b29sdGlwSGlkZScpO1xuICAgICAgICB0aGlzLl9zaG93X2xhYmVscyA9IG51bGw7XG4gICAgICAgIHRoaXMuX2NoYXJ0X3Nob3dfbGFiZWxzID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZDNfY29sb3VyX3NjYWxlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fc3Ryb2tlX3dpZHRoID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZm9udF9zaXplID0gMTI7XG4gICAgICAgIHRoaXMuX2luZGV4ID0gMDsgIC8vIFVzZWQgZm9yIGdlbmVyYXRpbmcgdW5pcXVlIGtleXNcbiAgICB9XG5cbiAgICBuYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmFtZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIGZvciBnZW5lcmF0aW5nIGEgdW5pcXVlIGtleS5cbiAgICAgKi9cbiAgICBpbmRleChpKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5faW5kZXg7XG4gICAgICAgIHRoaXMuX2luZGV4ID0gaTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAga2V5KCkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5faW5kZXh9OiR7dGhpcy5fbmFtZX1gXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJvdmlkZXMgYSBzb3J0IG9yZGVyIHByaW9yaXR5IGZvciBtZXRyaWNzLiBNZXRyaWNzIHdpdGggYSBoaWdoZXIgcHJpb3JpdHlcbiAgICAgKiBhcmUgZHJhd24gb24gdG9wIG9mIGxvd2VyIHByaW9yaXR5IG1ldHJpY3MuXG4gICAgICovXG4gICAgcHJpb3JpdHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcmlvcml0eTtcbiAgICB9XG5cbiAgICBlbGVtZW50KGVsKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5fZWxlbWVudDtcbiAgICAgICAgdGhpcy5fZWxlbWVudCA9IGVsO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB4KGdldHRlcikge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX3hfZ2V0dGVyIHx8IHRoaXMuX2NoYXJ0X3hfZ2V0dGVyO1xuICAgICAgICBpZiAodHlwZW9mIGdldHRlciAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IEVycm9yKFwieCBnZXR0ZXIgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICB0aGlzLl94X2dldHRlciA9IGdldHRlcjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgeShnZXR0ZXIpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl95X2dldHRlciB8fCB0aGlzLl9jaGFydF95X2dldHRlcjtcbiAgICAgICAgaWYgKHR5cGVvZiBnZXR0ZXIgIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBFcnJvcihcInkgZ2V0dGVyIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgdGhpcy5feV9nZXR0ZXIgPSBnZXR0ZXI7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHNldHVwWChnZXR0ZXIpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl9jaGFydF94X2dldHRlcjtcbiAgICAgICAgaWYgKHR5cGVvZiBnZXR0ZXIgIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBFcnJvcihcInggZ2V0dGVyIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgdGhpcy5fY2hhcnRfeF9nZXR0ZXIgPSBnZXR0ZXI7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHNldHVwWShnZXR0ZXIpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl9jaGFydF95X2dldHRlcjtcbiAgICAgICAgaWYgKHR5cGVvZiBnZXR0ZXIgIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBFcnJvcihcInkgZ2V0dGVyIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgdGhpcy5fY2hhcnRfeV9nZXR0ZXIgPSBnZXR0ZXI7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGNvbG91cihjb2xvdXIpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl9jb2xvdXIgfHwgdGhpcy5fY2hhcnRfY29sb3VyO1xuICAgICAgICB0aGlzLl9jb2xvdXIgPSBjb2xvdXI7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHNldHVwQ29sb3VyKGNvbG91cikge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX2NoYXJ0X2NvbG91cjtcbiAgICAgICAgdGhpcy5fY2hhcnRfY29sb3VyID0gY29sb3VyO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBjb2xvdXJTY2FsZShjb2xvdXJzKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5fY2hhcnRfY29sb3VyX3NjYWxlIHx8IHRoaXMuX2NvbG91cl9zY2FsZTtcbiAgICAgICAgaWYgKHR5cGVvZiBjb2xvdXJzICE9PSAnb2JqZWN0JyB8fCAhY29sb3Vycy5sZW5ndGgpIHRocm93IG5ldyBFcnJvcihcImNvbG91ciBtdXN0IGJlIGFuIEFycmF5XCIpO1xuICAgICAgICB0aGlzLl9jb2xvdXJfc2NhbGUgPSBjb2xvdXJzO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzZXR1cENvbG91clNjYWxlKGNvbG91cnMpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl9jaGFydF9jb2xvdXJfc2NhbGU7XG4gICAgICAgIGlmICh0eXBlb2YgY29sb3VycyAhPT0gJ29iamVjdCcgfHwgIWNvbG91cnMubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoXCJjb2xvdXIgbXVzdCBiZSBhbiBBcnJheVwiKTtcbiAgICAgICAgdGhpcy5fY2hhcnRfY29sb3VyX3NjYWxlID0gY29sb3VycztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaW5kaXZpZHVhbENvbG91cnMoY29sb3VyTWFwKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5faW5kaXZpZHVhbF9jb2xvdXJzIHx8IHRoaXMuX2NoYXJ0X2luZGl2aWR1YWxfY29sb3VycztcbiAgICAgICAgdGhpcy5faW5kaXZpZHVhbF9jb2xvdXJzID0gY29sb3VyTWFwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzZXR1cEluZGl2aWR1YWxDb2xvdXJzKGNvbG91ck1hcCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX2NoYXJ0X2luZGl2aWR1YWxfY29sb3VycztcbiAgICAgICAgdGhpcy5fY2hhcnRfaW5kaXZpZHVhbF9jb2xvdXJzID0gY29sb3VyTWFwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBtb2RpZnlDb2xvdXIobW9kaWZpZXIpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl9tb2RpZnlfY29sb3VyIHx8IHRoaXMuX2NoYXJ0X21vZGlmeV9jb2xvdXI7XG4gICAgICAgIHRoaXMuX21vZGlmeV9jb2xvdXIgPSBtb2RpZmllcjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgc2V0dXBNb2RpZnlDb2xvdXIobW9kaWZpZXIpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl9jaGFydF9tb2RpZnlfY29sb3VyO1xuICAgICAgICB0aGlzLl9jaGFydF9tb2RpZnlfY29sb3VyID0gbW9kaWZpZXI7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGQzQ29sb3VyU2NhbGUoc2NhbGUpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl9kM19jb2xvdXJfc2NhbGU7XG4gICAgICAgIHRoaXMuX2QzX2NvbG91cl9zY2FsZSA9IHNjYWxlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBnZXREM0NvbG91cihkKSB7XG4gICAgICAgIHJldHVybiBnZXRDb2xvcihkLCB0aGlzLmQzQ29sb3VyU2NhbGUoKSwgdGhpcy5pbmRpdmlkdWFsQ29sb3VycygpLCB0aGlzLm1vZGlmeUNvbG91cigpKTtcbiAgICB9XG5cbiAgICBzaXplKHNpemUpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl9zaXplIHx8IHRoaXMuX2NoYXJ0X3NpemU7XG4gICAgICAgIHRoaXMuX3NpemUgPSBzaXplO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzZXR1cFNpemUoc2l6ZSkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX2NoYXJ0X3NpemU7XG4gICAgICAgIHRoaXMuX2NoYXJ0X3NpemUgPSBzaXplO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzY2FsZVgoc2NhbGUpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl9zY2FsZV94IHx8IHRoaXMuX2NoYXJ0X3NjYWxlX3g7XG4gICAgICAgIHRoaXMuX3NjYWxlX3ggPSBzY2FsZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgc2V0dXBTY2FsZVgoc2NhbGUpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl9jaGFydF9zY2FsZV94O1xuICAgICAgICB0aGlzLl9jaGFydF9zY2FsZV94ID0gc2NhbGU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHNjYWxlWShzY2FsZSkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX3NjYWxlX3kgfHwgdGhpcy5fY2hhcnRfc2NhbGVfeTtcbiAgICAgICAgdGhpcy5fc2NhbGVfeSA9IHNjYWxlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzZXR1cFNjYWxlWShzY2FsZSkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX2NoYXJ0X3NjYWxlX3k7XG4gICAgICAgIHRoaXMuX2NoYXJ0X3NjYWxlX3kgPSBzY2FsZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZm9ybWF0WChmb3JtYXR0ZXIpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl94X2Zvcm1hdHRlciB8fCB0aGlzLl9jaGFydF94X2Zvcm1hdHRlcjtcbiAgICAgICAgaWYgKHR5cGVvZiBmb3JtYXR0ZXIgIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBFcnJvcihcImZvcm1hdHRlciBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG4gICAgICAgIHRoaXMuX3hfZm9ybWF0dGVyID0gZm9ybWF0dGVyO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzZXR1cEZvcm1hdFgoZm9ybWF0dGVyKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5fY2hhcnRfeF9mb3JtYXR0ZXI7XG4gICAgICAgIGlmICh0eXBlb2YgZm9ybWF0dGVyICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgRXJyb3IoXCJmb3JtYXR0ZXIgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICB0aGlzLl9jaGFydF94X2Zvcm1hdHRlciA9IGZvcm1hdHRlcjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZm9ybWF0WShmb3JtYXR0ZXIpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl95X2Zvcm1hdHRlciB8fCB0aGlzLl9jaGFydF95X2Zvcm1hdHRlcjtcbiAgICAgICAgaWYgKHR5cGVvZiBmb3JtYXR0ZXIgIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBFcnJvcihcImZvcm1hdHRlciBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG4gICAgICAgIHRoaXMuX3lfZm9ybWF0dGVyID0gZm9ybWF0dGVyO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzZXR1cEZvcm1hdFkoZm9ybWF0dGVyKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5fY2hhcnRfeV9mb3JtYXR0ZXI7XG4gICAgICAgIGlmICh0eXBlb2YgZm9ybWF0dGVyICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgRXJyb3IoXCJmb3JtYXR0ZXIgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICB0aGlzLl9jaGFydF95X2Zvcm1hdHRlciA9IGZvcm1hdHRlcjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZm9ybWF0TGFiZWwoZm9ybWF0dGVyKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5fbGFiZWxfZm9ybWF0dGVyIHx8IHRoaXMuX2NoYXJ0X2xhYmVsX2Zvcm1hdHRlciB8fCB0aGlzLmZvcm1hdFkoKTtcbiAgICAgICAgaWYgKHR5cGVvZiBmb3JtYXR0ZXIgIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBFcnJvcihcImZvcm1hdHRlciBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG4gICAgICAgIHRoaXMuX2xhYmVsX2Zvcm1hdHRlciA9IGZvcm1hdHRlcjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgc2V0dXBGb3JtYXRMYWJlbChmb3JtYXR0ZXIpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl9jaGFydF9sYWJlbF9mb3JtYXR0ZXI7XG4gICAgICAgIHRoaXMuX2NoYXJ0X2xhYmVsX2Zvcm1hdHRlciA9IGZvcm1hdHRlcjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgd2lkdGgod2lkdGgpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl93aWR0aDtcbiAgICAgICAgdGhpcy5fd2lkdGggPSB3aWR0aDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaGVpZ2h0KGhlaWdodCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX2hlaWdodDtcbiAgICAgICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzaG93TGFiZWxzKHNob3cpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl9jaGFydF9zaG93X2xhYmVscyB8fCB0aGlzLl9zaG93X2xhYmVscztcbiAgICAgICAgdGhpcy5fc2hvd19sYWJlbHMgPSAhIXNob3c7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHNldHVwU2hvd0xhYmVscyhzaG93KSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5fY2hhcnRfc2hvd19sYWJlbHM7XG4gICAgICAgIHRoaXMuX2NoYXJ0X3Nob3dfbGFiZWxzID0gISFzaG93O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB5QXhpc0xhYmVsKGxhYmVsKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5fY2hhcnRfeV9heGlzX2xhYmVsIHx8IHRoaXMuX3lfYXhpc19sYWJlbDtcbiAgICAgICAgdGhpcy5feV9heGlzX2xhYmVsID0gbGFiZWw7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHNldHVwWUF4aXNMYWJlbChsYWJlbCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX2NoYXJ0X3lfYXhpc19sYWJlbDtcbiAgICAgICAgdGhpcy5fY2hhcnRfeV9heGlzX2xhYmVsID0gbGFiZWw7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHhBeGlzTGFiZWwobGFiZWwpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl9jaGFydF94X2F4aXNfbGFiZWwgfHwgdGhpcy5feF9heGlzX2xhYmVsO1xuICAgICAgICB0aGlzLl95X2F4aXNfbGFiZWwgPSBsYWJlbDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgc2V0dXBYQXhpc0xhYmVsKGxhYmVsKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5fY2hhcnRfeF9heGlzX2xhYmVsO1xuICAgICAgICB0aGlzLl9jaGFydF94X2F4aXNfbGFiZWwgPSBsYWJlbDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaW1tZWRpYXRlbHlSZW5kZXJMYWJlbHMoc2hvdykge1xuICAgICAgICBjb25zb2xlLndhcm4oXCIjaW1tZWRpYXRlbHlSZW5kZXJMYWJlbHMgbm90IGltcGxlbWVudGVkIGZvclwiLCB0aGlzLm5hbWUoKSk7XG4gICAgfVxuXG4gICAgZGF0YShkYXRhKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5fZGF0YTtcbiAgICAgICAgdGhpcy5fZGF0YSA9IGRhdGE7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZhY2V0KHNlbGVjdG9yKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5fZmFjZXRfc2VsZWN0b3I7XG4gICAgICAgIGlmIChzZWxlY3RvciAhPSBudWxsICYmIHR5cGVvZiBzZWxlY3RvciAhPT0gJ2Z1bmN0aW9uJyAmJiBzZWxlY3RvciAhPT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKFwiRmFjZXQgc2VsZWN0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICB0aGlzLl9mYWNldF9zZWxlY3RvciA9IHNlbGVjdG9yO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzdHJva2VXaWR0aChwaXhlbHMpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl9zdHJva2Vfd2lkdGg7XG4gICAgICAgIHRoaXMuX3N0cm9rZV93aWR0aCA9IHBpeGVscztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZm9udFNpemUocHgpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl9mb250X3NpemU7XG4gICAgICAgIGlmICh0eXBlb2YgcHggIT09IFwibnVtYmVyXCIgJiYgcHggPiAwKSB0aHJvdyBuZXcgRXJyb3IoXCJmb250U2l6ZSBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyXCIpO1xuICAgICAgICB0aGlzLl9mb250X3NpemUgPSBweDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBUaGlzIHRha2VzIG91ciBhcnJheSBvZiBkYXRhLCBhbmQgZGV0ZXJtaW5lcyB3aGF0IGVsZW1lbnRzXG4gICAgICogYXJlIHRvIGJlIG1hcHBlZCB0byB3aGF0IGFlc3RoZXRpYyB2YWx1ZXMsIHN1Y2ggYXMgY29sb3VyIG9yIHNpemUuXG4gICAgICogRGF0YSBpcyBncm91cGVkIGJ5IHRoZXNlIGZpZWxkcy5cbiAgICAgKi9cbiAgICBwcmVwYXJlRGF0YShkYXRhLCBmYWNldGVkKSB7XG4gICAgICAgIGZhY2V0ZWQgPSAhIWZhY2V0ZWQgJiYgdGhpcy5mYWNldCgpO1xuICAgICAgICBkYXRhID0gZGF0YSB8fCB0aGlzLl9kYXRhO1xuICAgICAgICBpZiAoIWRhdGEgfHwgIWRhdGEubGVuZ3RoKSByZXR1cm4gW107XG5cbiAgICAgICAgY29uc3QgeCA9IHRoaXMueCgpLFxuICAgICAgICAgICAgICB5ID0gdGhpcy55KCksXG4gICAgICAgICAgICAgIHNjYWxlWCA9IHRoaXMuc2NhbGVYKCksXG4gICAgICAgICAgICAgIHNjYWxlWSA9IHRoaXMuc2NhbGVZKCk7XG5cbiAgICAgICAgbGV0IG1hcHBlZCA9IHt9O1xuXG4gICAgICAgIGRhdGEuZm9yRWFjaChkID0+IHtcbiAgICAgICAgICAgIGlmIChmYWNldGVkICYmICF0aGlzLmZhY2V0KCkoZCkpIHJldHVybjtcbiAgICAgICAgICAgIGNvbnN0IG9iamVjdCA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgICAgIF94OiBzY2FsZVgudHJhbnNmb3JtKHgoZCkpLFxuICAgICAgICAgICAgICAgIF95OiBzY2FsZVkudHJhbnNmb3JtKHkoZCkpLFxuICAgICAgICAgICAgICAgIF9jb2xvdXI6IHRoaXMuY29sb3VyKCkoZCksXG4gICAgICAgICAgICAgICAgX3NpemU6IHRoaXMuc2l6ZSgpKGQpXG4gICAgICAgICAgICB9LCBkKTtcblxuICAgICAgICAgICAgY29uc3Qga2V5ID0gZ2V0S2V5KG9iamVjdCk7XG4gICAgICAgICAgICBvYmplY3QuX2tleSA9IGtleTtcblxuICAgICAgICAgICAgbGV0IHNlcmllcyA9IG1hcHBlZFtrZXldIHx8IGdldEtleVBhcmFtZXRlcnMob2JqZWN0KTtcbiAgICAgICAgICAgIHNlcmllcy5kYXRhLnB1c2gob2JqZWN0KTtcbiAgICAgICAgICAgIG1hcHBlZFtrZXldID0gc2VyaWVzO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyhtYXBwZWQpO1xuICAgIH1cblxuICAgIGdldEQzWFNjYWxlKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJnZXREM1hTY2FsZSBub3QgaW1wbGVtZW50ZWQgZm9yIFwiICsgdGhpcy5uYW1lKCkpO1xuICAgIH1cblxuICAgIGdldEQzWVNjYWxlKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJnZXREM1lTY2FsZSBub3QgaW1wbGVtZW50ZWQgZm9yIFwiICsgdGhpcy5uYW1lKCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBhbGwgdGhlIFkgdmFsdWVzIGZvciB0aGlzIGdlb21ldHJ5LCBpZ25vcmluZyBmYWNldGluZy5cbiAgICAgKi9cbiAgICB5VmFsdWVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhKClcbiAgICAgICAgICAgIC5tYXAoZCA9PiB0aGlzLnkoKShkKSlcbiAgICAgICAgICAgIC5tYXAoZCA9PiB0aGlzLnNjYWxlWSgpLnRyYW5zZm9ybShkKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGFsbCB0aGUgWCB2YWx1ZXMgZm9yIHRoaXMgZ2VvbWV0cnksIGlnbm9yaW5nIGZhY2V0aW5nLlxuICAgICAqL1xuICAgIHhWYWx1ZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEoKVxuICAgICAgICAgICAgICAgICAgIC5tYXAoZCA9PiB0aGlzLngoKShkKSlcbiAgICAgICAgICAgICAgICAgICAubWFwKGQgPT4gdGhpcy5zY2FsZVgoKS50cmFuc2Zvcm0oZCkpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogSW1wbGVtZW50IHlvdXIgcmVuZGVyIGNvZGUgaGVyZS5cbiAgICAgKi9cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJFTkRFUiBOT1QgSU1QTEVNRU5URUQgRk9SIFwiICsgdGhpcy5uYW1lKCkpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdW5pcXVlIHZhbHVlcyB0aGF0IHRoZSBjb2xvdXIgZnVuY3Rpb25cbiAgICAgKiByZXR1cm5zLlxuICAgICAqIEBwYXJhbSBkYXRhXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZ2V0Q29sb3VyRG9tYWluKGRhdGEpIHtcbiAgICAgICAgaWYgKCFkYXRhIHx8ICFkYXRhLmxlbmd0aCkgcmV0dXJuIFtdO1xuXG4gICAgICAgIGNvbnN0IGNvbG91cnMgPSBuZXcgU2V0KCk7XG5cbiAgICAgICAgLy8gdG9kbyBjYWxjdWxhdGUgYnVja2V0c1xuICAgICAgICBkYXRhLmZvckVhY2goc2VyaWVzID0+IHtcbiAgICAgICAgICAgIHNlcmllcy5kYXRhLmZvckVhY2goZCA9PiB7XG4gICAgICAgICAgICAgICAgY29sb3Vycy5hZGQodGhpcy5jb2xvdXIoKShkKSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gWy4uLmNvbG91cnNdXG4gICAgfVxuXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDb2xvcihkLCBkM0NvbG91clNjYWxlLCBpbmRpdmlkdWFsQ29sb3VycywgbW9kaWZ5Q29sb3VyKSB7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRDb2xvdXIgPSBkM0NvbG91clNjYWxlKGQuX2NvbG91cik7XG4gICAgICAgIHJldHVybiBtb2RpZnlDb2xvdXIoaW5kaXZpZHVhbENvbG91cnMoZCwgZGVmYXVsdENvbG91cikgfHwgZGVmYXVsdENvbG91cik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRLZXkoZCkge1xuICAgIC8vIFRPRE8gd2UgcHJvYmFibHkgbmVlZCB0byBlbmNvZGUgdGhpcyBiZXR0ZXIgc28gd2UgY2FuIHNwbGl0IG9uIHRoZSA6XG4gICAgcmV0dXJuIFwiXCIgKyBkLl9jb2xvdXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tS2V5KGtleSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIF9jb2xvdXI6IGtleSxcbiAgICAgICAgX2tleToga2V5XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZXRLZXlQYXJhbWV0ZXJzKGQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBfa2V5OiBnZXRLZXkoZCksXG4gICAgICAgIF9zaXplOiBkLl9zaXplLFxuICAgICAgICBfY29sb3VyOiBkLl9jb2xvdXIsXG4gICAgICAgIGRhdGE6IFtdXG4gICAgfVxufSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/chart/Geometry.js\n')},"./src/chart/Histogram.js":
/*!********************************!*\
  !*** ./src/chart/Histogram.js ***!
  \********************************/
/*! exports provided: histogram, columnChart */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "histogram", function() { return histogram; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "columnChart", function() { return columnChart; });\n/* harmony import */ var _Geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Geometry */ "./src/chart/Geometry.js");\n/* harmony import */ var _Colours__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Colours */ "./src/Colours.js");\n/* harmony import */ var _Legend__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Legend */ "./src/Legend.js");\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../helpers */ "./src/helpers.js");\n// Copyright (C) 2013-2014, 2018 BrandsEye (PTY) LTD\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this\n// software and associated documentation files (the "Software"), to deal in the Software\n// without restriction, including without limitation the rights to use, copy, modify,\n//     merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following\n// conditions:\n//\n//     The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n//     INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n// CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n\n\n\n\nclass Histogram extends _Geometry__WEBPACK_IMPORTED_MODULE_0__["Geometry"] {\n\n    constructor(name, padding) {\n        super(name || "HISTOGRAM");\n        this._BAR_GROWTH = 100;\n        this._padding = padding || 0;\n        this._stroke_width = 1\n    }\n\n    /**\n     * Set the padding between bar groups. 0 padding is a standard histogram.\n     */\n    padding(padding) {\n        if (arguments.length === 0) return this._padding;\n        this._padding = padding;\n        return this;\n    }\n\n    render() {\n        const element = this._element;\n        const data = this.prepareData(null, true);\n        const allData = this.prepareData(null, false);\n        const width = this._width,\n              height = this._height;\n\n        element.classed("histogram", true);\n\n        const x = this.getD3XScale(data, width);\n        const y = this.getD3YScale(allData, height);\n        const xGroup = this.getD3XGroupScale(data, x);\n        const colours = this.d3ColourScale();\n\n        let groups = element.select(".bars").selectAll(\'.group\');\n\n        //----------------------------------------------\n        // Get rid of current labels\n\n        element.select(".chart-labels")\n           .remove();\n\n        //----------------------------------------------\n\n        if (groups.empty()) {\n            groups = element\n                .append("g")\n                .attr("class", "bars")\n                .selectAll(".group");\n        }\n\n        // Ensure that we\'re always using the correct height.\n        element.select(".bars")\n           .attr("transform", "translate(0, " + height + "), scale(1, -1)");\n\n        groups = groups.data(data);\n\n        groups.exit().remove();\n\n        groups.enter()\n              .append("g")\n                  .attr("class", "group")\n                  .attr("transform", d => "translate(" + x(d._key) + ",0)")\n                  .attr("width", x.bandwidth())\n                  .attr("height", "100%")\n              .merge(groups)\n              .interrupt("groups:move")\n              .transition("groups:move")\n                  .attr("transform", d => "translate(" + x(d._key) + ",0)")\n                  .attr("width", x.bandwidth())\n              .each((s_d, s_i, nodes) => {\n                  let group = d3.select(nodes[s_i]);\n\n                  let bars = group.selectAll(".bar")\n                                  .data(s_d.data);\n\n                  bars.exit().remove();\n\n                  bars.interrupt("bar:move")     // Animate the bars to their new position.\n                      .transition("bar:move")\n                      .attr("width", xGroup.bandwidth())\n                      .attr("x", d => xGroup(d._key))\n                      .attr("y", 0);\n\n                  bars.enter()\n                      .append("rect")\n                          .attr("height", 0)\n                          .style("cursor", "pointer")\n                      .on("contextmenu", () => d3.event.preventDefault()) // No right click.\n                      .merge(bars)\n                          .attr("x", d => xGroup(d._key))\n                          .attr("y", height - y(0))\n                          .attr("width", xGroup.bandwidth())\n                          .attr("class", d => "bar series series-" + Object(_Legend__WEBPACK_IMPORTED_MODULE_2__["toColourKey"])(d._colour))\n                          .style("fill", d => this.getD3Colour(d)) // colours(d._colour))\n                          .style("stroke", d => d3.hcl(this.getD3Colour(d)).darker())\n                          .style("stroke-width", this._stroke_width)\n                      .on("click auxclick", (d, i, nodes) => {\n                          this._dispatch.call("elementClick", this, {\n                              e: d3.event,\n                              point: d,\n                              series: d._series,\n                              seriesIndex: s_i,\n                              value: d._y\n                          })\n                      })\n                      .on("mouseover", (d, i, nodes) => { // Darken the bar on mouse over\n                          d3.select(nodes[i])\n                            .interrupt("hover:colour")\n                            .transition("hover:colour")\n                            .duration(400)\n                            .style("fill", d3.hcl(this.getD3Colour(d)).darker());\n                          this._dispatch.call("tooltipShow", this, {\n                              e: d3.event,\n                              point: d,\n                              series: s_d,\n                              seriesIndex: s_i,\n                              value: d._y\n                          })\n                      })\n                      .on("mouseout", (d, i, nodes) => { // bar is regular colour on mouse out.\n                          d3.select(nodes[i])\n                            .interrupt("hover:colour")\n                            .transition("hover:colour")\n                            .duration(400)\n                            .style("fill", d => this.getD3Colour(d));\n                          this._dispatch.call("tooltipHide", this);\n                      })\n                      .interrupt("bar:growth")    // Animate bars growing.\n                      .transition("bar:growth")\n                      .delay(() => this.calcBarGrowth(s_i, nodes.length))\n                          .style("fill", d => this.getD3Colour(d)) //colours(d._colour))\n                          .style("stroke", d => d3.hcl(this.getD3Colour(d)).darker())\n                          .attr("y", d => height - y(Math.min(0, d._y)))\n                          .attr("height", d => (Math.abs(y(0) - y(d._y))));\n              });\n\n        // Labels loaded after our last bar grows.\n        if (this.showLabels()) {\n            element.transition("bar:growth")\n               .on("end", (d, i, nodes) => {\n                   if (i < nodes.length - 1) return;\n                   this.renderLabels(element, data, x, xGroup, y, colours);\n               })\n        }\n    }\n\n    calcBarGrowth(i, max) {\n        if (max < 10) return i * this._BAR_GROWTH / 2;\n        if (max < 35) return i * this._BAR_GROWTH / 4;\n        return 1;\n    }\n\n    prepareData(data, faceted) {\n        data = _Geometry__WEBPACK_IMPORTED_MODULE_0__["Geometry"].prototype.prepareData.call(this, data, faceted);\n\n        const sortOrder = {};\n        this.xValues().forEach((d, i) => {\n            sortOrder[d] = sortOrder[d] || ("" + i);\n        });\n\n        let results = {};\n\n        // We want to calculate what bucket each bit of data belongs to.\n        const buckets = this.scaleX()\n                            .buckets(Object\n                                .values(data)\n                                .map(d => d.data)\n                                .reduce((acc, cur) => acc.concat(cur))\n                                .map(d => d._x));\n\n        // Sort data in to their appropriate buckets. This may be\n        // specific date buckets, or general buckets for continuous data.\n        Object.keys(data).forEach(key => {\n            let values = data[key].data;\n            values.forEach(d => {\n                d._bucket = buckets.bucket(d._x);\n                let bucket = results[d._bucket] || { _key: d._bucket, data: [] };\n                bucket.data.push(d);\n                results[d._bucket] = bucket;\n            })\n        });\n\n        return buckets.consolidateBuckets(Object.values(results))\n            .sort((lhs, rhs) => {\n                return sortOrder["" + lhs._key] - sortOrder["" + rhs._key];\n            });\n    }\n\n    getKeys(data) {\n        if (!data || !data.length) return [];\n\n        let keys = new Set();\n\n        // todo calculate buckets\n        Object.keys(data).forEach(key => {\n            let values = data[key].data;\n            values.forEach(d => keys.add(d._key))\n        });\n\n\n        return [...keys]\n    }\n\n    getD3XScale(data, width) {\n        data = data || this.prepareData(null, true);\n        width = width || this.width();\n\n        let p = this._padding\n        if (data[0].data.length > 1 && p === 0) p = 0.2\n        return d3.scaleBand()\n                 .rangeRound([0, width])\n                 .padding(p)\n                 .domain(data.map(d => d._key));\n    }\n\n    getD3YScale(data, height) {\n        data = data || this.prepareData(null, false);\n        height = height || this.height();\n\n\n        const max = Math.max(d3.max(data, d => d3.max(d.data, d => d._y)), 0);\n        const min = Math.min(0, d3.min(data, d => d3.min(d.data, d => d._y)));\n        return d3.scaleLinear()\n                 .rangeRound([height, 0])\n                 .nice()\n                 .domain([min, max]);\n    }\n\n    getD3XGroupScale(data, xscale) {\n        return d3.scaleBand()\n                 .padding(0)\n                 .domain(this.getKeys(data))\n                 .rangeRound([0, xscale.bandwidth()]);\n    }\n\n    renderLabels(selection, data, xscale, xgroup, yscale, colourScale, animate) {\n        animate = animate === undefined ? true : animate;\n        selection.selectAll(".chart-labels").remove();\n\n        let labels = selection.append("g")\n                              .attr("class", "chart-labels")\n                              .selectAll(".label-group")\n                              .data(data);\n\n        let maxWidth = 0;     // For calculating the max width of text.\n        let fontSize = this._font_size;    // Our initial font size.\n        const buffer = 5;     // Buffer space between words and the top of a bar.\n        const calcDy = (y, ypos) => ((y >= 0 && ypos < 10) || ( y < 0 && this._height - ypos > 10)) ? fontSize + 2: -buffer;\n\n        // Want to figure out if the label is too dark / light for the\n        // bar.\n        const getInvertedColor = d => {\n            let invertedColor = d3.hcl(this.getD3Colour(d));\n            invertedColor.l += Math.min(invertedColor.l + 50, 100);\n            return invertedColor;\n        };\n        const shouldInvert = d => d3.hcl(this.getD3Colour(d)).l < 60;\n        const fillColour = d3.hcl(_Colours__WEBPACK_IMPORTED_MODULE_1__["colours"].eighteen.darkGrey).brighter();\n        const lighterFillColour = d3.hcl(_Colours__WEBPACK_IMPORTED_MODULE_1__["colours"].eighteen.midGrey);\n        const findColour = (d, dy, labelText) => {\n            const onBar = (d._y >= 0 && dy > 0 || d._y < 0 && dy < 0);\n            return onBar && shouldInvert(d)\n                ? getInvertedColor(d).toString()\n                : (Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["labelIsZero"])(labelText)\n                    ? lighterFillColour\n                    : (onBar ? d3.hcl(fillColour).darker() : fillColour));\n        };\n\n        labels.enter().each((series, s_i, s_nodes) => {\n            // We want to determine which groups may have missing values, and provide them.\n            const requiredGroups = {};\n            xgroup.domain().map(_Geometry__WEBPACK_IMPORTED_MODULE_0__["fromKey"]).forEach(d => {\n                requiredGroups[d._colour] = d;\n            });\n\n            series.data.forEach(d => {\n                delete requiredGroups[d._colour]\n            });\n\n            const missingGroups = Object.values(requiredGroups);\n            missingGroups.forEach(d => {\n                d._x = series._key;\n                d._y = 0;\n            });\n\n            d3.select(s_nodes[s_i])\n              .append("g")\n              .attr("class", "label-group")\n              .attr("transform", d => "translate(" + xscale(d._key) + ",0)")\n              .selectAll(".chart-label")\n              .data(series.data.concat(Object.values(missingGroups)))\n              .enter()\n              .each((d, i, nodes) => {\n                  const labelText = this.formatLabel()(d._y, d);\n                  let ypos = yscale(d._y);\n                  let dy = calcDy(d._y, ypos);\n                  let text = d3.select(nodes[i])\n                        .append("text")\n                        .text(labelText)\n                        .style("font-size", fontSize + "px")\n                        .attr("class", d => "chart-label series series-" + Object(_Legend__WEBPACK_IMPORTED_MODULE_2__["toColourKey"])(d._colour))\n                        .attr("y", ypos)\n                        .attr("dx", animate ? -15 : 0)\n                        .attr("dy", dy)\n                        .style("opacity", 0)\n                        .style("pointer-events", "none")\n                        .style("fill", d => findColour(d, dy, labelText));\n\n                  // Set the x position, which is based on width.\n                  const width = text.node().getBBox().width;\n                  maxWidth = Math.max(width, maxWidth);\n                  text\n                      .attr("x", xgroup(d._key) + xgroup.bandwidth() / 2 - width / 2);\n\n                  text\n                      .transition("labels")\n                      .delay(() => animate ? this.calcBarGrowth(s_i, s_nodes.length) : 0) // Delay in lockstep with bar growth.\n                      .attr("dx", 0)\n                      .style("opacity", 1)\n              })\n        });\n\n\n        // Figure out if we don\'t have enough space to show our labels.\n        // We then want to resize, if possible.\n        if (xgroup.bandwidth() < maxWidth * 1.10) {\n            let scale = maxWidth / xgroup.bandwidth() * 1.10;\n            fontSize = Math.floor(fontSize / scale);\n\n            if (fontSize < 10) {\n                // The labels are too small.\n                labels.enter().selectAll("text").remove();\n            } else {\n                labels.enter()\n                      .merge(labels)\n                      .selectAll("text")\n                      .style("font-size", fontSize + "px")\n                      .each((d, i, nodes) => {\n                          const text = d3.select(nodes[i]);\n                          const width = text.node().getBBox().width;\n                          const dy = calcDy(d._y, yscale(d._y));\n\n                          text\n                              .attr("x", xgroup(d._key) + xgroup.bandwidth() / 2 - width / 2)\n                              .style("fill", d => findColour(d, dy, text.text()))\n                              .attr("dy", dy);\n                      })\n            }\n        }\n    }\n\n\n    immediatelyRenderLabels(show) {\n        const element = this.element();\n        if (!element) return;\n\n        if (!show) { // Hides the labels\n            element\n              .select(\'.chart-labels\')\n              .interrupt("labels")\n              .interrupt("labels:fade")\n              .transition("labels:fade")\n              .style("opacity", 0)\n              .on("end", (d, i, nodes) => {\n                  d3.select(nodes[i]).remove();\n              })\n        } else {\n            let labels = element.select(\'.chart-labels\');\n            if (!labels.empty()) return;\n\n            const data = this.prepareData(null, true);\n            const allData = this.prepareData(null, false);\n\n            const xscale = this.getD3XScale(data),\n                  xgroup = this.getD3XGroupScale(data, xscale),\n                  yscale = this.getD3YScale(data),\n                  colourScale = this.d3ColourScale();\n\n            labels.remove();\n            this.renderLabels(element, data, xscale, xgroup, yscale, colourScale, false);\n        }\n\n    }\n\n\n}\n\n\nfunction histogram() {\n    return new Histogram();\n}\n\nfunction columnChart() {\n    return new Histogram("COLUMN_CHART", 0.1);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY2hhcnQvSGlzdG9ncmFtLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYjNqcy8uL3NyYy9jaGFydC9IaXN0b2dyYW0uanM/MTkzMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKEMpIDIwMTMtMjAxNCwgMjAxOCBCcmFuZHNFeWUgKFBUWSkgTFREXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZiB0aGlzXG4vLyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmVcbi8vIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSxcbi8vICAgICBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvXG4vLyBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZ1xuLy8gY29uZGl0aW9uczpcbi8vXG4vLyAgICAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4vLyBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vICAgICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SIElNUExJRUQsXG4vLyAgICAgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEFcbi8vIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFRcbi8vIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRlxuLy8gQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFXG4vLyBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IHsgR2VvbWV0cnksIGZyb21LZXkgfSBmcm9tICcuL0dlb21ldHJ5JztcbmltcG9ydCB7IGNvbG91cnMgfSBmcm9tIFwiLi4vQ29sb3Vyc1wiO1xuaW1wb3J0IHsgdG9Db2xvdXJLZXkgfSBmcm9tIFwiLi4vTGVnZW5kXCI7XG5pbXBvcnQgeyBsYWJlbElzWmVybyB9IGZyb20gXCIuLi9oZWxwZXJzXCI7XG5cblxuY2xhc3MgSGlzdG9ncmFtIGV4dGVuZHMgR2VvbWV0cnkge1xuXG4gICAgY29uc3RydWN0b3IobmFtZSwgcGFkZGluZykge1xuICAgICAgICBzdXBlcihuYW1lIHx8IFwiSElTVE9HUkFNXCIpO1xuICAgICAgICB0aGlzLl9CQVJfR1JPV1RIID0gMTAwO1xuICAgICAgICB0aGlzLl9wYWRkaW5nID0gcGFkZGluZyB8fCAwO1xuICAgICAgICB0aGlzLl9zdHJva2Vfd2lkdGggPSAxXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBwYWRkaW5nIGJldHdlZW4gYmFyIGdyb3Vwcy4gMCBwYWRkaW5nIGlzIGEgc3RhbmRhcmQgaGlzdG9ncmFtLlxuICAgICAqL1xuICAgIHBhZGRpbmcocGFkZGluZykge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX3BhZGRpbmc7XG4gICAgICAgIHRoaXMuX3BhZGRpbmcgPSBwYWRkaW5nO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLl9lbGVtZW50O1xuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5wcmVwYXJlRGF0YShudWxsLCB0cnVlKTtcbiAgICAgICAgY29uc3QgYWxsRGF0YSA9IHRoaXMucHJlcGFyZURhdGEobnVsbCwgZmFsc2UpO1xuICAgICAgICBjb25zdCB3aWR0aCA9IHRoaXMuX3dpZHRoLFxuICAgICAgICAgICAgICBoZWlnaHQgPSB0aGlzLl9oZWlnaHQ7XG5cbiAgICAgICAgZWxlbWVudC5jbGFzc2VkKFwiaGlzdG9ncmFtXCIsIHRydWUpO1xuXG4gICAgICAgIGNvbnN0IHggPSB0aGlzLmdldEQzWFNjYWxlKGRhdGEsIHdpZHRoKTtcbiAgICAgICAgY29uc3QgeSA9IHRoaXMuZ2V0RDNZU2NhbGUoYWxsRGF0YSwgaGVpZ2h0KTtcbiAgICAgICAgY29uc3QgeEdyb3VwID0gdGhpcy5nZXREM1hHcm91cFNjYWxlKGRhdGEsIHgpO1xuICAgICAgICBjb25zdCBjb2xvdXJzID0gdGhpcy5kM0NvbG91clNjYWxlKCk7XG5cbiAgICAgICAgbGV0IGdyb3VwcyA9IGVsZW1lbnQuc2VsZWN0KFwiLmJhcnNcIikuc2VsZWN0QWxsKCcuZ3JvdXAnKTtcblxuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gR2V0IHJpZCBvZiBjdXJyZW50IGxhYmVsc1xuXG4gICAgICAgIGVsZW1lbnQuc2VsZWN0KFwiLmNoYXJ0LWxhYmVsc1wiKVxuICAgICAgICAgICAucmVtb3ZlKCk7XG5cbiAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgaWYgKGdyb3Vwcy5lbXB0eSgpKSB7XG4gICAgICAgICAgICBncm91cHMgPSBlbGVtZW50XG4gICAgICAgICAgICAgICAgLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwiYmFyc1wiKVxuICAgICAgICAgICAgICAgIC5zZWxlY3RBbGwoXCIuZ3JvdXBcIik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBFbnN1cmUgdGhhdCB3ZSdyZSBhbHdheXMgdXNpbmcgdGhlIGNvcnJlY3QgaGVpZ2h0LlxuICAgICAgICBlbGVtZW50LnNlbGVjdChcIi5iYXJzXCIpXG4gICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKDAsIFwiICsgaGVpZ2h0ICsgXCIpLCBzY2FsZSgxLCAtMSlcIik7XG5cbiAgICAgICAgZ3JvdXBzID0gZ3JvdXBzLmRhdGEoZGF0YSk7XG5cbiAgICAgICAgZ3JvdXBzLmV4aXQoKS5yZW1vdmUoKTtcblxuICAgICAgICBncm91cHMuZW50ZXIoKVxuICAgICAgICAgICAgICAuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImdyb3VwXCIpXG4gICAgICAgICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBkID0+IFwidHJhbnNsYXRlKFwiICsgeChkLl9rZXkpICsgXCIsMClcIilcbiAgICAgICAgICAgICAgICAgIC5hdHRyKFwid2lkdGhcIiwgeC5iYW5kd2lkdGgoKSlcbiAgICAgICAgICAgICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIFwiMTAwJVwiKVxuICAgICAgICAgICAgICAubWVyZ2UoZ3JvdXBzKVxuICAgICAgICAgICAgICAuaW50ZXJydXB0KFwiZ3JvdXBzOm1vdmVcIilcbiAgICAgICAgICAgICAgLnRyYW5zaXRpb24oXCJncm91cHM6bW92ZVwiKVxuICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgZCA9PiBcInRyYW5zbGF0ZShcIiArIHgoZC5fa2V5KSArIFwiLDApXCIpXG4gICAgICAgICAgICAgICAgICAuYXR0cihcIndpZHRoXCIsIHguYmFuZHdpZHRoKCkpXG4gICAgICAgICAgICAgIC5lYWNoKChzX2QsIHNfaSwgbm9kZXMpID0+IHtcbiAgICAgICAgICAgICAgICAgIGxldCBncm91cCA9IGQzLnNlbGVjdChub2Rlc1tzX2ldKTtcblxuICAgICAgICAgICAgICAgICAgbGV0IGJhcnMgPSBncm91cC5zZWxlY3RBbGwoXCIuYmFyXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmRhdGEoc19kLmRhdGEpO1xuXG4gICAgICAgICAgICAgICAgICBiYXJzLmV4aXQoKS5yZW1vdmUoKTtcblxuICAgICAgICAgICAgICAgICAgYmFycy5pbnRlcnJ1cHQoXCJiYXI6bW92ZVwiKSAgICAgLy8gQW5pbWF0ZSB0aGUgYmFycyB0byB0aGVpciBuZXcgcG9zaXRpb24uXG4gICAgICAgICAgICAgICAgICAgICAgLnRyYW5zaXRpb24oXCJiYXI6bW92ZVwiKVxuICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwid2lkdGhcIiwgeEdyb3VwLmJhbmR3aWR0aCgpKVxuICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwieFwiLCBkID0+IHhHcm91cChkLl9rZXkpKVxuICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwieVwiLCAwKTtcblxuICAgICAgICAgICAgICAgICAgYmFycy5lbnRlcigpXG4gICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZChcInJlY3RcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwiY3Vyc29yXCIsIFwicG9pbnRlclwiKVxuICAgICAgICAgICAgICAgICAgICAgIC5vbihcImNvbnRleHRtZW51XCIsICgpID0+IGQzLmV2ZW50LnByZXZlbnREZWZhdWx0KCkpIC8vIE5vIHJpZ2h0IGNsaWNrLlxuICAgICAgICAgICAgICAgICAgICAgIC5tZXJnZShiYXJzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcInhcIiwgZCA9PiB4R3JvdXAoZC5fa2V5KSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ5XCIsIGhlaWdodCAtIHkoMCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwid2lkdGhcIiwgeEdyb3VwLmJhbmR3aWR0aCgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIGQgPT4gXCJiYXIgc2VyaWVzIHNlcmllcy1cIiArIHRvQ29sb3VyS2V5KGQuX2NvbG91cikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcImZpbGxcIiwgZCA9PiB0aGlzLmdldEQzQ29sb3VyKGQpKSAvLyBjb2xvdXJzKGQuX2NvbG91cikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcInN0cm9rZVwiLCBkID0+IGQzLmhjbCh0aGlzLmdldEQzQ29sb3VyKGQpKS5kYXJrZXIoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwic3Ryb2tlLXdpZHRoXCIsIHRoaXMuX3N0cm9rZV93aWR0aClcbiAgICAgICAgICAgICAgICAgICAgICAub24oXCJjbGljayBhdXhjbGlja1wiLCAoZCwgaSwgbm9kZXMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlzcGF0Y2guY2FsbChcImVsZW1lbnRDbGlja1wiLCB0aGlzLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlOiBkMy5ldmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50OiBkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzOiBkLl9zZXJpZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXNJbmRleDogc19pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGQuX3lcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgIC5vbihcIm1vdXNlb3ZlclwiLCAoZCwgaSwgbm9kZXMpID0+IHsgLy8gRGFya2VuIHRoZSBiYXIgb24gbW91c2Ugb3ZlclxuICAgICAgICAgICAgICAgICAgICAgICAgICBkMy5zZWxlY3Qobm9kZXNbaV0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmludGVycnVwdChcImhvdmVyOmNvbG91clwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKFwiaG92ZXI6Y29sb3VyXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKDQwMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIGQzLmhjbCh0aGlzLmdldEQzQ29sb3VyKGQpKS5kYXJrZXIoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3BhdGNoLmNhbGwoXCJ0b29sdGlwU2hvd1wiLCB0aGlzLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlOiBkMy5ldmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50OiBkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzOiBzX2QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXNJbmRleDogc19pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGQuX3lcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgIC5vbihcIm1vdXNlb3V0XCIsIChkLCBpLCBub2RlcykgPT4geyAvLyBiYXIgaXMgcmVndWxhciBjb2xvdXIgb24gbW91c2Ugb3V0LlxuICAgICAgICAgICAgICAgICAgICAgICAgICBkMy5zZWxlY3Qobm9kZXNbaV0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmludGVycnVwdChcImhvdmVyOmNvbG91clwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKFwiaG92ZXI6Y29sb3VyXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKDQwMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIGQgPT4gdGhpcy5nZXREM0NvbG91cihkKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3BhdGNoLmNhbGwoXCJ0b29sdGlwSGlkZVwiLCB0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgIC5pbnRlcnJ1cHQoXCJiYXI6Z3Jvd3RoXCIpICAgIC8vIEFuaW1hdGUgYmFycyBncm93aW5nLlxuICAgICAgICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKFwiYmFyOmdyb3d0aFwiKVxuICAgICAgICAgICAgICAgICAgICAgIC5kZWxheSgoKSA9PiB0aGlzLmNhbGNCYXJHcm93dGgoc19pLCBub2Rlcy5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIGQgPT4gdGhpcy5nZXREM0NvbG91cihkKSkgLy9jb2xvdXJzKGQuX2NvbG91cikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcInN0cm9rZVwiLCBkID0+IGQzLmhjbCh0aGlzLmdldEQzQ29sb3VyKGQpKS5kYXJrZXIoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ5XCIsIGQgPT4gaGVpZ2h0IC0geShNYXRoLm1pbigwLCBkLl95KSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIGQgPT4gKE1hdGguYWJzKHkoMCkgLSB5KGQuX3kpKSkpO1xuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAvLyBMYWJlbHMgbG9hZGVkIGFmdGVyIG91ciBsYXN0IGJhciBncm93cy5cbiAgICAgICAgaWYgKHRoaXMuc2hvd0xhYmVscygpKSB7XG4gICAgICAgICAgICBlbGVtZW50LnRyYW5zaXRpb24oXCJiYXI6Z3Jvd3RoXCIpXG4gICAgICAgICAgICAgICAub24oXCJlbmRcIiwgKGQsIGksIG5vZGVzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgaWYgKGkgPCBub2Rlcy5sZW5ndGggLSAxKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJMYWJlbHMoZWxlbWVudCwgZGF0YSwgeCwgeEdyb3VwLCB5LCBjb2xvdXJzKTtcbiAgICAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjYWxjQmFyR3Jvd3RoKGksIG1heCkge1xuICAgICAgICBpZiAobWF4IDwgMTApIHJldHVybiBpICogdGhpcy5fQkFSX0dST1dUSCAvIDI7XG4gICAgICAgIGlmIChtYXggPCAzNSkgcmV0dXJuIGkgKiB0aGlzLl9CQVJfR1JPV1RIIC8gNDtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuXG4gICAgcHJlcGFyZURhdGEoZGF0YSwgZmFjZXRlZCkge1xuICAgICAgICBkYXRhID0gR2VvbWV0cnkucHJvdG90eXBlLnByZXBhcmVEYXRhLmNhbGwodGhpcywgZGF0YSwgZmFjZXRlZCk7XG5cbiAgICAgICAgY29uc3Qgc29ydE9yZGVyID0ge307XG4gICAgICAgIHRoaXMueFZhbHVlcygpLmZvckVhY2goKGQsIGkpID0+IHtcbiAgICAgICAgICAgIHNvcnRPcmRlcltkXSA9IHNvcnRPcmRlcltkXSB8fCAoXCJcIiArIGkpO1xuICAgICAgICB9KTtcblxuICAgICAgICBsZXQgcmVzdWx0cyA9IHt9O1xuXG4gICAgICAgIC8vIFdlIHdhbnQgdG8gY2FsY3VsYXRlIHdoYXQgYnVja2V0IGVhY2ggYml0IG9mIGRhdGEgYmVsb25ncyB0by5cbiAgICAgICAgY29uc3QgYnVja2V0cyA9IHRoaXMuc2NhbGVYKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYnVja2V0cyhPYmplY3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnZhbHVlcyhkYXRhKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKGQgPT4gZC5kYXRhKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVkdWNlKChhY2MsIGN1cikgPT4gYWNjLmNvbmNhdChjdXIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKGQgPT4gZC5feCkpO1xuXG4gICAgICAgIC8vIFNvcnQgZGF0YSBpbiB0byB0aGVpciBhcHByb3ByaWF0ZSBidWNrZXRzLiBUaGlzIG1heSBiZVxuICAgICAgICAvLyBzcGVjaWZpYyBkYXRlIGJ1Y2tldHMsIG9yIGdlbmVyYWwgYnVja2V0cyBmb3IgY29udGludW91cyBkYXRhLlxuICAgICAgICBPYmplY3Qua2V5cyhkYXRhKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWVzID0gZGF0YVtrZXldLmRhdGE7XG4gICAgICAgICAgICB2YWx1ZXMuZm9yRWFjaChkID0+IHtcbiAgICAgICAgICAgICAgICBkLl9idWNrZXQgPSBidWNrZXRzLmJ1Y2tldChkLl94KTtcbiAgICAgICAgICAgICAgICBsZXQgYnVja2V0ID0gcmVzdWx0c1tkLl9idWNrZXRdIHx8IHsgX2tleTogZC5fYnVja2V0LCBkYXRhOiBbXSB9O1xuICAgICAgICAgICAgICAgIGJ1Y2tldC5kYXRhLnB1c2goZCk7XG4gICAgICAgICAgICAgICAgcmVzdWx0c1tkLl9idWNrZXRdID0gYnVja2V0O1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGJ1Y2tldHMuY29uc29saWRhdGVCdWNrZXRzKE9iamVjdC52YWx1ZXMocmVzdWx0cykpXG4gICAgICAgICAgICAuc29ydCgobGhzLCByaHMpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc29ydE9yZGVyW1wiXCIgKyBsaHMuX2tleV0gLSBzb3J0T3JkZXJbXCJcIiArIHJocy5fa2V5XTtcbiAgICAgICAgICAgIH0pO1xuICAgIH1cblxuICAgIGdldEtleXMoZGF0YSkge1xuICAgICAgICBpZiAoIWRhdGEgfHwgIWRhdGEubGVuZ3RoKSByZXR1cm4gW107XG5cbiAgICAgICAgbGV0IGtleXMgPSBuZXcgU2V0KCk7XG5cbiAgICAgICAgLy8gdG9kbyBjYWxjdWxhdGUgYnVja2V0c1xuICAgICAgICBPYmplY3Qua2V5cyhkYXRhKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWVzID0gZGF0YVtrZXldLmRhdGE7XG4gICAgICAgICAgICB2YWx1ZXMuZm9yRWFjaChkID0+IGtleXMuYWRkKGQuX2tleSkpXG4gICAgICAgIH0pO1xuXG5cbiAgICAgICAgcmV0dXJuIFsuLi5rZXlzXVxuICAgIH1cblxuICAgIGdldEQzWFNjYWxlKGRhdGEsIHdpZHRoKSB7XG4gICAgICAgIGRhdGEgPSBkYXRhIHx8IHRoaXMucHJlcGFyZURhdGEobnVsbCwgdHJ1ZSk7XG4gICAgICAgIHdpZHRoID0gd2lkdGggfHwgdGhpcy53aWR0aCgpO1xuXG4gICAgICAgIGxldCBwID0gdGhpcy5fcGFkZGluZ1xuICAgICAgICBpZiAoZGF0YVswXS5kYXRhLmxlbmd0aCA+IDEgJiYgcCA9PT0gMCkgcCA9IDAuMlxuICAgICAgICByZXR1cm4gZDMuc2NhbGVCYW5kKClcbiAgICAgICAgICAgICAgICAgLnJhbmdlUm91bmQoWzAsIHdpZHRoXSlcbiAgICAgICAgICAgICAgICAgLnBhZGRpbmcocClcbiAgICAgICAgICAgICAgICAgLmRvbWFpbihkYXRhLm1hcChkID0+IGQuX2tleSkpO1xuICAgIH1cblxuICAgIGdldEQzWVNjYWxlKGRhdGEsIGhlaWdodCkge1xuICAgICAgICBkYXRhID0gZGF0YSB8fCB0aGlzLnByZXBhcmVEYXRhKG51bGwsIGZhbHNlKTtcbiAgICAgICAgaGVpZ2h0ID0gaGVpZ2h0IHx8IHRoaXMuaGVpZ2h0KCk7XG5cblxuICAgICAgICBjb25zdCBtYXggPSBNYXRoLm1heChkMy5tYXgoZGF0YSwgZCA9PiBkMy5tYXgoZC5kYXRhLCBkID0+IGQuX3kpKSwgMCk7XG4gICAgICAgIGNvbnN0IG1pbiA9IE1hdGgubWluKDAsIGQzLm1pbihkYXRhLCBkID0+IGQzLm1pbihkLmRhdGEsIGQgPT4gZC5feSkpKTtcbiAgICAgICAgcmV0dXJuIGQzLnNjYWxlTGluZWFyKClcbiAgICAgICAgICAgICAgICAgLnJhbmdlUm91bmQoW2hlaWdodCwgMF0pXG4gICAgICAgICAgICAgICAgIC5uaWNlKClcbiAgICAgICAgICAgICAgICAgLmRvbWFpbihbbWluLCBtYXhdKTtcbiAgICB9XG5cbiAgICBnZXREM1hHcm91cFNjYWxlKGRhdGEsIHhzY2FsZSkge1xuICAgICAgICByZXR1cm4gZDMuc2NhbGVCYW5kKClcbiAgICAgICAgICAgICAgICAgLnBhZGRpbmcoMClcbiAgICAgICAgICAgICAgICAgLmRvbWFpbih0aGlzLmdldEtleXMoZGF0YSkpXG4gICAgICAgICAgICAgICAgIC5yYW5nZVJvdW5kKFswLCB4c2NhbGUuYmFuZHdpZHRoKCldKTtcbiAgICB9XG5cbiAgICByZW5kZXJMYWJlbHMoc2VsZWN0aW9uLCBkYXRhLCB4c2NhbGUsIHhncm91cCwgeXNjYWxlLCBjb2xvdXJTY2FsZSwgYW5pbWF0ZSkge1xuICAgICAgICBhbmltYXRlID0gYW5pbWF0ZSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGFuaW1hdGU7XG4gICAgICAgIHNlbGVjdGlvbi5zZWxlY3RBbGwoXCIuY2hhcnQtbGFiZWxzXCIpLnJlbW92ZSgpO1xuXG4gICAgICAgIGxldCBsYWJlbHMgPSBzZWxlY3Rpb24uYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImNoYXJ0LWxhYmVsc1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnNlbGVjdEFsbChcIi5sYWJlbC1ncm91cFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmRhdGEoZGF0YSk7XG5cbiAgICAgICAgbGV0IG1heFdpZHRoID0gMDsgICAgIC8vIEZvciBjYWxjdWxhdGluZyB0aGUgbWF4IHdpZHRoIG9mIHRleHQuXG4gICAgICAgIGxldCBmb250U2l6ZSA9IHRoaXMuX2ZvbnRfc2l6ZTsgICAgLy8gT3VyIGluaXRpYWwgZm9udCBzaXplLlxuICAgICAgICBjb25zdCBidWZmZXIgPSA1OyAgICAgLy8gQnVmZmVyIHNwYWNlIGJldHdlZW4gd29yZHMgYW5kIHRoZSB0b3Agb2YgYSBiYXIuXG4gICAgICAgIGNvbnN0IGNhbGNEeSA9ICh5LCB5cG9zKSA9PiAoKHkgPj0gMCAmJiB5cG9zIDwgMTApIHx8ICggeSA8IDAgJiYgdGhpcy5faGVpZ2h0IC0geXBvcyA+IDEwKSkgPyBmb250U2l6ZSArIDI6IC1idWZmZXI7XG5cbiAgICAgICAgLy8gV2FudCB0byBmaWd1cmUgb3V0IGlmIHRoZSBsYWJlbCBpcyB0b28gZGFyayAvIGxpZ2h0IGZvciB0aGVcbiAgICAgICAgLy8gYmFyLlxuICAgICAgICBjb25zdCBnZXRJbnZlcnRlZENvbG9yID0gZCA9PiB7XG4gICAgICAgICAgICBsZXQgaW52ZXJ0ZWRDb2xvciA9IGQzLmhjbCh0aGlzLmdldEQzQ29sb3VyKGQpKTtcbiAgICAgICAgICAgIGludmVydGVkQ29sb3IubCArPSBNYXRoLm1pbihpbnZlcnRlZENvbG9yLmwgKyA1MCwgMTAwKTtcbiAgICAgICAgICAgIHJldHVybiBpbnZlcnRlZENvbG9yO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBzaG91bGRJbnZlcnQgPSBkID0+IGQzLmhjbCh0aGlzLmdldEQzQ29sb3VyKGQpKS5sIDwgNjA7XG4gICAgICAgIGNvbnN0IGZpbGxDb2xvdXIgPSBkMy5oY2woY29sb3Vycy5laWdodGVlbi5kYXJrR3JleSkuYnJpZ2h0ZXIoKTtcbiAgICAgICAgY29uc3QgbGlnaHRlckZpbGxDb2xvdXIgPSBkMy5oY2woY29sb3Vycy5laWdodGVlbi5taWRHcmV5KTtcbiAgICAgICAgY29uc3QgZmluZENvbG91ciA9IChkLCBkeSwgbGFiZWxUZXh0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvbkJhciA9IChkLl95ID49IDAgJiYgZHkgPiAwIHx8IGQuX3kgPCAwICYmIGR5IDwgMCk7XG4gICAgICAgICAgICByZXR1cm4gb25CYXIgJiYgc2hvdWxkSW52ZXJ0KGQpXG4gICAgICAgICAgICAgICAgPyBnZXRJbnZlcnRlZENvbG9yKGQpLnRvU3RyaW5nKClcbiAgICAgICAgICAgICAgICA6IChsYWJlbElzWmVybyhsYWJlbFRleHQpXG4gICAgICAgICAgICAgICAgICAgID8gbGlnaHRlckZpbGxDb2xvdXJcbiAgICAgICAgICAgICAgICAgICAgOiAob25CYXIgPyBkMy5oY2woZmlsbENvbG91cikuZGFya2VyKCkgOiBmaWxsQ29sb3VyKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgbGFiZWxzLmVudGVyKCkuZWFjaCgoc2VyaWVzLCBzX2ksIHNfbm9kZXMpID0+IHtcbiAgICAgICAgICAgIC8vIFdlIHdhbnQgdG8gZGV0ZXJtaW5lIHdoaWNoIGdyb3VwcyBtYXkgaGF2ZSBtaXNzaW5nIHZhbHVlcywgYW5kIHByb3ZpZGUgdGhlbS5cbiAgICAgICAgICAgIGNvbnN0IHJlcXVpcmVkR3JvdXBzID0ge307XG4gICAgICAgICAgICB4Z3JvdXAuZG9tYWluKCkubWFwKGZyb21LZXkpLmZvckVhY2goZCA9PiB7XG4gICAgICAgICAgICAgICAgcmVxdWlyZWRHcm91cHNbZC5fY29sb3VyXSA9IGQ7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgc2VyaWVzLmRhdGEuZm9yRWFjaChkID0+IHtcbiAgICAgICAgICAgICAgICBkZWxldGUgcmVxdWlyZWRHcm91cHNbZC5fY29sb3VyXVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGNvbnN0IG1pc3NpbmdHcm91cHMgPSBPYmplY3QudmFsdWVzKHJlcXVpcmVkR3JvdXBzKTtcbiAgICAgICAgICAgIG1pc3NpbmdHcm91cHMuZm9yRWFjaChkID0+IHtcbiAgICAgICAgICAgICAgICBkLl94ID0gc2VyaWVzLl9rZXk7XG4gICAgICAgICAgICAgICAgZC5feSA9IDA7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgZDMuc2VsZWN0KHNfbm9kZXNbc19pXSlcbiAgICAgICAgICAgICAgLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImxhYmVsLWdyb3VwXCIpXG4gICAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIGQgPT4gXCJ0cmFuc2xhdGUoXCIgKyB4c2NhbGUoZC5fa2V5KSArIFwiLDApXCIpXG4gICAgICAgICAgICAgIC5zZWxlY3RBbGwoXCIuY2hhcnQtbGFiZWxcIilcbiAgICAgICAgICAgICAgLmRhdGEoc2VyaWVzLmRhdGEuY29uY2F0KE9iamVjdC52YWx1ZXMobWlzc2luZ0dyb3VwcykpKVxuICAgICAgICAgICAgICAuZW50ZXIoKVxuICAgICAgICAgICAgICAuZWFjaCgoZCwgaSwgbm9kZXMpID0+IHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGxhYmVsVGV4dCA9IHRoaXMuZm9ybWF0TGFiZWwoKShkLl95LCBkKTtcbiAgICAgICAgICAgICAgICAgIGxldCB5cG9zID0geXNjYWxlKGQuX3kpO1xuICAgICAgICAgICAgICAgICAgbGV0IGR5ID0gY2FsY0R5KGQuX3ksIHlwb3MpO1xuICAgICAgICAgICAgICAgICAgbGV0IHRleHQgPSBkMy5zZWxlY3Qobm9kZXNbaV0pXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRleHQobGFiZWxUZXh0KVxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwiZm9udC1zaXplXCIsIGZvbnRTaXplICsgXCJweFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBkID0+IFwiY2hhcnQtbGFiZWwgc2VyaWVzIHNlcmllcy1cIiArIHRvQ29sb3VyS2V5KGQuX2NvbG91cikpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcInlcIiwgeXBvcylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiZHhcIiwgYW5pbWF0ZSA/IC0xNSA6IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcImR5XCIsIGR5KVxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwicG9pbnRlci1ldmVudHNcIiwgXCJub25lXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIGQgPT4gZmluZENvbG91cihkLCBkeSwgbGFiZWxUZXh0KSk7XG5cbiAgICAgICAgICAgICAgICAgIC8vIFNldCB0aGUgeCBwb3NpdGlvbiwgd2hpY2ggaXMgYmFzZWQgb24gd2lkdGguXG4gICAgICAgICAgICAgICAgICBjb25zdCB3aWR0aCA9IHRleHQubm9kZSgpLmdldEJCb3goKS53aWR0aDtcbiAgICAgICAgICAgICAgICAgIG1heFdpZHRoID0gTWF0aC5tYXgod2lkdGgsIG1heFdpZHRoKTtcbiAgICAgICAgICAgICAgICAgIHRleHRcbiAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcInhcIiwgeGdyb3VwKGQuX2tleSkgKyB4Z3JvdXAuYmFuZHdpZHRoKCkgLyAyIC0gd2lkdGggLyAyKTtcblxuICAgICAgICAgICAgICAgICAgdGV4dFxuICAgICAgICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKFwibGFiZWxzXCIpXG4gICAgICAgICAgICAgICAgICAgICAgLmRlbGF5KCgpID0+IGFuaW1hdGUgPyB0aGlzLmNhbGNCYXJHcm93dGgoc19pLCBzX25vZGVzLmxlbmd0aCkgOiAwKSAvLyBEZWxheSBpbiBsb2Nrc3RlcCB3aXRoIGJhciBncm93dGguXG4gICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJkeFwiLCAwKVxuICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMSlcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgfSk7XG5cblxuICAgICAgICAvLyBGaWd1cmUgb3V0IGlmIHdlIGRvbid0IGhhdmUgZW5vdWdoIHNwYWNlIHRvIHNob3cgb3VyIGxhYmVscy5cbiAgICAgICAgLy8gV2UgdGhlbiB3YW50IHRvIHJlc2l6ZSwgaWYgcG9zc2libGUuXG4gICAgICAgIGlmICh4Z3JvdXAuYmFuZHdpZHRoKCkgPCBtYXhXaWR0aCAqIDEuMTApIHtcbiAgICAgICAgICAgIGxldCBzY2FsZSA9IG1heFdpZHRoIC8geGdyb3VwLmJhbmR3aWR0aCgpICogMS4xMDtcbiAgICAgICAgICAgIGZvbnRTaXplID0gTWF0aC5mbG9vcihmb250U2l6ZSAvIHNjYWxlKTtcblxuICAgICAgICAgICAgaWYgKGZvbnRTaXplIDwgMTApIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgbGFiZWxzIGFyZSB0b28gc21hbGwuXG4gICAgICAgICAgICAgICAgbGFiZWxzLmVudGVyKCkuc2VsZWN0QWxsKFwidGV4dFwiKS5yZW1vdmUoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGFiZWxzLmVudGVyKClcbiAgICAgICAgICAgICAgICAgICAgICAubWVyZ2UobGFiZWxzKVxuICAgICAgICAgICAgICAgICAgICAgIC5zZWxlY3RBbGwoXCJ0ZXh0XCIpXG4gICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwiZm9udC1zaXplXCIsIGZvbnRTaXplICsgXCJweFwiKVxuICAgICAgICAgICAgICAgICAgICAgIC5lYWNoKChkLCBpLCBub2RlcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXh0ID0gZDMuc2VsZWN0KG5vZGVzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgd2lkdGggPSB0ZXh0Lm5vZGUoKS5nZXRCQm94KCkud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGR5ID0gY2FsY0R5KGQuX3ksIHlzY2FsZShkLl95KSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIHhncm91cChkLl9rZXkpICsgeGdyb3VwLmJhbmR3aWR0aCgpIC8gMiAtIHdpZHRoIC8gMilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcImZpbGxcIiwgZCA9PiBmaW5kQ29sb3VyKGQsIGR5LCB0ZXh0LnRleHQoKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcImR5XCIsIGR5KTtcbiAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICBpbW1lZGlhdGVseVJlbmRlckxhYmVscyhzaG93KSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQoKTtcbiAgICAgICAgaWYgKCFlbGVtZW50KSByZXR1cm47XG5cbiAgICAgICAgaWYgKCFzaG93KSB7IC8vIEhpZGVzIHRoZSBsYWJlbHNcbiAgICAgICAgICAgIGVsZW1lbnRcbiAgICAgICAgICAgICAgLnNlbGVjdCgnLmNoYXJ0LWxhYmVscycpXG4gICAgICAgICAgICAgIC5pbnRlcnJ1cHQoXCJsYWJlbHNcIilcbiAgICAgICAgICAgICAgLmludGVycnVwdChcImxhYmVsczpmYWRlXCIpXG4gICAgICAgICAgICAgIC50cmFuc2l0aW9uKFwibGFiZWxzOmZhZGVcIilcbiAgICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAwKVxuICAgICAgICAgICAgICAub24oXCJlbmRcIiwgKGQsIGksIG5vZGVzKSA9PiB7XG4gICAgICAgICAgICAgICAgICBkMy5zZWxlY3Qobm9kZXNbaV0pLnJlbW92ZSgpO1xuICAgICAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IGxhYmVscyA9IGVsZW1lbnQuc2VsZWN0KCcuY2hhcnQtbGFiZWxzJyk7XG4gICAgICAgICAgICBpZiAoIWxhYmVscy5lbXB0eSgpKSByZXR1cm47XG5cbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLnByZXBhcmVEYXRhKG51bGwsIHRydWUpO1xuICAgICAgICAgICAgY29uc3QgYWxsRGF0YSA9IHRoaXMucHJlcGFyZURhdGEobnVsbCwgZmFsc2UpO1xuXG4gICAgICAgICAgICBjb25zdCB4c2NhbGUgPSB0aGlzLmdldEQzWFNjYWxlKGRhdGEpLFxuICAgICAgICAgICAgICAgICAgeGdyb3VwID0gdGhpcy5nZXREM1hHcm91cFNjYWxlKGRhdGEsIHhzY2FsZSksXG4gICAgICAgICAgICAgICAgICB5c2NhbGUgPSB0aGlzLmdldEQzWVNjYWxlKGRhdGEpLFxuICAgICAgICAgICAgICAgICAgY29sb3VyU2NhbGUgPSB0aGlzLmQzQ29sb3VyU2NhbGUoKTtcblxuICAgICAgICAgICAgbGFiZWxzLnJlbW92ZSgpO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJMYWJlbHMoZWxlbWVudCwgZGF0YSwgeHNjYWxlLCB4Z3JvdXAsIHlzY2FsZSwgY29sb3VyU2NhbGUsIGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG5cbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gaGlzdG9ncmFtKCkge1xuICAgIHJldHVybiBuZXcgSGlzdG9ncmFtKCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb2x1bW5DaGFydCgpIHtcbiAgICByZXR1cm4gbmV3IEhpc3RvZ3JhbShcIkNPTFVNTl9DSEFSVFwiLCAwLjEpO1xufSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/chart/Histogram.js\n')},"./src/chart/Line.js":
/*!***************************!*\
  !*** ./src/chart/Line.js ***!
  \***************************/
/*! exports provided: line */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "line", function() { return line; });\n/* harmony import */ var _Geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Geometry */ "./src/chart/Geometry.js");\n/* harmony import */ var _Legend__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Legend */ "./src/Legend.js");\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helpers */ "./src/helpers.js");\n/* harmony import */ var _Colours__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Colours */ "./src/Colours.js");\n// Copyright (C) 2013-2014, 2018 BrandsEye (PTY) LTD\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this\n// software and associated documentation files (the "Software"), to deal in the Software\n// without restriction, including without limitation the rights to use, copy, modify,\n//     merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following\n// conditions:\n//\n//     The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n//     INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n// CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n\n\n\n\nclass Line extends _Geometry__WEBPACK_IMPORTED_MODULE_0__["Geometry"] {\n\n    constructor() {\n        super("LINE", 2);\n        this._stroke_width = 2\n        this._curve = \'curveCatmullRom\'\n    }\n\n  curve(curve) {\n    if (arguments.length === 0) return this._curve;\n    this._curve = curve;\n    return this;\n  }\n\n  render() {\n        const element = this._element;\n        const data = this.prepareData(null, true);\n        const width = this._width,\n              height = this._height;\n        const allData = this.prepareData(null, false).map(d => d.data).reduce((acc, val) => acc.concat(val));\n\n        element.classed("line-chart", true);\n\n\n        const x = this.getD3XScale(allData, width);\n        const y = this.getD3YScale(allData, height);\n        const invert = d3.scaleQuantize().domain(x.range()).range(x.domain());\n\n        //---------------------------------\n        // append the lines\n        let lineGroup = element.select(".lines");\n        lineGroup.selectAll("circle").remove();\n\n        let circle = false;\n        let lastMouse = null;\n        let lastMin = null;\n\n        if (lineGroup.empty()) {\n            lineGroup = element\n                .append("g")\n                .attr("class", "lines")\n                .attr("width", this.width())\n                .attr("height", this.height());\n\n            // This is needed to provide area for mouse interactions.\n            lineGroup\n                .append("rect")\n                .style("opacity", "0")\n                .attr("width", "100%")\n                .attr("height", "100%");\n        }\n\n        if (this.scaleX().isContinuous()) {\n            lineGroup\n            lineGroup\n                .on("mousemove", (d, i, nodes) => { // Darken the bar on mouse over\n                    const mouse = d3.mouse(nodes[i]);\n\n                    const xval = invert(mouse[0]);\n                    const yval = y.invert(mouse[1]);\n                    // let min = this.getClosestPoint(xval, yval, this.getTransformedData()[0].data);\n\n                    let mins = data.map(d => getClosestPoint(xval, yval, d.data));\n                    mins.forEach(d => d._dist =  [x(d._x), y(d._y)]);\n\n                    mins = mins.filter(min => {\n                        const minScreenDist = Math.sqrt((mouse[0] - min._dist[0]) ** 2 + (mouse[1] - min._dist[1]) ** 2);\n                        min._min_screen = minScreenDist;\n                        return minScreenDist < 100;\n                    });\n\n\n                    if (!mins || !mins.length) {\n                        lastMouse = null;\n                        lineGroup.selectAll("circle").remove();\n                        return;\n                    }\n\n                    mins = mins.sort((lhs, rhs) => lhs._min_screen - rhs._min_screen);\n                    let min = mins[0];\n\n                    if (circle) {\n                        if (lastMin && min._x.getTime() === lastMin._x.getTime()) return;\n                        lineGroup.selectAll("circle").remove();\n                    }\n\n                    circle = true;\n                    lastMouse = mouse;\n                    lastMin = min;\n                    lineGroup\n                        .append("circle")\n                        .attr("cx", x(min._x) + x.bandwidth() / 2)\n                        .attr("cy", y(min._y))\n                        .attr("r", 10)\n                        .attr("fill", this.getD3Colour(d))\n                        .style("opacity", 0.1)\n                        .on("contextmenu", () => d3.event.preventDefault()) // No right click.\n                        .on("click auxclick", (d, i, nodes) => {\n                            this._dispatch.call("elementClick", this, {\n                                e: d3.event,\n                                point: min,\n                                series: data[min._s_i],\n                                seriesIndex: min._s_i,\n                                value: min._y\n                            })\n                        })\n                        .on("mouseover", () => {\n                            this._dispatch.call("tooltipShow", this, {\n                                e: d3.event,\n                                point: min,\n                                series: data[min._s_i],\n                                seriesIndex: min._s_i,\n                                value: min._y\n                            })\n                        })\n                        .on("mouseout", (d, i, nodes) => { // bar is regular colour on mouse out.\n                            this._dispatch.call("tooltipHide", this);\n                        })\n                        .transition()\n                        .style("opacity", 0.5)\n\n                });\n        }\n\n        const lineGeom = d3.line()\n            .x(d => x(d._x) + x.bandwidth() / 2)\n            .y(d => y(d._y))\n            .curve(d3[this._curve]);\n\n        const flatGeom = d3.line()\n            .x(d => x(d._x) + x.bandwidth() / 2)\n            .y(y(0))\n            .curve(d3[this._curve]);\n\n        let lines = lineGroup.selectAll(\'.line\');\n        lines = lines.data(data, d => d._key);\n\n        lines.exit()\n            .interrupt()\n            .transition()\n            .attr("d", d => flatGeom(d.data))\n            .style("opacity", 0)\n            .on("end", (d, i, nodes) => d3.select(nodes[i]).remove());\n\n\n\n        const determineStrokeWidth = d => d.data.length <= 1 ? 20 : this._stroke_width;\n        const transparentColour = d3.hcl(_Colours__WEBPACK_IMPORTED_MODULE_3__["colours"].eighteen.darkGrey);\n        transparentColour.opacity = 0.8;\n        const determineStrokeColour = d => d3.hcl(this.getD3Colour(d)).c < 20 ? transparentColour : "none";\n\n        lines.interrupt("line:resize")\n            .transition("line:resize")\n            .duration(500)\n            .attr("d", d => lineGeom(d.data))\n            .attr("stroke", d => d3.hcl(this.getD3Colour(d.data[0])))\n            .style("stroke-width", determineStrokeWidth);\n\n        lines\n            .enter()\n            .append("path")\n                .attr("class", d => "line series series-" + Object(_Legend__WEBPACK_IMPORTED_MODULE_1__["toColourKey"])(d.data[0]._colour))\n                .attr("fill", "none")\n                .attr("stroke-linejoin", "round")\n                .attr("stroke-linecap", "round")\n                .style("stroke-width", determineStrokeWidth) // Want to make a circle if we have a line with only a single data point\n                .attr("stroke", d => d3.hcl(this.getD3Colour(d.data[0])))\n                .style("opacity", 0)\n                .attr("d", d => flatGeom(d.data))\n            .merge(lines)\n            .transition("line:introduction")\n            .duration(500)\n            .delay(100)\n                .style("opacity", 1)\n                .attr("d", d => lineGeom(d.data));\n\n\n        element.selectAll(".domain-selector").remove();\n        if (this.scaleX().isDiscrete()) {\n            const selectors = element\n                .selectAll(".domain-selector")\n                .data(x.domain());\n\n            selectors.enter()\n                     .append("g")\n                     .attr("class", "domain-selector")\n                     .each((d, i, nodes) => {\n                         const selector = d3.select(nodes[i]);\n                         selector.append("rect")\n                             .attr("x", d => x(d))\n                             .attr("y", y.range()[1])\n                             .attr("width", x.bandwidth() + "px")\n                             .attr("height", Math.abs(y.range()[0] - y.range()[1]))\n                             .style("fill", d3.color("#487329"))\n                             .style("opacity", 0);\n\n                         const STANDARD_OPACITY = 0.7;\n                         const RADIUS = 10;\n\n                         selector.on("mouseenter", d => {\n                                 const rect = selector.select("rect");\n                                 rect.interrupt("selector:highlight")\n                                     .transition("selector:highlight")\n                                     .duration(500)\n                                     .style("opacity", 0.2);\n\n                                 var inSelection = data\n                                     .map(line => {\n                                         return line.data.filter(p => {\n                                             return Object(_helpers__WEBPACK_IMPORTED_MODULE_2__["equals"])(p._x, d);\n                                         })\n                                     })\n                                     .flat();\n\n                                 if (inSelection.length) {\n                                     // this._dispatch.call("tooltipShow", this, {\n                                     //     e: d3.event,\n                                     //     point: inSelection[0],\n                                     //     points: inSelection\n                                     // });\n\n                                     selector\n                                         .selectAll(".line-highlight")\n                                         .data(inSelection)\n                                         .enter()\n                                         .append("circle")\n                                             .attr("class", "line-highlight")\n                                             .attr("cx", d => x(d._x) + x.bandwidth() / 2)\n                                             .attr("cy", d => y(d._y))\n                                             .attr("r", 1)\n                                             .style("cursor", "pointer")\n                                             .style("opacity", 0)\n                                             .style("fill", d => this.getD3Colour(d))\n                                             .style("stroke", determineStrokeColour)\n                                         .on("contextmenu", () => d3.event.preventDefault()) // No right click.\n                                         .on("click auxclick", d => {\n                                             this._dispatch.call("elementClick", this, {\n                                                 e: d3.event,\n                                                 point: d\n                                             })\n                                         })\n                                         .on("mouseover", (d, i, nodes) => {\n                                             this._dispatch.call("tooltipShow", this, {\n                                                 e: d3.event,\n                                                 point: d\n                                             });\n\n                                             d3.select(nodes[i])\n                                               .interrupt()\n                                               .transition()\n                                               .style("opacity", 1)\n                                               .attr("r", 15);\n                                         })\n                                         .on("mouseout", (d, i, nodes) => {\n                                             d3.select(nodes[i])\n                                               .interrupt()\n                                               .transition()\n                                               .style("opacity", STANDARD_OPACITY)\n                                               .attr("r", RADIUS);\n                                         })\n                                         .transition()\n                                             .delay(300)\n                                             .duration(500)\n                                             .attr("r", RADIUS)\n                                             .style("opacity", STANDARD_OPACITY);\n                                 }\n\n\n\n                             })\n                             .on("mouseleave", d => {\n                                 const rect = selector.select("rect");\n                                 rect.interrupt("selector:highlight")\n                                     .transition()\n                                     .style("opacity", 0);\n\n                                 selector.selectAll(".line-highlight")\n                                         .interrupt()\n                                         .transition()\n                                         .style("opacity", 0)\n                                         .attr("r", 1)\n                                         .on("end", (d, i, nodes) => d3.select(nodes[i]).remove());\n                             });\n                     })\n\n        }\n    }\n\n\n    getD3XScale(data, width) {\n        width = width || this.width();\n        data = data || this.prepareData()\n                           .map(d => d.data)\n                           .reduce((acc, val) => acc.concat(val));\n\n\n        return d3.scaleBand()\n            .range([0, width])\n            .domain(data.map(d => d._x));\n    }\n\n    getD3YScale(data, height) {\n        data = data || this.prepareData()\n                           .map(d => d.data)\n                           .reduce((acc, val) => acc.concat(val));\n        height = height || this.height();\n\n        return d3.scaleLinear()\n          .range([height, 0])\n          .nice(5)\n          .domain([Math.min(0, d3.min(data, d => d._y)), d3.max(data, d => d._y)]);\n\n    }\n}\n\n\nfunction getClosestPoint(xval, yval, data) {\n    let calcDist = d => Math.sqrt(Math.abs(d._x - xval) ** 2 + (d._y - yval) ** 2);\n    let min = data[0];\n    let minDist = calcDist(min);\n\n    data.forEach(d => {\n        let dist = calcDist(d);\n        if (dist < minDist) {\n            minDist = dist;\n            min = d;\n        }\n    });\n\n    return min;\n}\n\n\n\nfunction line() {\n    return new Line();\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY2hhcnQvTGluZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2IzanMvLi9zcmMvY2hhcnQvTGluZS5qcz8yZDkxIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoQykgMjAxMy0yMDE0LCAyMDE4IEJyYW5kc0V5ZSAoUFRZKSBMVERcbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXNcbi8vIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZVxuLy8gd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LFxuLy8gICAgIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG9cbi8vIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nXG4vLyBjb25kaXRpb25zOlxuLy9cbi8vICAgICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbi8vIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gICAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1IgSU1QTElFRCxcbi8vICAgICBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQVxuLy8gUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxuLy8gSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GXG4vLyBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkVcbi8vIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5pbXBvcnQgeyBHZW9tZXRyeSB9IGZyb20gJy4vR2VvbWV0cnknO1xuaW1wb3J0IHsgdG9Db2xvdXJLZXkgfSBmcm9tIFwiLi4vTGVnZW5kXCI7XG5pbXBvcnQgeyBlcXVhbHMgfSBmcm9tIFwiLi4vaGVscGVyc1wiO1xuaW1wb3J0IHtjb2xvdXJzfSBmcm9tIFwiLi4vQ29sb3Vyc1wiO1xuXG5cbmNsYXNzIExpbmUgZXh0ZW5kcyBHZW9tZXRyeSB7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoXCJMSU5FXCIsIDIpO1xuICAgICAgICB0aGlzLl9zdHJva2Vfd2lkdGggPSAyXG4gICAgICAgIHRoaXMuX2N1cnZlID0gJ2N1cnZlQ2F0bXVsbFJvbSdcbiAgICB9XG5cbiAgY3VydmUoY3VydmUpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX2N1cnZlO1xuICAgIHRoaXMuX2N1cnZlID0gY3VydmU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLl9lbGVtZW50O1xuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5wcmVwYXJlRGF0YShudWxsLCB0cnVlKTtcbiAgICAgICAgY29uc3Qgd2lkdGggPSB0aGlzLl93aWR0aCxcbiAgICAgICAgICAgICAgaGVpZ2h0ID0gdGhpcy5faGVpZ2h0O1xuICAgICAgICBjb25zdCBhbGxEYXRhID0gdGhpcy5wcmVwYXJlRGF0YShudWxsLCBmYWxzZSkubWFwKGQgPT4gZC5kYXRhKS5yZWR1Y2UoKGFjYywgdmFsKSA9PiBhY2MuY29uY2F0KHZhbCkpO1xuXG4gICAgICAgIGVsZW1lbnQuY2xhc3NlZChcImxpbmUtY2hhcnRcIiwgdHJ1ZSk7XG5cblxuICAgICAgICBjb25zdCB4ID0gdGhpcy5nZXREM1hTY2FsZShhbGxEYXRhLCB3aWR0aCk7XG4gICAgICAgIGNvbnN0IHkgPSB0aGlzLmdldEQzWVNjYWxlKGFsbERhdGEsIGhlaWdodCk7XG4gICAgICAgIGNvbnN0IGludmVydCA9IGQzLnNjYWxlUXVhbnRpemUoKS5kb21haW4oeC5yYW5nZSgpKS5yYW5nZSh4LmRvbWFpbigpKTtcblxuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBhcHBlbmQgdGhlIGxpbmVzXG4gICAgICAgIGxldCBsaW5lR3JvdXAgPSBlbGVtZW50LnNlbGVjdChcIi5saW5lc1wiKTtcbiAgICAgICAgbGluZUdyb3VwLnNlbGVjdEFsbChcImNpcmNsZVwiKS5yZW1vdmUoKTtcblxuICAgICAgICBsZXQgY2lyY2xlID0gZmFsc2U7XG4gICAgICAgIGxldCBsYXN0TW91c2UgPSBudWxsO1xuICAgICAgICBsZXQgbGFzdE1pbiA9IG51bGw7XG5cbiAgICAgICAgaWYgKGxpbmVHcm91cC5lbXB0eSgpKSB7XG4gICAgICAgICAgICBsaW5lR3JvdXAgPSBlbGVtZW50XG4gICAgICAgICAgICAgICAgLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwibGluZXNcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcIndpZHRoXCIsIHRoaXMud2lkdGgoKSlcbiAgICAgICAgICAgICAgICAuYXR0cihcImhlaWdodFwiLCB0aGlzLmhlaWdodCgpKTtcblxuICAgICAgICAgICAgLy8gVGhpcyBpcyBuZWVkZWQgdG8gcHJvdmlkZSBhcmVhIGZvciBtb3VzZSBpbnRlcmFjdGlvbnMuXG4gICAgICAgICAgICBsaW5lR3JvdXBcbiAgICAgICAgICAgICAgICAuYXBwZW5kKFwicmVjdFwiKVxuICAgICAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCBcIjEwMCVcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcImhlaWdodFwiLCBcIjEwMCVcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5zY2FsZVgoKS5pc0NvbnRpbnVvdXMoKSkge1xuICAgICAgICAgICAgbGluZUdyb3VwXG4gICAgICAgICAgICBsaW5lR3JvdXBcbiAgICAgICAgICAgICAgICAub24oXCJtb3VzZW1vdmVcIiwgKGQsIGksIG5vZGVzKSA9PiB7IC8vIERhcmtlbiB0aGUgYmFyIG9uIG1vdXNlIG92ZXJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbW91c2UgPSBkMy5tb3VzZShub2Rlc1tpXSk7XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeHZhbCA9IGludmVydChtb3VzZVswXSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHl2YWwgPSB5LmludmVydChtb3VzZVsxXSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGxldCBtaW4gPSB0aGlzLmdldENsb3Nlc3RQb2ludCh4dmFsLCB5dmFsLCB0aGlzLmdldFRyYW5zZm9ybWVkRGF0YSgpWzBdLmRhdGEpO1xuXG4gICAgICAgICAgICAgICAgICAgIGxldCBtaW5zID0gZGF0YS5tYXAoZCA9PiBnZXRDbG9zZXN0UG9pbnQoeHZhbCwgeXZhbCwgZC5kYXRhKSk7XG4gICAgICAgICAgICAgICAgICAgIG1pbnMuZm9yRWFjaChkID0+IGQuX2Rpc3QgPSAgW3goZC5feCksIHkoZC5feSldKTtcblxuICAgICAgICAgICAgICAgICAgICBtaW5zID0gbWlucy5maWx0ZXIobWluID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1pblNjcmVlbkRpc3QgPSBNYXRoLnNxcnQoKG1vdXNlWzBdIC0gbWluLl9kaXN0WzBdKSAqKiAyICsgKG1vdXNlWzFdIC0gbWluLl9kaXN0WzFdKSAqKiAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbi5fbWluX3NjcmVlbiA9IG1pblNjcmVlbkRpc3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWluU2NyZWVuRGlzdCA8IDEwMDtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cblxuICAgICAgICAgICAgICAgICAgICBpZiAoIW1pbnMgfHwgIW1pbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0TW91c2UgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGluZUdyb3VwLnNlbGVjdEFsbChcImNpcmNsZVwiKS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIG1pbnMgPSBtaW5zLnNvcnQoKGxocywgcmhzKSA9PiBsaHMuX21pbl9zY3JlZW4gLSByaHMuX21pbl9zY3JlZW4pO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbWluID0gbWluc1swXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoY2lyY2xlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGFzdE1pbiAmJiBtaW4uX3guZ2V0VGltZSgpID09PSBsYXN0TWluLl94LmdldFRpbWUoKSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGluZUdyb3VwLnNlbGVjdEFsbChcImNpcmNsZVwiKS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGNpcmNsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RNb3VzZSA9IG1vdXNlO1xuICAgICAgICAgICAgICAgICAgICBsYXN0TWluID0gbWluO1xuICAgICAgICAgICAgICAgICAgICBsaW5lR3JvdXBcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoXCJjaXJjbGVcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiY3hcIiwgeChtaW4uX3gpICsgeC5iYW5kd2lkdGgoKSAvIDIpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcImN5XCIsIHkobWluLl95KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiclwiLCAxMClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiZmlsbFwiLCB0aGlzLmdldEQzQ29sb3VyKGQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAwLjEpXG4gICAgICAgICAgICAgICAgICAgICAgICAub24oXCJjb250ZXh0bWVudVwiLCAoKSA9PiBkMy5ldmVudC5wcmV2ZW50RGVmYXVsdCgpKSAvLyBObyByaWdodCBjbGljay5cbiAgICAgICAgICAgICAgICAgICAgICAgIC5vbihcImNsaWNrIGF1eGNsaWNrXCIsIChkLCBpLCBub2RlcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3BhdGNoLmNhbGwoXCJlbGVtZW50Q2xpY2tcIiwgdGhpcywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlOiBkMy5ldmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQ6IG1pbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzOiBkYXRhW21pbi5fc19pXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzSW5kZXg6IG1pbi5fc19pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbWluLl95XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAub24oXCJtb3VzZW92ZXJcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3BhdGNoLmNhbGwoXCJ0b29sdGlwU2hvd1wiLCB0aGlzLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGU6IGQzLmV2ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludDogbWluLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXM6IGRhdGFbbWluLl9zX2ldLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXNJbmRleDogbWluLl9zX2ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBtaW4uX3lcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5vbihcIm1vdXNlb3V0XCIsIChkLCBpLCBub2RlcykgPT4geyAvLyBiYXIgaXMgcmVndWxhciBjb2xvdXIgb24gbW91c2Ugb3V0LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3BhdGNoLmNhbGwoXCJ0b29sdGlwSGlkZVwiLCB0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDAuNSlcblxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbGluZUdlb20gPSBkMy5saW5lKClcbiAgICAgICAgICAgIC54KGQgPT4geChkLl94KSArIHguYmFuZHdpZHRoKCkgLyAyKVxuICAgICAgICAgICAgLnkoZCA9PiB5KGQuX3kpKVxuICAgICAgICAgICAgLmN1cnZlKGQzW3RoaXMuX2N1cnZlXSk7XG5cbiAgICAgICAgY29uc3QgZmxhdEdlb20gPSBkMy5saW5lKClcbiAgICAgICAgICAgIC54KGQgPT4geChkLl94KSArIHguYmFuZHdpZHRoKCkgLyAyKVxuICAgICAgICAgICAgLnkoeSgwKSlcbiAgICAgICAgICAgIC5jdXJ2ZShkM1t0aGlzLl9jdXJ2ZV0pO1xuXG4gICAgICAgIGxldCBsaW5lcyA9IGxpbmVHcm91cC5zZWxlY3RBbGwoJy5saW5lJyk7XG4gICAgICAgIGxpbmVzID0gbGluZXMuZGF0YShkYXRhLCBkID0+IGQuX2tleSk7XG5cbiAgICAgICAgbGluZXMuZXhpdCgpXG4gICAgICAgICAgICAuaW50ZXJydXB0KClcbiAgICAgICAgICAgIC50cmFuc2l0aW9uKClcbiAgICAgICAgICAgIC5hdHRyKFwiZFwiLCBkID0+IGZsYXRHZW9tKGQuZGF0YSkpXG4gICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDApXG4gICAgICAgICAgICAub24oXCJlbmRcIiwgKGQsIGksIG5vZGVzKSA9PiBkMy5zZWxlY3Qobm9kZXNbaV0pLnJlbW92ZSgpKTtcblxuXG5cbiAgICAgICAgY29uc3QgZGV0ZXJtaW5lU3Ryb2tlV2lkdGggPSBkID0+IGQuZGF0YS5sZW5ndGggPD0gMSA/IDIwIDogdGhpcy5fc3Ryb2tlX3dpZHRoO1xuICAgICAgICBjb25zdCB0cmFuc3BhcmVudENvbG91ciA9IGQzLmhjbChjb2xvdXJzLmVpZ2h0ZWVuLmRhcmtHcmV5KTtcbiAgICAgICAgdHJhbnNwYXJlbnRDb2xvdXIub3BhY2l0eSA9IDAuODtcbiAgICAgICAgY29uc3QgZGV0ZXJtaW5lU3Ryb2tlQ29sb3VyID0gZCA9PiBkMy5oY2wodGhpcy5nZXREM0NvbG91cihkKSkuYyA8IDIwID8gdHJhbnNwYXJlbnRDb2xvdXIgOiBcIm5vbmVcIjtcblxuICAgICAgICBsaW5lcy5pbnRlcnJ1cHQoXCJsaW5lOnJlc2l6ZVwiKVxuICAgICAgICAgICAgLnRyYW5zaXRpb24oXCJsaW5lOnJlc2l6ZVwiKVxuICAgICAgICAgICAgLmR1cmF0aW9uKDUwMClcbiAgICAgICAgICAgIC5hdHRyKFwiZFwiLCBkID0+IGxpbmVHZW9tKGQuZGF0YSkpXG4gICAgICAgICAgICAuYXR0cihcInN0cm9rZVwiLCBkID0+IGQzLmhjbCh0aGlzLmdldEQzQ29sb3VyKGQuZGF0YVswXSkpKVxuICAgICAgICAgICAgLnN0eWxlKFwic3Ryb2tlLXdpZHRoXCIsIGRldGVybWluZVN0cm9rZVdpZHRoKTtcblxuICAgICAgICBsaW5lc1xuICAgICAgICAgICAgLmVudGVyKClcbiAgICAgICAgICAgIC5hcHBlbmQoXCJwYXRoXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBkID0+IFwibGluZSBzZXJpZXMgc2VyaWVzLVwiICsgdG9Db2xvdXJLZXkoZC5kYXRhWzBdLl9jb2xvdXIpKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiZmlsbFwiLCBcIm5vbmVcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcInN0cm9rZS1saW5lam9pblwiLCBcInJvdW5kXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJzdHJva2UtbGluZWNhcFwiLCBcInJvdW5kXCIpXG4gICAgICAgICAgICAgICAgLnN0eWxlKFwic3Ryb2tlLXdpZHRoXCIsIGRldGVybWluZVN0cm9rZVdpZHRoKSAvLyBXYW50IHRvIG1ha2UgYSBjaXJjbGUgaWYgd2UgaGF2ZSBhIGxpbmUgd2l0aCBvbmx5IGEgc2luZ2xlIGRhdGEgcG9pbnRcbiAgICAgICAgICAgICAgICAuYXR0cihcInN0cm9rZVwiLCBkID0+IGQzLmhjbCh0aGlzLmdldEQzQ29sb3VyKGQuZGF0YVswXSkpKVxuICAgICAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMClcbiAgICAgICAgICAgICAgICAuYXR0cihcImRcIiwgZCA9PiBmbGF0R2VvbShkLmRhdGEpKVxuICAgICAgICAgICAgLm1lcmdlKGxpbmVzKVxuICAgICAgICAgICAgLnRyYW5zaXRpb24oXCJsaW5lOmludHJvZHVjdGlvblwiKVxuICAgICAgICAgICAgLmR1cmF0aW9uKDUwMClcbiAgICAgICAgICAgIC5kZWxheSgxMDApXG4gICAgICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAxKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiZFwiLCBkID0+IGxpbmVHZW9tKGQuZGF0YSkpO1xuXG5cbiAgICAgICAgZWxlbWVudC5zZWxlY3RBbGwoXCIuZG9tYWluLXNlbGVjdG9yXCIpLnJlbW92ZSgpO1xuICAgICAgICBpZiAodGhpcy5zY2FsZVgoKS5pc0Rpc2NyZXRlKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdG9ycyA9IGVsZW1lbnRcbiAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKFwiLmRvbWFpbi1zZWxlY3RvclwiKVxuICAgICAgICAgICAgICAgIC5kYXRhKHguZG9tYWluKCkpO1xuXG4gICAgICAgICAgICBzZWxlY3RvcnMuZW50ZXIoKVxuICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJkb21haW4tc2VsZWN0b3JcIilcbiAgICAgICAgICAgICAgICAgICAgIC5lYWNoKChkLCBpLCBub2RlcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlbGVjdG9yID0gZDMuc2VsZWN0KG5vZGVzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rvci5hcHBlbmQoXCJyZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwieFwiLCBkID0+IHgoZCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwieVwiLCB5LnJhbmdlKClbMV0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwid2lkdGhcIiwgeC5iYW5kd2lkdGgoKSArIFwicHhcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgTWF0aC5hYnMoeS5yYW5nZSgpWzBdIC0geS5yYW5nZSgpWzFdKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBkMy5jb2xvcihcIiM0ODczMjlcIikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBTVEFOREFSRF9PUEFDSVRZID0gMC43O1xuICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IFJBRElVUyA9IDEwO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3Iub24oXCJtb3VzZWVudGVyXCIsIGQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVjdCA9IHNlbGVjdG9yLnNlbGVjdChcInJlY3RcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWN0LmludGVycnVwdChcInNlbGVjdG9yOmhpZ2hsaWdodFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKFwic2VsZWN0b3I6aGlnaGxpZ2h0XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKDUwMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDAuMik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpblNlbGVjdGlvbiA9IGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKGxpbmUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGluZS5kYXRhLmZpbHRlcihwID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcXVhbHMocC5feCwgZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmxhdCgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5TZWxlY3Rpb24ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcy5fZGlzcGF0Y2guY2FsbChcInRvb2x0aXBTaG93XCIsIHRoaXMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgZTogZDMuZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgIHBvaW50OiBpblNlbGVjdGlvblswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgcG9pbnRzOiBpblNlbGVjdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnNlbGVjdEFsbChcIi5saW5lLWhpZ2hsaWdodFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZGF0YShpblNlbGVjdGlvbilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmVudGVyKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZChcImNpcmNsZVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImxpbmUtaGlnaGxpZ2h0XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcImN4XCIsIGQgPT4geChkLl94KSArIHguYmFuZHdpZHRoKCkgLyAyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJjeVwiLCBkID0+IHkoZC5feSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcInJcIiwgMSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcImN1cnNvclwiLCBcInBvaW50ZXJcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcImZpbGxcIiwgZCA9PiB0aGlzLmdldEQzQ29sb3VyKGQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwic3Ryb2tlXCIsIGRldGVybWluZVN0cm9rZUNvbG91cilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLm9uKFwiY29udGV4dG1lbnVcIiwgKCkgPT4gZDMuZXZlbnQucHJldmVudERlZmF1bHQoKSkgLy8gTm8gcmlnaHQgY2xpY2suXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5vbihcImNsaWNrIGF1eGNsaWNrXCIsIGQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlzcGF0Y2guY2FsbChcImVsZW1lbnRDbGlja1wiLCB0aGlzLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZTogZDMuZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQ6IGRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5vbihcIm1vdXNlb3ZlclwiLCAoZCwgaSwgbm9kZXMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3BhdGNoLmNhbGwoXCJ0b29sdGlwU2hvd1wiLCB0aGlzLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZTogZDMuZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQ6IGRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkMy5zZWxlY3Qobm9kZXNbaV0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5pbnRlcnJ1cHQoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJyXCIsIDE1KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLm9uKFwibW91c2VvdXRcIiwgKGQsIGksIG5vZGVzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkMy5zZWxlY3Qobm9kZXNbaV0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5pbnRlcnJ1cHQoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgU1RBTkRBUkRfT1BBQ0lUWSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJyXCIsIFJBRElVUyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5kZWxheSgzMDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24oNTAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJyXCIsIFJBRElVUylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgU1RBTkRBUkRfT1BBQ0lUWSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cblxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5vbihcIm1vdXNlbGVhdmVcIiwgZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZWN0ID0gc2VsZWN0b3Iuc2VsZWN0KFwicmVjdFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY3QuaW50ZXJydXB0KFwic2VsZWN0b3I6aGlnaGxpZ2h0XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRyYW5zaXRpb24oKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yLnNlbGVjdEFsbChcIi5saW5lLWhpZ2hsaWdodFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuaW50ZXJydXB0KClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRyYW5zaXRpb24oKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiclwiLCAxKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAub24oXCJlbmRcIiwgKGQsIGksIG5vZGVzKSA9PiBkMy5zZWxlY3Qobm9kZXNbaV0pLnJlbW92ZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICB9KVxuXG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIGdldEQzWFNjYWxlKGRhdGEsIHdpZHRoKSB7XG4gICAgICAgIHdpZHRoID0gd2lkdGggfHwgdGhpcy53aWR0aCgpO1xuICAgICAgICBkYXRhID0gZGF0YSB8fCB0aGlzLnByZXBhcmVEYXRhKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoZCA9PiBkLmRhdGEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAucmVkdWNlKChhY2MsIHZhbCkgPT4gYWNjLmNvbmNhdCh2YWwpKTtcblxuXG4gICAgICAgIHJldHVybiBkMy5zY2FsZUJhbmQoKVxuICAgICAgICAgICAgLnJhbmdlKFswLCB3aWR0aF0pXG4gICAgICAgICAgICAuZG9tYWluKGRhdGEubWFwKGQgPT4gZC5feCkpO1xuICAgIH1cblxuICAgIGdldEQzWVNjYWxlKGRhdGEsIGhlaWdodCkge1xuICAgICAgICBkYXRhID0gZGF0YSB8fCB0aGlzLnByZXBhcmVEYXRhKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoZCA9PiBkLmRhdGEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAucmVkdWNlKChhY2MsIHZhbCkgPT4gYWNjLmNvbmNhdCh2YWwpKTtcbiAgICAgICAgaGVpZ2h0ID0gaGVpZ2h0IHx8IHRoaXMuaGVpZ2h0KCk7XG5cbiAgICAgICAgcmV0dXJuIGQzLnNjYWxlTGluZWFyKClcbiAgICAgICAgICAucmFuZ2UoW2hlaWdodCwgMF0pXG4gICAgICAgICAgLm5pY2UoNSlcbiAgICAgICAgICAuZG9tYWluKFtNYXRoLm1pbigwLCBkMy5taW4oZGF0YSwgZCA9PiBkLl95KSksIGQzLm1heChkYXRhLCBkID0+IGQuX3kpXSk7XG5cbiAgICB9XG59XG5cblxuZnVuY3Rpb24gZ2V0Q2xvc2VzdFBvaW50KHh2YWwsIHl2YWwsIGRhdGEpIHtcbiAgICBsZXQgY2FsY0Rpc3QgPSBkID0+IE1hdGguc3FydChNYXRoLmFicyhkLl94IC0geHZhbCkgKiogMiArIChkLl95IC0geXZhbCkgKiogMik7XG4gICAgbGV0IG1pbiA9IGRhdGFbMF07XG4gICAgbGV0IG1pbkRpc3QgPSBjYWxjRGlzdChtaW4pO1xuXG4gICAgZGF0YS5mb3JFYWNoKGQgPT4ge1xuICAgICAgICBsZXQgZGlzdCA9IGNhbGNEaXN0KGQpO1xuICAgICAgICBpZiAoZGlzdCA8IG1pbkRpc3QpIHtcbiAgICAgICAgICAgIG1pbkRpc3QgPSBkaXN0O1xuICAgICAgICAgICAgbWluID0gZDtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIG1pbjtcbn1cblxuXG5cbmV4cG9ydCBmdW5jdGlvbiBsaW5lKCkge1xuICAgIHJldHVybiBuZXcgTGluZSgpO1xufSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/chart/Line.js\n')},"./src/chart/Pie.js":
/*!**************************!*\
  !*** ./src/chart/Pie.js ***!
  \**************************/
/*! exports provided: pie */function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pie\", function() { return pie; });\n/* harmony import */ var _Geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Geometry */ \"./src/chart/Geometry.js\");\n/* harmony import */ var _Colours__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Colours */ \"./src/Colours.js\");\n// Copyright (C) 2020 BrandsEye (PTY) LTD\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this\n// software and associated documentation files (the \"Software\"), to deal in the Software\n// without restriction, including without limitation the rights to use, copy, modify,\n//     merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following\n// conditions:\n//\n//     The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n//     INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n// CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n\nclass Pie extends _Geometry__WEBPACK_IMPORTED_MODULE_0__[\"Geometry\"] {\n    constructor(name, isDonut, useOutsideLabels){\n        super(name || 'PIE');\n        this._is_donut = (typeof isDonut !== 'undefined' && isDonut !== null) ? isDonut : false;\n        this._use_outside_labels = (typeof useOutsideLabels !== 'undefined' && useOutsideLabels !== null) ? useOutsideLabels : false;\n        this._transition_duration = 200;\n    }\n\n    _getOverlayLabelColour(d){\n        const segmentColour = d3.hcl(this.getD3Colour(d.data));\n        let labelColour = d3.hcl(_Colours__WEBPACK_IMPORTED_MODULE_1__[\"colours\"].eighteen.darkGrey);\n\n        // invert\n        if (segmentColour.l < 60) labelColour.l += Math.min(labelColour.l + 50, 100)\n\n        return labelColour\n    }\n\n    _getWidthOfWidestLabel(){\n        const allLabels = [\n          ...this.xValues().map(xVal => this.formatX()(xVal)),\n          ...this.yValues().map(yVal => this.formatLabel()(yVal))\n        ];\n        const text = this._element\n            .append('text')\n            .style('font-size', this._font_size + 'px')\n            .attr('class', 'label-width-check')\n\n        text.selectAll('tspan')\n            .data(allLabels)\n            .enter()\n            .append('tspan')\n                .text(d => d)\n                .style('opacity', 0.3)\n                .attr('x', 0)\n                .attr('dy', '1em')\n\n        const textWidth = text.node().getBBox().width;\n\n        text.remove();\n\n        return textWidth\n    }\n\n    _getLabelHeight(){\n      const text = this._element\n        .append('text')\n        .style('font-size', this._font_size + 'px')\n        .attr('class', 'label-height-check')\n\n      const data = this.showLabels() ? ['Category', 'Value'] : ['Category'];\n\n      text.selectAll('tspan')\n        .data(data)\n        .enter()\n        .append('tspan')\n        .text(d => d)\n        .attr('x',0)\n        .attr('dy','1em')\n\n      const textHeight = text.node().getBBox().height;\n\n      text.remove()\n\n      return textHeight\n    }\n\n    _addCentreLabel() {\n        let xText = this.xAxisLabel();\n        let yText = this.yAxisLabel();\n\n        const hasYText = yText || yText === 0;\n        const hasXText = xText || xText === 0;\n\n        if (hasXText) xText = xText && xText.short || xText;\n        if (hasYText) yText = yText && yText.short || yText;\n\n        const centreText = this._appendIfEmpty(this._element.select('.pie'), 'text', 'centre-label')\n            .style('font-size', this._font_size + 'px')\n            .attr('text-anchor', 'middle');\n\n        if (!hasXText && !hasYText){\n            centreText.remove();\n            return\n        }\n\n        const ySpan = this._appendIfEmpty(centreText, 'tspan', 'y');\n        const xSpan = this._appendIfEmpty(centreText, 'tspan', 'x');\n\n        // populate spans or remove unneeded\n        hasYText\n            ? ySpan\n                .attr('dy', hasXText ? '-0.3em' : '0.3em')\n                .text(yText)\n            : ySpan\n                .remove();\n\n        hasXText\n            ? xSpan\n                .attr('dy', hasYText ? '1em' : '0.3em')\n                .attr('x', '0')\n                .text(xText)\n            : xSpan\n                .remove();\n    }\n\n    isDonut(bool) {\n        if (arguments.length === 0) return this._is_donut;\n        this._is_donut = bool;\n        return this\n    }\n\n    useOutsideLabels(bool) {\n        if (arguments.length === 0) return this._use_outside_labels;\n        this._use_outside_labels = bool;\n        return this\n    }\n\n    prepareData(data, faceted) {\n        faceted = !!faceted && this.facet();\n        data = data || this._data;\n        if (!data || !data.length) return [];\n\n        const x = this.x(),\n              y = this.y(),\n              scaleX = this.scaleX(),\n              scaleY = this.scaleY();\n\n        let mapped = [];\n\n        data.forEach((d,index) => {\n            if (faceted && !this.facet()(d)) return;\n            const xVal = scaleX.transform(x(d));\n            const object = Object.assign({\n                _key: index,\n                _x: xVal,\n                _y: scaleY.transform(y(d)),\n                _colour: xVal,\n                _size: this.size()(d)\n            }, d);\n\n            if (mapped[index]){\n                mapped[index].data.push(object)\n            } else {\n                mapped.push({\n                    _key: index,\n                    _size: object._size,\n                    _colour: object._colour,\n                    data: [object]\n                })\n            }\n        });\n\n        return mapped\n    }\n\n    getD3XScale(data, width) {\n        data = data || this.prepareData(null, true).map(d => d.data).reduce((acc, val) => acc.concat(val));\n        width = width || this.width();\n        return d3.scaleBand()\n                 .rangeRound([0, width])\n                 .domain(data.map(d => d._x));\n    }\n\n    getD3YScale(data, height) {\n        data = data || this.prepareData(null, false);\n        height = height || this.height();\n\n        const max = Math.max(d3.max(data, d => d3.max(d.data, d => d._y)), 0);\n        const min = Math.min(0, d3.min(data, d => d3.min(d.data, d => d._y)));\n        return d3.scaleLinear()\n                 .rangeRound([height, 0])\n                 .nice()\n                 .domain([min, max]);\n    }\n\n    _appendIfEmpty(appendTo, elementName, className) {\n        let selection = appendTo.select('.' + className);\n        if (selection.empty()) selection = appendTo.append(elementName).attr('class', className);\n        return selection\n    }\n\n    render() {\n        // check how much width we need for labels\n        const minLabelCharacters = 6;\n\n        let availableWidth = this.width();\n        let availableHeight = this.height();\n\n        let widestLabelWidth = 0;\n        let labelHeight = 0;\n\n        if (this.useOutsideLabels()){\n          widestLabelWidth = this._getWidthOfWidestLabel();\n          labelHeight = this._getLabelHeight();\n          availableWidth -= widestLabelWidth * 2;\n          availableHeight -= labelHeight * 2;\n        }\n\n        const minDimension = Math.min(availableWidth, availableHeight);\n\n        const pie = this._appendIfEmpty(this._element, 'g', 'pie');\n        pie.attr(\"transform\", `translate(${availableWidth/2 + widestLabelWidth},${minDimension/2 + labelHeight})`)\n\n        const data = this.prepareData(null, true).map(d => d.data).reduce((acc, val) => acc.concat(val));\n\n        const arc = d3.arc()\n            .innerRadius(this.isDonut() ? minDimension / 4 : 0)\n            .outerRadius(minDimension / 2);\n\n        const labelArc = this.isDonut()\n            ? arc\n            : d3.arc()\n                .innerRadius(minDimension / 6)\n                .outerRadius(minDimension / 2)\n\n        const radius = arc.outerRadius()();\n\n        const outerArc = d3.arc()\n            .innerRadius(minDimension / 2 + 10)\n            .outerRadius(minDimension / 2 + 10)\n\n        const arcs = d3.pie().value(this.y())(data);\n\n        const midAngle = d => d.startAngle + (d.endAngle - d.startAngle)/2;\n\n        const segmentWrapper = this._appendIfEmpty(pie, 'g', 'segments');\n\n        const paths = segmentWrapper.selectAll('.segment')\n          .data(arcs, d => d.data._x);\n\n        paths.enter()\n            .append('path')\n            .attr('class','segment')\n            .merge(paths)\n            .on(\"mouseover\", (d, i, nodes) => {\n                d3.select(nodes[i])\n                .interrupt(\"hover:colour\")\n                .transition(\"hover:colour\")\n                .duration(50)\n                .attr(\"fill\", d3.hcl(this.getD3Colour(d.data)).brighter(0.2))\n                .attr(\"stroke\", d => d3.hcl(this.getD3Colour(d.data)).darker(0.4));\n                this._dispatch.call(\"tooltipShow\", this, {\n                    e: d3.event,\n                    point: d.data,\n                    series: d.data._series,\n                    seriesIndex: 0,//s_i\n                    value: d.data._y\n                })\n            })\n            .on(\"mouseout\", (d, i, nodes) => { // bar is regular colour on mouse out.\n                d3.select(nodes[i])\n                .interrupt(\"hover:colour\")\n                .transition(\"hover:colour\")\n                .duration(100)\n                .attr(\"fill\", d => this.getD3Colour(d.data))\n                .attr(\"stroke\", d => d3.hcl(this.getD3Colour(d.data)).darker());\n                this._dispatch.call(\"tooltipHide\", this);\n            })\n            .on(\"click auxclick\", (d, i, nodes) => {\n                this._dispatch.call(\"elementClick\", this, {\n                    e: d3.event,\n                    point: d.data,\n                    series: d.data._series,\n                    seriesIndex: 0, //d.data._s_i,\n                    value: d.data._y\n                })\n            })\n            .attr(\"fill\", d => this.getD3Colour(d.data))\n            .attr(\"stroke\", d => d3.hcl(this.getD3Colour(d.data)).darker())\n            .each(function(d){this._current = d})\n            .transition().duration(this._transition_duration)\n            .attrTween('d', function(p,pi,pnodes){\n                var pInt = d3.interpolate(this._current, p);\n                this._current = pInt(0);\n                return t => arc(pInt(t));\n            })\n\n        paths.exit().remove();\n\n        const segmentLabelsWrapper = this._appendIfEmpty(pie, 'g', 'segment-labels');\n\n        const segmentLabels = segmentLabelsWrapper.selectAll('.segment-label')\n            .data(arcs, d => d.data._x);\n\n        segmentLabels.enter()\n            .append('text')\n            .attr('class', 'segment-label')\n            .attr('pointer-events', 'none')\n            .merge(segmentLabels)\n            .style('font-size', this._font_size + 'px')\n            .each((d, i, nodes) => {\n                const useOutsideLabels = this.useOutsideLabels();\n                const text = d3.select(nodes[i]);\n                let xLabel = text.select('.x-label');\n                let yLabel = text.select('.y-label');\n                if (xLabel.empty()) xLabel = text.append('tspan').attr('class','x-label');\n                if (yLabel.empty()) yLabel = text.append('tspan').attr('class','y-label');\n\n                xLabel\n                    .style(\"dy\", this.showLabels() ? \"-0.3em\" : \"0.3em\")\n                    .text(d => this.formatX()(this.x()(d.data)));\n\n                if (this.showLabels()){\n                    yLabel\n                        .attr(\"dy\", \"1em\")\n                        .attr(\"x\", \"0\")\n                        .text(d => this.formatLabel()(this.y()(d.data)));\n                }\n\n                const textColour = useOutsideLabels ? d3.hcl(_Colours__WEBPACK_IMPORTED_MODULE_1__[\"colours\"].eighteen.darkGrey).brighter() : this._getOverlayLabelColour(d);\n\n                text\n                    .attr('fill', textColour)\n                    .style('visibility', d => {\n                        if (useOutsideLabels) return null\n                        const radians = d.endAngle - d.startAngle;\n                        const arcLength = radians * radius;\n                        const bounding = text.node().getBBox();\n                        return bounding.width > arcLength ? 'hidden' : null\n                    })\n                    .transition().duration(this._transition_duration)\n                    .attrTween(\"transform\", function(d) {\n                        this._current = this._current || d;\n                        const interpolate = d3.interpolate(this._current, d);\n                        this._current = interpolate(0);\n\n                        return function(t) {\n                            const dInt = interpolate(t);\n                            if (useOutsideLabels){\n                                const pos = outerArc.centroid(dInt);\n                                pos[0] = radius * 1.03 * (midAngle(dInt) < Math.PI ? 1 : -1);\n                                return \"translate(\"+ pos +\")\";\n                            } else {\n                                return \"translate(\" + labelArc.centroid(dInt) + \")\";\n                            }\n                        };\n                    })\n                    .styleTween(\"text-anchor\", function(d){\n                        this._current = this._current || d;\n                        const interpolate = d3.interpolate(this._current, d);\n                        this._current = interpolate(0);\n                        return function(t) {\n                            const dInt = interpolate(t);\n                            return useOutsideLabels ? ( midAngle(dInt) < Math.PI ? 'start' : 'end' ) : 'middle';\n                        }\n                    })\n                // TODO:\n                // let previousLabel = null;\n                // whether to display outer label\n                // const finalPos = outerArc.centroid(d);\n                // const rightHandSide = midAngle(d) < Math.PI;\n                // finalPos[0] = radius * 1.03 * (rightHandSide ? 1 : -1);\n                // const rect = this.getBoundingClientRect();\n\n                // let intersectsWithPreviousLabel = false\n\n                // if (rightHandSide && previousLabel && previousLabel.right){\n                //     intersectsWithPreviousLabel = (previousLabel.y + previousLabel.height) > finalPos[1]\n                // } else if (!rightHandSide && previousLabel && !previousLabel.right){\n                //     intersectsWithPreviousLabel = ( finalPos[1] + rect.height ) > previousLabel.y\n                // }\n\n                // previousLabel = { y: finalPos[1], height: rect.height, right: rightHandSide};\n\n                // return intersectsWithPreviousLabel ? 'none' : null\n\n                // TODO:\n                // What do do with settings from another metric that don't suit pie?\n            })\n\n        segmentLabels.exit().remove();\n\n        const labelLinesWrapper = this._appendIfEmpty(pie, 'g', 'label-lines');\n        const labelLines = labelLinesWrapper.selectAll('.label-line')\n            .data(arcs, d => d.data._x)\n\n        if (this.useOutsideLabels()) {\n            labelLines.enter()\n                .append('polyline')\n                .attr('class', 'label-line')\n                .attr('stroke', d3.hcl(_Colours__WEBPACK_IMPORTED_MODULE_1__[\"colours\"].eighteen.darkGrey).brighter())\n                .attr('opacity', 0.5)\n                .attr('stroke-width', '1px')\n                .attr('fill', 'none')\n                .style('mix-blend-mode', 'multiply')\n                .merge(labelLines)\n                .transition().duration(this._transition_duration)\n                .attrTween(\"points\", function(d){\n                    this._current = this._current || d;\n                    var interpolate = d3.interpolate(this._current, d);\n                    this._current = interpolate(0);\n                    return function(t) {\n                        var d2 = interpolate(t);\n                        var start = arc.centroid(d2);\n                        var elbow = outerArc.centroid(d2);\n                        var terminal = outerArc.centroid(d2);\n                        const leftAligned = midAngle(d2) < Math.PI;\n                        terminal[0] = radius * 0.98 * (leftAligned ? 1 : -1);\n                        const positions = [start, elbow];\n                        if (leftAligned ? terminal[0] > elbow[0] : elbow[0] > terminal[0]){\n                            positions.push(terminal);\n                        }\n                        return positions;\n                    };\n                });\n\n            labelLines.exit().remove();\n        } else {\n            labelLinesWrapper.remove();\n        }\n\n        this.isDonut()\n            ? this._addCentreLabel()\n            : this._element.select('.centre-label').remove();\n    }\n\n}\n\nfunction pie() {\n    return new Pie();\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY2hhcnQvUGllLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYjNqcy8uL3NyYy9jaGFydC9QaWUuanM/YWIzNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKEMpIDIwMjAgQnJhbmRzRXllIChQVFkpIExURFxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpc1xuLy8gc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlXG4vLyB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksXG4vLyAgICAgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0b1xuLy8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcbi8vIGNvbmRpdGlvbnM6XG4vL1xuLy8gICAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuLy8gY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyAgICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUiBJTVBMSUVELFxuLy8gICAgIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBXG4vLyBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUXG4vLyBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0Zcbi8vIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRVxuLy8gT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCB7IEdlb21ldHJ5IH0gZnJvbSAnLi9HZW9tZXRyeSc7XG5pbXBvcnQgeyBjb2xvdXJzIH0gZnJvbSBcIi4uL0NvbG91cnNcIjtcblxuY2xhc3MgUGllIGV4dGVuZHMgR2VvbWV0cnkge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIGlzRG9udXQsIHVzZU91dHNpZGVMYWJlbHMpe1xuICAgICAgICBzdXBlcihuYW1lIHx8ICdQSUUnKTtcbiAgICAgICAgdGhpcy5faXNfZG9udXQgPSAodHlwZW9mIGlzRG9udXQgIT09ICd1bmRlZmluZWQnICYmIGlzRG9udXQgIT09IG51bGwpID8gaXNEb251dCA6IGZhbHNlO1xuICAgICAgICB0aGlzLl91c2Vfb3V0c2lkZV9sYWJlbHMgPSAodHlwZW9mIHVzZU91dHNpZGVMYWJlbHMgIT09ICd1bmRlZmluZWQnICYmIHVzZU91dHNpZGVMYWJlbHMgIT09IG51bGwpID8gdXNlT3V0c2lkZUxhYmVscyA6IGZhbHNlO1xuICAgICAgICB0aGlzLl90cmFuc2l0aW9uX2R1cmF0aW9uID0gMjAwO1xuICAgIH1cblxuICAgIF9nZXRPdmVybGF5TGFiZWxDb2xvdXIoZCl7XG4gICAgICAgIGNvbnN0IHNlZ21lbnRDb2xvdXIgPSBkMy5oY2wodGhpcy5nZXREM0NvbG91cihkLmRhdGEpKTtcbiAgICAgICAgbGV0IGxhYmVsQ29sb3VyID0gZDMuaGNsKGNvbG91cnMuZWlnaHRlZW4uZGFya0dyZXkpO1xuXG4gICAgICAgIC8vIGludmVydFxuICAgICAgICBpZiAoc2VnbWVudENvbG91ci5sIDwgNjApIGxhYmVsQ29sb3VyLmwgKz0gTWF0aC5taW4obGFiZWxDb2xvdXIubCArIDUwLCAxMDApXG5cbiAgICAgICAgcmV0dXJuIGxhYmVsQ29sb3VyXG4gICAgfVxuXG4gICAgX2dldFdpZHRoT2ZXaWRlc3RMYWJlbCgpe1xuICAgICAgICBjb25zdCBhbGxMYWJlbHMgPSBbXG4gICAgICAgICAgLi4udGhpcy54VmFsdWVzKCkubWFwKHhWYWwgPT4gdGhpcy5mb3JtYXRYKCkoeFZhbCkpLFxuICAgICAgICAgIC4uLnRoaXMueVZhbHVlcygpLm1hcCh5VmFsID0+IHRoaXMuZm9ybWF0TGFiZWwoKSh5VmFsKSlcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3QgdGV4dCA9IHRoaXMuX2VsZW1lbnRcbiAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxuICAgICAgICAgICAgLnN0eWxlKCdmb250LXNpemUnLCB0aGlzLl9mb250X3NpemUgKyAncHgnKVxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2xhYmVsLXdpZHRoLWNoZWNrJylcblxuICAgICAgICB0ZXh0LnNlbGVjdEFsbCgndHNwYW4nKVxuICAgICAgICAgICAgLmRhdGEoYWxsTGFiZWxzKVxuICAgICAgICAgICAgLmVudGVyKClcbiAgICAgICAgICAgIC5hcHBlbmQoJ3RzcGFuJylcbiAgICAgICAgICAgICAgICAudGV4dChkID0+IGQpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdvcGFjaXR5JywgMC4zKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgMClcbiAgICAgICAgICAgICAgICAuYXR0cignZHknLCAnMWVtJylcblxuICAgICAgICBjb25zdCB0ZXh0V2lkdGggPSB0ZXh0Lm5vZGUoKS5nZXRCQm94KCkud2lkdGg7XG5cbiAgICAgICAgdGV4dC5yZW1vdmUoKTtcblxuICAgICAgICByZXR1cm4gdGV4dFdpZHRoXG4gICAgfVxuXG4gICAgX2dldExhYmVsSGVpZ2h0KCl7XG4gICAgICBjb25zdCB0ZXh0ID0gdGhpcy5fZWxlbWVudFxuICAgICAgICAuYXBwZW5kKCd0ZXh0JylcbiAgICAgICAgLnN0eWxlKCdmb250LXNpemUnLCB0aGlzLl9mb250X3NpemUgKyAncHgnKVxuICAgICAgICAuYXR0cignY2xhc3MnLCAnbGFiZWwtaGVpZ2h0LWNoZWNrJylcblxuICAgICAgY29uc3QgZGF0YSA9IHRoaXMuc2hvd0xhYmVscygpID8gWydDYXRlZ29yeScsICdWYWx1ZSddIDogWydDYXRlZ29yeSddO1xuXG4gICAgICB0ZXh0LnNlbGVjdEFsbCgndHNwYW4nKVxuICAgICAgICAuZGF0YShkYXRhKVxuICAgICAgICAuZW50ZXIoKVxuICAgICAgICAuYXBwZW5kKCd0c3BhbicpXG4gICAgICAgIC50ZXh0KGQgPT4gZClcbiAgICAgICAgLmF0dHIoJ3gnLDApXG4gICAgICAgIC5hdHRyKCdkeScsJzFlbScpXG5cbiAgICAgIGNvbnN0IHRleHRIZWlnaHQgPSB0ZXh0Lm5vZGUoKS5nZXRCQm94KCkuaGVpZ2h0O1xuXG4gICAgICB0ZXh0LnJlbW92ZSgpXG5cbiAgICAgIHJldHVybiB0ZXh0SGVpZ2h0XG4gICAgfVxuXG4gICAgX2FkZENlbnRyZUxhYmVsKCkge1xuICAgICAgICBsZXQgeFRleHQgPSB0aGlzLnhBeGlzTGFiZWwoKTtcbiAgICAgICAgbGV0IHlUZXh0ID0gdGhpcy55QXhpc0xhYmVsKCk7XG5cbiAgICAgICAgY29uc3QgaGFzWVRleHQgPSB5VGV4dCB8fCB5VGV4dCA9PT0gMDtcbiAgICAgICAgY29uc3QgaGFzWFRleHQgPSB4VGV4dCB8fCB4VGV4dCA9PT0gMDtcblxuICAgICAgICBpZiAoaGFzWFRleHQpIHhUZXh0ID0geFRleHQgJiYgeFRleHQuc2hvcnQgfHwgeFRleHQ7XG4gICAgICAgIGlmIChoYXNZVGV4dCkgeVRleHQgPSB5VGV4dCAmJiB5VGV4dC5zaG9ydCB8fCB5VGV4dDtcblxuICAgICAgICBjb25zdCBjZW50cmVUZXh0ID0gdGhpcy5fYXBwZW5kSWZFbXB0eSh0aGlzLl9lbGVtZW50LnNlbGVjdCgnLnBpZScpLCAndGV4dCcsICdjZW50cmUtbGFiZWwnKVxuICAgICAgICAgICAgLnN0eWxlKCdmb250LXNpemUnLCB0aGlzLl9mb250X3NpemUgKyAncHgnKVxuICAgICAgICAgICAgLmF0dHIoJ3RleHQtYW5jaG9yJywgJ21pZGRsZScpO1xuXG4gICAgICAgIGlmICghaGFzWFRleHQgJiYgIWhhc1lUZXh0KXtcbiAgICAgICAgICAgIGNlbnRyZVRleHQucmVtb3ZlKCk7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHlTcGFuID0gdGhpcy5fYXBwZW5kSWZFbXB0eShjZW50cmVUZXh0LCAndHNwYW4nLCAneScpO1xuICAgICAgICBjb25zdCB4U3BhbiA9IHRoaXMuX2FwcGVuZElmRW1wdHkoY2VudHJlVGV4dCwgJ3RzcGFuJywgJ3gnKTtcblxuICAgICAgICAvLyBwb3B1bGF0ZSBzcGFucyBvciByZW1vdmUgdW5uZWVkZWRcbiAgICAgICAgaGFzWVRleHRcbiAgICAgICAgICAgID8geVNwYW5cbiAgICAgICAgICAgICAgICAuYXR0cignZHknLCBoYXNYVGV4dCA/ICctMC4zZW0nIDogJzAuM2VtJylcbiAgICAgICAgICAgICAgICAudGV4dCh5VGV4dClcbiAgICAgICAgICAgIDogeVNwYW5cbiAgICAgICAgICAgICAgICAucmVtb3ZlKCk7XG5cbiAgICAgICAgaGFzWFRleHRcbiAgICAgICAgICAgID8geFNwYW5cbiAgICAgICAgICAgICAgICAuYXR0cignZHknLCBoYXNZVGV4dCA/ICcxZW0nIDogJzAuM2VtJylcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsICcwJylcbiAgICAgICAgICAgICAgICAudGV4dCh4VGV4dClcbiAgICAgICAgICAgIDogeFNwYW5cbiAgICAgICAgICAgICAgICAucmVtb3ZlKCk7XG4gICAgfVxuXG4gICAgaXNEb251dChib29sKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5faXNfZG9udXQ7XG4gICAgICAgIHRoaXMuX2lzX2RvbnV0ID0gYm9vbDtcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICB1c2VPdXRzaWRlTGFiZWxzKGJvb2wpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl91c2Vfb3V0c2lkZV9sYWJlbHM7XG4gICAgICAgIHRoaXMuX3VzZV9vdXRzaWRlX2xhYmVscyA9IGJvb2w7XG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgcHJlcGFyZURhdGEoZGF0YSwgZmFjZXRlZCkge1xuICAgICAgICBmYWNldGVkID0gISFmYWNldGVkICYmIHRoaXMuZmFjZXQoKTtcbiAgICAgICAgZGF0YSA9IGRhdGEgfHwgdGhpcy5fZGF0YTtcbiAgICAgICAgaWYgKCFkYXRhIHx8ICFkYXRhLmxlbmd0aCkgcmV0dXJuIFtdO1xuXG4gICAgICAgIGNvbnN0IHggPSB0aGlzLngoKSxcbiAgICAgICAgICAgICAgeSA9IHRoaXMueSgpLFxuICAgICAgICAgICAgICBzY2FsZVggPSB0aGlzLnNjYWxlWCgpLFxuICAgICAgICAgICAgICBzY2FsZVkgPSB0aGlzLnNjYWxlWSgpO1xuXG4gICAgICAgIGxldCBtYXBwZWQgPSBbXTtcblxuICAgICAgICBkYXRhLmZvckVhY2goKGQsaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGlmIChmYWNldGVkICYmICF0aGlzLmZhY2V0KCkoZCkpIHJldHVybjtcbiAgICAgICAgICAgIGNvbnN0IHhWYWwgPSBzY2FsZVgudHJhbnNmb3JtKHgoZCkpO1xuICAgICAgICAgICAgY29uc3Qgb2JqZWN0ID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICAgICAgX2tleTogaW5kZXgsXG4gICAgICAgICAgICAgICAgX3g6IHhWYWwsXG4gICAgICAgICAgICAgICAgX3k6IHNjYWxlWS50cmFuc2Zvcm0oeShkKSksXG4gICAgICAgICAgICAgICAgX2NvbG91cjogeFZhbCxcbiAgICAgICAgICAgICAgICBfc2l6ZTogdGhpcy5zaXplKCkoZClcbiAgICAgICAgICAgIH0sIGQpO1xuXG4gICAgICAgICAgICBpZiAobWFwcGVkW2luZGV4XSl7XG4gICAgICAgICAgICAgICAgbWFwcGVkW2luZGV4XS5kYXRhLnB1c2gob2JqZWN0KVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtYXBwZWQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIF9rZXk6IGluZGV4LFxuICAgICAgICAgICAgICAgICAgICBfc2l6ZTogb2JqZWN0Ll9zaXplLFxuICAgICAgICAgICAgICAgICAgICBfY29sb3VyOiBvYmplY3QuX2NvbG91cixcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogW29iamVjdF1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gbWFwcGVkXG4gICAgfVxuXG4gICAgZ2V0RDNYU2NhbGUoZGF0YSwgd2lkdGgpIHtcbiAgICAgICAgZGF0YSA9IGRhdGEgfHwgdGhpcy5wcmVwYXJlRGF0YShudWxsLCB0cnVlKS5tYXAoZCA9PiBkLmRhdGEpLnJlZHVjZSgoYWNjLCB2YWwpID0+IGFjYy5jb25jYXQodmFsKSk7XG4gICAgICAgIHdpZHRoID0gd2lkdGggfHwgdGhpcy53aWR0aCgpO1xuICAgICAgICByZXR1cm4gZDMuc2NhbGVCYW5kKClcbiAgICAgICAgICAgICAgICAgLnJhbmdlUm91bmQoWzAsIHdpZHRoXSlcbiAgICAgICAgICAgICAgICAgLmRvbWFpbihkYXRhLm1hcChkID0+IGQuX3gpKTtcbiAgICB9XG5cbiAgICBnZXREM1lTY2FsZShkYXRhLCBoZWlnaHQpIHtcbiAgICAgICAgZGF0YSA9IGRhdGEgfHwgdGhpcy5wcmVwYXJlRGF0YShudWxsLCBmYWxzZSk7XG4gICAgICAgIGhlaWdodCA9IGhlaWdodCB8fCB0aGlzLmhlaWdodCgpO1xuXG4gICAgICAgIGNvbnN0IG1heCA9IE1hdGgubWF4KGQzLm1heChkYXRhLCBkID0+IGQzLm1heChkLmRhdGEsIGQgPT4gZC5feSkpLCAwKTtcbiAgICAgICAgY29uc3QgbWluID0gTWF0aC5taW4oMCwgZDMubWluKGRhdGEsIGQgPT4gZDMubWluKGQuZGF0YSwgZCA9PiBkLl95KSkpO1xuICAgICAgICByZXR1cm4gZDMuc2NhbGVMaW5lYXIoKVxuICAgICAgICAgICAgICAgICAucmFuZ2VSb3VuZChbaGVpZ2h0LCAwXSlcbiAgICAgICAgICAgICAgICAgLm5pY2UoKVxuICAgICAgICAgICAgICAgICAuZG9tYWluKFttaW4sIG1heF0pO1xuICAgIH1cblxuICAgIF9hcHBlbmRJZkVtcHR5KGFwcGVuZFRvLCBlbGVtZW50TmFtZSwgY2xhc3NOYW1lKSB7XG4gICAgICAgIGxldCBzZWxlY3Rpb24gPSBhcHBlbmRUby5zZWxlY3QoJy4nICsgY2xhc3NOYW1lKTtcbiAgICAgICAgaWYgKHNlbGVjdGlvbi5lbXB0eSgpKSBzZWxlY3Rpb24gPSBhcHBlbmRUby5hcHBlbmQoZWxlbWVudE5hbWUpLmF0dHIoJ2NsYXNzJywgY2xhc3NOYW1lKTtcbiAgICAgICAgcmV0dXJuIHNlbGVjdGlvblxuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgLy8gY2hlY2sgaG93IG11Y2ggd2lkdGggd2UgbmVlZCBmb3IgbGFiZWxzXG4gICAgICAgIGNvbnN0IG1pbkxhYmVsQ2hhcmFjdGVycyA9IDY7XG5cbiAgICAgICAgbGV0IGF2YWlsYWJsZVdpZHRoID0gdGhpcy53aWR0aCgpO1xuICAgICAgICBsZXQgYXZhaWxhYmxlSGVpZ2h0ID0gdGhpcy5oZWlnaHQoKTtcblxuICAgICAgICBsZXQgd2lkZXN0TGFiZWxXaWR0aCA9IDA7XG4gICAgICAgIGxldCBsYWJlbEhlaWdodCA9IDA7XG5cbiAgICAgICAgaWYgKHRoaXMudXNlT3V0c2lkZUxhYmVscygpKXtcbiAgICAgICAgICB3aWRlc3RMYWJlbFdpZHRoID0gdGhpcy5fZ2V0V2lkdGhPZldpZGVzdExhYmVsKCk7XG4gICAgICAgICAgbGFiZWxIZWlnaHQgPSB0aGlzLl9nZXRMYWJlbEhlaWdodCgpO1xuICAgICAgICAgIGF2YWlsYWJsZVdpZHRoIC09IHdpZGVzdExhYmVsV2lkdGggKiAyO1xuICAgICAgICAgIGF2YWlsYWJsZUhlaWdodCAtPSBsYWJlbEhlaWdodCAqIDI7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBtaW5EaW1lbnNpb24gPSBNYXRoLm1pbihhdmFpbGFibGVXaWR0aCwgYXZhaWxhYmxlSGVpZ2h0KTtcblxuICAgICAgICBjb25zdCBwaWUgPSB0aGlzLl9hcHBlbmRJZkVtcHR5KHRoaXMuX2VsZW1lbnQsICdnJywgJ3BpZScpO1xuICAgICAgICBwaWUuYXR0cihcInRyYW5zZm9ybVwiLCBgdHJhbnNsYXRlKCR7YXZhaWxhYmxlV2lkdGgvMiArIHdpZGVzdExhYmVsV2lkdGh9LCR7bWluRGltZW5zaW9uLzIgKyBsYWJlbEhlaWdodH0pYClcblxuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5wcmVwYXJlRGF0YShudWxsLCB0cnVlKS5tYXAoZCA9PiBkLmRhdGEpLnJlZHVjZSgoYWNjLCB2YWwpID0+IGFjYy5jb25jYXQodmFsKSk7XG5cbiAgICAgICAgY29uc3QgYXJjID0gZDMuYXJjKClcbiAgICAgICAgICAgIC5pbm5lclJhZGl1cyh0aGlzLmlzRG9udXQoKSA/IG1pbkRpbWVuc2lvbiAvIDQgOiAwKVxuICAgICAgICAgICAgLm91dGVyUmFkaXVzKG1pbkRpbWVuc2lvbiAvIDIpO1xuXG4gICAgICAgIGNvbnN0IGxhYmVsQXJjID0gdGhpcy5pc0RvbnV0KClcbiAgICAgICAgICAgID8gYXJjXG4gICAgICAgICAgICA6IGQzLmFyYygpXG4gICAgICAgICAgICAgICAgLmlubmVyUmFkaXVzKG1pbkRpbWVuc2lvbiAvIDYpXG4gICAgICAgICAgICAgICAgLm91dGVyUmFkaXVzKG1pbkRpbWVuc2lvbiAvIDIpXG5cbiAgICAgICAgY29uc3QgcmFkaXVzID0gYXJjLm91dGVyUmFkaXVzKCkoKTtcblxuICAgICAgICBjb25zdCBvdXRlckFyYyA9IGQzLmFyYygpXG4gICAgICAgICAgICAuaW5uZXJSYWRpdXMobWluRGltZW5zaW9uIC8gMiArIDEwKVxuICAgICAgICAgICAgLm91dGVyUmFkaXVzKG1pbkRpbWVuc2lvbiAvIDIgKyAxMClcblxuICAgICAgICBjb25zdCBhcmNzID0gZDMucGllKCkudmFsdWUodGhpcy55KCkpKGRhdGEpO1xuXG4gICAgICAgIGNvbnN0IG1pZEFuZ2xlID0gZCA9PiBkLnN0YXJ0QW5nbGUgKyAoZC5lbmRBbmdsZSAtIGQuc3RhcnRBbmdsZSkvMjtcblxuICAgICAgICBjb25zdCBzZWdtZW50V3JhcHBlciA9IHRoaXMuX2FwcGVuZElmRW1wdHkocGllLCAnZycsICdzZWdtZW50cycpO1xuXG4gICAgICAgIGNvbnN0IHBhdGhzID0gc2VnbWVudFdyYXBwZXIuc2VsZWN0QWxsKCcuc2VnbWVudCcpXG4gICAgICAgICAgLmRhdGEoYXJjcywgZCA9PiBkLmRhdGEuX3gpO1xuXG4gICAgICAgIHBhdGhzLmVudGVyKClcbiAgICAgICAgICAgIC5hcHBlbmQoJ3BhdGgnKVxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywnc2VnbWVudCcpXG4gICAgICAgICAgICAubWVyZ2UocGF0aHMpXG4gICAgICAgICAgICAub24oXCJtb3VzZW92ZXJcIiwgKGQsIGksIG5vZGVzKSA9PiB7XG4gICAgICAgICAgICAgICAgZDMuc2VsZWN0KG5vZGVzW2ldKVxuICAgICAgICAgICAgICAgIC5pbnRlcnJ1cHQoXCJob3Zlcjpjb2xvdXJcIilcbiAgICAgICAgICAgICAgICAudHJhbnNpdGlvbihcImhvdmVyOmNvbG91clwiKVxuICAgICAgICAgICAgICAgIC5kdXJhdGlvbig1MClcbiAgICAgICAgICAgICAgICAuYXR0cihcImZpbGxcIiwgZDMuaGNsKHRoaXMuZ2V0RDNDb2xvdXIoZC5kYXRhKSkuYnJpZ2h0ZXIoMC4yKSlcbiAgICAgICAgICAgICAgICAuYXR0cihcInN0cm9rZVwiLCBkID0+IGQzLmhjbCh0aGlzLmdldEQzQ29sb3VyKGQuZGF0YSkpLmRhcmtlcigwLjQpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9kaXNwYXRjaC5jYWxsKFwidG9vbHRpcFNob3dcIiwgdGhpcywge1xuICAgICAgICAgICAgICAgICAgICBlOiBkMy5ldmVudCxcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQ6IGQuZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgc2VyaWVzOiBkLmRhdGEuX3NlcmllcyxcbiAgICAgICAgICAgICAgICAgICAgc2VyaWVzSW5kZXg6IDAsLy9zX2lcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGQuZGF0YS5feVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLm9uKFwibW91c2VvdXRcIiwgKGQsIGksIG5vZGVzKSA9PiB7IC8vIGJhciBpcyByZWd1bGFyIGNvbG91ciBvbiBtb3VzZSBvdXQuXG4gICAgICAgICAgICAgICAgZDMuc2VsZWN0KG5vZGVzW2ldKVxuICAgICAgICAgICAgICAgIC5pbnRlcnJ1cHQoXCJob3Zlcjpjb2xvdXJcIilcbiAgICAgICAgICAgICAgICAudHJhbnNpdGlvbihcImhvdmVyOmNvbG91clwiKVxuICAgICAgICAgICAgICAgIC5kdXJhdGlvbigxMDApXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJmaWxsXCIsIGQgPT4gdGhpcy5nZXREM0NvbG91cihkLmRhdGEpKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwic3Ryb2tlXCIsIGQgPT4gZDMuaGNsKHRoaXMuZ2V0RDNDb2xvdXIoZC5kYXRhKSkuZGFya2VyKCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3BhdGNoLmNhbGwoXCJ0b29sdGlwSGlkZVwiLCB0aGlzKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAub24oXCJjbGljayBhdXhjbGlja1wiLCAoZCwgaSwgbm9kZXMpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kaXNwYXRjaC5jYWxsKFwiZWxlbWVudENsaWNrXCIsIHRoaXMsIHtcbiAgICAgICAgICAgICAgICAgICAgZTogZDMuZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgIHBvaW50OiBkLmRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHNlcmllczogZC5kYXRhLl9zZXJpZXMsXG4gICAgICAgICAgICAgICAgICAgIHNlcmllc0luZGV4OiAwLCAvL2QuZGF0YS5fc19pLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZC5kYXRhLl95XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuYXR0cihcImZpbGxcIiwgZCA9PiB0aGlzLmdldEQzQ29sb3VyKGQuZGF0YSkpXG4gICAgICAgICAgICAuYXR0cihcInN0cm9rZVwiLCBkID0+IGQzLmhjbCh0aGlzLmdldEQzQ29sb3VyKGQuZGF0YSkpLmRhcmtlcigpKVxuICAgICAgICAgICAgLmVhY2goZnVuY3Rpb24oZCl7dGhpcy5fY3VycmVudCA9IGR9KVxuICAgICAgICAgICAgLnRyYW5zaXRpb24oKS5kdXJhdGlvbih0aGlzLl90cmFuc2l0aW9uX2R1cmF0aW9uKVxuICAgICAgICAgICAgLmF0dHJUd2VlbignZCcsIGZ1bmN0aW9uKHAscGkscG5vZGVzKXtcbiAgICAgICAgICAgICAgICB2YXIgcEludCA9IGQzLmludGVycG9sYXRlKHRoaXMuX2N1cnJlbnQsIHApO1xuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnQgPSBwSW50KDApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0ID0+IGFyYyhwSW50KHQpKTtcbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgcGF0aHMuZXhpdCgpLnJlbW92ZSgpO1xuXG4gICAgICAgIGNvbnN0IHNlZ21lbnRMYWJlbHNXcmFwcGVyID0gdGhpcy5fYXBwZW5kSWZFbXB0eShwaWUsICdnJywgJ3NlZ21lbnQtbGFiZWxzJyk7XG5cbiAgICAgICAgY29uc3Qgc2VnbWVudExhYmVscyA9IHNlZ21lbnRMYWJlbHNXcmFwcGVyLnNlbGVjdEFsbCgnLnNlZ21lbnQtbGFiZWwnKVxuICAgICAgICAgICAgLmRhdGEoYXJjcywgZCA9PiBkLmRhdGEuX3gpO1xuXG4gICAgICAgIHNlZ21lbnRMYWJlbHMuZW50ZXIoKVxuICAgICAgICAgICAgLmFwcGVuZCgndGV4dCcpXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnc2VnbWVudC1sYWJlbCcpXG4gICAgICAgICAgICAuYXR0cigncG9pbnRlci1ldmVudHMnLCAnbm9uZScpXG4gICAgICAgICAgICAubWVyZ2Uoc2VnbWVudExhYmVscylcbiAgICAgICAgICAgIC5zdHlsZSgnZm9udC1zaXplJywgdGhpcy5fZm9udF9zaXplICsgJ3B4JylcbiAgICAgICAgICAgIC5lYWNoKChkLCBpLCBub2RlcykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHVzZU91dHNpZGVMYWJlbHMgPSB0aGlzLnVzZU91dHNpZGVMYWJlbHMoKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXh0ID0gZDMuc2VsZWN0KG5vZGVzW2ldKTtcbiAgICAgICAgICAgICAgICBsZXQgeExhYmVsID0gdGV4dC5zZWxlY3QoJy54LWxhYmVsJyk7XG4gICAgICAgICAgICAgICAgbGV0IHlMYWJlbCA9IHRleHQuc2VsZWN0KCcueS1sYWJlbCcpO1xuICAgICAgICAgICAgICAgIGlmICh4TGFiZWwuZW1wdHkoKSkgeExhYmVsID0gdGV4dC5hcHBlbmQoJ3RzcGFuJykuYXR0cignY2xhc3MnLCd4LWxhYmVsJyk7XG4gICAgICAgICAgICAgICAgaWYgKHlMYWJlbC5lbXB0eSgpKSB5TGFiZWwgPSB0ZXh0LmFwcGVuZCgndHNwYW4nKS5hdHRyKCdjbGFzcycsJ3ktbGFiZWwnKTtcblxuICAgICAgICAgICAgICAgIHhMYWJlbFxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJkeVwiLCB0aGlzLnNob3dMYWJlbHMoKSA/IFwiLTAuM2VtXCIgOiBcIjAuM2VtXCIpXG4gICAgICAgICAgICAgICAgICAgIC50ZXh0KGQgPT4gdGhpcy5mb3JtYXRYKCkodGhpcy54KCkoZC5kYXRhKSkpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2hvd0xhYmVscygpKXtcbiAgICAgICAgICAgICAgICAgICAgeUxhYmVsXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcImR5XCIsIFwiMWVtXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcInhcIiwgXCIwXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAudGV4dChkID0+IHRoaXMuZm9ybWF0TGFiZWwoKSh0aGlzLnkoKShkLmRhdGEpKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3QgdGV4dENvbG91ciA9IHVzZU91dHNpZGVMYWJlbHMgPyBkMy5oY2woY29sb3Vycy5laWdodGVlbi5kYXJrR3JleSkuYnJpZ2h0ZXIoKSA6IHRoaXMuX2dldE92ZXJsYXlMYWJlbENvbG91cihkKTtcblxuICAgICAgICAgICAgICAgIHRleHRcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCB0ZXh0Q29sb3VyKVxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ3Zpc2liaWxpdHknLCBkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1c2VPdXRzaWRlTGFiZWxzKSByZXR1cm4gbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmFkaWFucyA9IGQuZW5kQW5nbGUgLSBkLnN0YXJ0QW5nbGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhcmNMZW5ndGggPSByYWRpYW5zICogcmFkaXVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYm91bmRpbmcgPSB0ZXh0Lm5vZGUoKS5nZXRCQm94KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYm91bmRpbmcud2lkdGggPiBhcmNMZW5ndGggPyAnaGlkZGVuJyA6IG51bGxcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLnRyYW5zaXRpb24oKS5kdXJhdGlvbih0aGlzLl90cmFuc2l0aW9uX2R1cmF0aW9uKVxuICAgICAgICAgICAgICAgICAgICAuYXR0clR3ZWVuKFwidHJhbnNmb3JtXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnQgPSB0aGlzLl9jdXJyZW50IHx8IGQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbnRlcnBvbGF0ZSA9IGQzLmludGVycG9sYXRlKHRoaXMuX2N1cnJlbnQsIGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudCA9IGludGVycG9sYXRlKDApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRJbnQgPSBpbnRlcnBvbGF0ZSh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodXNlT3V0c2lkZUxhYmVscyl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvcyA9IG91dGVyQXJjLmNlbnRyb2lkKGRJbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NbMF0gPSByYWRpdXMgKiAxLjAzICogKG1pZEFuZ2xlKGRJbnQpIDwgTWF0aC5QSSA/IDEgOiAtMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcInRyYW5zbGF0ZShcIisgcG9zICtcIilcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJ0cmFuc2xhdGUoXCIgKyBsYWJlbEFyYy5jZW50cm9pZChkSW50KSArIFwiKVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZVR3ZWVuKFwidGV4dC1hbmNob3JcIiwgZnVuY3Rpb24oZCl7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50ID0gdGhpcy5fY3VycmVudCB8fCBkO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW50ZXJwb2xhdGUgPSBkMy5pbnRlcnBvbGF0ZSh0aGlzLl9jdXJyZW50LCBkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnQgPSBpbnRlcnBvbGF0ZSgwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZEludCA9IGludGVycG9sYXRlKHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1c2VPdXRzaWRlTGFiZWxzID8gKCBtaWRBbmdsZShkSW50KSA8IE1hdGguUEkgPyAnc3RhcnQnIDogJ2VuZCcgKSA6ICdtaWRkbGUnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC8vIFRPRE86XG4gICAgICAgICAgICAgICAgLy8gbGV0IHByZXZpb3VzTGFiZWwgPSBudWxsO1xuICAgICAgICAgICAgICAgIC8vIHdoZXRoZXIgdG8gZGlzcGxheSBvdXRlciBsYWJlbFxuICAgICAgICAgICAgICAgIC8vIGNvbnN0IGZpbmFsUG9zID0gb3V0ZXJBcmMuY2VudHJvaWQoZCk7XG4gICAgICAgICAgICAgICAgLy8gY29uc3QgcmlnaHRIYW5kU2lkZSA9IG1pZEFuZ2xlKGQpIDwgTWF0aC5QSTtcbiAgICAgICAgICAgICAgICAvLyBmaW5hbFBvc1swXSA9IHJhZGl1cyAqIDEuMDMgKiAocmlnaHRIYW5kU2lkZSA/IDEgOiAtMSk7XG4gICAgICAgICAgICAgICAgLy8gY29uc3QgcmVjdCA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgICAgICAgICAgICAvLyBsZXQgaW50ZXJzZWN0c1dpdGhQcmV2aW91c0xhYmVsID0gZmFsc2VcblxuICAgICAgICAgICAgICAgIC8vIGlmIChyaWdodEhhbmRTaWRlICYmIHByZXZpb3VzTGFiZWwgJiYgcHJldmlvdXNMYWJlbC5yaWdodCl7XG4gICAgICAgICAgICAgICAgLy8gICAgIGludGVyc2VjdHNXaXRoUHJldmlvdXNMYWJlbCA9IChwcmV2aW91c0xhYmVsLnkgKyBwcmV2aW91c0xhYmVsLmhlaWdodCkgPiBmaW5hbFBvc1sxXVxuICAgICAgICAgICAgICAgIC8vIH0gZWxzZSBpZiAoIXJpZ2h0SGFuZFNpZGUgJiYgcHJldmlvdXNMYWJlbCAmJiAhcHJldmlvdXNMYWJlbC5yaWdodCl7XG4gICAgICAgICAgICAgICAgLy8gICAgIGludGVyc2VjdHNXaXRoUHJldmlvdXNMYWJlbCA9ICggZmluYWxQb3NbMV0gKyByZWN0LmhlaWdodCApID4gcHJldmlvdXNMYWJlbC55XG4gICAgICAgICAgICAgICAgLy8gfVxuXG4gICAgICAgICAgICAgICAgLy8gcHJldmlvdXNMYWJlbCA9IHsgeTogZmluYWxQb3NbMV0sIGhlaWdodDogcmVjdC5oZWlnaHQsIHJpZ2h0OiByaWdodEhhbmRTaWRlfTtcblxuICAgICAgICAgICAgICAgIC8vIHJldHVybiBpbnRlcnNlY3RzV2l0aFByZXZpb3VzTGFiZWwgPyAnbm9uZScgOiBudWxsXG5cbiAgICAgICAgICAgICAgICAvLyBUT0RPOlxuICAgICAgICAgICAgICAgIC8vIFdoYXQgZG8gZG8gd2l0aCBzZXR0aW5ncyBmcm9tIGFub3RoZXIgbWV0cmljIHRoYXQgZG9uJ3Qgc3VpdCBwaWU/XG4gICAgICAgICAgICB9KVxuXG4gICAgICAgIHNlZ21lbnRMYWJlbHMuZXhpdCgpLnJlbW92ZSgpO1xuXG4gICAgICAgIGNvbnN0IGxhYmVsTGluZXNXcmFwcGVyID0gdGhpcy5fYXBwZW5kSWZFbXB0eShwaWUsICdnJywgJ2xhYmVsLWxpbmVzJyk7XG4gICAgICAgIGNvbnN0IGxhYmVsTGluZXMgPSBsYWJlbExpbmVzV3JhcHBlci5zZWxlY3RBbGwoJy5sYWJlbC1saW5lJylcbiAgICAgICAgICAgIC5kYXRhKGFyY3MsIGQgPT4gZC5kYXRhLl94KVxuXG4gICAgICAgIGlmICh0aGlzLnVzZU91dHNpZGVMYWJlbHMoKSkge1xuICAgICAgICAgICAgbGFiZWxMaW5lcy5lbnRlcigpXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgncG9seWxpbmUnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdsYWJlbC1saW5lJylcbiAgICAgICAgICAgICAgICAuYXR0cignc3Ryb2tlJywgZDMuaGNsKGNvbG91cnMuZWlnaHRlZW4uZGFya0dyZXkpLmJyaWdodGVyKCkpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ29wYWNpdHknLCAwLjUpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZS13aWR0aCcsICcxcHgnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgJ25vbmUnKVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnbWl4LWJsZW5kLW1vZGUnLCAnbXVsdGlwbHknKVxuICAgICAgICAgICAgICAgIC5tZXJnZShsYWJlbExpbmVzKVxuICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKCkuZHVyYXRpb24odGhpcy5fdHJhbnNpdGlvbl9kdXJhdGlvbilcbiAgICAgICAgICAgICAgICAuYXR0clR3ZWVuKFwicG9pbnRzXCIsIGZ1bmN0aW9uKGQpe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50ID0gdGhpcy5fY3VycmVudCB8fCBkO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW50ZXJwb2xhdGUgPSBkMy5pbnRlcnBvbGF0ZSh0aGlzLl9jdXJyZW50LCBkKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudCA9IGludGVycG9sYXRlKDApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGQyID0gaW50ZXJwb2xhdGUodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSBhcmMuY2VudHJvaWQoZDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVsYm93ID0gb3V0ZXJBcmMuY2VudHJvaWQoZDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRlcm1pbmFsID0gb3V0ZXJBcmMuY2VudHJvaWQoZDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGVmdEFsaWduZWQgPSBtaWRBbmdsZShkMikgPCBNYXRoLlBJO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGVybWluYWxbMF0gPSByYWRpdXMgKiAwLjk4ICogKGxlZnRBbGlnbmVkID8gMSA6IC0xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9ucyA9IFtzdGFydCwgZWxib3ddO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxlZnRBbGlnbmVkID8gdGVybWluYWxbMF0gPiBlbGJvd1swXSA6IGVsYm93WzBdID4gdGVybWluYWxbMF0pe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9ucy5wdXNoKHRlcm1pbmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwb3NpdGlvbnM7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGxhYmVsTGluZXMuZXhpdCgpLnJlbW92ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGFiZWxMaW5lc1dyYXBwZXIucmVtb3ZlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmlzRG9udXQoKVxuICAgICAgICAgICAgPyB0aGlzLl9hZGRDZW50cmVMYWJlbCgpXG4gICAgICAgICAgICA6IHRoaXMuX2VsZW1lbnQuc2VsZWN0KCcuY2VudHJlLWxhYmVsJykucmVtb3ZlKCk7XG4gICAgfVxuXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwaWUoKSB7XG4gICAgcmV0dXJuIG5ldyBQaWUoKTtcbn0iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/chart/Pie.js\n")},"./src/chart/Points.js":
/*!*****************************!*\
  !*** ./src/chart/Points.js ***!
  \*****************************/
/*! exports provided: points */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "points", function() { return points; });\n/* harmony import */ var _Geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Geometry */ "./src/chart/Geometry.js");\n/* harmony import */ var _Colours__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Colours */ "./src/Colours.js");\n/* harmony import */ var _Legend__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Legend */ "./src/Legend.js");\n// Copyright (C) 2013-2014, 2018 BrandsEye (PTY) LTD\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this\n// software and associated documentation files (the "Software"), to deal in the Software\n// without restriction, including without limitation the rights to use, copy, modify,\n//     merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following\n// conditions:\n//\n//     The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n//     INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n// CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n\n\n\nclass Point extends _Geometry__WEBPACK_IMPORTED_MODULE_0__["Geometry"] {\n\n    constructor() {\n        super("POINT", 3);\n    }\n\n    render() {\n        const element = this._element;\n        const data = this.prepareData(null, true);\n        const width = this._width,\n              height = this._height;\n        const allData = this.prepareData(null, false).map(d => d.data).reduce((acc, val) => acc.concat(val));\n        const totalElements = data.map(d => d.data.length).reduce( (acc, val) => acc + val);\n\n        element.classed("points", true);\n\n        const x = this.getD3XScale(allData, width);\n        const y = this.getD3YScale(allData, height);\n        const sizeScale = this.getSizeScale(allData);\n\n        let groups = element.selectAll(\'.point-groups\');\n        groups = groups.data(data, d => d._key);\n\n        groups.exit().remove();\n\n        const transparentColour = d3.hcl(_Colours__WEBPACK_IMPORTED_MODULE_1__["colours"].eighteen.darkGrey);\n        transparentColour.opacity = 0.8;\n        const determineStroke = d => d3.hcl(this.getD3Colour(d)).c < 20 ? transparentColour : "none";\n\n        // Try to choose opacity of the points based on how much data there is,\n        // and how much space we have to display them. When they are overlapping (this is\n        // a heuristic to determine that), greater opacity helps to see clustering and distribution.\n        const diagonal = Math.sqrt(this.width() * this.width() + this.height() * this.height());\n        const defaultOpacity = Math.max(Math.min(0.9, diagonal / totalElements / 15), 0.5);\n\n        groups.enter()\n              .append("g")\n              .attr("class", d => "point-groups series series-" + Object(_Legend__WEBPACK_IMPORTED_MODULE_2__["toColourKey"])(d.data[0]._colour))\n              .merge(groups)\n              .each((d, i, nodes) => {\n                  const group = d3.select(nodes[i]);\n                  const points = group.selectAll(".point")\n                      .data(d.data, d => d._x);\n\n                  const isFirstRender = !group.property("renderedOnce");\n                  group.property("renderedOnce", true);\n\n                  points.interrupt("point:move")\n                      .transition("point:move")\n                      .duration(500)\n                          .attr("cy", d => y(d._y))\n                          .attr("cx", d => x(d._x) + x.bandwidth() / 2)\n                          .attr("r", d => sizeScale(Math.abs(d._size)))\n                          .style("stroke", determineStroke)\n                          .style("fill", d => this.getD3Colour(d));\n\n                  points.enter()\n                      .append("circle")\n                          .attr("class", "point")\n                          .style("opacity", 0)\n                          .attr("cx", d => x(d._x) + x.bandwidth() / 2)\n                          .attr("cy", y(0))\n                          .attr("r", 1)\n                          .style("fill", d => this.getD3Colour(d))\n                          .style("stroke", determineStroke)\n                          .style("cursor", "pointer")\n                      .merge(points)\n                      .on("contextmenu", () => d3.event.preventDefault()) // No right click.\n                      .on("mouseover", (d, i, nodes) => {\n                          this._dispatch.call("tooltipShow", this, {\n                              e: d3.event,\n                              point: d\n                          });\n\n                          const point = d3.select(nodes[i]);\n\n                          point.interrupt("point:grow")\n                              .transition("point:grow")\n                              .duration(250)\n                              .style("opacity", 1)\n                              .style("fill", d => d3.hcl(this.getD3Colour(d)).darker())\n                              .attr("r", d => sizeScale(Math.abs(d._size)) + 5);\n                      })\n                      .on("mouseout", (d, i, nodes) => {\n                          const point = d3.select(nodes[i]);\n\n                          point.interrupt("point:grow")\n                              .transition("point:grow")\n                              .duration(250)\n                              .style("opacity", defaultOpacity)\n                              .style("fill", d => this.getD3Colour(d))\n                              .attr("r", d => sizeScale(Math.abs(d._size)));\n                      })\n                      .on("click auxclick", d => {\n                          this._dispatch.call("elementClick", this, {\n                              e: d3.event,\n                              point: d\n                          })\n                      })\n                      .transition("point:grow")\n                      .duration(800)\n                      .delay(isFirstRender ? 0 : 500)\n                        .attr("cy", d => y(d._y))\n                        .style("opacity", defaultOpacity)\n                        .attr("r", d => sizeScale(Math.abs(d._size)));\n\n                  points.exit()\n                      .interrupt()\n                      .transition()\n                      .duration(800)\n                      .style("opacity", 0)\n                      .attr("cy", y(0))\n                      .on("end", (d, i, nodes) => d3.select(nodes[i]).remove());\n\n\n              });\n    }\n\n    getD3XScale(data, width) {\n        width = width || this.width();\n        data = data || this.prepareData()\n            .map(d => d.data)\n            .reduce((acc, val) => acc.concat(val));\n\n        return d3.scaleBand()\n            .rangeRound([0, width])\n            .domain(data.map(d => d._x));\n    }\n\n    getD3YScale(data, height) {\n        data = data || this.prepareData()\n            .map(d => d.data)\n            .reduce((acc, val) => acc.concat(val));\n        height = height || this.height();\n\n        return d3.scaleLinear()\n            .range([height, 0])\n            .nice(5)\n            .domain([Math.min(0, d3.min(data, d => d._y)), d3.max(data, d => d._y)]);\n\n    }\n\n    getSizeScale(data) {\n        data = data || this.prepareData()\n            .map(d => d.data)\n            .reduce((acc, val) => acc.concat(val));\n\n        const min = d3.min(data, d => Math.abs(d._size));\n        const max = d3.max(data, d => Math.abs(d._size));\n\n        if (min === max) return () => 5;\n\n        let rangeMin = 5;\n        let rangeMax = 20;\n        const size = Math.min(this.width(), this.height());\n        if (size < 200) {\n            rangeMax = Math.max(8, size * 0.05);\n            rangeMin = Math.max(2, size * 0.025);\n        }\n\n        return d3.scaleLinear()\n            .range([rangeMin, rangeMax])\n            .domain([Math.min(0, min), Math.max(max, 0)]);\n    }\n}\n\n\nfunction points() {\n    return new Point();\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY2hhcnQvUG9pbnRzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYjNqcy8uL3NyYy9jaGFydC9Qb2ludHMuanM/Nzc0MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKEMpIDIwMTMtMjAxNCwgMjAxOCBCcmFuZHNFeWUgKFBUWSkgTFREXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZiB0aGlzXG4vLyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmVcbi8vIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSxcbi8vICAgICBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvXG4vLyBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZ1xuLy8gY29uZGl0aW9uczpcbi8vXG4vLyAgICAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4vLyBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vICAgICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SIElNUExJRUQsXG4vLyAgICAgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEFcbi8vIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFRcbi8vIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRlxuLy8gQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFXG4vLyBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IHsgR2VvbWV0cnkgfSBmcm9tICcuL0dlb21ldHJ5JztcbmltcG9ydCB7IGNvbG91cnMgfSBmcm9tIFwiLi4vQ29sb3Vyc1wiO1xuaW1wb3J0IHsgdG9Db2xvdXJLZXkgfSBmcm9tIFwiLi4vTGVnZW5kXCI7XG5cblxuY2xhc3MgUG9pbnQgZXh0ZW5kcyBHZW9tZXRyeSB7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoXCJQT0lOVFwiLCAzKTtcbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLl9lbGVtZW50O1xuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5wcmVwYXJlRGF0YShudWxsLCB0cnVlKTtcbiAgICAgICAgY29uc3Qgd2lkdGggPSB0aGlzLl93aWR0aCxcbiAgICAgICAgICAgICAgaGVpZ2h0ID0gdGhpcy5faGVpZ2h0O1xuICAgICAgICBjb25zdCBhbGxEYXRhID0gdGhpcy5wcmVwYXJlRGF0YShudWxsLCBmYWxzZSkubWFwKGQgPT4gZC5kYXRhKS5yZWR1Y2UoKGFjYywgdmFsKSA9PiBhY2MuY29uY2F0KHZhbCkpO1xuICAgICAgICBjb25zdCB0b3RhbEVsZW1lbnRzID0gZGF0YS5tYXAoZCA9PiBkLmRhdGEubGVuZ3RoKS5yZWR1Y2UoIChhY2MsIHZhbCkgPT4gYWNjICsgdmFsKTtcblxuICAgICAgICBlbGVtZW50LmNsYXNzZWQoXCJwb2ludHNcIiwgdHJ1ZSk7XG5cbiAgICAgICAgY29uc3QgeCA9IHRoaXMuZ2V0RDNYU2NhbGUoYWxsRGF0YSwgd2lkdGgpO1xuICAgICAgICBjb25zdCB5ID0gdGhpcy5nZXREM1lTY2FsZShhbGxEYXRhLCBoZWlnaHQpO1xuICAgICAgICBjb25zdCBzaXplU2NhbGUgPSB0aGlzLmdldFNpemVTY2FsZShhbGxEYXRhKTtcblxuICAgICAgICBsZXQgZ3JvdXBzID0gZWxlbWVudC5zZWxlY3RBbGwoJy5wb2ludC1ncm91cHMnKTtcbiAgICAgICAgZ3JvdXBzID0gZ3JvdXBzLmRhdGEoZGF0YSwgZCA9PiBkLl9rZXkpO1xuXG4gICAgICAgIGdyb3Vwcy5leGl0KCkucmVtb3ZlKCk7XG5cbiAgICAgICAgY29uc3QgdHJhbnNwYXJlbnRDb2xvdXIgPSBkMy5oY2woY29sb3Vycy5laWdodGVlbi5kYXJrR3JleSk7XG4gICAgICAgIHRyYW5zcGFyZW50Q29sb3VyLm9wYWNpdHkgPSAwLjg7XG4gICAgICAgIGNvbnN0IGRldGVybWluZVN0cm9rZSA9IGQgPT4gZDMuaGNsKHRoaXMuZ2V0RDNDb2xvdXIoZCkpLmMgPCAyMCA/IHRyYW5zcGFyZW50Q29sb3VyIDogXCJub25lXCI7XG5cbiAgICAgICAgLy8gVHJ5IHRvIGNob29zZSBvcGFjaXR5IG9mIHRoZSBwb2ludHMgYmFzZWQgb24gaG93IG11Y2ggZGF0YSB0aGVyZSBpcyxcbiAgICAgICAgLy8gYW5kIGhvdyBtdWNoIHNwYWNlIHdlIGhhdmUgdG8gZGlzcGxheSB0aGVtLiBXaGVuIHRoZXkgYXJlIG92ZXJsYXBwaW5nICh0aGlzIGlzXG4gICAgICAgIC8vIGEgaGV1cmlzdGljIHRvIGRldGVybWluZSB0aGF0KSwgZ3JlYXRlciBvcGFjaXR5IGhlbHBzIHRvIHNlZSBjbHVzdGVyaW5nIGFuZCBkaXN0cmlidXRpb24uXG4gICAgICAgIGNvbnN0IGRpYWdvbmFsID0gTWF0aC5zcXJ0KHRoaXMud2lkdGgoKSAqIHRoaXMud2lkdGgoKSArIHRoaXMuaGVpZ2h0KCkgKiB0aGlzLmhlaWdodCgpKTtcbiAgICAgICAgY29uc3QgZGVmYXVsdE9wYWNpdHkgPSBNYXRoLm1heChNYXRoLm1pbigwLjksIGRpYWdvbmFsIC8gdG90YWxFbGVtZW50cyAvIDE1KSwgMC41KTtcblxuICAgICAgICBncm91cHMuZW50ZXIoKVxuICAgICAgICAgICAgICAuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIGQgPT4gXCJwb2ludC1ncm91cHMgc2VyaWVzIHNlcmllcy1cIiArIHRvQ29sb3VyS2V5KGQuZGF0YVswXS5fY29sb3VyKSlcbiAgICAgICAgICAgICAgLm1lcmdlKGdyb3VwcylcbiAgICAgICAgICAgICAgLmVhY2goKGQsIGksIG5vZGVzKSA9PiB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBncm91cCA9IGQzLnNlbGVjdChub2Rlc1tpXSk7XG4gICAgICAgICAgICAgICAgICBjb25zdCBwb2ludHMgPSBncm91cC5zZWxlY3RBbGwoXCIucG9pbnRcIilcbiAgICAgICAgICAgICAgICAgICAgICAuZGF0YShkLmRhdGEsIGQgPT4gZC5feCk7XG5cbiAgICAgICAgICAgICAgICAgIGNvbnN0IGlzRmlyc3RSZW5kZXIgPSAhZ3JvdXAucHJvcGVydHkoXCJyZW5kZXJlZE9uY2VcIik7XG4gICAgICAgICAgICAgICAgICBncm91cC5wcm9wZXJ0eShcInJlbmRlcmVkT25jZVwiLCB0cnVlKTtcblxuICAgICAgICAgICAgICAgICAgcG9pbnRzLmludGVycnVwdChcInBvaW50Om1vdmVcIilcbiAgICAgICAgICAgICAgICAgICAgICAudHJhbnNpdGlvbihcInBvaW50Om1vdmVcIilcbiAgICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24oNTAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcImN5XCIsIGQgPT4geShkLl95KSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJjeFwiLCBkID0+IHgoZC5feCkgKyB4LmJhbmR3aWR0aCgpIC8gMilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJyXCIsIGQgPT4gc2l6ZVNjYWxlKE1hdGguYWJzKGQuX3NpemUpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwic3Ryb2tlXCIsIGRldGVybWluZVN0cm9rZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBkID0+IHRoaXMuZ2V0RDNDb2xvdXIoZCkpO1xuXG4gICAgICAgICAgICAgICAgICBwb2ludHMuZW50ZXIoKVxuICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoXCJjaXJjbGVcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcInBvaW50XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJjeFwiLCBkID0+IHgoZC5feCkgKyB4LmJhbmR3aWR0aCgpIC8gMilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJjeVwiLCB5KDApKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcInJcIiwgMSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBkID0+IHRoaXMuZ2V0RDNDb2xvdXIoZCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcInN0cm9rZVwiLCBkZXRlcm1pbmVTdHJva2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcImN1cnNvclwiLCBcInBvaW50ZXJcIilcbiAgICAgICAgICAgICAgICAgICAgICAubWVyZ2UocG9pbnRzKVxuICAgICAgICAgICAgICAgICAgICAgIC5vbihcImNvbnRleHRtZW51XCIsICgpID0+IGQzLmV2ZW50LnByZXZlbnREZWZhdWx0KCkpIC8vIE5vIHJpZ2h0IGNsaWNrLlxuICAgICAgICAgICAgICAgICAgICAgIC5vbihcIm1vdXNlb3ZlclwiLCAoZCwgaSwgbm9kZXMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlzcGF0Y2guY2FsbChcInRvb2x0aXBTaG93XCIsIHRoaXMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGU6IGQzLmV2ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQ6IGRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9pbnQgPSBkMy5zZWxlY3Qobm9kZXNbaV0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50LmludGVycnVwdChcInBvaW50Omdyb3dcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKFwicG9pbnQ6Z3Jvd1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKDI1MClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcImZpbGxcIiwgZCA9PiBkMy5oY2wodGhpcy5nZXREM0NvbG91cihkKSkuZGFya2VyKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcInJcIiwgZCA9PiBzaXplU2NhbGUoTWF0aC5hYnMoZC5fc2l6ZSkpICsgNSk7XG4gICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAub24oXCJtb3VzZW91dFwiLCAoZCwgaSwgbm9kZXMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9pbnQgPSBkMy5zZWxlY3Qobm9kZXNbaV0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50LmludGVycnVwdChcInBvaW50Omdyb3dcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKFwicG9pbnQ6Z3Jvd1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKDI1MClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgZGVmYXVsdE9wYWNpdHkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIGQgPT4gdGhpcy5nZXREM0NvbG91cihkKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiclwiLCBkID0+IHNpemVTY2FsZShNYXRoLmFicyhkLl9zaXplKSkpO1xuICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgLm9uKFwiY2xpY2sgYXV4Y2xpY2tcIiwgZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3BhdGNoLmNhbGwoXCJlbGVtZW50Q2xpY2tcIiwgdGhpcywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZTogZDMuZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludDogZFxuICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgLnRyYW5zaXRpb24oXCJwb2ludDpncm93XCIpXG4gICAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKDgwMClcbiAgICAgICAgICAgICAgICAgICAgICAuZGVsYXkoaXNGaXJzdFJlbmRlciA/IDAgOiA1MDApXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcImN5XCIsIGQgPT4geShkLl95KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgZGVmYXVsdE9wYWNpdHkpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcInJcIiwgZCA9PiBzaXplU2NhbGUoTWF0aC5hYnMoZC5fc2l6ZSkpKTtcblxuICAgICAgICAgICAgICAgICAgcG9pbnRzLmV4aXQoKVxuICAgICAgICAgICAgICAgICAgICAgIC5pbnRlcnJ1cHQoKVxuICAgICAgICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKClcbiAgICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24oODAwKVxuICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMClcbiAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcImN5XCIsIHkoMCkpXG4gICAgICAgICAgICAgICAgICAgICAgLm9uKFwiZW5kXCIsIChkLCBpLCBub2RlcykgPT4gZDMuc2VsZWN0KG5vZGVzW2ldKS5yZW1vdmUoKSk7XG5cblxuICAgICAgICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBnZXREM1hTY2FsZShkYXRhLCB3aWR0aCkge1xuICAgICAgICB3aWR0aCA9IHdpZHRoIHx8IHRoaXMud2lkdGgoKTtcbiAgICAgICAgZGF0YSA9IGRhdGEgfHwgdGhpcy5wcmVwYXJlRGF0YSgpXG4gICAgICAgICAgICAubWFwKGQgPT4gZC5kYXRhKVxuICAgICAgICAgICAgLnJlZHVjZSgoYWNjLCB2YWwpID0+IGFjYy5jb25jYXQodmFsKSk7XG5cbiAgICAgICAgcmV0dXJuIGQzLnNjYWxlQmFuZCgpXG4gICAgICAgICAgICAucmFuZ2VSb3VuZChbMCwgd2lkdGhdKVxuICAgICAgICAgICAgLmRvbWFpbihkYXRhLm1hcChkID0+IGQuX3gpKTtcbiAgICB9XG5cbiAgICBnZXREM1lTY2FsZShkYXRhLCBoZWlnaHQpIHtcbiAgICAgICAgZGF0YSA9IGRhdGEgfHwgdGhpcy5wcmVwYXJlRGF0YSgpXG4gICAgICAgICAgICAubWFwKGQgPT4gZC5kYXRhKVxuICAgICAgICAgICAgLnJlZHVjZSgoYWNjLCB2YWwpID0+IGFjYy5jb25jYXQodmFsKSk7XG4gICAgICAgIGhlaWdodCA9IGhlaWdodCB8fCB0aGlzLmhlaWdodCgpO1xuXG4gICAgICAgIHJldHVybiBkMy5zY2FsZUxpbmVhcigpXG4gICAgICAgICAgICAucmFuZ2UoW2hlaWdodCwgMF0pXG4gICAgICAgICAgICAubmljZSg1KVxuICAgICAgICAgICAgLmRvbWFpbihbTWF0aC5taW4oMCwgZDMubWluKGRhdGEsIGQgPT4gZC5feSkpLCBkMy5tYXgoZGF0YSwgZCA9PiBkLl95KV0pO1xuXG4gICAgfVxuXG4gICAgZ2V0U2l6ZVNjYWxlKGRhdGEpIHtcbiAgICAgICAgZGF0YSA9IGRhdGEgfHwgdGhpcy5wcmVwYXJlRGF0YSgpXG4gICAgICAgICAgICAubWFwKGQgPT4gZC5kYXRhKVxuICAgICAgICAgICAgLnJlZHVjZSgoYWNjLCB2YWwpID0+IGFjYy5jb25jYXQodmFsKSk7XG5cbiAgICAgICAgY29uc3QgbWluID0gZDMubWluKGRhdGEsIGQgPT4gTWF0aC5hYnMoZC5fc2l6ZSkpO1xuICAgICAgICBjb25zdCBtYXggPSBkMy5tYXgoZGF0YSwgZCA9PiBNYXRoLmFicyhkLl9zaXplKSk7XG5cbiAgICAgICAgaWYgKG1pbiA9PT0gbWF4KSByZXR1cm4gKCkgPT4gNTtcblxuICAgICAgICBsZXQgcmFuZ2VNaW4gPSA1O1xuICAgICAgICBsZXQgcmFuZ2VNYXggPSAyMDtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IE1hdGgubWluKHRoaXMud2lkdGgoKSwgdGhpcy5oZWlnaHQoKSk7XG4gICAgICAgIGlmIChzaXplIDwgMjAwKSB7XG4gICAgICAgICAgICByYW5nZU1heCA9IE1hdGgubWF4KDgsIHNpemUgKiAwLjA1KTtcbiAgICAgICAgICAgIHJhbmdlTWluID0gTWF0aC5tYXgoMiwgc2l6ZSAqIDAuMDI1KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkMy5zY2FsZUxpbmVhcigpXG4gICAgICAgICAgICAucmFuZ2UoW3JhbmdlTWluLCByYW5nZU1heF0pXG4gICAgICAgICAgICAuZG9tYWluKFtNYXRoLm1pbigwLCBtaW4pLCBNYXRoLm1heChtYXgsIDApXSk7XG4gICAgfVxufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBwb2ludHMoKSB7XG4gICAgcmV0dXJuIG5ldyBQb2ludCgpO1xufSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/chart/Points.js\n')},"./src/chart/Scales.js":
/*!*****************************!*\
  !*** ./src/chart/Scales.js ***!
  \*****************************/
/*! exports provided: scaleTime, scaleIdentity, scaleDiscrete, chooseScale */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaleTime", function() { return scaleTime; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaleIdentity", function() { return scaleIdentity; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaleDiscrete", function() { return scaleDiscrete; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "chooseScale", function() { return chooseScale; });\n/* harmony import */ var _Bucket__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Bucket */ "./src/chart/Bucket.js");\n// Copyright (C) 2013-2014, 2018 BrandsEye (PTY) LTD\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this\n// software and associated documentation files (the "Software"), to deal in the Software\n// without restriction, including without limitation the rights to use, copy, modify,\n//     merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following\n// conditions:\n//\n//     The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n//     INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n// CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nclass Scale {\n    constructor() {\n        this.getCount = d => d._y;\n        this.setCount = (d, v) => d._y = v;\n    }\n\n    transform(val) {\n        return val;\n    }\n\n    setCountGetter(y) {\n        this.getCount = y;\n        return this;\n    }\n\n    setCountSetter(y) {\n        this.setCount = y;\n        return this;\n    }\n\n    isShowGrid() { return true };\n\n    isContinuous() { return !this.isDiscrete() };\n    isDiscrete() { throw new Error("Not implemented") };\n}\n\n\nclass ScaleTime extends Scale {\n    transform(val) {\n        if (val instanceof Date) return val;\n        if (typeof val !== \'string\') throw new Error("Value is not a string and cannot be converted to a date");\n        return new Date(val);\n    }\n\n    buckets(data) {\n        return new _Bucket__WEBPACK_IMPORTED_MODULE_0__["DateBucket"](data)\n            .setCountSetter(this.setCount)\n            .setCountGetter(this.getCount);\n    }\n\n    isShowGrid() { return false };\n    isDiscrete() { return true };\n}\n\nclass ScaleIdentity extends Scale  {\n    transform(val) {\n        return val;\n    }\n\n    buckets(data) {\n        return new _Bucket__WEBPACK_IMPORTED_MODULE_0__["ContinuousBucket"](data)\n            .setCountSetter(this.setCount)\n            .setCountGetter(this.getCount)\n    }\n\n    isShowGrid() { return true };\n    isDiscrete() { return false };\n}\n\nclass ScaleDiscrete extends Scale  {\n    transform(val) {\n        return val;\n    }\n\n    buckets(data) {\n        return new _Bucket__WEBPACK_IMPORTED_MODULE_0__["DiscreteBucket"](data)\n            .setCountSetter(this.setCount)\n            .setCountGetter(this.getCount)\n    }\n\n    isShowGrid() { return false };\n    isDiscrete() { return true };\n}\n\n\nfunction scaleTime() {\n    return new ScaleTime();\n}\n\nfunction scaleIdentity() {\n    return new ScaleIdentity();\n}\n\nfunction scaleDiscrete() {\n    return new ScaleDiscrete();\n}\n\nfunction chooseScale(exampleValue) {\n    if (Array.isArray(exampleValue)) {\n        const scales = new Set();\n        for (const example of exampleValue) {\n            scales.add(chooseScale(example).constructor);\n        }\n\n        if (scales.size === 0) {\n            throw new Error("Unable to determine scales");\n        }\n\n        if (scales.size === 1) {\n            return new (scales.values().next().value);\n        }\n\n        // There is a priority amongst the scale types.\n        let scale = null;\n        for (const s of scales) {\n            if (s === ScaleIdentity) scale = scaleIdentity();\n            else if (s === ScaleDiscrete) scale = scaleDiscrete();\n            else scale = scaleTime();\n        }\n\n        return scale;\n    }\n\n    if (exampleValue === undefined) throw new Error("No value provided for chooseScale");\n    try {\n        if (Date.parse(exampleValue)) return scaleTime();\n    } catch (e) {\n        // ignore - likely not a valid date\n    }\n    if (exampleValue instanceof Date) return scaleTime();\n    if (typeof exampleValue === \'string\') return scaleDiscrete();\n    if (typeof exampleValue === \'number\') return scaleIdentity();\n\n    throw new Error("Unable to determine wanted scale for example value [" + exampleValue + "]");\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY2hhcnQvU2NhbGVzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYjNqcy8uL3NyYy9jaGFydC9TY2FsZXMuanM/NjI4YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKEMpIDIwMTMtMjAxNCwgMjAxOCBCcmFuZHNFeWUgKFBUWSkgTFREXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZiB0aGlzXG4vLyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmVcbi8vIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSxcbi8vICAgICBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvXG4vLyBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZ1xuLy8gY29uZGl0aW9uczpcbi8vXG4vLyAgICAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4vLyBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vICAgICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SIElNUExJRUQsXG4vLyAgICAgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEFcbi8vIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFRcbi8vIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRlxuLy8gQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFXG4vLyBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IHtEYXRlQnVja2V0LCBDb250aW51b3VzQnVja2V0LCBEaXNjcmV0ZUJ1Y2tldH0gZnJvbSBcIi4vQnVja2V0XCI7XG5cbmNsYXNzIFNjYWxlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5nZXRDb3VudCA9IGQgPT4gZC5feTtcbiAgICAgICAgdGhpcy5zZXRDb3VudCA9IChkLCB2KSA9PiBkLl95ID0gdjtcbiAgICB9XG5cbiAgICB0cmFuc2Zvcm0odmFsKSB7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuXG4gICAgc2V0Q291bnRHZXR0ZXIoeSkge1xuICAgICAgICB0aGlzLmdldENvdW50ID0geTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgc2V0Q291bnRTZXR0ZXIoeSkge1xuICAgICAgICB0aGlzLnNldENvdW50ID0geTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaXNTaG93R3JpZCgpIHsgcmV0dXJuIHRydWUgfTtcblxuICAgIGlzQ29udGludW91cygpIHsgcmV0dXJuICF0aGlzLmlzRGlzY3JldGUoKSB9O1xuICAgIGlzRGlzY3JldGUoKSB7IHRocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZFwiKSB9O1xufVxuXG5cbmNsYXNzIFNjYWxlVGltZSBleHRlbmRzIFNjYWxlIHtcbiAgICB0cmFuc2Zvcm0odmFsKSB7XG4gICAgICAgIGlmICh2YWwgaW5zdGFuY2VvZiBEYXRlKSByZXR1cm4gdmFsO1xuICAgICAgICBpZiAodHlwZW9mIHZhbCAhPT0gJ3N0cmluZycpIHRocm93IG5ldyBFcnJvcihcIlZhbHVlIGlzIG5vdCBhIHN0cmluZyBhbmQgY2Fubm90IGJlIGNvbnZlcnRlZCB0byBhIGRhdGVcIik7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSh2YWwpO1xuICAgIH1cblxuICAgIGJ1Y2tldHMoZGF0YSkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGVCdWNrZXQoZGF0YSlcbiAgICAgICAgICAgIC5zZXRDb3VudFNldHRlcih0aGlzLnNldENvdW50KVxuICAgICAgICAgICAgLnNldENvdW50R2V0dGVyKHRoaXMuZ2V0Q291bnQpO1xuICAgIH1cblxuICAgIGlzU2hvd0dyaWQoKSB7IHJldHVybiBmYWxzZSB9O1xuICAgIGlzRGlzY3JldGUoKSB7IHJldHVybiB0cnVlIH07XG59XG5cbmNsYXNzIFNjYWxlSWRlbnRpdHkgZXh0ZW5kcyBTY2FsZSAge1xuICAgIHRyYW5zZm9ybSh2YWwpIHtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG5cbiAgICBidWNrZXRzKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb250aW51b3VzQnVja2V0KGRhdGEpXG4gICAgICAgICAgICAuc2V0Q291bnRTZXR0ZXIodGhpcy5zZXRDb3VudClcbiAgICAgICAgICAgIC5zZXRDb3VudEdldHRlcih0aGlzLmdldENvdW50KVxuICAgIH1cblxuICAgIGlzU2hvd0dyaWQoKSB7IHJldHVybiB0cnVlIH07XG4gICAgaXNEaXNjcmV0ZSgpIHsgcmV0dXJuIGZhbHNlIH07XG59XG5cbmNsYXNzIFNjYWxlRGlzY3JldGUgZXh0ZW5kcyBTY2FsZSAge1xuICAgIHRyYW5zZm9ybSh2YWwpIHtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG5cbiAgICBidWNrZXRzKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEaXNjcmV0ZUJ1Y2tldChkYXRhKVxuICAgICAgICAgICAgLnNldENvdW50U2V0dGVyKHRoaXMuc2V0Q291bnQpXG4gICAgICAgICAgICAuc2V0Q291bnRHZXR0ZXIodGhpcy5nZXRDb3VudClcbiAgICB9XG5cbiAgICBpc1Nob3dHcmlkKCkgeyByZXR1cm4gZmFsc2UgfTtcbiAgICBpc0Rpc2NyZXRlKCkgeyByZXR1cm4gdHJ1ZSB9O1xufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBzY2FsZVRpbWUoKSB7XG4gICAgcmV0dXJuIG5ldyBTY2FsZVRpbWUoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlSWRlbnRpdHkoKSB7XG4gICAgcmV0dXJuIG5ldyBTY2FsZUlkZW50aXR5KCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzY2FsZURpc2NyZXRlKCkge1xuICAgIHJldHVybiBuZXcgU2NhbGVEaXNjcmV0ZSgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2hvb3NlU2NhbGUoZXhhbXBsZVZhbHVlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZXhhbXBsZVZhbHVlKSkge1xuICAgICAgICBjb25zdCBzY2FsZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIGZvciAoY29uc3QgZXhhbXBsZSBvZiBleGFtcGxlVmFsdWUpIHtcbiAgICAgICAgICAgIHNjYWxlcy5hZGQoY2hvb3NlU2NhbGUoZXhhbXBsZSkuY29uc3RydWN0b3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNjYWxlcy5zaXplID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gZGV0ZXJtaW5lIHNjYWxlc1wiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzY2FsZXMuc2l6ZSA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyAoc2NhbGVzLnZhbHVlcygpLm5leHQoKS52YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGVyZSBpcyBhIHByaW9yaXR5IGFtb25nc3QgdGhlIHNjYWxlIHR5cGVzLlxuICAgICAgICBsZXQgc2NhbGUgPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IHMgb2Ygc2NhbGVzKSB7XG4gICAgICAgICAgICBpZiAocyA9PT0gU2NhbGVJZGVudGl0eSkgc2NhbGUgPSBzY2FsZUlkZW50aXR5KCk7XG4gICAgICAgICAgICBlbHNlIGlmIChzID09PSBTY2FsZURpc2NyZXRlKSBzY2FsZSA9IHNjYWxlRGlzY3JldGUoKTtcbiAgICAgICAgICAgIGVsc2Ugc2NhbGUgPSBzY2FsZVRpbWUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzY2FsZTtcbiAgICB9XG5cbiAgICBpZiAoZXhhbXBsZVZhbHVlID09PSB1bmRlZmluZWQpIHRocm93IG5ldyBFcnJvcihcIk5vIHZhbHVlIHByb3ZpZGVkIGZvciBjaG9vc2VTY2FsZVwiKTtcbiAgICB0cnkge1xuICAgICAgICBpZiAoRGF0ZS5wYXJzZShleGFtcGxlVmFsdWUpKSByZXR1cm4gc2NhbGVUaW1lKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBpZ25vcmUgLSBsaWtlbHkgbm90IGEgdmFsaWQgZGF0ZVxuICAgIH1cbiAgICBpZiAoZXhhbXBsZVZhbHVlIGluc3RhbmNlb2YgRGF0ZSkgcmV0dXJuIHNjYWxlVGltZSgpO1xuICAgIGlmICh0eXBlb2YgZXhhbXBsZVZhbHVlID09PSAnc3RyaW5nJykgcmV0dXJuIHNjYWxlRGlzY3JldGUoKTtcbiAgICBpZiAodHlwZW9mIGV4YW1wbGVWYWx1ZSA9PT0gJ251bWJlcicpIHJldHVybiBzY2FsZUlkZW50aXR5KCk7XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gZGV0ZXJtaW5lIHdhbnRlZCBzY2FsZSBmb3IgZXhhbXBsZSB2YWx1ZSBbXCIgKyBleGFtcGxlVmFsdWUgKyBcIl1cIik7XG59Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/chart/Scales.js\n')},"./src/helpers.js":
/*!************************!*\
  !*** ./src/helpers.js ***!
  \************************/
/*! exports provided: maxBounding, getBoundings, labelIsZero, equals */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "maxBounding", function() { return maxBounding; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBoundings", function() { return getBoundings; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "labelIsZero", function() { return labelIsZero; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });\n// Copyright (C) 2013-2014, 2018 BrandsEye (PTY) LTD\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this\n// software and associated documentation files (the "Software"), to deal in the Software\n// without restriction, including without limitation the rights to use, copy, modify,\n//     merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following\n// conditions:\n//\n//     The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n//     INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n// CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n/**\n * Given an array of text, this places things in the DOM to figure out how\n * much pixel space the text takes up.\n */\nfunction maxBounding(selection, text, font, fontSize) {\n    // font = font || "Open Sans, sans-serif";\n    // fontSize = fontSize || "12";\n\n    const boundings = getBoundings(selection, text, font, fontSize);\n\n    let width = 0;\n    let height = 0;\n\n    Object.values(boundings).forEach(bounding => {\n        if (bounding.width > width) width = bounding.width;\n        if (bounding.height > height) height = bounding.height;\n    });\n\n    return {\n        width: width,\n        height: height\n    }\n}\n\nfunction getBoundings(selection, text, font, fontSize) {\n    // font = font || "Open Sans, sans-serif";\n    // fontSize = fontSize || "12";\n\n    const boundings = {};\n    selection.append("g")\n             .attr("class", "text-size")\n             .style("opacity", 0)\n             .attr("transform", "translate(-100, -100)")\n             .selectAll(".text-measurement")\n             .data(text)\n             .enter()\n             .append("text")\n             .text(d => d)\n             .style("font-size", fontSize ? fontSize + "px" : null)\n             .each((d, i, nodes) => {\n                 const node = nodes[i];\n                 const bb = node.getBBox();\n                 boundings[d] = {\n                     width: bb.width,\n                     height: bb.height\n                 };\n             });\n\n    selection.select(".text-size").remove();\n    return boundings;\n}\n\n\n\n/** A test to whether a given data label is 0, or 0%. */\nfunction labelIsZero(label) {\n    label = "" + label;\n    return label === "0" || label === "0%" || label === "0.0%"\n}\n\nfunction equals(lhs, rhs) {\n    if (lhs instanceof Date && rhs instanceof Date) {\n        return lhs.getTime() === rhs.getTime();\n    }\n\n    return lhs === rhs;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaGVscGVycy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2IzanMvLi9zcmMvaGVscGVycy5qcz9kN2MyIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoQykgMjAxMy0yMDE0LCAyMDE4IEJyYW5kc0V5ZSAoUFRZKSBMVERcbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXNcbi8vIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZVxuLy8gd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LFxuLy8gICAgIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG9cbi8vIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nXG4vLyBjb25kaXRpb25zOlxuLy9cbi8vICAgICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbi8vIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gICAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1IgSU1QTElFRCxcbi8vICAgICBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQVxuLy8gUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxuLy8gSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GXG4vLyBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkVcbi8vIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5cbi8qKlxuICogR2l2ZW4gYW4gYXJyYXkgb2YgdGV4dCwgdGhpcyBwbGFjZXMgdGhpbmdzIGluIHRoZSBET00gdG8gZmlndXJlIG91dCBob3dcbiAqIG11Y2ggcGl4ZWwgc3BhY2UgdGhlIHRleHQgdGFrZXMgdXAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXhCb3VuZGluZyhzZWxlY3Rpb24sIHRleHQsIGZvbnQsIGZvbnRTaXplKSB7XG4gICAgLy8gZm9udCA9IGZvbnQgfHwgXCJPcGVuIFNhbnMsIHNhbnMtc2VyaWZcIjtcbiAgICAvLyBmb250U2l6ZSA9IGZvbnRTaXplIHx8IFwiMTJcIjtcblxuICAgIGNvbnN0IGJvdW5kaW5ncyA9IGdldEJvdW5kaW5ncyhzZWxlY3Rpb24sIHRleHQsIGZvbnQsIGZvbnRTaXplKTtcblxuICAgIGxldCB3aWR0aCA9IDA7XG4gICAgbGV0IGhlaWdodCA9IDA7XG5cbiAgICBPYmplY3QudmFsdWVzKGJvdW5kaW5ncykuZm9yRWFjaChib3VuZGluZyA9PiB7XG4gICAgICAgIGlmIChib3VuZGluZy53aWR0aCA+IHdpZHRoKSB3aWR0aCA9IGJvdW5kaW5nLndpZHRoO1xuICAgICAgICBpZiAoYm91bmRpbmcuaGVpZ2h0ID4gaGVpZ2h0KSBoZWlnaHQgPSBib3VuZGluZy5oZWlnaHQ7XG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Qm91bmRpbmdzKHNlbGVjdGlvbiwgdGV4dCwgZm9udCwgZm9udFNpemUpIHtcbiAgICAvLyBmb250ID0gZm9udCB8fCBcIk9wZW4gU2Fucywgc2Fucy1zZXJpZlwiO1xuICAgIC8vIGZvbnRTaXplID0gZm9udFNpemUgfHwgXCIxMlwiO1xuXG4gICAgY29uc3QgYm91bmRpbmdzID0ge307XG4gICAgc2VsZWN0aW9uLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwidGV4dC1zaXplXCIpXG4gICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAwKVxuICAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKC0xMDAsIC0xMDApXCIpXG4gICAgICAgICAgICAgLnNlbGVjdEFsbChcIi50ZXh0LW1lYXN1cmVtZW50XCIpXG4gICAgICAgICAgICAgLmRhdGEodGV4dClcbiAgICAgICAgICAgICAuZW50ZXIoKVxuICAgICAgICAgICAgIC5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgICAgICAgICAgLnRleHQoZCA9PiBkKVxuICAgICAgICAgICAgIC5zdHlsZShcImZvbnQtc2l6ZVwiLCBmb250U2l6ZSA/IGZvbnRTaXplICsgXCJweFwiIDogbnVsbClcbiAgICAgICAgICAgICAuZWFjaCgoZCwgaSwgbm9kZXMpID0+IHtcbiAgICAgICAgICAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICAgICAgICAgICBjb25zdCBiYiA9IG5vZGUuZ2V0QkJveCgpO1xuICAgICAgICAgICAgICAgICBib3VuZGluZ3NbZF0gPSB7XG4gICAgICAgICAgICAgICAgICAgICB3aWR0aDogYmIud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGJiLmhlaWdodFxuICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgIH0pO1xuXG4gICAgc2VsZWN0aW9uLnNlbGVjdChcIi50ZXh0LXNpemVcIikucmVtb3ZlKCk7XG4gICAgcmV0dXJuIGJvdW5kaW5ncztcbn1cblxuXG5cbi8qKiBBIHRlc3QgdG8gd2hldGhlciBhIGdpdmVuIGRhdGEgbGFiZWwgaXMgMCwgb3IgMCUuICovXG5leHBvcnQgZnVuY3Rpb24gbGFiZWxJc1plcm8obGFiZWwpIHtcbiAgICBsYWJlbCA9IFwiXCIgKyBsYWJlbDtcbiAgICByZXR1cm4gbGFiZWwgPT09IFwiMFwiIHx8IGxhYmVsID09PSBcIjAlXCIgfHwgbGFiZWwgPT09IFwiMC4wJVwiXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbHMobGhzLCByaHMpIHtcbiAgICBpZiAobGhzIGluc3RhbmNlb2YgRGF0ZSAmJiByaHMgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIHJldHVybiBsaHMuZ2V0VGltZSgpID09PSByaHMuZ2V0VGltZSgpO1xuICAgIH1cblxuICAgIHJldHVybiBsaHMgPT09IHJocztcbn0iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/helpers.js\n')},"./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! exports provided: ColumnChart, BarChart, PieChart, LineChart, colours, chart, histogram, columnChart, barChart, line, pie, points, scaleTime, scaleIdentity, scaleDiscrete, chooseScale */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _ColumnChart__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ColumnChart */ "./src/ColumnChart.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ColumnChart", function() { return _ColumnChart__WEBPACK_IMPORTED_MODULE_0__["ColumnChart"]; });\n\n/* harmony import */ var _BarChart__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BarChart */ "./src/BarChart.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BarChart", function() { return _BarChart__WEBPACK_IMPORTED_MODULE_1__["BarChart"]; });\n\n/* harmony import */ var _PieChart__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./PieChart */ "./src/PieChart.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PieChart", function() { return _PieChart__WEBPACK_IMPORTED_MODULE_2__["PieChart"]; });\n\n/* harmony import */ var _LineChart__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./LineChart */ "./src/LineChart.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LineChart", function() { return _LineChart__WEBPACK_IMPORTED_MODULE_3__["LineChart"]; });\n\n/* harmony import */ var _Colours__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Colours */ "./src/Colours.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "colours", function() { return _Colours__WEBPACK_IMPORTED_MODULE_4__["colours"]; });\n\n/* harmony import */ var _chart_FantasticChart__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./chart/FantasticChart */ "./src/chart/FantasticChart.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "chart", function() { return _chart_FantasticChart__WEBPACK_IMPORTED_MODULE_5__["chart"]; });\n\n/* harmony import */ var _chart_Histogram__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./chart/Histogram */ "./src/chart/Histogram.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "histogram", function() { return _chart_Histogram__WEBPACK_IMPORTED_MODULE_6__["histogram"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "columnChart", function() { return _chart_Histogram__WEBPACK_IMPORTED_MODULE_6__["columnChart"]; });\n\n/* harmony import */ var _chart_BarChart__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./chart/BarChart */ "./src/chart/BarChart.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "barChart", function() { return _chart_BarChart__WEBPACK_IMPORTED_MODULE_7__["barChart"]; });\n\n/* harmony import */ var _chart_Line__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./chart/Line */ "./src/chart/Line.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "line", function() { return _chart_Line__WEBPACK_IMPORTED_MODULE_8__["line"]; });\n\n/* harmony import */ var _chart_Pie__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./chart/Pie */ "./src/chart/Pie.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pie", function() { return _chart_Pie__WEBPACK_IMPORTED_MODULE_9__["pie"]; });\n\n/* harmony import */ var _chart_Points__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./chart/Points */ "./src/chart/Points.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "points", function() { return _chart_Points__WEBPACK_IMPORTED_MODULE_10__["points"]; });\n\n/* harmony import */ var _chart_Scales__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./chart/Scales */ "./src/chart/Scales.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleTime", function() { return _chart_Scales__WEBPACK_IMPORTED_MODULE_11__["scaleTime"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleIdentity", function() { return _chart_Scales__WEBPACK_IMPORTED_MODULE_11__["scaleIdentity"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleDiscrete", function() { return _chart_Scales__WEBPACK_IMPORTED_MODULE_11__["scaleDiscrete"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "chooseScale", function() { return _chart_Scales__WEBPACK_IMPORTED_MODULE_11__["chooseScale"]; });\n\n// Copyright (C) 2013-2014, 2018 BrandsEye (PTY) LTD\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this\n// software and associated documentation files (the "Software"), to deal in the Software\n// without restriction, including without limitation the rights to use, copy, modify,\n//     merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following\n// conditions:\n//\n//     The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n//     INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n// CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n\n\n\n\n// For the Fantastic Chart\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9iM2pzLy4vc3JjL2luZGV4LmpzP2I2MzUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChDKSAyMDEzLTIwMTQsIDIwMTggQnJhbmRzRXllIChQVFkpIExURFxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpc1xuLy8gc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlXG4vLyB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksXG4vLyAgICAgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0b1xuLy8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcbi8vIGNvbmRpdGlvbnM6XG4vL1xuLy8gICAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuLy8gY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyAgICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUiBJTVBMSUVELFxuLy8gICAgIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBXG4vLyBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUXG4vLyBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0Zcbi8vIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRVxuLy8gT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbmV4cG9ydCB7IENvbHVtbkNoYXJ0IGFzIENvbHVtbkNoYXJ0IH0gZnJvbSAnLi9Db2x1bW5DaGFydCc7XG5leHBvcnQgeyBCYXJDaGFydCBhcyBCYXJDaGFydCB9IGZyb20gJy4vQmFyQ2hhcnQnO1xuZXhwb3J0IHsgUGllQ2hhcnQgYXMgUGllQ2hhcnQgfSBmcm9tICcuL1BpZUNoYXJ0JztcbmV4cG9ydCB7IExpbmVDaGFydCBhcyBMaW5lQ2hhcnQgfSBmcm9tICcuL0xpbmVDaGFydCc7XG5leHBvcnQgeyBjb2xvdXJzIH0gZnJvbSAnLi9Db2xvdXJzJztcblxuLy8gRm9yIHRoZSBGYW50YXN0aWMgQ2hhcnRcbmV4cG9ydCB7IGNoYXJ0IH0gZnJvbSAnLi9jaGFydC9GYW50YXN0aWNDaGFydCc7XG5leHBvcnQgeyBoaXN0b2dyYW0sIGNvbHVtbkNoYXJ0IH0gZnJvbSAnLi9jaGFydC9IaXN0b2dyYW0nO1xuZXhwb3J0IHsgYmFyQ2hhcnQgfSBmcm9tICcuL2NoYXJ0L0JhckNoYXJ0JztcbmV4cG9ydCB7IGxpbmUgfSBmcm9tICcuL2NoYXJ0L0xpbmUnO1xuZXhwb3J0IHsgcGllIH0gZnJvbSAnLi9jaGFydC9QaWUnO1xuZXhwb3J0IHsgcG9pbnRzIH0gZnJvbSAnLi9jaGFydC9Qb2ludHMnO1xuZXhwb3J0IHsgc2NhbGVUaW1lLCBzY2FsZUlkZW50aXR5LCBzY2FsZURpc2NyZXRlLCBjaG9vc2VTY2FsZSB9IGZyb20gJy4vY2hhcnQvU2NhbGVzJzsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/index.js\n')}});