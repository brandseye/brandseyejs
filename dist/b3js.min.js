var b3js=function(I){var g={};function C(A){if(g[A])return g[A].exports;var t=g[A]={i:A,l:!1,exports:{}};return I[A].call(t.exports,t,t.exports,C),t.l=!0,t.exports}return C.m=I,C.c=g,C.d=function(I,g,A){C.o(I,g)||Object.defineProperty(I,g,{configurable:!1,enumerable:!0,get:A})},C.r=function(I){Object.defineProperty(I,"__esModule",{value:!0})},C.n=function(I){var g=I&&I.__esModule?function(){return I.default}:function(){return I};return C.d(g,"a",g),g},C.o=function(I,g){return Object.prototype.hasOwnProperty.call(I,g)},C.p="",C(C.s="./src/index.js")}({"./node_modules/compute-iqr/lib/index.js":
/*!***********************************************!*\
  !*** ./node_modules/compute-iqr/lib/index.js ***!
  \***********************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("/**\n*\n*\tCOMPUTE: iqr\n*\n*\n*\tDESCRIPTION:\n*\t\t- Computes the interquartile range for an array of values.\n*\n*\n*\tNOTES:\n*\t\t[1]\n*\n*\n*\tTODO:\n*\t\t[1]\n*\n*\n*\tLICENSE:\n*\t\tMIT\n*\n*\tCopyright (c) 2014. Athan Reines.\n*\n*\n*\tAUTHOR:\n*\t\tAthan Reines. kgryte@gmail.com. 2014.\n*\n*/\n\n\n\n// MODULES //\n\nvar isObject = __webpack_require__( /*! validate.io-object */ \"./node_modules/validate.io-object/lib/index.js\" ),\n\tquantile = __webpack_require__( /*! compute-quantile */ \"./node_modules/compute-quantile/lib/index.js\" );\n\n\n// FUNCTIONS //\n\n/**\n* FUNCTION: ascending( a, b )\n*\tComparator function used to sort values in ascending order.\n*\n* @private\n* @param {Number} a\n* @param {Number} b\n* @returns {Number} difference between `a` and `b`\n*/\nfunction ascending( a, b ) {\n\treturn a - b;\n} // end FUNCTION ascending()\n\n\n// INTERQUARTILE RANGE //\n\n/**\n* FUNCTION: iqr( arr )\n*\tComputes the interquartile range for an array.\n*\n* @param {Array} arr - array of values\n* @returns {Number} interquartile range\n*/\nfunction iqr( arr, opts ) {\n\tif ( !Array.isArray( arr ) ) {\n\t\tthrow new TypeError( 'iqr()::invalid input argument. Must provide an array.' );\n\t}\n\tif ( arguments.length > 1 ) {\n\t\tif ( !isObject( opts ) ) {\n\t\t\tthrow new TypeError( 'iqr()::invalid input argument. Options should be an object.' );\n\t\t}\n\t} else {\n\t\topts = {\n\t\t\t'sorted': false\n\t\t};\n\t}\n\tif ( !opts.sorted ) {\n\t\tarr = arr.slice();\n\t\tarr.sort( ascending );\n\t\topts.sorted = true;\n\t}\n\treturn quantile( arr, 0.75, opts ) - quantile( arr, 0.25, opts );\n} // end FUNCTION iqr()\n\n\n// EXPORTS //\n\nmodule.exports = iqr;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY29tcHV0ZS1pcXIvbGliL2luZGV4LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYjNqcy8uL25vZGVfbW9kdWxlcy9jb21wdXRlLWlxci9saWIvaW5kZXguanM/MDBhOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbipcbipcdENPTVBVVEU6IGlxclxuKlxuKlxuKlx0REVTQ1JJUFRJT046XG4qXHRcdC0gQ29tcHV0ZXMgdGhlIGludGVycXVhcnRpbGUgcmFuZ2UgZm9yIGFuIGFycmF5IG9mIHZhbHVlcy5cbipcbipcbipcdE5PVEVTOlxuKlx0XHRbMV1cbipcbipcbipcdFRPRE86XG4qXHRcdFsxXVxuKlxuKlxuKlx0TElDRU5TRTpcbipcdFx0TUlUXG4qXG4qXHRDb3B5cmlnaHQgKGMpIDIwMTQuIEF0aGFuIFJlaW5lcy5cbipcbipcbipcdEFVVEhPUjpcbipcdFx0QXRoYW4gUmVpbmVzLiBrZ3J5dGVAZ21haWwuY29tLiAyMDE0LlxuKlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBNT0RVTEVTIC8vXG5cbnZhciBpc09iamVjdCA9IHJlcXVpcmUoICd2YWxpZGF0ZS5pby1vYmplY3QnICksXG5cdHF1YW50aWxlID0gcmVxdWlyZSggJ2NvbXB1dGUtcXVhbnRpbGUnICk7XG5cblxuLy8gRlVOQ1RJT05TIC8vXG5cbi8qKlxuKiBGVU5DVElPTjogYXNjZW5kaW5nKCBhLCBiIClcbipcdENvbXBhcmF0b3IgZnVuY3Rpb24gdXNlZCB0byBzb3J0IHZhbHVlcyBpbiBhc2NlbmRpbmcgb3JkZXIuXG4qXG4qIEBwcml2YXRlXG4qIEBwYXJhbSB7TnVtYmVyfSBhXG4qIEBwYXJhbSB7TnVtYmVyfSBiXG4qIEByZXR1cm5zIHtOdW1iZXJ9IGRpZmZlcmVuY2UgYmV0d2VlbiBgYWAgYW5kIGBiYFxuKi9cbmZ1bmN0aW9uIGFzY2VuZGluZyggYSwgYiApIHtcblx0cmV0dXJuIGEgLSBiO1xufSAvLyBlbmQgRlVOQ1RJT04gYXNjZW5kaW5nKClcblxuXG4vLyBJTlRFUlFVQVJUSUxFIFJBTkdFIC8vXG5cbi8qKlxuKiBGVU5DVElPTjogaXFyKCBhcnIgKVxuKlx0Q29tcHV0ZXMgdGhlIGludGVycXVhcnRpbGUgcmFuZ2UgZm9yIGFuIGFycmF5LlxuKlxuKiBAcGFyYW0ge0FycmF5fSBhcnIgLSBhcnJheSBvZiB2YWx1ZXNcbiogQHJldHVybnMge051bWJlcn0gaW50ZXJxdWFydGlsZSByYW5nZVxuKi9cbmZ1bmN0aW9uIGlxciggYXJyLCBvcHRzICkge1xuXHRpZiAoICFBcnJheS5pc0FycmF5KCBhcnIgKSApIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCAnaXFyKCk6OmludmFsaWQgaW5wdXQgYXJndW1lbnQuIE11c3QgcHJvdmlkZSBhbiBhcnJheS4nICk7XG5cdH1cblx0aWYgKCBhcmd1bWVudHMubGVuZ3RoID4gMSApIHtcblx0XHRpZiAoICFpc09iamVjdCggb3B0cyApICkge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvciggJ2lxcigpOjppbnZhbGlkIGlucHV0IGFyZ3VtZW50LiBPcHRpb25zIHNob3VsZCBiZSBhbiBvYmplY3QuJyApO1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRvcHRzID0ge1xuXHRcdFx0J3NvcnRlZCc6IGZhbHNlXG5cdFx0fTtcblx0fVxuXHRpZiAoICFvcHRzLnNvcnRlZCApIHtcblx0XHRhcnIgPSBhcnIuc2xpY2UoKTtcblx0XHRhcnIuc29ydCggYXNjZW5kaW5nICk7XG5cdFx0b3B0cy5zb3J0ZWQgPSB0cnVlO1xuXHR9XG5cdHJldHVybiBxdWFudGlsZSggYXJyLCAwLjc1LCBvcHRzICkgLSBxdWFudGlsZSggYXJyLCAwLjI1LCBvcHRzICk7XG59IC8vIGVuZCBGVU5DVElPTiBpcXIoKVxuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBpcXI7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/compute-iqr/lib/index.js\n")},"./node_modules/compute-quantile/lib/index.js":
/*!****************************************************!*\
  !*** ./node_modules/compute-quantile/lib/index.js ***!
  \****************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("/**\n*\n*\tCOMPUTE: quantile\n*\n*\n*\tDESCRIPTION:\n*\t\t- Computes a quantile for a numeric array.\n*\n*\n*\tNOTES:\n*\t\t[1]\n*\n*\n*\tTODO:\n*\t\t[1]\n*\n*\n*\tLICENSE:\n*\t\tMIT\n*\n*\tCopyright (c) 2014. Athan Reines.\n*\n*\n*\tAUTHOR:\n*\t\tAthan Reines. kgryte@gmail.com. 2014.\n*\n*/\n\n\n\n// MODULES //\n\nvar isObject = __webpack_require__( /*! validate.io-object */ \"./node_modules/validate.io-object/lib/index.js\" );\n\n\n// FUNCTIONS //\n\n/**\n* FUNCTION: ascending( a, b )\n*\tComparator function used to sort values in ascending order.\n*\n* @private\n* @param {Number} a\n* @param {Number} b\n* @returns {Number} difference between `a` and `b`\n*/\nfunction ascending( a, b ) {\n\treturn a - b;\n} // end FUNCTION ascending()\n\n\n// QUANTILE //\n\n/**\n* FUNCTION: quantile( arr, prob[, opts] )\n*\tComputes a quantile for a numeric array.\n*\n* @private\n* @param {Array} arr - 1d array\n* @param {Number} prob - quantile prob [0,1]\n* @param {Object} [opts] - method options:\n\t`method`: method used to interpolate a quantile value\n\t`sorted`: boolean flag indicating if the input array is sorted\n* @returns {Number} quantile value\n*/\nfunction quantile( arr, p, opts ) {\n\tif ( !Array.isArray( arr ) ) {\n\t\tthrow new TypeError( 'quantile()::invalid input argument. First argument must be an array.' );\n\t}\n\tif ( typeof p !== 'number' || p !== p ) {\n\t\tthrow new TypeError( 'quantile()::invalid input argument. Quantile probability must be numeric.' );\n\t}\n\tif ( p < 0 || p > 1 ) {\n\t\tthrow new TypeError( 'quantile()::invalid input argument. Quantile probability must be on the interval [0,1].' );\n\t}\n\tif ( arguments.length > 2 ) {\n\t\tif ( !isObject( opts ) ) {\n\t\t\tthrow new TypeError( 'quantile()::invalid input argument. Options must be an object.' );\n\t\t}\n\t\tif ( opts.hasOwnProperty( 'sorted' ) && typeof opts.sorted !== 'boolean' ) {\n\t\t\tthrow new TypeError( 'quantile()::invalid input argument. Sorted flag must be a boolean.' );\n\t\t}\n\t\tif ( opts.hasOwnProperty( 'method' ) && typeof opts.method !== 'string' ) {\n\t\t\tthrow new TypeError( 'quantile()::invalid input argument. Method must be a string.' );\n\t\t}\n\t\t// TODO: validate that the requested method is supported. list.indexOf( method )\n\t} else {\n\t\topts = {};\n\t}\n\tvar len = arr.length,\n\t\tid;\n\n\tif ( !opts.sorted ) {\n\t\tarr = arr.slice();\n\t\tarr.sort( ascending );\n\t}\n\n\t// Cases...\n\n\t// [0] 0th percentile is the minimum value...\n\tif ( p === 0.0 ) {\n\t\treturn arr[ 0 ];\n\t}\n\t// [1] 100th percentile is the maximum value...\n\tif ( p === 1.0 ) {\n\t\treturn arr[ len-1 ];\n\t}\n\t// Calculate the vector index marking the quantile:\n\tid = ( len*p ) - 1;\n\n\t// [2] Is the index an integer?\n\tif ( id === Math.floor( id ) ) {\n\t\t// Value is the average between the value at id and id+1:\n\t\treturn ( arr[ id ] + arr[ id+1 ] ) / 2.0;\n\t}\n\t// [3] Round up to the next index:\n\tid = Math.ceil( id );\n\treturn arr[ id ];\n} // end FUNCTION quantile()\n\n\n// EXPORTS //\n\nmodule.exports = quantile;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY29tcHV0ZS1xdWFudGlsZS9saWIvaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9iM2pzLy4vbm9kZV9tb2R1bGVzL2NvbXB1dGUtcXVhbnRpbGUvbGliL2luZGV4LmpzP2FhZjciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4qXG4qXHRDT01QVVRFOiBxdWFudGlsZVxuKlxuKlxuKlx0REVTQ1JJUFRJT046XG4qXHRcdC0gQ29tcHV0ZXMgYSBxdWFudGlsZSBmb3IgYSBudW1lcmljIGFycmF5LlxuKlxuKlxuKlx0Tk9URVM6XG4qXHRcdFsxXVxuKlxuKlxuKlx0VE9ETzpcbipcdFx0WzFdXG4qXG4qXG4qXHRMSUNFTlNFOlxuKlx0XHRNSVRcbipcbipcdENvcHlyaWdodCAoYykgMjAxNC4gQXRoYW4gUmVpbmVzLlxuKlxuKlxuKlx0QVVUSE9SOlxuKlx0XHRBdGhhbiBSZWluZXMuIGtncnl0ZUBnbWFpbC5jb20uIDIwMTQuXG4qXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIE1PRFVMRVMgLy9cblxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSggJ3ZhbGlkYXRlLmlvLW9iamVjdCcgKTtcblxuXG4vLyBGVU5DVElPTlMgLy9cblxuLyoqXG4qIEZVTkNUSU9OOiBhc2NlbmRpbmcoIGEsIGIgKVxuKlx0Q29tcGFyYXRvciBmdW5jdGlvbiB1c2VkIHRvIHNvcnQgdmFsdWVzIGluIGFzY2VuZGluZyBvcmRlci5cbipcbiogQHByaXZhdGVcbiogQHBhcmFtIHtOdW1iZXJ9IGFcbiogQHBhcmFtIHtOdW1iZXJ9IGJcbiogQHJldHVybnMge051bWJlcn0gZGlmZmVyZW5jZSBiZXR3ZWVuIGBhYCBhbmQgYGJgXG4qL1xuZnVuY3Rpb24gYXNjZW5kaW5nKCBhLCBiICkge1xuXHRyZXR1cm4gYSAtIGI7XG59IC8vIGVuZCBGVU5DVElPTiBhc2NlbmRpbmcoKVxuXG5cbi8vIFFVQU5USUxFIC8vXG5cbi8qKlxuKiBGVU5DVElPTjogcXVhbnRpbGUoIGFyciwgcHJvYlssIG9wdHNdIClcbipcdENvbXB1dGVzIGEgcXVhbnRpbGUgZm9yIGEgbnVtZXJpYyBhcnJheS5cbipcbiogQHByaXZhdGVcbiogQHBhcmFtIHtBcnJheX0gYXJyIC0gMWQgYXJyYXlcbiogQHBhcmFtIHtOdW1iZXJ9IHByb2IgLSBxdWFudGlsZSBwcm9iIFswLDFdXG4qIEBwYXJhbSB7T2JqZWN0fSBbb3B0c10gLSBtZXRob2Qgb3B0aW9uczpcblx0YG1ldGhvZGA6IG1ldGhvZCB1c2VkIHRvIGludGVycG9sYXRlIGEgcXVhbnRpbGUgdmFsdWVcblx0YHNvcnRlZGA6IGJvb2xlYW4gZmxhZyBpbmRpY2F0aW5nIGlmIHRoZSBpbnB1dCBhcnJheSBpcyBzb3J0ZWRcbiogQHJldHVybnMge051bWJlcn0gcXVhbnRpbGUgdmFsdWVcbiovXG5mdW5jdGlvbiBxdWFudGlsZSggYXJyLCBwLCBvcHRzICkge1xuXHRpZiAoICFBcnJheS5pc0FycmF5KCBhcnIgKSApIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCAncXVhbnRpbGUoKTo6aW52YWxpZCBpbnB1dCBhcmd1bWVudC4gRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhbiBhcnJheS4nICk7XG5cdH1cblx0aWYgKCB0eXBlb2YgcCAhPT0gJ251bWJlcicgfHwgcCAhPT0gcCApIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCAncXVhbnRpbGUoKTo6aW52YWxpZCBpbnB1dCBhcmd1bWVudC4gUXVhbnRpbGUgcHJvYmFiaWxpdHkgbXVzdCBiZSBudW1lcmljLicgKTtcblx0fVxuXHRpZiAoIHAgPCAwIHx8IHAgPiAxICkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoICdxdWFudGlsZSgpOjppbnZhbGlkIGlucHV0IGFyZ3VtZW50LiBRdWFudGlsZSBwcm9iYWJpbGl0eSBtdXN0IGJlIG9uIHRoZSBpbnRlcnZhbCBbMCwxXS4nICk7XG5cdH1cblx0aWYgKCBhcmd1bWVudHMubGVuZ3RoID4gMiApIHtcblx0XHRpZiAoICFpc09iamVjdCggb3B0cyApICkge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvciggJ3F1YW50aWxlKCk6OmludmFsaWQgaW5wdXQgYXJndW1lbnQuIE9wdGlvbnMgbXVzdCBiZSBhbiBvYmplY3QuJyApO1xuXHRcdH1cblx0XHRpZiAoIG9wdHMuaGFzT3duUHJvcGVydHkoICdzb3J0ZWQnICkgJiYgdHlwZW9mIG9wdHMuc29ydGVkICE9PSAnYm9vbGVhbicgKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCAncXVhbnRpbGUoKTo6aW52YWxpZCBpbnB1dCBhcmd1bWVudC4gU29ydGVkIGZsYWcgbXVzdCBiZSBhIGJvb2xlYW4uJyApO1xuXHRcdH1cblx0XHRpZiAoIG9wdHMuaGFzT3duUHJvcGVydHkoICdtZXRob2QnICkgJiYgdHlwZW9mIG9wdHMubWV0aG9kICE9PSAnc3RyaW5nJyApIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoICdxdWFudGlsZSgpOjppbnZhbGlkIGlucHV0IGFyZ3VtZW50LiBNZXRob2QgbXVzdCBiZSBhIHN0cmluZy4nICk7XG5cdFx0fVxuXHRcdC8vIFRPRE86IHZhbGlkYXRlIHRoYXQgdGhlIHJlcXVlc3RlZCBtZXRob2QgaXMgc3VwcG9ydGVkLiBsaXN0LmluZGV4T2YoIG1ldGhvZCApXG5cdH0gZWxzZSB7XG5cdFx0b3B0cyA9IHt9O1xuXHR9XG5cdHZhciBsZW4gPSBhcnIubGVuZ3RoLFxuXHRcdGlkO1xuXG5cdGlmICggIW9wdHMuc29ydGVkICkge1xuXHRcdGFyciA9IGFyci5zbGljZSgpO1xuXHRcdGFyci5zb3J0KCBhc2NlbmRpbmcgKTtcblx0fVxuXG5cdC8vIENhc2VzLi4uXG5cblx0Ly8gWzBdIDB0aCBwZXJjZW50aWxlIGlzIHRoZSBtaW5pbXVtIHZhbHVlLi4uXG5cdGlmICggcCA9PT0gMC4wICkge1xuXHRcdHJldHVybiBhcnJbIDAgXTtcblx0fVxuXHQvLyBbMV0gMTAwdGggcGVyY2VudGlsZSBpcyB0aGUgbWF4aW11bSB2YWx1ZS4uLlxuXHRpZiAoIHAgPT09IDEuMCApIHtcblx0XHRyZXR1cm4gYXJyWyBsZW4tMSBdO1xuXHR9XG5cdC8vIENhbGN1bGF0ZSB0aGUgdmVjdG9yIGluZGV4IG1hcmtpbmcgdGhlIHF1YW50aWxlOlxuXHRpZCA9ICggbGVuKnAgKSAtIDE7XG5cblx0Ly8gWzJdIElzIHRoZSBpbmRleCBhbiBpbnRlZ2VyP1xuXHRpZiAoIGlkID09PSBNYXRoLmZsb29yKCBpZCApICkge1xuXHRcdC8vIFZhbHVlIGlzIHRoZSBhdmVyYWdlIGJldHdlZW4gdGhlIHZhbHVlIGF0IGlkIGFuZCBpZCsxOlxuXHRcdHJldHVybiAoIGFyclsgaWQgXSArIGFyclsgaWQrMSBdICkgLyAyLjA7XG5cdH1cblx0Ly8gWzNdIFJvdW5kIHVwIHRvIHRoZSBuZXh0IGluZGV4OlxuXHRpZCA9IE1hdGguY2VpbCggaWQgKTtcblx0cmV0dXJuIGFyclsgaWQgXTtcbn0gLy8gZW5kIEZVTkNUSU9OIHF1YW50aWxlKClcblxuXG4vLyBFWFBPUlRTIC8vXG5cbm1vZHVsZS5leHBvcnRzID0gcXVhbnRpbGU7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/compute-quantile/lib/index.js\n")},"./node_modules/validate.io-array/lib/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/validate.io-array/lib/index.js ***!
  \*****************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\n\n/**\n* FUNCTION: isArray( value )\n*\tValidates if a value is an array.\n*\n* @param {*} value - value to be validated\n* @returns {Boolean} boolean indicating whether value is an array\n*/\nfunction isArray( value ) {\n\treturn Object.prototype.toString.call( value ) === '[object Array]';\n} // end FUNCTION isArray()\n\n// EXPORTS //\n\nmodule.exports = Array.isArray || isArray;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdmFsaWRhdGUuaW8tYXJyYXkvbGliL2luZGV4LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYjNqcy8uL25vZGVfbW9kdWxlcy92YWxpZGF0ZS5pby1hcnJheS9saWIvaW5kZXguanM/NjMzNyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKlxuKiBGVU5DVElPTjogaXNBcnJheSggdmFsdWUgKVxuKlx0VmFsaWRhdGVzIGlmIGEgdmFsdWUgaXMgYW4gYXJyYXkuXG4qXG4qIEBwYXJhbSB7Kn0gdmFsdWUgLSB2YWx1ZSB0byBiZSB2YWxpZGF0ZWRcbiogQHJldHVybnMge0Jvb2xlYW59IGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHZhbHVlIGlzIGFuIGFycmF5XG4qL1xuZnVuY3Rpb24gaXNBcnJheSggdmFsdWUgKSB7XG5cdHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoIHZhbHVlICkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59IC8vIGVuZCBGVU5DVElPTiBpc0FycmF5KClcblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgaXNBcnJheTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/validate.io-array/lib/index.js\n")},"./node_modules/validate.io-object/lib/index.js":
/*!******************************************************!*\
  !*** ./node_modules/validate.io-object/lib/index.js ***!
  \******************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\n\n// MODULES //\n\nvar isArray = __webpack_require__( /*! validate.io-array */ \"./node_modules/validate.io-array/lib/index.js\" );\n\n\n// ISOBJECT //\n\n/**\n* FUNCTION: isObject( value )\n*\tValidates if a value is a object; e.g., {}.\n*\n* @param {*} value - value to be validated\n* @returns {Boolean} boolean indicating whether value is a object\n*/\nfunction isObject( value ) {\n\treturn ( typeof value === 'object' && value !== null && !isArray( value ) );\n} // end FUNCTION isObject()\n\n\n// EXPORTS //\n\nmodule.exports = isObject;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdmFsaWRhdGUuaW8tb2JqZWN0L2xpYi9pbmRleC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2IzanMvLi9ub2RlX21vZHVsZXMvdmFsaWRhdGUuaW8tb2JqZWN0L2xpYi9pbmRleC5qcz8yMjlmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLy8gTU9EVUxFUyAvL1xuXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoICd2YWxpZGF0ZS5pby1hcnJheScgKTtcblxuXG4vLyBJU09CSkVDVCAvL1xuXG4vKipcbiogRlVOQ1RJT046IGlzT2JqZWN0KCB2YWx1ZSApXG4qXHRWYWxpZGF0ZXMgaWYgYSB2YWx1ZSBpcyBhIG9iamVjdDsgZS5nLiwge30uXG4qXG4qIEBwYXJhbSB7Kn0gdmFsdWUgLSB2YWx1ZSB0byBiZSB2YWxpZGF0ZWRcbiogQHJldHVybnMge0Jvb2xlYW59IGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHZhbHVlIGlzIGEgb2JqZWN0XG4qL1xuZnVuY3Rpb24gaXNPYmplY3QoIHZhbHVlICkge1xuXHRyZXR1cm4gKCB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsICYmICFpc0FycmF5KCB2YWx1ZSApICk7XG59IC8vIGVuZCBGVU5DVElPTiBpc09iamVjdCgpXG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/validate.io-object/lib/index.js\n")},"./src/Axes.js":
/*!*********************!*\
  !*** ./src/Axes.js ***!
  \*********************/
/*! exports provided: xaxis, yaxis */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "xaxis", function() { return xaxis; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "yaxis", function() { return yaxis; });\n/* harmony import */ var _Colours__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Colours */ "./src/Colours.js");\n// Copyright (C) 2013-2014, 2018 BrandsEye (PTY) LTD\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this\n// software and associated documentation files (the "Software"), to deal in the Software\n// without restriction, including without limitation the rights to use, copy, modify,\n//     merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following\n// conditions:\n//\n//     The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n//     INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n// CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n\nfunction xaxis(selection, height, width, axisObject) {\n    selection.select(".x-axis").remove();\n    let axis = selection.append("g")\n                        .attr("class", "x-axis")\n                        .attr("transform", "translate(0," + height + ")")\n                        .style("opacity", 0)\n                        .call(axisObject);\n\n    axis.select(".domain").remove();\n\n    let max = 0;\n    const fontSize = 12;\n    axis.selectAll("text")\n        .style("fill", _Colours__WEBPACK_IMPORTED_MODULE_0__["colours"].eighteen.darkGrey)\n        .nodes()\n        .forEach(text => max = Math.max(max, text.getBBox().width));\n\n    if (max >= width - 10) {\n        const bad = max >= width * 2;\n        const angle = bad ? -90 : -30;\n        const fontSize = width <= 13 ? 8 : 12;\n        const x = bad ? -fontSize : 0;\n        const y = bad ? 5 : 2;\n\n        axis.selectAll("text")\n            .style(\'text-anchor\', \'end\')\n            .style("font-size", fontSize + "px")\n            .attr("transform", () => "translate(" + x + "," + y + ") rotate(" + angle + " 0,0)")\n    }\n\n    axis\n        .transition()\n        .duration(1000)\n        .style("opacity", 1);\n\n    const axisHeight = axis.node().getBBox().height;\n    axis.attr("transform", "translate(0," + (height - axisHeight) + ")");\n    return axisHeight;\n}\n\nfunction yaxis(selection, axis) {\n    selection.select(".y-axis").remove();\n    let x = selection.append("g")\n                     .attr("class", "y-axis")\n                     .call(axis.tickSize(0).tickPadding(10))\n                     .style("opacity", 0)\n                     .transition()\n                     .duration(1000)\n                     .style("opacity", 1);\n\n    x.selectAll("text")\n     .style("fill", _Colours__WEBPACK_IMPORTED_MODULE_0__["colours"].eighteen.darkGrey);\n\n    const width = x.node().getBBox().width;\n    x.attr("transform", "translate(" + width + ",0)");\n\n    return width;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvQXhlcy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2IzanMvLi9zcmMvQXhlcy5qcz84ZTE3Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoQykgMjAxMy0yMDE0LCAyMDE4IEJyYW5kc0V5ZSAoUFRZKSBMVERcbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXNcbi8vIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZVxuLy8gd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LFxuLy8gICAgIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG9cbi8vIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nXG4vLyBjb25kaXRpb25zOlxuLy9cbi8vICAgICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbi8vIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gICAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1IgSU1QTElFRCxcbi8vICAgICBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQVxuLy8gUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxuLy8gSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GXG4vLyBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkVcbi8vIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5pbXBvcnQge2NvbG91cnN9IGZyb20gXCIuL0NvbG91cnNcIjtcblxuXG5leHBvcnQgZnVuY3Rpb24geGF4aXMoc2VsZWN0aW9uLCBoZWlnaHQsIHdpZHRoLCBheGlzT2JqZWN0KSB7XG4gICAgc2VsZWN0aW9uLnNlbGVjdChcIi54LWF4aXNcIikucmVtb3ZlKCk7XG4gICAgbGV0IGF4aXMgPSBzZWxlY3Rpb24uYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcIngtYXhpc1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoMCxcIiArIGhlaWdodCArIFwiKVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNhbGwoYXhpc09iamVjdCk7XG5cbiAgICBheGlzLnNlbGVjdChcIi5kb21haW5cIikucmVtb3ZlKCk7XG5cbiAgICBsZXQgbWF4ID0gMDtcbiAgICBjb25zdCBmb250U2l6ZSA9IDEyO1xuICAgIGF4aXMuc2VsZWN0QWxsKFwidGV4dFwiKVxuICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIGNvbG91cnMuZWlnaHRlZW4uZGFya0dyZXkpXG4gICAgICAgIC5ub2RlcygpXG4gICAgICAgIC5mb3JFYWNoKHRleHQgPT4gbWF4ID0gTWF0aC5tYXgobWF4LCB0ZXh0LmdldEJCb3goKS53aWR0aCkpO1xuXG4gICAgaWYgKG1heCA+PSB3aWR0aCAtIDEwKSB7XG4gICAgICAgIGNvbnN0IGJhZCA9IG1heCA+PSB3aWR0aCAqIDI7XG4gICAgICAgIGNvbnN0IGFuZ2xlID0gYmFkID8gLTkwIDogLTMwO1xuICAgICAgICBjb25zdCBmb250U2l6ZSA9IHdpZHRoIDw9IDEzID8gOCA6IDEyO1xuICAgICAgICBjb25zdCB4ID0gYmFkID8gLWZvbnRTaXplIDogMDtcbiAgICAgICAgY29uc3QgeSA9IGJhZCA/IDUgOiAyO1xuXG4gICAgICAgIGF4aXMuc2VsZWN0QWxsKFwidGV4dFwiKVxuICAgICAgICAgICAgLnN0eWxlKCd0ZXh0LWFuY2hvcicsICdlbmQnKVxuICAgICAgICAgICAgLnN0eWxlKFwiZm9udC1zaXplXCIsIGZvbnRTaXplICsgXCJweFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgKCkgPT4gXCJ0cmFuc2xhdGUoXCIgKyB4ICsgXCIsXCIgKyB5ICsgXCIpIHJvdGF0ZShcIiArIGFuZ2xlICsgXCIgMCwwKVwiKVxuICAgIH1cblxuICAgIGF4aXNcbiAgICAgICAgLnRyYW5zaXRpb24oKVxuICAgICAgICAuZHVyYXRpb24oMTAwMClcbiAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAxKTtcblxuICAgIGNvbnN0IGF4aXNIZWlnaHQgPSBheGlzLm5vZGUoKS5nZXRCQm94KCkuaGVpZ2h0O1xuICAgIGF4aXMuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZSgwLFwiICsgKGhlaWdodCAtIGF4aXNIZWlnaHQpICsgXCIpXCIpO1xuICAgIHJldHVybiBheGlzSGVpZ2h0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24geWF4aXMoc2VsZWN0aW9uLCBheGlzKSB7XG4gICAgc2VsZWN0aW9uLnNlbGVjdChcIi55LWF4aXNcIikucmVtb3ZlKCk7XG4gICAgbGV0IHggPSBzZWxlY3Rpb24uYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcInktYXhpc1wiKVxuICAgICAgICAgICAgICAgICAgICAgLmNhbGwoYXhpcy50aWNrU2l6ZSgwKS50aWNrUGFkZGluZygxMCkpXG4gICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDApXG4gICAgICAgICAgICAgICAgICAgICAudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24oMTAwMClcbiAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMSk7XG5cbiAgICB4LnNlbGVjdEFsbChcInRleHRcIilcbiAgICAgLnN0eWxlKFwiZmlsbFwiLCBjb2xvdXJzLmVpZ2h0ZWVuLmRhcmtHcmV5KTtcblxuICAgIGNvbnN0IHdpZHRoID0geC5ub2RlKCkuZ2V0QkJveCgpLndpZHRoO1xuICAgIHguYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIHdpZHRoICsgXCIsMClcIik7XG5cbiAgICByZXR1cm4gd2lkdGg7XG59Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/Axes.js\n')},"./src/BarChart.js":
/*!*************************!*\
  !*** ./src/BarChart.js ***!
  \*************************/
/*! exports provided: BarChart */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BarChart", function() { return BarChart; });\n/* harmony import */ var _Colours__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Colours */ "./src/Colours.js");\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers */ "./src/helpers.js");\n/* harmony import */ var _Chart__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Chart */ "./src/Chart.js");\n// Copyright (C) 2013-2014, 2018 BrandsEye (PTY) LTD\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this\n// software and associated documentation files (the "Software"), to deal in the Software\n// without restriction, including without limitation the rights to use, copy, modify,\n//     merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following\n// conditions:\n//\n//     The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n//     INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n// CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n\n\n\n\nclass BarChart extends _Chart__WEBPACK_IMPORTED_MODULE_2__["Chart"] {\n\n    //------------------------------------------------------\n\n    data(data) {\n        if (!arguments.length) return this._data;\n        if (data && data[0].key === undefined) {\n            data = [\n                {\n                    key: "series 1",\n                    values: data\n                }\n            ];\n        }\n        this._data = data;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    element(element) {\n        if (!arguments.length) return this._element;\n        this._element = element;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    showLabels(show) {\n        if (!arguments.length) return this._show_labels;\n        this._show_labels = show;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    // todo dispatch\n    showLegend(show) {\n        if (!arguments.length) return this._show_legend;\n        this._show_legend = show;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    x(x) {\n        if (!arguments.length) return this._x;\n        this._x = x;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    y(y) {\n        if (!arguments.length) return this._y;\n        this._y = y;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    width(width) {\n        if (!arguments.length) return this._width;\n        this._width = width;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    height(height) {\n        if (!arguments.length) return this._height;\n        this._height = height;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    colours(colours) {\n        if (!arguments.length) return this._colours;\n        this._colours = colours;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    backgroundColour(colour) {\n        if (!arguments.length) return this._backgroundColour;\n        this._backgroundColour = colour || "#FFF"; // never set it to null.\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    tickFormat(format) {\n        if (!arguments.length) return this._tickFormat;\n        this._tickFormat = format;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    xAxisTickFormat(format) {\n        if (!arguments.length) return this._xAxisTickFormat;\n        this._xAxisTickFormat = format || (d => d.toString());\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    labelFormat(format) {\n        if (!arguments.length) return this._labelFormat;\n        this._labelFormat = format || (d => d.toString());\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    // todo missing\n    labelCompression(compression) {\n        if (!arguments.length) return this._compression;\n        this._compression = compression;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    //todo missing\n    dataAxisLabel(label) {\n        if (!arguments.length) return this._dataAxisLabel;\n        this._dataAxisLabel = label;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    tooltip(tooltip) {\n        if (!arguments.length) return this._tooltip;\n        this._tooltip = tooltip;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    forceY(force) {\n        if (!arguments.length) return this._forceY;\n        this._forceY = force;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n// todo missing\n    duration(duration) {\n        if (!arguments.length) return this._duration;\n        this._duration = duration;\n        return this;\n    }\n\n// todo missing\n    coarseness(coarseness) {\n        if (!arguments.length) return this._coarseness;\n        this._coarseness = coarseness;\n        return this;\n    }\n\n    // todo missing\n    padding(padding) {\n        if (!arguments.length) return this._padding;\n        this._padding = padding;\n        return this;\n    }\n\n    // todo missing\n    xAxisTooltips(tooltips) {\n        if (!arguments.length) return this._xAxisTooltips;\n        this._xAxisTooltips = tooltips;\n        return this;\n    }\n\n    xAxisOverride(override) {\n        if (!arguments.length) return this._xAxisOverride;\n        this._xAxisOverride = override;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    dispatch() {\n        return this._dispatch;\n    }\n\n    //------------------------------------------------------\n\n    render() {\n        if (!this._element) throw new Error("No element set for ColumnChart. See #element()");\n        if (!this._data) {\n            console.warn("No data set for ColumnChart. See #data()");\n            return;\n        }\n\n        const data = this.getTransformedData();\n        const keys = this.getKeys();\n\n        //------------------------------------------------\n        // Set up the SVG area\n\n        let topLevel = d3.select(this._element).select("svg");\n        if (topLevel.empty()) topLevel = d3.select(this._element).append("svg")\n\n        topLevel\n            .style("width", this._width + "px")\n            .style("height", this._height + "px");\n\n\n        // ---------------------------------\n        // Measure max data axis text length\n\n        const dataAxisBB = Object(_helpers__WEBPACK_IMPORTED_MODULE_1__["maxBounding"])(topLevel, data.map(d => this._xAxisTickFormat(d.key)));\n\n        // ---------------------------------\n        // Layout the showLegend.\n        //\n        // We do this now because we need to know how much space the legend\n        // takes up in order to finish calculating the margins.\n\n        const legendHeight = this.renderLegend();\n\n        //----------------------------------\n        // Calculate margins.\n\n        const margin = {top: 20, right: 20, bottom: 40, left: 10};\n        margin.bottom += legendHeight ? legendHeight + 20 : 0;\n        margin.left += dataAxisBB.width + 10;\n        if (this._dataAxisLabel) margin.bottom += 10 + 12;\n\n        const width = this._width - margin.left - margin.right,\n              height = this._height - margin.top - margin.bottom;\n\n        //----------------------------------\n        // Calculate scales and so on.\n\n        const x = d3.scaleLinear()\n            .rangeRound([0, width])\n            .nice();\n\n        const y = d3.scaleBand()\n            .rangeRound([0, height])\n            .padding(this._data.length > 1 ? 0.08 : 0.1);\n\n        const yGroup = d3.scaleBand()\n            .padding(0);\n\n        this._xscale = x;\n        this._ygroupscale = yGroup;\n        this._yscale = y;\n\n        // Scale the range of the data in the domains\n        y.domain(data.map(d => d.key));\n        yGroup.rangeRound([0, y.bandwidth()]).domain(keys);\n        x.domain([0, d3.max(data, d => d3.max(d.data, d => d._y))]);\n\n        //------------------------------\n\n        let svg = topLevel.select(\'.main-group\');\n\n        if (svg.empty()) {\n            svg = topLevel\n                .append("g")\n                .attr("class", "main-group")\n        }\n\n        svg.attr("transform", "translate(" + margin.left + "," + margin.top + ")");\n\n        //---------------------------------\n        // Get rid of current labels.\n        svg.select(".chart-labels")\n            .remove();\n\n        //---------------------------------\n        // append the rectangles for the bar chart\n        let groups = svg.select(".bars").selectAll(\'.group\');\n\n        if (groups.empty()) {\n            groups = svg\n                .append("g")\n                .attr("class", "bars")\n                .selectAll(".group");\n        }\n\n        groups = groups.data(data);\n\n        groups.exit().remove();\n\n        // Adding new groups, and hence adding new bars to those groups.\n        groups.enter()\n            .append("g")\n                .attr("class", "group")\n                .attr("transform", d => "translate(0," + y(d.key) + ")")\n                .attr("height", height - y.bandwidth())\n                .attr("width", "100%")\n            .merge(groups)\n            .interrupt("groups:move")\n            .transition("groups:move")\n                .attr("transform", d => "translate(0," + y(d.key) + ")")\n                .attr("height", y.bandwidth())\n            .each((s_d, s_i, nodes) => {\n                let group = d3.select(nodes[s_i]);\n\n                let bars = group.selectAll(".bar")\n                    .data(s_d.data);\n\n                bars.exit().remove();\n\n                bars.interrupt("bar:move")     // Animate the bars to their new position.\n                    .transition("bar:move")\n                        .attr("height", yGroup.bandwidth())\n                        .attr("y", d => yGroup(d._key))\n                        .attr("x", 0);\n\n                bars.enter()\n                    .append("rect")\n                        .attr("class", (d, i) => "bar series series-" + i)\n                        .attr("y", d => yGroup(d._key))\n                        .attr("x", 0)\n                        .attr("height", yGroup.bandwidth())\n                        .attr("width", 0)\n                        .style("fill", (d, i) => this.getSeriesColour(i))\n                        .style("cursor", "pointer")\n                    .on("mouseover", (d, i, nodes) => { // Darken the bar on mouse over\n                        d3.select(nodes[i])\n                            .interrupt("hover:colour")\n                            .transition("hover:colour")\n                            .duration(400)\n                            .style("fill", d3.hcl(this.getSeriesColour(i)).darker())\n                        this._dispatch.call("tooltipShow", this, {\n                            e: d3.event,\n                            point: d,\n                            series: s_d,\n                            seriesIndex: s_i,\n                            value: d._y\n                        })\n                    })\n                    .on("mouseout", (d, i, nodes) => { // bar is regular colour on mouse out.\n                        d3.select(nodes[i])\n                            .interrupt("hover:colour")\n                            .transition("hover:colour")\n                            .duration(400)\n                            .style("fill", this.getSeriesColour(i));\n                        this._dispatch.call("tooltipHide", this);\n                    })\n                    .on("click auxclick", (d, i, nodes) => {\n                        this._dispatch.call("elementClick", this, {\n                            e: d3.event,\n                            point: d,\n                            series: d._series,\n                            seriesIndex: s_i,\n                            value: this._y(d)\n                        })\n                    })\n                    .merge(bars)\n                    .interrupt("bar:growth")    // Animate bars growing.\n                    .transition("bar:growth")\n                    .delay(() => {\n                        return this.calcBarGrowth(s_i, nodes.length);\n                    })\n                    .duration(this._duration)\n                        .style("fill", (d, i) => this.getSeriesColour(i))\n                        .attr("width", d => x(d._y));\n\n            });\n\n        // ---------------------------------\n        // Labels loaded after our first bar grows.\n        if (this._show_labels) {\n            svg.transition("bar:growth")\n                .on("end", (d, i, nodes) => {\n                    if (i < nodes.length - 1) return;\n                    this.renderLabels(svg, data, x, yGroup, y);\n                })\n        }\n\n        // ---------------------------------\n        // Draw the data axis data label.\n\n        if (this._dataAxisLabel) {\n            this.renderDataAxisLabel(width, margin);\n        }\n\n        // ---------------------------------\n        // Set the background colour\n\n        d3.select(this._element).select(".background").remove();\n        if (this._backgroundColour) {\n            d3.select(this._element).select("svg")\n                .append("rect")\n                    .attr("class", "background")\n                    .attr("width", "100%")\n                    .attr("height", "100%")\n                    .style("fill", this._backgroundColour)\n                .lower();\n        }\n\n        //---------------------------------\n        // add the Y gridlines\n        svg.call(this.grid, height, d3.axisBottom(x).ticks(5));\n\n        //---------------------------------\n        // axes\n        svg.call(this.labelAxis, d3.axisLeft(y).tickSize(0).tickPadding(5).tickFormat(this._xAxisTickFormat));\n        svg.call(this.dataAxis, height, d3.axisBottom(x).ticks(5).tickFormat(this._tickFormat));\n    }\n\n    //------------------------------------------------------\n\n    /*\n     * Returns an object with two functions, #show() and #hide(),\n     * to show and hide the labels.\n     */\n    labels() {\n        return {\n\n            show: () => {\n                if (this._element) {\n                    let selection = this._element,\n                        data = this.getTransformedData(),\n                        xscale = this._xscale,\n                        ygroup = this._ygroupscale,\n                        yscale = this._yscale;\n\n                    if (selection) selection = d3.select(this._element).select("svg").select("g");\n                    if (!selection.empty() && data && xscale && yscale && ygroup) {\n                        let labels = selection.select(\'.chart-labels\');\n                        if (!labels.empty()) return;\n                        labels.remove()\n                        this.renderLabels(selection, data, xscale, ygroup, yscale, false);\n                    }\n                }\n\n            },\n\n            hide: () => {\n                if (this._element) {\n                    d3.select(this._element)\n                        .select(\'.chart-labels\')\n                        .interrupt("labels")\n                        .interrupt("labels:fade")\n                        .transition("labels:fade")\n                        .style("opacity", 0)\n                        .on("end", (d, i, nodes) => {\n                            d3.select(nodes[i]).remove();\n                        })\n                }\n            }\n        }\n    }\n\n    //------------------------------------------------------\n\n    renderLabels(selection, data, xscale, ygroup, yscale, animate) {\n        animate = animate === undefined ? true : animate;\n        selection.selectAll(".chart-labels").remove();\n\n        let labels = selection.append("g")\n            .attr("class", "chart-labels")\n            .selectAll(".label-group")\n            .data(data);\n\n        let fontSize = 12;    // Our initial font size.\n        const buffer = 5;     // Buffer space between words and the top of a bar.\n\n        labels.enter().each((series, s_i, s_nodes) => {\n            let group = d3.select(s_nodes[s_i])\n                .append("g")\n                .attr("class", "label-group")\n                .attr("transform", d => "translate(0," + yscale(d.key) + ")")\n                .selectAll(".chart-label")\n                .data(series.data)\n                .enter()\n                .each((d, i, nodes) => {\n\n                    // Want to figure out if the label is too dark / light for the\n                    // bar.\n                    let invertedColor = d3.hcl(this.getSeriesColour(i));\n                    invertedColor.l += Math.min(invertedColor.l + 50, 100);\n                    let invert = d3.hcl(this.getSeriesColour(i)).l < 60;\n\n                    let xpos = xscale(d._y);\n\n                    let text = d3.select(nodes[i])\n                        .append("text")\n                        .text(this._labelFormat(d._y))\n                            .attr("class", "chart-label")\n                            .attr("x", xpos + buffer)\n                            .attr("dx", animate ? -15 : 0)\n                            .style("opacity", 0)\n                            .style("pointer-events", "none")\n                            .style("font-size", fontSize + "px");\n\n\n                    const bb = text.node().getBBox();\n                    const oversize = xpos + bb.width + buffer > xscale.range()[1];\n\n                    text\n                        .attr("y", ygroup(d._key) + fontSize / 2 + ygroup.bandwidth() / 2)\n                        .attr("x", oversize ? xpos - buffer - bb.width : xpos + buffer)\n                        .style("fill", oversize && invert ? invertedColor.toString() : _Colours__WEBPACK_IMPORTED_MODULE_0__["colours"].eighteen.darkGrey);\n\n                    text\n                        .transition("labels")\n                        .delay(() => animate ? this.calcBarGrowth(s_i, s_nodes.length) : 0) // Delay in lockstep with bar growth.\n                        .duration(this._duration)\n                        .attr("dx", 0)\n                        .style("opacity", 1)\n                })\n        });\n\n    }\n\n    //------------------------------------------------------\n\n    renderDataAxisLabel(width, margins) {\n        let svg = d3.select(this._element).select(\'svg\');\n        svg.selectAll(".data-labels").remove();\n\n        if (!this._dataAxisLabel) return;\n        let text = this._dataAxisLabel;\n        if (text.long) text = text.long;\n\n        let x = (margins.left + width / 2);\n\n        let label = svg.append("g")\n            .attr("class", "data-labels")\n            .append("text")\n            .text(text)\n            .attr("transform", "translate(" + x + "," + (this._height - margins.bottom + 50) + ")")\n            .style("fill", _Colours__WEBPACK_IMPORTED_MODULE_0__["colours"].eighteen.darkGrey);\n\n        let textWidth = label.node().getBBox().width;\n        if (textWidth >= width && this._dataAxisLabel.short) {\n            label.text(this._dataAxisLabel.short);\n            textWidth = label.node().getBBox().width;\n        }\n\n        label.attr("dx", -textWidth / 2);\n    }\n\n    //------------------------------------------------------\n\n\n\n    grid(selection, height, axis) {\n        selection.select(".grid").remove();\n\n        let grid = selection.append("g")\n            .attr("class", "grid")\n            .call(axis\n                .tickSize(height)\n                .tickFormat("")\n            );\n\n        grid.selectAll("line")\n            .style("stroke", _Colours__WEBPACK_IMPORTED_MODULE_0__["colours"].eighteen.lightGrey);\n        grid.selectAll(".domain").remove();\n\n        grid\n            .lower() // Always ensure that this is earlier in the dom. Things must be drawn on top of it.\n            .style("opacity", 0)\n            .transition()\n            .delay(500)\n            .duration(500)\n            .style("opacity", 1);\n    }\n\n    //------------------------------------------------------\n\n    labelAxis(selection, axis_object) {\n        selection.select(".label-axis").remove();\n        let axis = selection.append("g")\n            .attr("class", "label-axis")\n            .style("opacity", 0)\n            .call(axis_object);\n\n        axis.select(".domain").remove();\n\n        let max = 0;\n        const fontSize = 12;\n        axis.selectAll("text")\n            .style("fill", _Colours__WEBPACK_IMPORTED_MODULE_0__["colours"].eighteen.darkGrey)\n            .nodes()\n            .forEach(text => max = Math.max(max, text.getBBox().width));\n\n        axis\n            .transition()\n            .duration(1000)\n            .style("opacity", 1);\n    }\n\n    //------------------------------------------------------\n\n    dataAxis(selection, height, axis_object) {\n        selection.select(".data-axis").remove();\n        let axis = selection.append("g")\n                .attr("class", "data-axis")\n                .attr("transform", "translate(0," + height + ")")\n            .call(axis_object.tickSize(0).tickPadding(10))\n                .style("opacity", 0)\n            .transition()\n            .duration(1000)\n                .style("opacity", 1);\n\n        axis.selectAll("text")\n                .style("fill", _Colours__WEBPACK_IMPORTED_MODULE_0__["colours"].eighteen.darkGrey)\n    }\n\n    //------------------------------------------------------\n\n    calcBarGrowth(i, max) {\n        if (max < 10) return i * this._BAR_GROWTH / 2;\n        if (max < 35) return i * this._BAR_GROWTH / 4;\n        return 1;\n    }\n\n    getSeriesColour(i) {\n        if (i < 0 || !this._colours) return _Colours__WEBPACK_IMPORTED_MODULE_0__["colours"].eighteen.midGrey;\n\n        i = i % this._colours.length;\n        return this._colours[i];\n    }\n\n    getSortedData() {\n        let data = this._data;\n        if (!data || !data.length) return [];\n\n        data = this._data.sort((lhs, rhs) => {\n            lhs = lhs.key.toLowerCase();\n            rhs = rhs.key.toLowerCase();\n\n            if (lhs === rhs) return 0;\n            if (lhs < rhs) return -1;\n            return 1;\n        });\n\n        return data;\n    }\n\n    getTransformedData() {\n        let data = this.getSortedData();\n        if (!data || !data.length) return [];\n\n        let results = [];\n\n        const getX = d => this._xAxisOverride ? this._xAxisOverride[this._x(d)] : this._x(d);\n\n        data.forEach((series, s_i) => {\n            series.values.forEach((d, d_i) => {\n                let field = results.find(bucket => bucket.key === getX(d));\n                if (!field) {\n                    field = {\n                        data: [],\n                        key: getX(d)\n                    };\n                    results.push(field);\n                }\n\n                field.data.push(Object.assign({\n                    _series: series,\n                    _s_i: s_i,\n                    _key: series.key,\n                    _y: this._y(d)\n                }, d));\n            })\n        });\n\n        return results;\n    }\n\n    getKeys() {\n        let data = this._data;\n        if (!data || !data.length) return [];\n\n        return [...new Set(data.map(d => d.key))]\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvQmFyQ2hhcnQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9iM2pzLy4vc3JjL0JhckNoYXJ0LmpzPzNjODUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChDKSAyMDEzLTIwMTQsIDIwMTggQnJhbmRzRXllIChQVFkpIExURFxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpc1xuLy8gc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlXG4vLyB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksXG4vLyAgICAgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0b1xuLy8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcbi8vIGNvbmRpdGlvbnM6XG4vL1xuLy8gICAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuLy8gY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyAgICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUiBJTVBMSUVELFxuLy8gICAgIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBXG4vLyBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUXG4vLyBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0Zcbi8vIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRVxuLy8gT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cblxuaW1wb3J0IHsgY29sb3VycyB9IGZyb20gJy4vQ29sb3Vycyc7XG5pbXBvcnQgeyBtYXhCb3VuZGluZyB9IGZyb20gXCIuL2hlbHBlcnNcIjtcbmltcG9ydCB7IENoYXJ0IH0gZnJvbSBcIi4vQ2hhcnRcIjtcblxuXG5leHBvcnQgY2xhc3MgQmFyQ2hhcnQgZXh0ZW5kcyBDaGFydCB7XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgZGF0YShkYXRhKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX2RhdGE7XG4gICAgICAgIGlmIChkYXRhICYmIGRhdGFbMF0ua2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRhdGEgPSBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBrZXk6IFwic2VyaWVzIDFcIixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzOiBkYXRhXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGVsZW1lbnQoZWxlbWVudCkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9lbGVtZW50O1xuICAgICAgICB0aGlzLl9lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHNob3dMYWJlbHMoc2hvdykge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9zaG93X2xhYmVscztcbiAgICAgICAgdGhpcy5fc2hvd19sYWJlbHMgPSBzaG93O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLy8gdG9kbyBkaXNwYXRjaFxuICAgIHNob3dMZWdlbmQoc2hvdykge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9zaG93X2xlZ2VuZDtcbiAgICAgICAgdGhpcy5fc2hvd19sZWdlbmQgPSBzaG93O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgeCh4KSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3g7XG4gICAgICAgIHRoaXMuX3ggPSB4O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgeSh5KSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3k7XG4gICAgICAgIHRoaXMuX3kgPSB5O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgd2lkdGgod2lkdGgpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fd2lkdGg7XG4gICAgICAgIHRoaXMuX3dpZHRoID0gd2lkdGg7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBoZWlnaHQoaGVpZ2h0KSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX2hlaWdodDtcbiAgICAgICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgY29sb3Vycyhjb2xvdXJzKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX2NvbG91cnM7XG4gICAgICAgIHRoaXMuX2NvbG91cnMgPSBjb2xvdXJzO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgYmFja2dyb3VuZENvbG91cihjb2xvdXIpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fYmFja2dyb3VuZENvbG91cjtcbiAgICAgICAgdGhpcy5fYmFja2dyb3VuZENvbG91ciA9IGNvbG91ciB8fCBcIiNGRkZcIjsgLy8gbmV2ZXIgc2V0IGl0IHRvIG51bGwuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB0aWNrRm9ybWF0KGZvcm1hdCkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl90aWNrRm9ybWF0O1xuICAgICAgICB0aGlzLl90aWNrRm9ybWF0ID0gZm9ybWF0O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgeEF4aXNUaWNrRm9ybWF0KGZvcm1hdCkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl94QXhpc1RpY2tGb3JtYXQ7XG4gICAgICAgIHRoaXMuX3hBeGlzVGlja0Zvcm1hdCA9IGZvcm1hdCB8fCAoZCA9PiBkLnRvU3RyaW5nKCkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgbGFiZWxGb3JtYXQoZm9ybWF0KSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX2xhYmVsRm9ybWF0O1xuICAgICAgICB0aGlzLl9sYWJlbEZvcm1hdCA9IGZvcm1hdCB8fCAoZCA9PiBkLnRvU3RyaW5nKCkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLy8gdG9kbyBtaXNzaW5nXG4gICAgbGFiZWxDb21wcmVzc2lvbihjb21wcmVzc2lvbikge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9jb21wcmVzc2lvbjtcbiAgICAgICAgdGhpcy5fY29tcHJlc3Npb24gPSBjb21wcmVzc2lvbjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8vdG9kbyBtaXNzaW5nXG4gICAgZGF0YUF4aXNMYWJlbChsYWJlbCkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9kYXRhQXhpc0xhYmVsO1xuICAgICAgICB0aGlzLl9kYXRhQXhpc0xhYmVsID0gbGFiZWw7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB0b29sdGlwKHRvb2x0aXApIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fdG9vbHRpcDtcbiAgICAgICAgdGhpcy5fdG9vbHRpcCA9IHRvb2x0aXA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBmb3JjZVkoZm9yY2UpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fZm9yY2VZO1xuICAgICAgICB0aGlzLl9mb3JjZVkgPSBmb3JjZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLy8gdG9kbyBtaXNzaW5nXG4gICAgZHVyYXRpb24oZHVyYXRpb24pIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fZHVyYXRpb247XG4gICAgICAgIHRoaXMuX2R1cmF0aW9uID0gZHVyYXRpb247XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuLy8gdG9kbyBtaXNzaW5nXG4gICAgY29hcnNlbmVzcyhjb2Fyc2VuZXNzKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX2NvYXJzZW5lc3M7XG4gICAgICAgIHRoaXMuX2NvYXJzZW5lc3MgPSBjb2Fyc2VuZXNzO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyB0b2RvIG1pc3NpbmdcbiAgICBwYWRkaW5nKHBhZGRpbmcpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fcGFkZGluZztcbiAgICAgICAgdGhpcy5fcGFkZGluZyA9IHBhZGRpbmc7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIHRvZG8gbWlzc2luZ1xuICAgIHhBeGlzVG9vbHRpcHModG9vbHRpcHMpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5feEF4aXNUb29sdGlwcztcbiAgICAgICAgdGhpcy5feEF4aXNUb29sdGlwcyA9IHRvb2x0aXBzO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB4QXhpc092ZXJyaWRlKG92ZXJyaWRlKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3hBeGlzT3ZlcnJpZGU7XG4gICAgICAgIHRoaXMuX3hBeGlzT3ZlcnJpZGUgPSBvdmVycmlkZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGRpc3BhdGNoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGlzcGF0Y2g7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9lbGVtZW50KSB0aHJvdyBuZXcgRXJyb3IoXCJObyBlbGVtZW50IHNldCBmb3IgQ29sdW1uQ2hhcnQuIFNlZSAjZWxlbWVudCgpXCIpO1xuICAgICAgICBpZiAoIXRoaXMuX2RhdGEpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIk5vIGRhdGEgc2V0IGZvciBDb2x1bW5DaGFydC4gU2VlICNkYXRhKClcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5nZXRUcmFuc2Zvcm1lZERhdGEoKTtcbiAgICAgICAgY29uc3Qga2V5cyA9IHRoaXMuZ2V0S2V5cygpO1xuXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIFNldCB1cCB0aGUgU1ZHIGFyZWFcblxuICAgICAgICBsZXQgdG9wTGV2ZWwgPSBkMy5zZWxlY3QodGhpcy5fZWxlbWVudCkuc2VsZWN0KFwic3ZnXCIpO1xuICAgICAgICBpZiAodG9wTGV2ZWwuZW1wdHkoKSkgdG9wTGV2ZWwgPSBkMy5zZWxlY3QodGhpcy5fZWxlbWVudCkuYXBwZW5kKFwic3ZnXCIpXG5cbiAgICAgICAgdG9wTGV2ZWxcbiAgICAgICAgICAgIC5zdHlsZShcIndpZHRoXCIsIHRoaXMuX3dpZHRoICsgXCJweFwiKVxuICAgICAgICAgICAgLnN0eWxlKFwiaGVpZ2h0XCIsIHRoaXMuX2hlaWdodCArIFwicHhcIik7XG5cblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gTWVhc3VyZSBtYXggZGF0YSBheGlzIHRleHQgbGVuZ3RoXG5cbiAgICAgICAgY29uc3QgZGF0YUF4aXNCQiA9IG1heEJvdW5kaW5nKHRvcExldmVsLCBkYXRhLm1hcChkID0+IHRoaXMuX3hBeGlzVGlja0Zvcm1hdChkLmtleSkpKTtcblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gTGF5b3V0IHRoZSBzaG93TGVnZW5kLlxuICAgICAgICAvL1xuICAgICAgICAvLyBXZSBkbyB0aGlzIG5vdyBiZWNhdXNlIHdlIG5lZWQgdG8ga25vdyBob3cgbXVjaCBzcGFjZSB0aGUgbGVnZW5kXG4gICAgICAgIC8vIHRha2VzIHVwIGluIG9yZGVyIHRvIGZpbmlzaCBjYWxjdWxhdGluZyB0aGUgbWFyZ2lucy5cblxuICAgICAgICBjb25zdCBsZWdlbmRIZWlnaHQgPSB0aGlzLnJlbmRlckxlZ2VuZCgpO1xuXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBDYWxjdWxhdGUgbWFyZ2lucy5cblxuICAgICAgICBjb25zdCBtYXJnaW4gPSB7dG9wOiAyMCwgcmlnaHQ6IDIwLCBib3R0b206IDQwLCBsZWZ0OiAxMH07XG4gICAgICAgIG1hcmdpbi5ib3R0b20gKz0gbGVnZW5kSGVpZ2h0ID8gbGVnZW5kSGVpZ2h0ICsgMjAgOiAwO1xuICAgICAgICBtYXJnaW4ubGVmdCArPSBkYXRhQXhpc0JCLndpZHRoICsgMTA7XG4gICAgICAgIGlmICh0aGlzLl9kYXRhQXhpc0xhYmVsKSBtYXJnaW4uYm90dG9tICs9IDEwICsgMTI7XG5cbiAgICAgICAgY29uc3Qgd2lkdGggPSB0aGlzLl93aWR0aCAtIG1hcmdpbi5sZWZ0IC0gbWFyZ2luLnJpZ2h0LFxuICAgICAgICAgICAgICBoZWlnaHQgPSB0aGlzLl9oZWlnaHQgLSBtYXJnaW4udG9wIC0gbWFyZ2luLmJvdHRvbTtcblxuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHNjYWxlcyBhbmQgc28gb24uXG5cbiAgICAgICAgY29uc3QgeCA9IGQzLnNjYWxlTGluZWFyKClcbiAgICAgICAgICAgIC5yYW5nZVJvdW5kKFswLCB3aWR0aF0pXG4gICAgICAgICAgICAubmljZSgpO1xuXG4gICAgICAgIGNvbnN0IHkgPSBkMy5zY2FsZUJhbmQoKVxuICAgICAgICAgICAgLnJhbmdlUm91bmQoWzAsIGhlaWdodF0pXG4gICAgICAgICAgICAucGFkZGluZyh0aGlzLl9kYXRhLmxlbmd0aCA+IDEgPyAwLjA4IDogMC4xKTtcblxuICAgICAgICBjb25zdCB5R3JvdXAgPSBkMy5zY2FsZUJhbmQoKVxuICAgICAgICAgICAgLnBhZGRpbmcoMCk7XG5cbiAgICAgICAgdGhpcy5feHNjYWxlID0geDtcbiAgICAgICAgdGhpcy5feWdyb3Vwc2NhbGUgPSB5R3JvdXA7XG4gICAgICAgIHRoaXMuX3lzY2FsZSA9IHk7XG5cbiAgICAgICAgLy8gU2NhbGUgdGhlIHJhbmdlIG9mIHRoZSBkYXRhIGluIHRoZSBkb21haW5zXG4gICAgICAgIHkuZG9tYWluKGRhdGEubWFwKGQgPT4gZC5rZXkpKTtcbiAgICAgICAgeUdyb3VwLnJhbmdlUm91bmQoWzAsIHkuYmFuZHdpZHRoKCldKS5kb21haW4oa2V5cyk7XG4gICAgICAgIHguZG9tYWluKFswLCBkMy5tYXgoZGF0YSwgZCA9PiBkMy5tYXgoZC5kYXRhLCBkID0+IGQuX3kpKV0pO1xuXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgbGV0IHN2ZyA9IHRvcExldmVsLnNlbGVjdCgnLm1haW4tZ3JvdXAnKTtcblxuICAgICAgICBpZiAoc3ZnLmVtcHR5KCkpIHtcbiAgICAgICAgICAgIHN2ZyA9IHRvcExldmVsXG4gICAgICAgICAgICAgICAgLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwibWFpbi1ncm91cFwiKVxuICAgICAgICB9XG5cbiAgICAgICAgc3ZnLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyBtYXJnaW4ubGVmdCArIFwiLFwiICsgbWFyZ2luLnRvcCArIFwiKVwiKTtcblxuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBHZXQgcmlkIG9mIGN1cnJlbnQgbGFiZWxzLlxuICAgICAgICBzdmcuc2VsZWN0KFwiLmNoYXJ0LWxhYmVsc1wiKVxuICAgICAgICAgICAgLnJlbW92ZSgpO1xuXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIGFwcGVuZCB0aGUgcmVjdGFuZ2xlcyBmb3IgdGhlIGJhciBjaGFydFxuICAgICAgICBsZXQgZ3JvdXBzID0gc3ZnLnNlbGVjdChcIi5iYXJzXCIpLnNlbGVjdEFsbCgnLmdyb3VwJyk7XG5cbiAgICAgICAgaWYgKGdyb3Vwcy5lbXB0eSgpKSB7XG4gICAgICAgICAgICBncm91cHMgPSBzdmdcbiAgICAgICAgICAgICAgICAuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJiYXJzXCIpXG4gICAgICAgICAgICAgICAgLnNlbGVjdEFsbChcIi5ncm91cFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdyb3VwcyA9IGdyb3Vwcy5kYXRhKGRhdGEpO1xuXG4gICAgICAgIGdyb3Vwcy5leGl0KCkucmVtb3ZlKCk7XG5cbiAgICAgICAgLy8gQWRkaW5nIG5ldyBncm91cHMsIGFuZCBoZW5jZSBhZGRpbmcgbmV3IGJhcnMgdG8gdGhvc2UgZ3JvdXBzLlxuICAgICAgICBncm91cHMuZW50ZXIoKVxuICAgICAgICAgICAgLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwiZ3JvdXBcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBkID0+IFwidHJhbnNsYXRlKDAsXCIgKyB5KGQua2V5KSArIFwiKVwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIGhlaWdodCAtIHkuYmFuZHdpZHRoKCkpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCBcIjEwMCVcIilcbiAgICAgICAgICAgIC5tZXJnZShncm91cHMpXG4gICAgICAgICAgICAuaW50ZXJydXB0KFwiZ3JvdXBzOm1vdmVcIilcbiAgICAgICAgICAgIC50cmFuc2l0aW9uKFwiZ3JvdXBzOm1vdmVcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBkID0+IFwidHJhbnNsYXRlKDAsXCIgKyB5KGQua2V5KSArIFwiKVwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIHkuYmFuZHdpZHRoKCkpXG4gICAgICAgICAgICAuZWFjaCgoc19kLCBzX2ksIG5vZGVzKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGdyb3VwID0gZDMuc2VsZWN0KG5vZGVzW3NfaV0pO1xuXG4gICAgICAgICAgICAgICAgbGV0IGJhcnMgPSBncm91cC5zZWxlY3RBbGwoXCIuYmFyXCIpXG4gICAgICAgICAgICAgICAgICAgIC5kYXRhKHNfZC5kYXRhKTtcblxuICAgICAgICAgICAgICAgIGJhcnMuZXhpdCgpLnJlbW92ZSgpO1xuXG4gICAgICAgICAgICAgICAgYmFycy5pbnRlcnJ1cHQoXCJiYXI6bW92ZVwiKSAgICAgLy8gQW5pbWF0ZSB0aGUgYmFycyB0byB0aGVpciBuZXcgcG9zaXRpb24uXG4gICAgICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKFwiYmFyOm1vdmVcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIHlHcm91cC5iYW5kd2lkdGgoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwieVwiLCBkID0+IHlHcm91cChkLl9rZXkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIDApO1xuXG4gICAgICAgICAgICAgICAgYmFycy5lbnRlcigpXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoXCJyZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIChkLCBpKSA9PiBcImJhciBzZXJpZXMgc2VyaWVzLVwiICsgaSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwieVwiLCBkID0+IHlHcm91cChkLl9rZXkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIDApXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcImhlaWdodFwiLCB5R3JvdXAuYmFuZHdpZHRoKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcIndpZHRoXCIsIDApXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIChkLCBpKSA9PiB0aGlzLmdldFNlcmllc0NvbG91cihpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcImN1cnNvclwiLCBcInBvaW50ZXJcIilcbiAgICAgICAgICAgICAgICAgICAgLm9uKFwibW91c2VvdmVyXCIsIChkLCBpLCBub2RlcykgPT4geyAvLyBEYXJrZW4gdGhlIGJhciBvbiBtb3VzZSBvdmVyXG4gICAgICAgICAgICAgICAgICAgICAgICBkMy5zZWxlY3Qobm9kZXNbaV0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmludGVycnVwdChcImhvdmVyOmNvbG91clwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKFwiaG92ZXI6Y29sb3VyXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKDQwMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIGQzLmhjbCh0aGlzLmdldFNlcmllc0NvbG91cihpKSkuZGFya2VyKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXNwYXRjaC5jYWxsKFwidG9vbHRpcFNob3dcIiwgdGhpcywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGU6IGQzLmV2ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50OiBkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllczogc19kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllc0luZGV4OiBzX2ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGQuX3lcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5vbihcIm1vdXNlb3V0XCIsIChkLCBpLCBub2RlcykgPT4geyAvLyBiYXIgaXMgcmVndWxhciBjb2xvdXIgb24gbW91c2Ugb3V0LlxuICAgICAgICAgICAgICAgICAgICAgICAgZDMuc2VsZWN0KG5vZGVzW2ldKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5pbnRlcnJ1cHQoXCJob3Zlcjpjb2xvdXJcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudHJhbnNpdGlvbihcImhvdmVyOmNvbG91clwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbig0MDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCB0aGlzLmdldFNlcmllc0NvbG91cihpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXNwYXRjaC5jYWxsKFwidG9vbHRpcEhpZGVcIiwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5vbihcImNsaWNrIGF1eGNsaWNrXCIsIChkLCBpLCBub2RlcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlzcGF0Y2guY2FsbChcImVsZW1lbnRDbGlja1wiLCB0aGlzLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZTogZDMuZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQ6IGQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzOiBkLl9zZXJpZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzSW5kZXg6IHNfaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy5feShkKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLm1lcmdlKGJhcnMpXG4gICAgICAgICAgICAgICAgICAgIC5pbnRlcnJ1cHQoXCJiYXI6Z3Jvd3RoXCIpICAgIC8vIEFuaW1hdGUgYmFycyBncm93aW5nLlxuICAgICAgICAgICAgICAgICAgICAudHJhbnNpdGlvbihcImJhcjpncm93dGhcIilcbiAgICAgICAgICAgICAgICAgICAgLmRlbGF5KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNhbGNCYXJHcm93dGgoc19pLCBub2Rlcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24odGhpcy5fZHVyYXRpb24pXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIChkLCBpKSA9PiB0aGlzLmdldFNlcmllc0NvbG91cihpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwid2lkdGhcIiwgZCA9PiB4KGQuX3kpKTtcblxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIExhYmVscyBsb2FkZWQgYWZ0ZXIgb3VyIGZpcnN0IGJhciBncm93cy5cbiAgICAgICAgaWYgKHRoaXMuX3Nob3dfbGFiZWxzKSB7XG4gICAgICAgICAgICBzdmcudHJhbnNpdGlvbihcImJhcjpncm93dGhcIilcbiAgICAgICAgICAgICAgICAub24oXCJlbmRcIiwgKGQsIGksIG5vZGVzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpIDwgbm9kZXMubGVuZ3RoIC0gMSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckxhYmVscyhzdmcsIGRhdGEsIHgsIHlHcm91cCwgeSk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBEcmF3IHRoZSBkYXRhIGF4aXMgZGF0YSBsYWJlbC5cblxuICAgICAgICBpZiAodGhpcy5fZGF0YUF4aXNMYWJlbCkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJEYXRhQXhpc0xhYmVsKHdpZHRoLCBtYXJnaW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIFNldCB0aGUgYmFja2dyb3VuZCBjb2xvdXJcblxuICAgICAgICBkMy5zZWxlY3QodGhpcy5fZWxlbWVudCkuc2VsZWN0KFwiLmJhY2tncm91bmRcIikucmVtb3ZlKCk7XG4gICAgICAgIGlmICh0aGlzLl9iYWNrZ3JvdW5kQ29sb3VyKSB7XG4gICAgICAgICAgICBkMy5zZWxlY3QodGhpcy5fZWxlbWVudCkuc2VsZWN0KFwic3ZnXCIpXG4gICAgICAgICAgICAgICAgLmFwcGVuZChcInJlY3RcIilcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImJhY2tncm91bmRcIilcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCBcIjEwMCVcIilcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgXCIxMDAlXCIpXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZShcImZpbGxcIiwgdGhpcy5fYmFja2dyb3VuZENvbG91cilcbiAgICAgICAgICAgICAgICAubG93ZXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIGFkZCB0aGUgWSBncmlkbGluZXNcbiAgICAgICAgc3ZnLmNhbGwodGhpcy5ncmlkLCBoZWlnaHQsIGQzLmF4aXNCb3R0b20oeCkudGlja3MoNSkpO1xuXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIGF4ZXNcbiAgICAgICAgc3ZnLmNhbGwodGhpcy5sYWJlbEF4aXMsIGQzLmF4aXNMZWZ0KHkpLnRpY2tTaXplKDApLnRpY2tQYWRkaW5nKDUpLnRpY2tGb3JtYXQodGhpcy5feEF4aXNUaWNrRm9ybWF0KSk7XG4gICAgICAgIHN2Zy5jYWxsKHRoaXMuZGF0YUF4aXMsIGhlaWdodCwgZDMuYXhpc0JvdHRvbSh4KS50aWNrcyg1KS50aWNrRm9ybWF0KHRoaXMuX3RpY2tGb3JtYXQpKTtcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLypcbiAgICAgKiBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIHR3byBmdW5jdGlvbnMsICNzaG93KCkgYW5kICNoaWRlKCksXG4gICAgICogdG8gc2hvdyBhbmQgaGlkZSB0aGUgbGFiZWxzLlxuICAgICAqL1xuICAgIGxhYmVscygpIHtcbiAgICAgICAgcmV0dXJuIHtcblxuICAgICAgICAgICAgc2hvdzogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9lbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzZWxlY3Rpb24gPSB0aGlzLl9lbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHRoaXMuZ2V0VHJhbnNmb3JtZWREYXRhKCksXG4gICAgICAgICAgICAgICAgICAgICAgICB4c2NhbGUgPSB0aGlzLl94c2NhbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB5Z3JvdXAgPSB0aGlzLl95Z3JvdXBzY2FsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHlzY2FsZSA9IHRoaXMuX3lzY2FsZTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uKSBzZWxlY3Rpb24gPSBkMy5zZWxlY3QodGhpcy5fZWxlbWVudCkuc2VsZWN0KFwic3ZnXCIpLnNlbGVjdChcImdcIik7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2VsZWN0aW9uLmVtcHR5KCkgJiYgZGF0YSAmJiB4c2NhbGUgJiYgeXNjYWxlICYmIHlncm91cCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGxhYmVscyA9IHNlbGVjdGlvbi5zZWxlY3QoJy5jaGFydC1sYWJlbHMnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbGFiZWxzLmVtcHR5KCkpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVscy5yZW1vdmUoKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJMYWJlbHMoc2VsZWN0aW9uLCBkYXRhLCB4c2NhbGUsIHlncm91cCwgeXNjYWxlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGhpZGU6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBkMy5zZWxlY3QodGhpcy5fZWxlbWVudClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZWxlY3QoJy5jaGFydC1sYWJlbHMnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmludGVycnVwdChcImxhYmVsc1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmludGVycnVwdChcImxhYmVsczpmYWRlXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAudHJhbnNpdGlvbihcImxhYmVsczpmYWRlXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDApXG4gICAgICAgICAgICAgICAgICAgICAgICAub24oXCJlbmRcIiwgKGQsIGksIG5vZGVzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZDMuc2VsZWN0KG5vZGVzW2ldKS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHJlbmRlckxhYmVscyhzZWxlY3Rpb24sIGRhdGEsIHhzY2FsZSwgeWdyb3VwLCB5c2NhbGUsIGFuaW1hdGUpIHtcbiAgICAgICAgYW5pbWF0ZSA9IGFuaW1hdGUgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBhbmltYXRlO1xuICAgICAgICBzZWxlY3Rpb24uc2VsZWN0QWxsKFwiLmNoYXJ0LWxhYmVsc1wiKS5yZW1vdmUoKTtcblxuICAgICAgICBsZXQgbGFiZWxzID0gc2VsZWN0aW9uLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJjaGFydC1sYWJlbHNcIilcbiAgICAgICAgICAgIC5zZWxlY3RBbGwoXCIubGFiZWwtZ3JvdXBcIilcbiAgICAgICAgICAgIC5kYXRhKGRhdGEpO1xuXG4gICAgICAgIGxldCBmb250U2l6ZSA9IDEyOyAgICAvLyBPdXIgaW5pdGlhbCBmb250IHNpemUuXG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IDU7ICAgICAvLyBCdWZmZXIgc3BhY2UgYmV0d2VlbiB3b3JkcyBhbmQgdGhlIHRvcCBvZiBhIGJhci5cblxuICAgICAgICBsYWJlbHMuZW50ZXIoKS5lYWNoKChzZXJpZXMsIHNfaSwgc19ub2RlcykgPT4ge1xuICAgICAgICAgICAgbGV0IGdyb3VwID0gZDMuc2VsZWN0KHNfbm9kZXNbc19pXSlcbiAgICAgICAgICAgICAgICAuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJsYWJlbC1ncm91cFwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIGQgPT4gXCJ0cmFuc2xhdGUoMCxcIiArIHlzY2FsZShkLmtleSkgKyBcIilcIilcbiAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKFwiLmNoYXJ0LWxhYmVsXCIpXG4gICAgICAgICAgICAgICAgLmRhdGEoc2VyaWVzLmRhdGEpXG4gICAgICAgICAgICAgICAgLmVudGVyKClcbiAgICAgICAgICAgICAgICAuZWFjaCgoZCwgaSwgbm9kZXMpID0+IHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBXYW50IHRvIGZpZ3VyZSBvdXQgaWYgdGhlIGxhYmVsIGlzIHRvbyBkYXJrIC8gbGlnaHQgZm9yIHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyBiYXIuXG4gICAgICAgICAgICAgICAgICAgIGxldCBpbnZlcnRlZENvbG9yID0gZDMuaGNsKHRoaXMuZ2V0U2VyaWVzQ29sb3VyKGkpKTtcbiAgICAgICAgICAgICAgICAgICAgaW52ZXJ0ZWRDb2xvci5sICs9IE1hdGgubWluKGludmVydGVkQ29sb3IubCArIDUwLCAxMDApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgaW52ZXJ0ID0gZDMuaGNsKHRoaXMuZ2V0U2VyaWVzQ29sb3VyKGkpKS5sIDwgNjA7XG5cbiAgICAgICAgICAgICAgICAgICAgbGV0IHhwb3MgPSB4c2NhbGUoZC5feSk7XG5cbiAgICAgICAgICAgICAgICAgICAgbGV0IHRleHQgPSBkMy5zZWxlY3Qobm9kZXNbaV0pXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRleHQodGhpcy5fbGFiZWxGb3JtYXQoZC5feSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImNoYXJ0LWxhYmVsXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIHhwb3MgKyBidWZmZXIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJkeFwiLCBhbmltYXRlID8gLTE1IDogMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwicG9pbnRlci1ldmVudHNcIiwgXCJub25lXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwiZm9udC1zaXplXCIsIGZvbnRTaXplICsgXCJweFwiKTtcblxuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJiID0gdGV4dC5ub2RlKCkuZ2V0QkJveCgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvdmVyc2l6ZSA9IHhwb3MgKyBiYi53aWR0aCArIGJ1ZmZlciA+IHhzY2FsZS5yYW5nZSgpWzFdO1xuXG4gICAgICAgICAgICAgICAgICAgIHRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwieVwiLCB5Z3JvdXAoZC5fa2V5KSArIGZvbnRTaXplIC8gMiArIHlncm91cC5iYW5kd2lkdGgoKSAvIDIpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcInhcIiwgb3ZlcnNpemUgPyB4cG9zIC0gYnVmZmVyIC0gYmIud2lkdGggOiB4cG9zICsgYnVmZmVyKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBvdmVyc2l6ZSAmJiBpbnZlcnQgPyBpbnZlcnRlZENvbG9yLnRvU3RyaW5nKCkgOiBjb2xvdXJzLmVpZ2h0ZWVuLmRhcmtHcmV5KTtcblxuICAgICAgICAgICAgICAgICAgICB0ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICAudHJhbnNpdGlvbihcImxhYmVsc1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmRlbGF5KCgpID0+IGFuaW1hdGUgPyB0aGlzLmNhbGNCYXJHcm93dGgoc19pLCBzX25vZGVzLmxlbmd0aCkgOiAwKSAvLyBEZWxheSBpbiBsb2Nrc3RlcCB3aXRoIGJhciBncm93dGguXG4gICAgICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24odGhpcy5fZHVyYXRpb24pXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcImR4XCIsIDApXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDEpXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgfSk7XG5cbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgcmVuZGVyRGF0YUF4aXNMYWJlbCh3aWR0aCwgbWFyZ2lucykge1xuICAgICAgICBsZXQgc3ZnID0gZDMuc2VsZWN0KHRoaXMuX2VsZW1lbnQpLnNlbGVjdCgnc3ZnJyk7XG4gICAgICAgIHN2Zy5zZWxlY3RBbGwoXCIuZGF0YS1sYWJlbHNcIikucmVtb3ZlKCk7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9kYXRhQXhpc0xhYmVsKSByZXR1cm47XG4gICAgICAgIGxldCB0ZXh0ID0gdGhpcy5fZGF0YUF4aXNMYWJlbDtcbiAgICAgICAgaWYgKHRleHQubG9uZykgdGV4dCA9IHRleHQubG9uZztcblxuICAgICAgICBsZXQgeCA9IChtYXJnaW5zLmxlZnQgKyB3aWR0aCAvIDIpO1xuXG4gICAgICAgIGxldCBsYWJlbCA9IHN2Zy5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwiZGF0YS1sYWJlbHNcIilcbiAgICAgICAgICAgIC5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgICAgICAgICAudGV4dCh0ZXh0KVxuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyB4ICsgXCIsXCIgKyAodGhpcy5faGVpZ2h0IC0gbWFyZ2lucy5ib3R0b20gKyA1MCkgKyBcIilcIilcbiAgICAgICAgICAgIC5zdHlsZShcImZpbGxcIiwgY29sb3Vycy5laWdodGVlbi5kYXJrR3JleSk7XG5cbiAgICAgICAgbGV0IHRleHRXaWR0aCA9IGxhYmVsLm5vZGUoKS5nZXRCQm94KCkud2lkdGg7XG4gICAgICAgIGlmICh0ZXh0V2lkdGggPj0gd2lkdGggJiYgdGhpcy5fZGF0YUF4aXNMYWJlbC5zaG9ydCkge1xuICAgICAgICAgICAgbGFiZWwudGV4dCh0aGlzLl9kYXRhQXhpc0xhYmVsLnNob3J0KTtcbiAgICAgICAgICAgIHRleHRXaWR0aCA9IGxhYmVsLm5vZGUoKS5nZXRCQm94KCkud2lkdGg7XG4gICAgICAgIH1cblxuICAgICAgICBsYWJlbC5hdHRyKFwiZHhcIiwgLXRleHRXaWR0aCAvIDIpO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuXG4gICAgZ3JpZChzZWxlY3Rpb24sIGhlaWdodCwgYXhpcykge1xuICAgICAgICBzZWxlY3Rpb24uc2VsZWN0KFwiLmdyaWRcIikucmVtb3ZlKCk7XG5cbiAgICAgICAgbGV0IGdyaWQgPSBzZWxlY3Rpb24uYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImdyaWRcIilcbiAgICAgICAgICAgIC5jYWxsKGF4aXNcbiAgICAgICAgICAgICAgICAudGlja1NpemUoaGVpZ2h0KVxuICAgICAgICAgICAgICAgIC50aWNrRm9ybWF0KFwiXCIpXG4gICAgICAgICAgICApO1xuXG4gICAgICAgIGdyaWQuc2VsZWN0QWxsKFwibGluZVwiKVxuICAgICAgICAgICAgLnN0eWxlKFwic3Ryb2tlXCIsIGNvbG91cnMuZWlnaHRlZW4ubGlnaHRHcmV5KTtcbiAgICAgICAgZ3JpZC5zZWxlY3RBbGwoXCIuZG9tYWluXCIpLnJlbW92ZSgpO1xuXG4gICAgICAgIGdyaWRcbiAgICAgICAgICAgIC5sb3dlcigpIC8vIEFsd2F5cyBlbnN1cmUgdGhhdCB0aGlzIGlzIGVhcmxpZXIgaW4gdGhlIGRvbS4gVGhpbmdzIG11c3QgYmUgZHJhd24gb24gdG9wIG9mIGl0LlxuICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAwKVxuICAgICAgICAgICAgLnRyYW5zaXRpb24oKVxuICAgICAgICAgICAgLmRlbGF5KDUwMClcbiAgICAgICAgICAgIC5kdXJhdGlvbig1MDApXG4gICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDEpO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBsYWJlbEF4aXMoc2VsZWN0aW9uLCBheGlzX29iamVjdCkge1xuICAgICAgICBzZWxlY3Rpb24uc2VsZWN0KFwiLmxhYmVsLWF4aXNcIikucmVtb3ZlKCk7XG4gICAgICAgIGxldCBheGlzID0gc2VsZWN0aW9uLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJsYWJlbC1heGlzXCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDApXG4gICAgICAgICAgICAuY2FsbChheGlzX29iamVjdCk7XG5cbiAgICAgICAgYXhpcy5zZWxlY3QoXCIuZG9tYWluXCIpLnJlbW92ZSgpO1xuXG4gICAgICAgIGxldCBtYXggPSAwO1xuICAgICAgICBjb25zdCBmb250U2l6ZSA9IDEyO1xuICAgICAgICBheGlzLnNlbGVjdEFsbChcInRleHRcIilcbiAgICAgICAgICAgIC5zdHlsZShcImZpbGxcIiwgY29sb3Vycy5laWdodGVlbi5kYXJrR3JleSlcbiAgICAgICAgICAgIC5ub2RlcygpXG4gICAgICAgICAgICAuZm9yRWFjaCh0ZXh0ID0+IG1heCA9IE1hdGgubWF4KG1heCwgdGV4dC5nZXRCQm94KCkud2lkdGgpKTtcblxuICAgICAgICBheGlzXG4gICAgICAgICAgICAudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAuZHVyYXRpb24oMTAwMClcbiAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMSk7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGRhdGFBeGlzKHNlbGVjdGlvbiwgaGVpZ2h0LCBheGlzX29iamVjdCkge1xuICAgICAgICBzZWxlY3Rpb24uc2VsZWN0KFwiLmRhdGEtYXhpc1wiKS5yZW1vdmUoKTtcbiAgICAgICAgbGV0IGF4aXMgPSBzZWxlY3Rpb24uYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJkYXRhLWF4aXNcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZSgwLFwiICsgaGVpZ2h0ICsgXCIpXCIpXG4gICAgICAgICAgICAuY2FsbChheGlzX29iamVjdC50aWNrU2l6ZSgwKS50aWNrUGFkZGluZygxMCkpXG4gICAgICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAwKVxuICAgICAgICAgICAgLnRyYW5zaXRpb24oKVxuICAgICAgICAgICAgLmR1cmF0aW9uKDEwMDApXG4gICAgICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAxKTtcblxuICAgICAgICBheGlzLnNlbGVjdEFsbChcInRleHRcIilcbiAgICAgICAgICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIGNvbG91cnMuZWlnaHRlZW4uZGFya0dyZXkpXG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGNhbGNCYXJHcm93dGgoaSwgbWF4KSB7XG4gICAgICAgIGlmIChtYXggPCAxMCkgcmV0dXJuIGkgKiB0aGlzLl9CQVJfR1JPV1RIIC8gMjtcbiAgICAgICAgaWYgKG1heCA8IDM1KSByZXR1cm4gaSAqIHRoaXMuX0JBUl9HUk9XVEggLyA0O1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICBnZXRTZXJpZXNDb2xvdXIoaSkge1xuICAgICAgICBpZiAoaSA8IDAgfHwgIXRoaXMuX2NvbG91cnMpIHJldHVybiBjb2xvdXJzLmVpZ2h0ZWVuLm1pZEdyZXk7XG5cbiAgICAgICAgaSA9IGkgJSB0aGlzLl9jb2xvdXJzLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbG91cnNbaV07XG4gICAgfVxuXG4gICAgZ2V0U29ydGVkRGF0YSgpIHtcbiAgICAgICAgbGV0IGRhdGEgPSB0aGlzLl9kYXRhO1xuICAgICAgICBpZiAoIWRhdGEgfHwgIWRhdGEubGVuZ3RoKSByZXR1cm4gW107XG5cbiAgICAgICAgZGF0YSA9IHRoaXMuX2RhdGEuc29ydCgobGhzLCByaHMpID0+IHtcbiAgICAgICAgICAgIGxocyA9IGxocy5rZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIHJocyA9IHJocy5rZXkudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICAgICAgaWYgKGxocyA9PT0gcmhzKSByZXR1cm4gMDtcbiAgICAgICAgICAgIGlmIChsaHMgPCByaHMpIHJldHVybiAtMTtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICBnZXRUcmFuc2Zvcm1lZERhdGEoKSB7XG4gICAgICAgIGxldCBkYXRhID0gdGhpcy5nZXRTb3J0ZWREYXRhKCk7XG4gICAgICAgIGlmICghZGF0YSB8fCAhZGF0YS5sZW5ndGgpIHJldHVybiBbXTtcblxuICAgICAgICBsZXQgcmVzdWx0cyA9IFtdO1xuXG4gICAgICAgIGNvbnN0IGdldFggPSBkID0+IHRoaXMuX3hBeGlzT3ZlcnJpZGUgPyB0aGlzLl94QXhpc092ZXJyaWRlW3RoaXMuX3goZCldIDogdGhpcy5feChkKTtcblxuICAgICAgICBkYXRhLmZvckVhY2goKHNlcmllcywgc19pKSA9PiB7XG4gICAgICAgICAgICBzZXJpZXMudmFsdWVzLmZvckVhY2goKGQsIGRfaSkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBmaWVsZCA9IHJlc3VsdHMuZmluZChidWNrZXQgPT4gYnVja2V0LmtleSA9PT0gZ2V0WChkKSk7XG4gICAgICAgICAgICAgICAgaWYgKCFmaWVsZCkge1xuICAgICAgICAgICAgICAgICAgICBmaWVsZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiBnZXRYKGQpXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChmaWVsZCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZmllbGQuZGF0YS5wdXNoKE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgICAgICAgICBfc2VyaWVzOiBzZXJpZXMsXG4gICAgICAgICAgICAgICAgICAgIF9zX2k6IHNfaSxcbiAgICAgICAgICAgICAgICAgICAgX2tleTogc2VyaWVzLmtleSxcbiAgICAgICAgICAgICAgICAgICAgX3k6IHRoaXMuX3koZClcbiAgICAgICAgICAgICAgICB9LCBkKSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG5cbiAgICBnZXRLZXlzKCkge1xuICAgICAgICBsZXQgZGF0YSA9IHRoaXMuX2RhdGE7XG4gICAgICAgIGlmICghZGF0YSB8fCAhZGF0YS5sZW5ndGgpIHJldHVybiBbXTtcblxuICAgICAgICByZXR1cm4gWy4uLm5ldyBTZXQoZGF0YS5tYXAoZCA9PiBkLmtleSkpXVxuICAgIH1cbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/BarChart.js\n')},"./src/Bucket.js":
/*!***********************!*\
  !*** ./src/Bucket.js ***!
  \***********************/
/*! exports provided: DateBucket, ContinuousBucket */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DateBucket", function() { return DateBucket; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ContinuousBucket", function() { return ContinuousBucket; });\n/* harmony import */ var _Statistics__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Statistics */ "./src/Statistics.js");\n// Copyright (C) 2013-2014, 2018 BrandsEye (PTY) LTD\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this\n// software and associated documentation files (the "Software"), to deal in the Software\n// without restriction, including without limitation the rights to use, copy, modify,\n//     merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following\n// conditions:\n//\n//     The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n//     INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n// CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n/**\n * The bucket of a Date object is just itself. We assume that\n * dates are their own buckets.\n */\nclass DateBucket {\n    constructor(data) {\n\n    }\n\n    // A noop: each date is its own bucket.\n    bucket(d) {\n        return d;\n    }\n\n    // A noop: our buckets are already consolidated.\n    consolidateBuckets(data) {\n        return data;\n    }\n}\n\n\nclass ContinuousBucket {\n    // We calculate buckets based on the Freedman-Draconis\n    // inter-quartile range method.\n    constructor(data) {\n        this._bucketWidth = Object(_Statistics__WEBPACK_IMPORTED_MODULE_0__["freedmanDiaconis"])(data);\n    }\n\n    bucket(d) {\n        const b = Math.floor(d / this._bucketWidth);\n        return Math.ceil(b * this._bucketWidth + this._bucketWidth);\n    }\n\n    consolidateBuckets(data) {\n        data.forEach(bucket => {\n            const counts = {};\n            const examples = {};\n            // Count everything grouped by their keys\n            // (i.e. count individual series\n            bucket.data.forEach(d => {\n                counts[d._key] = (counts[d._key] || 0) + 1;\n                examples[d._key] = d;\n            });\n            // Provide one summary per series, but preserve\n            // any extra data, such as colour and so on.\n            bucket.data = Object.keys(counts).map(key => {\n                const example = examples[key];\n                return Object.assign({}, example, {\n                    _y: counts[key]\n                })\n            })\n        });\n\n        return data;\n    }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvQnVja2V0LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYjNqcy8uL3NyYy9CdWNrZXQuanM/ZTU5YSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKEMpIDIwMTMtMjAxNCwgMjAxOCBCcmFuZHNFeWUgKFBUWSkgTFREXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZiB0aGlzXG4vLyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmVcbi8vIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSxcbi8vICAgICBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvXG4vLyBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZ1xuLy8gY29uZGl0aW9uczpcbi8vXG4vLyAgICAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4vLyBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vICAgICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SIElNUExJRUQsXG4vLyAgICAgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEFcbi8vIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFRcbi8vIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRlxuLy8gQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFXG4vLyBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IHtmcmVlZG1hbkRpYWNvbmlzfSBmcm9tIFwiLi9TdGF0aXN0aWNzXCI7XG5cbi8qKlxuICogVGhlIGJ1Y2tldCBvZiBhIERhdGUgb2JqZWN0IGlzIGp1c3QgaXRzZWxmLiBXZSBhc3N1bWUgdGhhdFxuICogZGF0ZXMgYXJlIHRoZWlyIG93biBidWNrZXRzLlxuICovXG5leHBvcnQgY2xhc3MgRGF0ZUJ1Y2tldCB7XG4gICAgY29uc3RydWN0b3IoZGF0YSkge1xuXG4gICAgfVxuXG4gICAgLy8gQSBub29wOiBlYWNoIGRhdGUgaXMgaXRzIG93biBidWNrZXQuXG4gICAgYnVja2V0KGQpIHtcbiAgICAgICAgcmV0dXJuIGQ7XG4gICAgfVxuXG4gICAgLy8gQSBub29wOiBvdXIgYnVja2V0cyBhcmUgYWxyZWFkeSBjb25zb2xpZGF0ZWQuXG4gICAgY29uc29saWRhdGVCdWNrZXRzKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxufVxuXG5cbmV4cG9ydCBjbGFzcyBDb250aW51b3VzQnVja2V0IHtcbiAgICAvLyBXZSBjYWxjdWxhdGUgYnVja2V0cyBiYXNlZCBvbiB0aGUgRnJlZWRtYW4tRHJhY29uaXNcbiAgICAvLyBpbnRlci1xdWFydGlsZSByYW5nZSBtZXRob2QuXG4gICAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgICAgICB0aGlzLl9idWNrZXRXaWR0aCA9IGZyZWVkbWFuRGlhY29uaXMoZGF0YSk7XG4gICAgfVxuXG4gICAgYnVja2V0KGQpIHtcbiAgICAgICAgY29uc3QgYiA9IE1hdGguZmxvb3IoZCAvIHRoaXMuX2J1Y2tldFdpZHRoKTtcbiAgICAgICAgcmV0dXJuIE1hdGguY2VpbChiICogdGhpcy5fYnVja2V0V2lkdGggKyB0aGlzLl9idWNrZXRXaWR0aCk7XG4gICAgfVxuXG4gICAgY29uc29saWRhdGVCdWNrZXRzKGRhdGEpIHtcbiAgICAgICAgZGF0YS5mb3JFYWNoKGJ1Y2tldCA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb3VudHMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGV4YW1wbGVzID0ge307XG4gICAgICAgICAgICAvLyBDb3VudCBldmVyeXRoaW5nIGdyb3VwZWQgYnkgdGhlaXIga2V5c1xuICAgICAgICAgICAgLy8gKGkuZS4gY291bnQgaW5kaXZpZHVhbCBzZXJpZXNcbiAgICAgICAgICAgIGJ1Y2tldC5kYXRhLmZvckVhY2goZCA9PiB7XG4gICAgICAgICAgICAgICAgY291bnRzW2QuX2tleV0gPSAoY291bnRzW2QuX2tleV0gfHwgMCkgKyAxO1xuICAgICAgICAgICAgICAgIGV4YW1wbGVzW2QuX2tleV0gPSBkO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBQcm92aWRlIG9uZSBzdW1tYXJ5IHBlciBzZXJpZXMsIGJ1dCBwcmVzZXJ2ZVxuICAgICAgICAgICAgLy8gYW55IGV4dHJhIGRhdGEsIHN1Y2ggYXMgY29sb3VyIGFuZCBzbyBvbi5cbiAgICAgICAgICAgIGJ1Y2tldC5kYXRhID0gT2JqZWN0LmtleXMoY291bnRzKS5tYXAoa2V5ID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBleGFtcGxlID0gZXhhbXBsZXNba2V5XTtcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgZXhhbXBsZSwge1xuICAgICAgICAgICAgICAgICAgICBfeTogY291bnRzW2tleV1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxufSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/Bucket.js\n')},"./src/Chart.js":
/*!**********************!*\
  !*** ./src/Chart.js ***!
  \**********************/
/*! exports provided: Chart */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Chart", function() { return Chart; });\n/* harmony import */ var _Colours__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Colours */ "./src/Colours.js");\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers */ "./src/helpers.js");\n// Copyright (C) 2013-2014, 2018 BrandsEye (PTY) LTD\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this\n// software and associated documentation files (the "Software"), to deal in the Software\n// without restriction, including without limitation the rights to use, copy, modify,\n//     merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following\n// conditions:\n//\n//     The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n//     INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n// CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n\n\n\nclass Chart {\n    constructor() {\n        this._x = (d) => d.x;\n        this._y = (d) => d.y;\n        this._height = 420;\n        this._width = 420;\n        this._BAR_GROWTH = 100;\n        this._duration = 300;\n        this._dispatch = d3.dispatch(\'elementClick\', \'elementMiddleClick\', \'elementRightClick\',\n            \'tooltipShow\', \'tooltipHide\');\n        this._xAxisTickFormat = this._tickFormat = this._labelFormat = d => d.toString();\n        this._colours = [ _Colours__WEBPACK_IMPORTED_MODULE_0__["colours"].eighteen.midGrey, _Colours__WEBPACK_IMPORTED_MODULE_0__["colours"].eighteen.lightGrey, _Colours__WEBPACK_IMPORTED_MODULE_0__["colours"].eighteen.darkGrey ];\n        this._backgroundColour = "#FFF";\n        this._interbarProportion = null;\n    }\n\n    renderLegend(svg, data, min, width, height, getter) {\n        svg = svg || d3.select(this._element).select("svg");\n        svg.selectAll(".legend").remove();\n        if (!this._show_legend) return 0;\n\n        min = min || 2;\n        data = data || this.getSortedData();\n        width = width || this._width;\n        height = height || this._height;\n        getter = getter || (d => d.key);\n\n        // Only if we have multiple series.\n        if (!data || data.length < min) return 0;\n\n        let maxWidth = Object(_helpers__WEBPACK_IMPORTED_MODULE_1__["maxBounding"])(svg, data.map(getter)).width;\n\n        const legend = svg.append("g")\n            .attr("class", "legend");\n\n        let elements = legend.selectAll(".legend-element")\n            .data(data);\n\n        const position_start = 20;\n        let position = position_start;\n        let position_height = 0;\n\n        elements.enter()\n            .append("g")\n            .attr("class", (d, i) => "legend-element series series-" + i)\n            .style("cursor", "default")\n            .each((d, i, nodes) => {\n                let element = d3.select(nodes[i]);\n\n                element.append("rect")\n                    .attr("width", 10)\n                    .attr("height", 10)\n                    .attr("rx", 2)\n                    .attr("ry", 2)\n                    .attr("y", -10)\n                    .style("fill", () => this.getSeriesColour(i));\n\n                element.append("text")\n                    .text(getter)\n                    .attr("dx", 12)\n                    .style("font-family", "Open Sans, sans-serif")\n                    .style("font-weight", "normal")\n                    .style("font-size", "12px")\n                    .style("fill", _Colours__WEBPACK_IMPORTED_MODULE_0__["colours"].eighteen.darkGrey);\n\n                element.append("title")\n                    .text(getter);\n\n                element.attr("transform", "translate(" + position + "," + position_height +")");\n                const positionDelta = maxWidth + 20; // element.node().getBBox().width + 10;\n                position += positionDelta;\n\n                if (position >= width) {\n                    position = position_start;\n                    position_height += 15;\n                    element.attr("transform", "translate(" + position + "," + position_height + ")");\n                    position += positionDelta;\n                }\n\n            })\n            .on("mouseover", (d, i, nodes) => {\n                svg.selectAll(".series:not(.series-" + i + ")")\n                    .interrupt("legend:highlight")\n                    .transition("legend:highlight")\n                    .style("opacity", 0.3);\n            })\n            .on("mouseout", (d, i, nodes) => {\n                svg.selectAll(".series")\n                    .interrupt("legend:highlight")\n                    .transition("legend:highlight")\n                    .style("opacity", 1);\n            })\n            .style("opacity", 0)\n            .transition()\n            .duration(1000)\n            .style("opacity", 1);\n\n        const legendHeight = legend.node().getBBox().height;\n        legend.attr("transform", "translate(0," + (height - legendHeight) + ")");\n        return legendHeight;\n    }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvQ2hhcnQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9iM2pzLy4vc3JjL0NoYXJ0LmpzPzYyYWUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChDKSAyMDEzLTIwMTQsIDIwMTggQnJhbmRzRXllIChQVFkpIExURFxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpc1xuLy8gc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlXG4vLyB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksXG4vLyAgICAgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0b1xuLy8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcbi8vIGNvbmRpdGlvbnM6XG4vL1xuLy8gICAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuLy8gY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyAgICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUiBJTVBMSUVELFxuLy8gICAgIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBXG4vLyBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUXG4vLyBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0Zcbi8vIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRVxuLy8gT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCB7Y29sb3Vyc30gZnJvbSAnLi9Db2xvdXJzJztcbmltcG9ydCB7IG1heEJvdW5kaW5nIH0gZnJvbSBcIi4vaGVscGVyc1wiO1xuXG5cblxuZXhwb3J0IGNsYXNzIENoYXJ0IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5feCA9IChkKSA9PiBkLng7XG4gICAgICAgIHRoaXMuX3kgPSAoZCkgPT4gZC55O1xuICAgICAgICB0aGlzLl9oZWlnaHQgPSA0MjA7XG4gICAgICAgIHRoaXMuX3dpZHRoID0gNDIwO1xuICAgICAgICB0aGlzLl9CQVJfR1JPV1RIID0gMTAwO1xuICAgICAgICB0aGlzLl9kdXJhdGlvbiA9IDMwMDtcbiAgICAgICAgdGhpcy5fZGlzcGF0Y2ggPSBkMy5kaXNwYXRjaCgnZWxlbWVudENsaWNrJywgJ2VsZW1lbnRNaWRkbGVDbGljaycsICdlbGVtZW50UmlnaHRDbGljaycsXG4gICAgICAgICAgICAndG9vbHRpcFNob3cnLCAndG9vbHRpcEhpZGUnKTtcbiAgICAgICAgdGhpcy5feEF4aXNUaWNrRm9ybWF0ID0gdGhpcy5fdGlja0Zvcm1hdCA9IHRoaXMuX2xhYmVsRm9ybWF0ID0gZCA9PiBkLnRvU3RyaW5nKCk7XG4gICAgICAgIHRoaXMuX2NvbG91cnMgPSBbIGNvbG91cnMuZWlnaHRlZW4ubWlkR3JleSwgY29sb3Vycy5laWdodGVlbi5saWdodEdyZXksIGNvbG91cnMuZWlnaHRlZW4uZGFya0dyZXkgXTtcbiAgICAgICAgdGhpcy5fYmFja2dyb3VuZENvbG91ciA9IFwiI0ZGRlwiO1xuICAgICAgICB0aGlzLl9pbnRlcmJhclByb3BvcnRpb24gPSBudWxsO1xuICAgIH1cblxuICAgIHJlbmRlckxlZ2VuZChzdmcsIGRhdGEsIG1pbiwgd2lkdGgsIGhlaWdodCwgZ2V0dGVyKSB7XG4gICAgICAgIHN2ZyA9IHN2ZyB8fCBkMy5zZWxlY3QodGhpcy5fZWxlbWVudCkuc2VsZWN0KFwic3ZnXCIpO1xuICAgICAgICBzdmcuc2VsZWN0QWxsKFwiLmxlZ2VuZFwiKS5yZW1vdmUoKTtcbiAgICAgICAgaWYgKCF0aGlzLl9zaG93X2xlZ2VuZCkgcmV0dXJuIDA7XG5cbiAgICAgICAgbWluID0gbWluIHx8IDI7XG4gICAgICAgIGRhdGEgPSBkYXRhIHx8IHRoaXMuZ2V0U29ydGVkRGF0YSgpO1xuICAgICAgICB3aWR0aCA9IHdpZHRoIHx8IHRoaXMuX3dpZHRoO1xuICAgICAgICBoZWlnaHQgPSBoZWlnaHQgfHwgdGhpcy5faGVpZ2h0O1xuICAgICAgICBnZXR0ZXIgPSBnZXR0ZXIgfHwgKGQgPT4gZC5rZXkpO1xuXG4gICAgICAgIC8vIE9ubHkgaWYgd2UgaGF2ZSBtdWx0aXBsZSBzZXJpZXMuXG4gICAgICAgIGlmICghZGF0YSB8fCBkYXRhLmxlbmd0aCA8IG1pbikgcmV0dXJuIDA7XG5cbiAgICAgICAgbGV0IG1heFdpZHRoID0gbWF4Qm91bmRpbmcoc3ZnLCBkYXRhLm1hcChnZXR0ZXIpKS53aWR0aDtcblxuICAgICAgICBjb25zdCBsZWdlbmQgPSBzdmcuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImxlZ2VuZFwiKTtcblxuICAgICAgICBsZXQgZWxlbWVudHMgPSBsZWdlbmQuc2VsZWN0QWxsKFwiLmxlZ2VuZC1lbGVtZW50XCIpXG4gICAgICAgICAgICAuZGF0YShkYXRhKTtcblxuICAgICAgICBjb25zdCBwb3NpdGlvbl9zdGFydCA9IDIwO1xuICAgICAgICBsZXQgcG9zaXRpb24gPSBwb3NpdGlvbl9zdGFydDtcbiAgICAgICAgbGV0IHBvc2l0aW9uX2hlaWdodCA9IDA7XG5cbiAgICAgICAgZWxlbWVudHMuZW50ZXIoKVxuICAgICAgICAgICAgLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgKGQsIGkpID0+IFwibGVnZW5kLWVsZW1lbnQgc2VyaWVzIHNlcmllcy1cIiArIGkpXG4gICAgICAgICAgICAuc3R5bGUoXCJjdXJzb3JcIiwgXCJkZWZhdWx0XCIpXG4gICAgICAgICAgICAuZWFjaCgoZCwgaSwgbm9kZXMpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgZWxlbWVudCA9IGQzLnNlbGVjdChub2Rlc1tpXSk7XG5cbiAgICAgICAgICAgICAgICBlbGVtZW50LmFwcGVuZChcInJlY3RcIilcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCAxMClcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgMTApXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFwicnhcIiwgMilcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJyeVwiLCAyKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcInlcIiwgLTEwKVxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJmaWxsXCIsICgpID0+IHRoaXMuZ2V0U2VyaWVzQ29sb3VyKGkpKTtcblxuICAgICAgICAgICAgICAgIGVsZW1lbnQuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgICAgICAgICAgICAgICAudGV4dChnZXR0ZXIpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiZHhcIiwgMTIpXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZShcImZvbnQtZmFtaWx5XCIsIFwiT3BlbiBTYW5zLCBzYW5zLXNlcmlmXCIpXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZShcImZvbnQtd2VpZ2h0XCIsIFwibm9ybWFsXCIpXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZShcImZvbnQtc2l6ZVwiLCBcIjEycHhcIilcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBjb2xvdXJzLmVpZ2h0ZWVuLmRhcmtHcmV5KTtcblxuICAgICAgICAgICAgICAgIGVsZW1lbnQuYXBwZW5kKFwidGl0bGVcIilcbiAgICAgICAgICAgICAgICAgICAgLnRleHQoZ2V0dGVyKTtcblxuICAgICAgICAgICAgICAgIGVsZW1lbnQuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIHBvc2l0aW9uICsgXCIsXCIgKyBwb3NpdGlvbl9oZWlnaHQgK1wiKVwiKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwb3NpdGlvbkRlbHRhID0gbWF4V2lkdGggKyAyMDsgLy8gZWxlbWVudC5ub2RlKCkuZ2V0QkJveCgpLndpZHRoICsgMTA7XG4gICAgICAgICAgICAgICAgcG9zaXRpb24gKz0gcG9zaXRpb25EZWx0YTtcblxuICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA+PSB3aWR0aCkge1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IHBvc2l0aW9uX3N0YXJ0O1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbl9oZWlnaHQgKz0gMTU7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIHBvc2l0aW9uICsgXCIsXCIgKyBwb3NpdGlvbl9oZWlnaHQgKyBcIilcIik7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uICs9IHBvc2l0aW9uRGVsdGE7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLm9uKFwibW91c2VvdmVyXCIsIChkLCBpLCBub2RlcykgPT4ge1xuICAgICAgICAgICAgICAgIHN2Zy5zZWxlY3RBbGwoXCIuc2VyaWVzOm5vdCguc2VyaWVzLVwiICsgaSArIFwiKVwiKVxuICAgICAgICAgICAgICAgICAgICAuaW50ZXJydXB0KFwibGVnZW5kOmhpZ2hsaWdodFwiKVxuICAgICAgICAgICAgICAgICAgICAudHJhbnNpdGlvbihcImxlZ2VuZDpoaWdobGlnaHRcIilcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAwLjMpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbihcIm1vdXNlb3V0XCIsIChkLCBpLCBub2RlcykgPT4ge1xuICAgICAgICAgICAgICAgIHN2Zy5zZWxlY3RBbGwoXCIuc2VyaWVzXCIpXG4gICAgICAgICAgICAgICAgICAgIC5pbnRlcnJ1cHQoXCJsZWdlbmQ6aGlnaGxpZ2h0XCIpXG4gICAgICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKFwibGVnZW5kOmhpZ2hsaWdodFwiKVxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDEpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMClcbiAgICAgICAgICAgIC50cmFuc2l0aW9uKClcbiAgICAgICAgICAgIC5kdXJhdGlvbigxMDAwKVxuICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAxKTtcblxuICAgICAgICBjb25zdCBsZWdlbmRIZWlnaHQgPSBsZWdlbmQubm9kZSgpLmdldEJCb3goKS5oZWlnaHQ7XG4gICAgICAgIGxlZ2VuZC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKDAsXCIgKyAoaGVpZ2h0IC0gbGVnZW5kSGVpZ2h0KSArIFwiKVwiKTtcbiAgICAgICAgcmV0dXJuIGxlZ2VuZEhlaWdodDtcbiAgICB9XG59Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/Chart.js\n')},"./src/Colours.js":
/*!************************!*\
  !*** ./src/Colours.js ***!
  \************************/
/*! exports provided: colours */function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"colours\", function() { return colours; });\n// Copyright (C) 2013-2014, 2018 BrandsEye (PTY) LTD\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this\n// software and associated documentation files (the \"Software\"), to deal in the Software\n// without restriction, including without limitation the rights to use, copy, modify,\n//     merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following\n// conditions:\n//\n//     The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n//     INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n// CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\nlet colours = {\n  // **brandseye.colours.scheme** is our basic colour scheme.\n    scheme: [\n        '#58B6FF',\n        '#5473BD',\n        '#DF71FC',\n        '#9856B0',\n        '#ff58a3',\n        '#D22D6F',\n        '#fc6a4b',\n        '#E53E39',\n        '#FFD658',\n        '#E8AF44',\n        '#43C278',\n        '#318F58'\n    ],\n    // And **brandseye.colours.allColours** defines a large number of colours.\n    allColours: [\n        '#f0f8ff', '#faebd7', '#00ffff', '#7fffd4', '#f0ffff', '#f5f5dc', '#ffe4c4', '#000000', '#ffebcd', '#0000ff', '#8a2be2',\n        '#a52a2a', '#deb887', '#5f9ea0', '#7fff00', '#d2691e', '#ff7f50', '#6495ed', '#fff8dc', '#dc143c', '#00ffff', '#00008b',\n        '#008b8b', '#b8860b', '#a9a9a9', '#006400', '#bdb76b', '#8b008b', '#556b2f', '#ff8c00', '#9932cc', '#8b0000', '#e9967a',\n        '#8fbc8f', '#483d8b', '#2f4f4f', '#00ced1', '#9400d3', '#ff1493', '#00bfff', '#696969', '#1e90ff', '#d19275', '#b22222',\n        '#fffaf0', '#228b22', '#ff00ff', '#dcdcdc', '#f8f8ff', '#ffd700', '#daa520', '#808080', '#008000', '#adff2f', '#f0fff0',\n        '#ff69b4', '#cd5c5c', '#4b0082', '#fffff0', '#f0e68c', '#e6e6fa', '#fff0f5', '#7cfc00', '#fffacd', '#add8e6', '#f08080',\n        '#e0ffff', '#fafad2', '#d3d3d3', '#90ee90', '#ffb6c1', '#ffa07a', '#20b2aa', '#87cefa', '#8470ff', '#778899', '#b0c4de',\n        '#ffffe0', '#00ff00', '#32cd32', '#faf0e6', '#ff00ff', '#800000', '#66cdaa', '#0000cd', '#ba55d3', '#9370d8', '#3cb371',\n        '#7b68ee', '#00fa9a', '#48d1cc', '#c71585', '#191970', '#f5fffa', '#ffe4e1', '#ffe4b5', '#ffdead', '#000080', '#fdf5e6',\n        '#808000', '#6b8e23', '#ffa500', '#ff4500', '#da70d6', '#eee8aa', '#98fb98', '#afeeee', '#d87093', '#ffefd5', '#ffdab9',\n        '#cd853f', '#ffc0cb', '#dda0dd', '#b0e0e6', '#800080', '#ff0000', '#bc8f8f', '#4169e1', '#8b4513', '#fa8072', '#f4a460',\n        '#2e8b57', '#fff5ee', '#a0522d', '#c0c0c0', '#87ceeb', '#6a5acd', '#708090', '#fffafa', '#00ff7f', '#4682b4', '#d2b48c',\n        '#008080', '#d8bfd8', '#ff6347', '#40e0d0', '#ee82ee', '#d02090', '#f5deb3', '#ffffff', '#f5f5f5', '#ffff00', '#9acd32'\n    ],\n\n    // These are the new brandseye colours for 2018, defined in reporting v.4.5.8\n    eighteen: {\n      good: \"#00c9a0\",       // Bright Green\n      series: [\n        \"#eba25d\",           // Muted orange\n        \"#9cd261\",           // Green\n        \"#958cb5\",           // Purple\n      ],\n      lightGrey: \"#e9e9e9\",  // gridlines, bars and columns, neutral sentiment\n      midGrey: \"#c0c0c0\",    // table borders, bars and columns if light grey is too lightGrey\n      darkGrey: \"#444444\",   // All text\n      sentiment: {\n        positive: \"#00b0b9\", // blue\n        neutral: \"#e9e9e9\",  // light grey\n        negative: \"#ee2737\", // Red\n        net: \"#1c1f2a\"       // Elite\n      }\n    }\n\n\n\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvQ29sb3Vycy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2IzanMvLi9zcmMvQ29sb3Vycy5qcz8yY2RhIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoQykgMjAxMy0yMDE0LCAyMDE4IEJyYW5kc0V5ZSAoUFRZKSBMVERcbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXNcbi8vIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZVxuLy8gd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LFxuLy8gICAgIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG9cbi8vIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nXG4vLyBjb25kaXRpb25zOlxuLy9cbi8vICAgICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbi8vIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gICAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1IgSU1QTElFRCxcbi8vICAgICBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQVxuLy8gUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxuLy8gSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GXG4vLyBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkVcbi8vIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5cbmV4cG9ydCBsZXQgY29sb3VycyA9IHtcbiAgLy8gKipicmFuZHNleWUuY29sb3Vycy5zY2hlbWUqKiBpcyBvdXIgYmFzaWMgY29sb3VyIHNjaGVtZS5cbiAgICBzY2hlbWU6IFtcbiAgICAgICAgJyM1OEI2RkYnLFxuICAgICAgICAnIzU0NzNCRCcsXG4gICAgICAgICcjREY3MUZDJyxcbiAgICAgICAgJyM5ODU2QjAnLFxuICAgICAgICAnI2ZmNThhMycsXG4gICAgICAgICcjRDIyRDZGJyxcbiAgICAgICAgJyNmYzZhNGInLFxuICAgICAgICAnI0U1M0UzOScsXG4gICAgICAgICcjRkZENjU4JyxcbiAgICAgICAgJyNFOEFGNDQnLFxuICAgICAgICAnIzQzQzI3OCcsXG4gICAgICAgICcjMzE4RjU4J1xuICAgIF0sXG4gICAgLy8gQW5kICoqYnJhbmRzZXllLmNvbG91cnMuYWxsQ29sb3VycyoqIGRlZmluZXMgYSBsYXJnZSBudW1iZXIgb2YgY29sb3Vycy5cbiAgICBhbGxDb2xvdXJzOiBbXG4gICAgICAgICcjZjBmOGZmJywgJyNmYWViZDcnLCAnIzAwZmZmZicsICcjN2ZmZmQ0JywgJyNmMGZmZmYnLCAnI2Y1ZjVkYycsICcjZmZlNGM0JywgJyMwMDAwMDAnLCAnI2ZmZWJjZCcsICcjMDAwMGZmJywgJyM4YTJiZTInLFxuICAgICAgICAnI2E1MmEyYScsICcjZGViODg3JywgJyM1ZjllYTAnLCAnIzdmZmYwMCcsICcjZDI2OTFlJywgJyNmZjdmNTAnLCAnIzY0OTVlZCcsICcjZmZmOGRjJywgJyNkYzE0M2MnLCAnIzAwZmZmZicsICcjMDAwMDhiJyxcbiAgICAgICAgJyMwMDhiOGInLCAnI2I4ODYwYicsICcjYTlhOWE5JywgJyMwMDY0MDAnLCAnI2JkYjc2YicsICcjOGIwMDhiJywgJyM1NTZiMmYnLCAnI2ZmOGMwMCcsICcjOTkzMmNjJywgJyM4YjAwMDAnLCAnI2U5OTY3YScsXG4gICAgICAgICcjOGZiYzhmJywgJyM0ODNkOGInLCAnIzJmNGY0ZicsICcjMDBjZWQxJywgJyM5NDAwZDMnLCAnI2ZmMTQ5MycsICcjMDBiZmZmJywgJyM2OTY5NjknLCAnIzFlOTBmZicsICcjZDE5Mjc1JywgJyNiMjIyMjInLFxuICAgICAgICAnI2ZmZmFmMCcsICcjMjI4YjIyJywgJyNmZjAwZmYnLCAnI2RjZGNkYycsICcjZjhmOGZmJywgJyNmZmQ3MDAnLCAnI2RhYTUyMCcsICcjODA4MDgwJywgJyMwMDgwMDAnLCAnI2FkZmYyZicsICcjZjBmZmYwJyxcbiAgICAgICAgJyNmZjY5YjQnLCAnI2NkNWM1YycsICcjNGIwMDgyJywgJyNmZmZmZjAnLCAnI2YwZTY4YycsICcjZTZlNmZhJywgJyNmZmYwZjUnLCAnIzdjZmMwMCcsICcjZmZmYWNkJywgJyNhZGQ4ZTYnLCAnI2YwODA4MCcsXG4gICAgICAgICcjZTBmZmZmJywgJyNmYWZhZDInLCAnI2QzZDNkMycsICcjOTBlZTkwJywgJyNmZmI2YzEnLCAnI2ZmYTA3YScsICcjMjBiMmFhJywgJyM4N2NlZmEnLCAnIzg0NzBmZicsICcjNzc4ODk5JywgJyNiMGM0ZGUnLFxuICAgICAgICAnI2ZmZmZlMCcsICcjMDBmZjAwJywgJyMzMmNkMzInLCAnI2ZhZjBlNicsICcjZmYwMGZmJywgJyM4MDAwMDAnLCAnIzY2Y2RhYScsICcjMDAwMGNkJywgJyNiYTU1ZDMnLCAnIzkzNzBkOCcsICcjM2NiMzcxJyxcbiAgICAgICAgJyM3YjY4ZWUnLCAnIzAwZmE5YScsICcjNDhkMWNjJywgJyNjNzE1ODUnLCAnIzE5MTk3MCcsICcjZjVmZmZhJywgJyNmZmU0ZTEnLCAnI2ZmZTRiNScsICcjZmZkZWFkJywgJyMwMDAwODAnLCAnI2ZkZjVlNicsXG4gICAgICAgICcjODA4MDAwJywgJyM2YjhlMjMnLCAnI2ZmYTUwMCcsICcjZmY0NTAwJywgJyNkYTcwZDYnLCAnI2VlZThhYScsICcjOThmYjk4JywgJyNhZmVlZWUnLCAnI2Q4NzA5MycsICcjZmZlZmQ1JywgJyNmZmRhYjknLFxuICAgICAgICAnI2NkODUzZicsICcjZmZjMGNiJywgJyNkZGEwZGQnLCAnI2IwZTBlNicsICcjODAwMDgwJywgJyNmZjAwMDAnLCAnI2JjOGY4ZicsICcjNDE2OWUxJywgJyM4YjQ1MTMnLCAnI2ZhODA3MicsICcjZjRhNDYwJyxcbiAgICAgICAgJyMyZThiNTcnLCAnI2ZmZjVlZScsICcjYTA1MjJkJywgJyNjMGMwYzAnLCAnIzg3Y2VlYicsICcjNmE1YWNkJywgJyM3MDgwOTAnLCAnI2ZmZmFmYScsICcjMDBmZjdmJywgJyM0NjgyYjQnLCAnI2QyYjQ4YycsXG4gICAgICAgICcjMDA4MDgwJywgJyNkOGJmZDgnLCAnI2ZmNjM0NycsICcjNDBlMGQwJywgJyNlZTgyZWUnLCAnI2QwMjA5MCcsICcjZjVkZWIzJywgJyNmZmZmZmYnLCAnI2Y1ZjVmNScsICcjZmZmZjAwJywgJyM5YWNkMzInXG4gICAgXSxcblxuICAgIC8vIFRoZXNlIGFyZSB0aGUgbmV3IGJyYW5kc2V5ZSBjb2xvdXJzIGZvciAyMDE4LCBkZWZpbmVkIGluIHJlcG9ydGluZyB2LjQuNS44XG4gICAgZWlnaHRlZW46IHtcbiAgICAgIGdvb2Q6IFwiIzAwYzlhMFwiLCAgICAgICAvLyBCcmlnaHQgR3JlZW5cbiAgICAgIHNlcmllczogW1xuICAgICAgICBcIiNlYmEyNWRcIiwgICAgICAgICAgIC8vIE11dGVkIG9yYW5nZVxuICAgICAgICBcIiM5Y2QyNjFcIiwgICAgICAgICAgIC8vIEdyZWVuXG4gICAgICAgIFwiIzk1OGNiNVwiLCAgICAgICAgICAgLy8gUHVycGxlXG4gICAgICBdLFxuICAgICAgbGlnaHRHcmV5OiBcIiNlOWU5ZTlcIiwgIC8vIGdyaWRsaW5lcywgYmFycyBhbmQgY29sdW1ucywgbmV1dHJhbCBzZW50aW1lbnRcbiAgICAgIG1pZEdyZXk6IFwiI2MwYzBjMFwiLCAgICAvLyB0YWJsZSBib3JkZXJzLCBiYXJzIGFuZCBjb2x1bW5zIGlmIGxpZ2h0IGdyZXkgaXMgdG9vIGxpZ2h0R3JleVxuICAgICAgZGFya0dyZXk6IFwiIzQ0NDQ0NFwiLCAgIC8vIEFsbCB0ZXh0XG4gICAgICBzZW50aW1lbnQ6IHtcbiAgICAgICAgcG9zaXRpdmU6IFwiIzAwYjBiOVwiLCAvLyBibHVlXG4gICAgICAgIG5ldXRyYWw6IFwiI2U5ZTllOVwiLCAgLy8gbGlnaHQgZ3JleVxuICAgICAgICBuZWdhdGl2ZTogXCIjZWUyNzM3XCIsIC8vIFJlZFxuICAgICAgICBuZXQ6IFwiIzFjMWYyYVwiICAgICAgIC8vIEVsaXRlXG4gICAgICB9XG4gICAgfVxuXG5cblxufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/Colours.js\n")},"./src/ColumnChart.js":
/*!****************************!*\
  !*** ./src/ColumnChart.js ***!
  \****************************/
/*! exports provided: ColumnChart */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ColumnChart", function() { return ColumnChart; });\n/* harmony import */ var _Colours__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Colours */ "./src/Colours.js");\n/* harmony import */ var _Chart__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Chart */ "./src/Chart.js");\n// Copyright (C) 2013-2014, 2018 BrandsEye (PTY) LTD\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this\n// software and associated documentation files (the "Software"), to deal in the Software\n// without restriction, including without limitation the rights to use, copy, modify,\n//     merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following\n// conditions:\n//\n//     The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n//     INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n// CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n\n\nclass ColumnChart extends _Chart__WEBPACK_IMPORTED_MODULE_1__["Chart"] {\n\n    //------------------------------------------------------\n\n    data(data) {\n        if (!arguments.length) return this._data;\n        if (data && data[0].key === undefined) {\n            data = [\n                {\n                    key: "series 1",\n                    values: data\n                }\n            ];\n        }\n        this._data = data;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    element(element) {\n        if (!arguments.length) return this._element;\n        this._element = element;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    showLabels(show) {\n        if (!arguments.length) return this._show_labels;\n        this._show_labels = show;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    // todo dispatch\n    showLegend(show) {\n        if (!arguments.length) return this._show_legend;\n        this._show_legend = show;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    x(x) {\n        if (!arguments.length) return this._x;\n        this._x = x;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    y(y) {\n        if (!arguments.length) return this._y;\n        this._y = y;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    width(width) {\n        if (!arguments.length) return this._width;\n        this._width = width;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    height(height) {\n        if (!arguments.length) return this._height;\n        this._height = height;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    colours(colours) {\n        if (!arguments.length) return this._colours;\n        this._colours = colours;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    backgroundColour(colour) {\n        if (!arguments.length) return this._backgroundColour;\n        this._backgroundColour = colour || "#FFF"; // never set it to null.\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    tickFormat(format) {\n        if (!arguments.length) return this._tickFormat;\n        this._tickFormat = format;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    xAxisTickFormat(format) {\n        if (!arguments.length) return this._xAxisTickFormat;\n        this._xAxisTickFormat = format || (d => d.toString());\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    labelFormat(format) {\n        if (!arguments.length) return this._labelFormat;\n        this._labelFormat = format || (d => d.toString());\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    // todo missing\n    labelCompression(compression) {\n        if (!arguments.length) return this._compression;\n        this._compression = compression;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    //todo missing\n    dataAxisLabel(label) {\n        if (!arguments.length) return this._dataAxisLabel;\n        this._dataAxisLabel = label;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    tooltip(tooltip) {\n        if (!arguments.length) return this._tooltip;\n        this._tooltip = tooltip;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    forceY(force) {\n        if (!arguments.length) return this._forceY;\n        this._forceY = force;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n// todo missing\n    duration(duration) {\n        if (!arguments.length) return this._duration;\n        this._duration = duration;\n        return this;\n    }\n\n// todo missing\n    coarseness(coarseness) {\n        if (!arguments.length) return this._coarseness;\n        this._coarseness = coarseness;\n        return this;\n    }\n\n    // todo missing\n    padding(padding) {\n        if (!arguments.length) return this._padding;\n        this._padding = padding;\n        return this;\n    }\n\n    // todo missing\n    xAxisTooltips(tooltips) {\n        if (!arguments.length) return this._xAxisTooltips;\n        this._xAxisTooltips = tooltips;\n        return this;\n    }\n\n    xAxisOverride(override) {\n        if (!arguments.length) return this._xAxisOverride;\n        this._xAxisOverride = override;\n        return this;\n    }\n\n    interbarProportion(proportion) {\n        if (!arguments.length) return this._interbarProportion;\n        this._interbarProportion = proportion;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    dispatch() {\n        return this._dispatch;\n    }\n\n    //------------------------------------------------------\n\n    render() {\n        if (!this._element) throw new Error("No element set for ColumnChart. See #element()");\n        if (!this._data) {\n            console.warn("No data set for ColumnChart. See #data()");\n            return;\n        }\n\n        const data = this.getTransformedData();\n        const keys = this.getKeys();\n\n        //------------------------------------------------\n        // Set up the SVG area\n\n        let topLevel = d3.select(this._element).select("svg");\n        if (topLevel.empty()) {\n            topLevel = d3.select(this._element).append("svg");\n        }\n\n        topLevel\n            .style("width", this._width + "px")\n            .style("height", this._height + "px");\n\n\n        // ---------------------------------\n        // Layout the showLegend.\n        //\n        // We do this now because we need to know how much space the legend\n        // takes up in order to finish calculating the margins.\n\n        const legendHeight = this.renderLegend();\n\n        //----------------------------------\n        // Calculate margins.\n\n        const margin = {top: 20, right: 20, bottom: 40, left: 40};\n        margin.bottom += legendHeight ? legendHeight + 20 : 0;\n\n        if (this._dataAxisLabel) margin.left += 20 + 12;\n        if (data) {\n            let maxLabelLength = 0;\n            data.forEach(d => {\n                d.data.forEach(d => {\n                    let length = this._xAxisTickFormat(this._x(d)).length;\n                    if (length > maxLabelLength) maxLabelLength = length;\n                })\n            });\n            margin.bottom += maxLabelLength * 2 + 10;    // space for axes labels.\n        }\n\n        const width = this._width - margin.left - margin.right,\n            height = this._height - margin.top - margin.bottom;\n\n        //----------------------------------\n        // Calculate scales and so on.\n\n        const x = d3.scaleBand()\n            .rangeRound([0, width])\n            .padding(this._interbarProportion !== null ? this._interbarProportion : (this._data.length > 1 ? 0.08 : 0.1));\n\n        const xGroup = d3.scaleBand()\n            .padding(0);\n\n        const y = d3.scaleLinear()\n            .rangeRound([height, 0])\n            .nice();\n        this._xscale = x;\n        this._xgroupscale = xGroup;\n        this._yscale = y;\n\n        // Scale the range of the data in the domains\n        x.domain(data.map(d => d.key));\n        xGroup.rangeRound([0, x.bandwidth()]).domain(keys);\n        y.domain([0, d3.max(data, d => d3.max(d.data, d => d._y))]);\n\n        //------------------------------\n\n        let svg = topLevel.select(\'.main-group\');\n\n        if (svg.empty()) {\n            svg = topLevel\n                .append("g")\n                .attr("class", "main-group");\n        }\n\n        svg.attr("transform", "translate(" + margin.left + "," + margin.top + ")");\n\n        //---------------------------------\n        // Get rid of current labels.\n        svg.select(".chart-labels")\n            .remove();\n\n        //---------------------------------\n        // append the rectangles for the bar chart\n        let groups = svg.select(".bars").selectAll(\'.group\');\n\n        if (groups.empty()) {\n            groups = svg\n                .append("g")\n                .attr("class", "bars")\n                .selectAll(".group");\n        }\n\n        svg.select(".bars")\n            .attr("transform", "translate(0, " + height + "), scale(1, -1)")\n\n        groups = groups.data(data);\n\n        groups.exit().remove();\n\n        // Adding new groups, and hence adding new bars to those groups.\n        groups.enter()\n            .append("g")\n            .attr("class", "group")\n            .attr("transform", d => "translate(" + x(d.key) + ",0)")\n            .attr("width", x.bandwidth())\n            .attr("height", "100%")\n            .merge(groups)\n            .interrupt("groups:move")\n            .transition("groups:move")\n            .attr("transform", d => "translate(" + x(d.key) + ",0)")\n            .attr("width", x.bandwidth())\n            .each((s_d, s_i, nodes) => {\n                let group = d3.select(nodes[s_i])\n\n                let bars = group.selectAll(".bar")\n                    .data(s_d.data);\n\n                bars.exit().remove();\n\n                bars.interrupt("bar:move")     // Animate the bars to their new position.\n                    .transition("bar:move")\n                    .attr("width", xGroup.bandwidth())\n                    .attr("x", d => xGroup(d._key))\n                    .attr("y", 0);\n\n                bars.enter()\n                    .append("rect")\n                    .attr("class", (d, i) => "bar series series-" + i)\n                    .attr("x", d => xGroup(d._key))\n                    .attr("y", 0)\n                    .attr("width", xGroup.bandwidth())\n                    .attr("height", 0)\n                    .style("fill", (d, i) => this.getSeriesColour(i))\n                    .style("cursor", "pointer")\n                    .on("mouseover", (d, i, nodes) => { // Darken the bar on mouse over\n                        d3.select(nodes[i])\n                            .interrupt("hover:colour")\n                            .transition("hover:colour")\n                            .duration(400)\n                            .style("fill", d3.hcl(this.getSeriesColour(i)).darker())\n                        this._dispatch.call("tooltipShow", this, {\n                            e: d3.event,\n                            point: d,\n                            series: s_d,\n                            seriesIndex: s_i,\n                            value: d._y\n                        })\n                    })\n                    .on("mouseout", (d, i, nodes) => { // bar is regular colour on mouse out.\n                        d3.select(nodes[i])\n                            .interrupt("hover:colour")\n                            .transition("hover:colour")\n                            .duration(400)\n                            .style("fill", this.getSeriesColour(i));\n                        this._dispatch.call("tooltipHide", this);\n                    })\n                    .on("click auxclick", (d, i, nodes) => {\n                        this._dispatch.call("elementClick", this, {\n                            e: d3.event,\n                            point: d,\n                            series: d._series,\n                            seriesIndex: s_i,\n                            value: this._y(d)\n                        })\n                    })\n                    .merge(bars)\n                    .interrupt("bar:growth")    // Animate bars growing.\n                    .transition("bar:growth")\n                    .delay((d) => {\n                        return this.calcBarGrowth(s_i, nodes.length);\n                    })\n                    .duration(this._duration)\n                    .style("fill", (d, i) => this.getSeriesColour(i))\n                    .attr("height", d => height - y(d._y));\n\n            })\n\n        // ---------------------------------\n        // Labels loaded after our first bar grows.\n        if (this._show_labels) {\n            svg.transition("bar:growth")\n                .on("end", (d, i, nodes) => {\n                    if (i < nodes.length - 1) return;\n                    this.renderLabels(svg, data, x, xGroup, y);\n                })\n        }\n\n        // ---------------------------------\n        // Draw the y axis data label.\n\n        if (this._dataAxisLabel) {\n            this.renderDataAxisLabel(height, margin);\n        }\n\n        // ---------------------------------\n        // Set the background colour\n\n        d3.select(this._element).select(".background").remove();\n        if (this._backgroundColour) {\n            d3.select(this._element).select("svg")\n                .append("rect")\n                .attr("class", "background")\n                .attr("width", "100%")\n                .attr("height", "100%")\n                .style("fill", this._backgroundColour)\n                .lower();\n        }\n\n        //---------------------------------\n        // add the Y gridlines\n        svg.call(this.grid, width, d3.axisLeft(y).ticks(5));\n\n        //---------------------------------\n        // axes\n        svg.call(this.xaxis, height, x.bandwidth(), d3.axisBottom(x).tickSize(0).tickPadding(5).tickFormat(this._xAxisTickFormat));\n        svg.call(this.yaxis, d3.axisLeft(y).ticks(5).tickFormat(this._tickFormat));\n    }\n\n    //------------------------------------------------------\n\n    /*\n     * Returns an object with two functions, #show() and #hide(),\n     * to show and hide the labels.\n     */\n    labels() {\n        return {\n\n            show: () => {\n                if (this._element) {\n                    let selection = this._element,\n                        data = this.getTransformedData(),\n                        xscale = this._xscale,\n                        xgroup = this._xgroupscale,\n                        yscale = this._yscale;\n\n                    if (selection) selection = d3.select(this._element).select("svg").select("g");\n                    if (!selection.empty() && data && xscale && yscale && xgroup) {\n                        let labels = selection.select(\'.chart-labels\');\n                        if (!labels.empty()) return;\n                        labels.remove()\n                        this.renderLabels(selection, data, xscale, xgroup, yscale, false);\n                    }\n                }\n\n            },\n\n            hide: () => {\n                if (this._element) {\n                    d3.select(this._element)\n                        .select(\'.chart-labels\')\n                        .interrupt("labels")\n                        .interrupt("labels:fade")\n                        .transition("labels:fade")\n                        .style("opacity", 0)\n                        .on("end", (d, i, nodes) => {\n                            d3.select(nodes[i]).remove();\n                        })\n                }\n            }\n        }\n    }\n\n    //------------------------------------------------------\n\n    renderLabels(selection, data, xscale, xgroup, yscale, animate) {\n        animate = animate === undefined ? true : animate;\n        selection.selectAll(".chart-labels").remove();\n\n        let labels = selection.append("g")\n            .attr("class", "chart-labels")\n            // .selectAll(".chart-label")\n            .selectAll(".label-group")\n            .data(data)\n\n        let maxWidth = 0;     // For calculating the max width of text.\n        let fontSize = 12;    // Our initial font size.\n        const buffer = 5;     // Buffer space between words and the top of a bar.\n        const calcDy = (ypos) => ypos < 10 ? fontSize + buffer : -buffer;\n\n        // Want to figure out if the label is too dark / light for the\n        // bar.\n        const getInvertedColor = (i) => {\n            let invertedColor = d3.hcl(this.getSeriesColour(i));\n            invertedColor.l += Math.min(invertedColor.l + 50, 100);\n            return invertedColor;\n        };\n        const shouldInvert = (i) => d3.hcl(this.getSeriesColour(i)).l < 60;\n\n        labels.enter().each((series, s_i, s_nodes) => {\n            let group = d3.select(s_nodes[s_i])\n                .append("g")\n                .attr("class", "label-group")\n                .attr("transform", d => "translate(" + xscale(d.key) + ",0)")\n                .selectAll(".chart-label")\n                .data(series.data)\n                .enter()\n                .each((d, i, nodes) => {\n                    let ypos = yscale(d._y);\n                    let dy = calcDy(ypos);\n                    let text = d3.select(nodes[i])\n                        .append("text")\n                        .text(this._labelFormat(d._y))\n                        .attr("class", "chart-label")\n                        .attr("y", ypos)\n                        .attr("dx", animate ? -15 : 0)\n                        .attr("dy", dy)\n                        .style("opacity", 0)\n                        .style("pointer-events", "none")\n                        // .style("font-family", "Open Sans, sans-serif")\n                        // .style("font-weight", "normal")\n                        // .style("font-size", fontSize + "px")\n                        .style("fill", dy > 0 && shouldInvert(i)? getInvertedColor(i).toString() : _Colours__WEBPACK_IMPORTED_MODULE_0__["colours"].eighteen.darkGrey);\n\n                    // Set the x position, which is based on width.\n                    const width = text.node().getBBox().width;\n                    maxWidth = Math.max(width, maxWidth);\n                    text\n                        .attr("x", xgroup(d._key) + xgroup.bandwidth() / 2 - width / 2);\n\n                    text\n                        .transition("labels")\n                        .delay(() => animate ? this.calcBarGrowth(s_i, s_nodes.length) : 0) // Delay in lockstep with bar growth.\n                        .duration(this._duration)\n                        .attr("dx", 0)\n                        .style("opacity", 1)\n                })\n        })\n\n\n        // Figure out if we don\'t have enough space to show our labels.\n        // We then want to resize, if possible.\n        if (xgroup.bandwidth() < maxWidth * 1.05) {\n            let scale = maxWidth / xgroup.bandwidth() * 1.05;\n            fontSize = Math.floor(fontSize / scale);\n\n            if (fontSize < 8) {\n                // The labels are too small.\n                labels.enter().selectAll("text").remove();\n            } else {\n                labels.enter()\n                    .merge(labels)\n                    .selectAll("text")\n                    .style("font-size", fontSize + "px")\n                    .each((d, i, nodes) => {\n                        const text = d3.select(nodes[i]);\n                        const width = text.node().getBBox().width;\n                        const dy = calcDy(d._y);\n\n                        text\n                            .attr("x", xgroup(d._key) + xgroup.bandwidth() / 2 - width / 2)\n                            .style("fill", dy > 0 && shouldInvert(i) ? getInvertedColor(i).toString() : _Colours__WEBPACK_IMPORTED_MODULE_0__["colours"].eighteen.darkGrey)\n                            .attr("dy", dy);\n                    })\n            }\n        }\n    }\n\n    //------------------------------------------------------\n\n    renderDataAxisLabel(height, margins) {\n        let svg = d3.select(this._element).select(\'svg\');\n        svg.selectAll(".data-labels").remove();\n\n        if (!this._dataAxisLabel) return;\n        let text = this._dataAxisLabel;\n        if (text.long) text = text.long;\n\n        let x = -(margins.top + height / 2);\n\n        let label = svg.append("g")\n            .attr("class", "data-labels")\n            .append("text")\n            .text(text)\n            .attr("transform", "rotate(-90 0,0) translate(" + x + ", 20)")\n            // .style("font-family", "Open Sans, sans-serif")\n            // .style("font-size", "12px")\n            // .style("font-style", "italic")\n            .style("fill", _Colours__WEBPACK_IMPORTED_MODULE_0__["colours"].eighteen.darkGrey);\n\n        let width = label.node().getBBox().width;\n        if (width >= height && this._dataAxisLabel.short) {\n            label.text(this._dataAxisLabel.short);\n            width = label.node().getBBox().width;\n        }\n\n        label.attr("dx", -width / 2);\n    }\n\n    //------------------------------------------------------\n\n    grid(selection, width, axis) {\n        selection.select(".grid").remove();\n\n        let grid = selection.append("g")\n            .attr("class", "grid")\n            .call(axis\n                .tickSize(-width)\n                .tickFormat("")\n            );\n\n        grid.selectAll("line")\n            .style("stroke", _Colours__WEBPACK_IMPORTED_MODULE_0__["colours"].eighteen.lightGrey);\n        grid.selectAll(".domain").remove();\n\n        grid\n            .lower() // Always ensure that this is earlier in the dom. Things must be drawn on top of it.\n            .style("opacity", 0)\n            .transition()\n            .delay(500)\n            .duration(500)\n            .style("opacity", 1);\n    }\n\n    //------------------------------------------------------\n\n    xaxis(selection, height, width, xaxis) {\n        selection.select(".x-axis").remove();\n        let axis = selection.append("g")\n            .attr("class", "x-axis")\n            .attr("transform", "translate(0," + height + ")")\n            .style("opacity", 0)\n            .call(xaxis);\n\n        axis.select(".domain").remove();\n\n        let max = 0;\n        const fontSize = 12;\n        axis.selectAll("text")\n            // .style("font-family", "Open Sans, sans-serif")\n            // .style("font-size", fontSize + "px")\n            .style("fill", _Colours__WEBPACK_IMPORTED_MODULE_0__["colours"].eighteen.darkGrey)\n            .nodes()\n            .forEach(text => max = Math.max(max, text.getBBox().width));\n\n        if (max >= width - 10) {\n            const bad = max >= width * 2;\n            const angle = bad ? -90 : -30;\n            const fontSize = width <= 13 ? 8 : 12;\n            const x = bad ? -fontSize : 0;\n            const y = bad ? 5 : 2;\n\n            axis.selectAll("text")\n                .style(\'text-anchor\', \'end\')\n                .style("font-size", fontSize + "px")\n                .attr("transform", () => "translate(" + x + "," + y + ") rotate(" + angle + " 0,0)")\n        }\n\n        axis\n            .transition()\n            .duration(1000)\n            .style("opacity", 1);\n    }\n\n    //------------------------------------------------------\n\n    yaxis(selection, axis) {\n        selection.select(".y-axis").remove();\n        let x = selection.append("g")\n            .attr("class", "y-axis")\n            .call(axis.tickSize(0).tickPadding(10))\n            .style("opacity", 0)\n            .transition()\n            .duration(1000)\n            .style("opacity", 1);\n\n        x.selectAll("text")\n            // .style("font-family", "Open Sans, sans-serif")\n            .style("fill", _Colours__WEBPACK_IMPORTED_MODULE_0__["colours"].eighteen.darkGrey)\n    }\n\n    //------------------------------------------------------\n\n    calcBarGrowth(i, max) {\n        if (max < 10) return i * this._BAR_GROWTH / 2;\n        if (max < 35) return i * this._BAR_GROWTH / 4;\n        return 1;\n    }\n\n    getSeriesColour(i) {\n        if (i < 0 || !this._colours) return _Colours__WEBPACK_IMPORTED_MODULE_0__["colours"].eighteen.midGrey;\n\n        i = i % this._colours.length;\n        return this._colours[i];\n    }\n\n    getSortedData() {\n        let data = this._data;\n        if (!data || !data.length) return [];\n\n        data = this._data.sort((lhs, rhs) => {\n            lhs = lhs.key.toLowerCase();\n            rhs = rhs.key.toLowerCase();\n\n            if (lhs === rhs) return 0;\n            if (lhs < rhs) return -1;\n            return 1;\n        });\n\n        return data;\n    }\n\n    getTransformedData() {\n        let data = this.getSortedData();\n        if (!data || !data.length) return [];\n\n        let results = [];\n\n        const getX = d => this._xAxisOverride ? this._xAxisOverride[this._x(d)] : this._x(d);\n\n        data.forEach((series, s_i) => {\n            series.values.forEach((d, d_i) => {\n                let field = results.find(bucket => bucket.key === getX(d));\n                if (!field) {\n                    field = {\n                        data: [],\n                        key: getX(d)\n                    };\n                    results.push(field);\n                }\n\n                field.data.push(Object.assign({\n                    _series: series,\n                    _s_i: s_i,\n                    _key: series.key,\n                    _y: this._y(d)\n                }, d));\n            })\n        });\n\n        return results;\n    }\n\n    getKeys() {\n        let data = this._data;\n        if (!data || !data.length) return [];\n\n        return [...new Set(data.map(d => d.key))]\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvQ29sdW1uQ2hhcnQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9iM2pzLy4vc3JjL0NvbHVtbkNoYXJ0LmpzPzNlNDAiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChDKSAyMDEzLTIwMTQsIDIwMTggQnJhbmRzRXllIChQVFkpIExURFxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpc1xuLy8gc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlXG4vLyB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksXG4vLyAgICAgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0b1xuLy8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcbi8vIGNvbmRpdGlvbnM6XG4vL1xuLy8gICAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuLy8gY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyAgICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUiBJTVBMSUVELFxuLy8gICAgIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBXG4vLyBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUXG4vLyBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0Zcbi8vIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRVxuLy8gT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCB7Y29sb3Vyc30gZnJvbSAnLi9Db2xvdXJzJztcbmltcG9ydCB7Q2hhcnR9IGZyb20gJy4vQ2hhcnQnO1xuXG5cbmV4cG9ydCBjbGFzcyBDb2x1bW5DaGFydCBleHRlbmRzIENoYXJ0IHtcblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBkYXRhKGRhdGEpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fZGF0YTtcbiAgICAgICAgaWYgKGRhdGEgJiYgZGF0YVswXS5rZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZGF0YSA9IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGtleTogXCJzZXJpZXMgMVwiLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZXM6IGRhdGFcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgZWxlbWVudChlbGVtZW50KSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX2VsZW1lbnQ7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgc2hvd0xhYmVscyhzaG93KSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3Nob3dfbGFiZWxzO1xuICAgICAgICB0aGlzLl9zaG93X2xhYmVscyA9IHNob3c7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvLyB0b2RvIGRpc3BhdGNoXG4gICAgc2hvd0xlZ2VuZChzaG93KSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3Nob3dfbGVnZW5kO1xuICAgICAgICB0aGlzLl9zaG93X2xlZ2VuZCA9IHNob3c7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB4KHgpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5feDtcbiAgICAgICAgdGhpcy5feCA9IHg7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB5KHkpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5feTtcbiAgICAgICAgdGhpcy5feSA9IHk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB3aWR0aCh3aWR0aCkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl93aWR0aDtcbiAgICAgICAgdGhpcy5fd2lkdGggPSB3aWR0aDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGhlaWdodChoZWlnaHQpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5faGVpZ2h0O1xuICAgICAgICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBjb2xvdXJzKGNvbG91cnMpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fY29sb3VycztcbiAgICAgICAgdGhpcy5fY29sb3VycyA9IGNvbG91cnM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBiYWNrZ3JvdW5kQ29sb3VyKGNvbG91cikge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9iYWNrZ3JvdW5kQ29sb3VyO1xuICAgICAgICB0aGlzLl9iYWNrZ3JvdW5kQ29sb3VyID0gY29sb3VyIHx8IFwiI0ZGRlwiOyAvLyBuZXZlciBzZXQgaXQgdG8gbnVsbC5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHRpY2tGb3JtYXQoZm9ybWF0KSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3RpY2tGb3JtYXQ7XG4gICAgICAgIHRoaXMuX3RpY2tGb3JtYXQgPSBmb3JtYXQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB4QXhpc1RpY2tGb3JtYXQoZm9ybWF0KSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3hBeGlzVGlja0Zvcm1hdDtcbiAgICAgICAgdGhpcy5feEF4aXNUaWNrRm9ybWF0ID0gZm9ybWF0IHx8IChkID0+IGQudG9TdHJpbmcoKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBsYWJlbEZvcm1hdChmb3JtYXQpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fbGFiZWxGb3JtYXQ7XG4gICAgICAgIHRoaXMuX2xhYmVsRm9ybWF0ID0gZm9ybWF0IHx8IChkID0+IGQudG9TdHJpbmcoKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvLyB0b2RvIG1pc3NpbmdcbiAgICBsYWJlbENvbXByZXNzaW9uKGNvbXByZXNzaW9uKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX2NvbXByZXNzaW9uO1xuICAgICAgICB0aGlzLl9jb21wcmVzc2lvbiA9IGNvbXByZXNzaW9uO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLy90b2RvIG1pc3NpbmdcbiAgICBkYXRhQXhpc0xhYmVsKGxhYmVsKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX2RhdGFBeGlzTGFiZWw7XG4gICAgICAgIHRoaXMuX2RhdGFBeGlzTGFiZWwgPSBsYWJlbDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHRvb2x0aXAodG9vbHRpcCkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl90b29sdGlwO1xuICAgICAgICB0aGlzLl90b29sdGlwID0gdG9vbHRpcDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGZvcmNlWShmb3JjZSkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9mb3JjZVk7XG4gICAgICAgIHRoaXMuX2ZvcmNlWSA9IGZvcmNlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vLyB0b2RvIG1pc3NpbmdcbiAgICBkdXJhdGlvbihkdXJhdGlvbikge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9kdXJhdGlvbjtcbiAgICAgICAgdGhpcy5fZHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4vLyB0b2RvIG1pc3NpbmdcbiAgICBjb2Fyc2VuZXNzKGNvYXJzZW5lc3MpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fY29hcnNlbmVzcztcbiAgICAgICAgdGhpcy5fY29hcnNlbmVzcyA9IGNvYXJzZW5lc3M7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIHRvZG8gbWlzc2luZ1xuICAgIHBhZGRpbmcocGFkZGluZykge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9wYWRkaW5nO1xuICAgICAgICB0aGlzLl9wYWRkaW5nID0gcGFkZGluZztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gdG9kbyBtaXNzaW5nXG4gICAgeEF4aXNUb29sdGlwcyh0b29sdGlwcykge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl94QXhpc1Rvb2x0aXBzO1xuICAgICAgICB0aGlzLl94QXhpc1Rvb2x0aXBzID0gdG9vbHRpcHM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHhBeGlzT3ZlcnJpZGUob3ZlcnJpZGUpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5feEF4aXNPdmVycmlkZTtcbiAgICAgICAgdGhpcy5feEF4aXNPdmVycmlkZSA9IG92ZXJyaWRlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpbnRlcmJhclByb3BvcnRpb24ocHJvcG9ydGlvbikge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9pbnRlcmJhclByb3BvcnRpb247XG4gICAgICAgIHRoaXMuX2ludGVyYmFyUHJvcG9ydGlvbiA9IHByb3BvcnRpb247XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBkaXNwYXRjaCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc3BhdGNoO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGlmICghdGhpcy5fZWxlbWVudCkgdGhyb3cgbmV3IEVycm9yKFwiTm8gZWxlbWVudCBzZXQgZm9yIENvbHVtbkNoYXJ0LiBTZWUgI2VsZW1lbnQoKVwiKTtcbiAgICAgICAgaWYgKCF0aGlzLl9kYXRhKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJObyBkYXRhIHNldCBmb3IgQ29sdW1uQ2hhcnQuIFNlZSAjZGF0YSgpXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMuZ2V0VHJhbnNmb3JtZWREYXRhKCk7XG4gICAgICAgIGNvbnN0IGtleXMgPSB0aGlzLmdldEtleXMoKTtcblxuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBTZXQgdXAgdGhlIFNWRyBhcmVhXG5cbiAgICAgICAgbGV0IHRvcExldmVsID0gZDMuc2VsZWN0KHRoaXMuX2VsZW1lbnQpLnNlbGVjdChcInN2Z1wiKTtcbiAgICAgICAgaWYgKHRvcExldmVsLmVtcHR5KCkpIHtcbiAgICAgICAgICAgIHRvcExldmVsID0gZDMuc2VsZWN0KHRoaXMuX2VsZW1lbnQpLmFwcGVuZChcInN2Z1wiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRvcExldmVsXG4gICAgICAgICAgICAuc3R5bGUoXCJ3aWR0aFwiLCB0aGlzLl93aWR0aCArIFwicHhcIilcbiAgICAgICAgICAgIC5zdHlsZShcImhlaWdodFwiLCB0aGlzLl9oZWlnaHQgKyBcInB4XCIpO1xuXG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIExheW91dCB0aGUgc2hvd0xlZ2VuZC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gV2UgZG8gdGhpcyBub3cgYmVjYXVzZSB3ZSBuZWVkIHRvIGtub3cgaG93IG11Y2ggc3BhY2UgdGhlIGxlZ2VuZFxuICAgICAgICAvLyB0YWtlcyB1cCBpbiBvcmRlciB0byBmaW5pc2ggY2FsY3VsYXRpbmcgdGhlIG1hcmdpbnMuXG5cbiAgICAgICAgY29uc3QgbGVnZW5kSGVpZ2h0ID0gdGhpcy5yZW5kZXJMZWdlbmQoKTtcblxuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gQ2FsY3VsYXRlIG1hcmdpbnMuXG5cbiAgICAgICAgY29uc3QgbWFyZ2luID0ge3RvcDogMjAsIHJpZ2h0OiAyMCwgYm90dG9tOiA0MCwgbGVmdDogNDB9O1xuICAgICAgICBtYXJnaW4uYm90dG9tICs9IGxlZ2VuZEhlaWdodCA/IGxlZ2VuZEhlaWdodCArIDIwIDogMDtcblxuICAgICAgICBpZiAodGhpcy5fZGF0YUF4aXNMYWJlbCkgbWFyZ2luLmxlZnQgKz0gMjAgKyAxMjtcbiAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgIGxldCBtYXhMYWJlbExlbmd0aCA9IDA7XG4gICAgICAgICAgICBkYXRhLmZvckVhY2goZCA9PiB7XG4gICAgICAgICAgICAgICAgZC5kYXRhLmZvckVhY2goZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBsZW5ndGggPSB0aGlzLl94QXhpc1RpY2tGb3JtYXQodGhpcy5feChkKSkubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGVuZ3RoID4gbWF4TGFiZWxMZW5ndGgpIG1heExhYmVsTGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG1hcmdpbi5ib3R0b20gKz0gbWF4TGFiZWxMZW5ndGggKiAyICsgMTA7ICAgIC8vIHNwYWNlIGZvciBheGVzIGxhYmVscy5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHdpZHRoID0gdGhpcy5fd2lkdGggLSBtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodCxcbiAgICAgICAgICAgIGhlaWdodCA9IHRoaXMuX2hlaWdodCAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tO1xuXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBDYWxjdWxhdGUgc2NhbGVzIGFuZCBzbyBvbi5cblxuICAgICAgICBjb25zdCB4ID0gZDMuc2NhbGVCYW5kKClcbiAgICAgICAgICAgIC5yYW5nZVJvdW5kKFswLCB3aWR0aF0pXG4gICAgICAgICAgICAucGFkZGluZyh0aGlzLl9pbnRlcmJhclByb3BvcnRpb24gIT09IG51bGwgPyB0aGlzLl9pbnRlcmJhclByb3BvcnRpb24gOiAodGhpcy5fZGF0YS5sZW5ndGggPiAxID8gMC4wOCA6IDAuMSkpO1xuXG4gICAgICAgIGNvbnN0IHhHcm91cCA9IGQzLnNjYWxlQmFuZCgpXG4gICAgICAgICAgICAucGFkZGluZygwKTtcblxuICAgICAgICBjb25zdCB5ID0gZDMuc2NhbGVMaW5lYXIoKVxuICAgICAgICAgICAgLnJhbmdlUm91bmQoW2hlaWdodCwgMF0pXG4gICAgICAgICAgICAubmljZSgpO1xuICAgICAgICB0aGlzLl94c2NhbGUgPSB4O1xuICAgICAgICB0aGlzLl94Z3JvdXBzY2FsZSA9IHhHcm91cDtcbiAgICAgICAgdGhpcy5feXNjYWxlID0geTtcblxuICAgICAgICAvLyBTY2FsZSB0aGUgcmFuZ2Ugb2YgdGhlIGRhdGEgaW4gdGhlIGRvbWFpbnNcbiAgICAgICAgeC5kb21haW4oZGF0YS5tYXAoZCA9PiBkLmtleSkpO1xuICAgICAgICB4R3JvdXAucmFuZ2VSb3VuZChbMCwgeC5iYW5kd2lkdGgoKV0pLmRvbWFpbihrZXlzKTtcbiAgICAgICAgeS5kb21haW4oWzAsIGQzLm1heChkYXRhLCBkID0+IGQzLm1heChkLmRhdGEsIGQgPT4gZC5feSkpXSk7XG5cbiAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICBsZXQgc3ZnID0gdG9wTGV2ZWwuc2VsZWN0KCcubWFpbi1ncm91cCcpO1xuXG4gICAgICAgIGlmIChzdmcuZW1wdHkoKSkge1xuICAgICAgICAgICAgc3ZnID0gdG9wTGV2ZWxcbiAgICAgICAgICAgICAgICAuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJtYWluLWdyb3VwXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3ZnLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyBtYXJnaW4ubGVmdCArIFwiLFwiICsgbWFyZ2luLnRvcCArIFwiKVwiKTtcblxuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBHZXQgcmlkIG9mIGN1cnJlbnQgbGFiZWxzLlxuICAgICAgICBzdmcuc2VsZWN0KFwiLmNoYXJ0LWxhYmVsc1wiKVxuICAgICAgICAgICAgLnJlbW92ZSgpO1xuXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIGFwcGVuZCB0aGUgcmVjdGFuZ2xlcyBmb3IgdGhlIGJhciBjaGFydFxuICAgICAgICBsZXQgZ3JvdXBzID0gc3ZnLnNlbGVjdChcIi5iYXJzXCIpLnNlbGVjdEFsbCgnLmdyb3VwJyk7XG5cbiAgICAgICAgaWYgKGdyb3Vwcy5lbXB0eSgpKSB7XG4gICAgICAgICAgICBncm91cHMgPSBzdmdcbiAgICAgICAgICAgICAgICAuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJiYXJzXCIpXG4gICAgICAgICAgICAgICAgLnNlbGVjdEFsbChcIi5ncm91cFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN2Zy5zZWxlY3QoXCIuYmFyc1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoMCwgXCIgKyBoZWlnaHQgKyBcIiksIHNjYWxlKDEsIC0xKVwiKVxuXG4gICAgICAgIGdyb3VwcyA9IGdyb3Vwcy5kYXRhKGRhdGEpO1xuXG4gICAgICAgIGdyb3Vwcy5leGl0KCkucmVtb3ZlKCk7XG5cbiAgICAgICAgLy8gQWRkaW5nIG5ldyBncm91cHMsIGFuZCBoZW5jZSBhZGRpbmcgbmV3IGJhcnMgdG8gdGhvc2UgZ3JvdXBzLlxuICAgICAgICBncm91cHMuZW50ZXIoKVxuICAgICAgICAgICAgLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJncm91cFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgZCA9PiBcInRyYW5zbGF0ZShcIiArIHgoZC5rZXkpICsgXCIsMClcIilcbiAgICAgICAgICAgIC5hdHRyKFwid2lkdGhcIiwgeC5iYW5kd2lkdGgoKSlcbiAgICAgICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIFwiMTAwJVwiKVxuICAgICAgICAgICAgLm1lcmdlKGdyb3VwcylcbiAgICAgICAgICAgIC5pbnRlcnJ1cHQoXCJncm91cHM6bW92ZVwiKVxuICAgICAgICAgICAgLnRyYW5zaXRpb24oXCJncm91cHM6bW92ZVwiKVxuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgZCA9PiBcInRyYW5zbGF0ZShcIiArIHgoZC5rZXkpICsgXCIsMClcIilcbiAgICAgICAgICAgIC5hdHRyKFwid2lkdGhcIiwgeC5iYW5kd2lkdGgoKSlcbiAgICAgICAgICAgIC5lYWNoKChzX2QsIHNfaSwgbm9kZXMpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgZ3JvdXAgPSBkMy5zZWxlY3Qobm9kZXNbc19pXSlcblxuICAgICAgICAgICAgICAgIGxldCBiYXJzID0gZ3JvdXAuc2VsZWN0QWxsKFwiLmJhclwiKVxuICAgICAgICAgICAgICAgICAgICAuZGF0YShzX2QuZGF0YSk7XG5cbiAgICAgICAgICAgICAgICBiYXJzLmV4aXQoKS5yZW1vdmUoKTtcblxuICAgICAgICAgICAgICAgIGJhcnMuaW50ZXJydXB0KFwiYmFyOm1vdmVcIikgICAgIC8vIEFuaW1hdGUgdGhlIGJhcnMgdG8gdGhlaXIgbmV3IHBvc2l0aW9uLlxuICAgICAgICAgICAgICAgICAgICAudHJhbnNpdGlvbihcImJhcjptb3ZlXCIpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFwid2lkdGhcIiwgeEdyb3VwLmJhbmR3aWR0aCgpKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcInhcIiwgZCA9PiB4R3JvdXAoZC5fa2V5KSlcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ5XCIsIDApO1xuXG4gICAgICAgICAgICAgICAgYmFycy5lbnRlcigpXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoXCJyZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgKGQsIGkpID0+IFwiYmFyIHNlcmllcyBzZXJpZXMtXCIgKyBpKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcInhcIiwgZCA9PiB4R3JvdXAoZC5fa2V5KSlcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ5XCIsIDApXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFwid2lkdGhcIiwgeEdyb3VwLmJhbmR3aWR0aCgpKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcImhlaWdodFwiLCAwKVxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIChkLCBpKSA9PiB0aGlzLmdldFNlcmllc0NvbG91cihpKSlcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwiY3Vyc29yXCIsIFwicG9pbnRlclwiKVxuICAgICAgICAgICAgICAgICAgICAub24oXCJtb3VzZW92ZXJcIiwgKGQsIGksIG5vZGVzKSA9PiB7IC8vIERhcmtlbiB0aGUgYmFyIG9uIG1vdXNlIG92ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGQzLnNlbGVjdChub2Rlc1tpXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuaW50ZXJydXB0KFwiaG92ZXI6Y29sb3VyXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRyYW5zaXRpb24oXCJob3Zlcjpjb2xvdXJcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24oNDAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcImZpbGxcIiwgZDMuaGNsKHRoaXMuZ2V0U2VyaWVzQ29sb3VyKGkpKS5kYXJrZXIoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3BhdGNoLmNhbGwoXCJ0b29sdGlwU2hvd1wiLCB0aGlzLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZTogZDMuZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQ6IGQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzOiBzX2QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzSW5kZXg6IHNfaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZC5feVxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLm9uKFwibW91c2VvdXRcIiwgKGQsIGksIG5vZGVzKSA9PiB7IC8vIGJhciBpcyByZWd1bGFyIGNvbG91ciBvbiBtb3VzZSBvdXQuXG4gICAgICAgICAgICAgICAgICAgICAgICBkMy5zZWxlY3Qobm9kZXNbaV0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmludGVycnVwdChcImhvdmVyOmNvbG91clwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKFwiaG92ZXI6Y29sb3VyXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKDQwMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIHRoaXMuZ2V0U2VyaWVzQ29sb3VyKGkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3BhdGNoLmNhbGwoXCJ0b29sdGlwSGlkZVwiLCB0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLm9uKFwiY2xpY2sgYXV4Y2xpY2tcIiwgKGQsIGksIG5vZGVzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXNwYXRjaC5jYWxsKFwiZWxlbWVudENsaWNrXCIsIHRoaXMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlOiBkMy5ldmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludDogZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXM6IGQuX3NlcmllcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXNJbmRleDogc19pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLl95KGQpXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAubWVyZ2UoYmFycylcbiAgICAgICAgICAgICAgICAgICAgLmludGVycnVwdChcImJhcjpncm93dGhcIikgICAgLy8gQW5pbWF0ZSBiYXJzIGdyb3dpbmcuXG4gICAgICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKFwiYmFyOmdyb3d0aFwiKVxuICAgICAgICAgICAgICAgICAgICAuZGVsYXkoKGQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNhbGNCYXJHcm93dGgoc19pLCBub2Rlcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24odGhpcy5fZHVyYXRpb24pXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZShcImZpbGxcIiwgKGQsIGkpID0+IHRoaXMuZ2V0U2VyaWVzQ29sb3VyKGkpKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcImhlaWdodFwiLCBkID0+IGhlaWdodCAtIHkoZC5feSkpO1xuXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBMYWJlbHMgbG9hZGVkIGFmdGVyIG91ciBmaXJzdCBiYXIgZ3Jvd3MuXG4gICAgICAgIGlmICh0aGlzLl9zaG93X2xhYmVscykge1xuICAgICAgICAgICAgc3ZnLnRyYW5zaXRpb24oXCJiYXI6Z3Jvd3RoXCIpXG4gICAgICAgICAgICAgICAgLm9uKFwiZW5kXCIsIChkLCBpLCBub2RlcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA8IG5vZGVzLmxlbmd0aCAtIDEpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJMYWJlbHMoc3ZnLCBkYXRhLCB4LCB4R3JvdXAsIHkpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gRHJhdyB0aGUgeSBheGlzIGRhdGEgbGFiZWwuXG5cbiAgICAgICAgaWYgKHRoaXMuX2RhdGFBeGlzTGFiZWwpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyRGF0YUF4aXNMYWJlbChoZWlnaHQsIG1hcmdpbik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gU2V0IHRoZSBiYWNrZ3JvdW5kIGNvbG91clxuXG4gICAgICAgIGQzLnNlbGVjdCh0aGlzLl9lbGVtZW50KS5zZWxlY3QoXCIuYmFja2dyb3VuZFwiKS5yZW1vdmUoKTtcbiAgICAgICAgaWYgKHRoaXMuX2JhY2tncm91bmRDb2xvdXIpIHtcbiAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzLl9lbGVtZW50KS5zZWxlY3QoXCJzdmdcIilcbiAgICAgICAgICAgICAgICAuYXBwZW5kKFwicmVjdFwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJiYWNrZ3JvdW5kXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCBcIjEwMCVcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcImhlaWdodFwiLCBcIjEwMCVcIilcbiAgICAgICAgICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIHRoaXMuX2JhY2tncm91bmRDb2xvdXIpXG4gICAgICAgICAgICAgICAgLmxvd2VyKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBhZGQgdGhlIFkgZ3JpZGxpbmVzXG4gICAgICAgIHN2Zy5jYWxsKHRoaXMuZ3JpZCwgd2lkdGgsIGQzLmF4aXNMZWZ0KHkpLnRpY2tzKDUpKTtcblxuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBheGVzXG4gICAgICAgIHN2Zy5jYWxsKHRoaXMueGF4aXMsIGhlaWdodCwgeC5iYW5kd2lkdGgoKSwgZDMuYXhpc0JvdHRvbSh4KS50aWNrU2l6ZSgwKS50aWNrUGFkZGluZyg1KS50aWNrRm9ybWF0KHRoaXMuX3hBeGlzVGlja0Zvcm1hdCkpO1xuICAgICAgICBzdmcuY2FsbCh0aGlzLnlheGlzLCBkMy5heGlzTGVmdCh5KS50aWNrcyg1KS50aWNrRm9ybWF0KHRoaXMuX3RpY2tGb3JtYXQpKTtcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLypcbiAgICAgKiBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIHR3byBmdW5jdGlvbnMsICNzaG93KCkgYW5kICNoaWRlKCksXG4gICAgICogdG8gc2hvdyBhbmQgaGlkZSB0aGUgbGFiZWxzLlxuICAgICAqL1xuICAgIGxhYmVscygpIHtcbiAgICAgICAgcmV0dXJuIHtcblxuICAgICAgICAgICAgc2hvdzogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9lbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzZWxlY3Rpb24gPSB0aGlzLl9lbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHRoaXMuZ2V0VHJhbnNmb3JtZWREYXRhKCksXG4gICAgICAgICAgICAgICAgICAgICAgICB4c2NhbGUgPSB0aGlzLl94c2NhbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB4Z3JvdXAgPSB0aGlzLl94Z3JvdXBzY2FsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHlzY2FsZSA9IHRoaXMuX3lzY2FsZTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uKSBzZWxlY3Rpb24gPSBkMy5zZWxlY3QodGhpcy5fZWxlbWVudCkuc2VsZWN0KFwic3ZnXCIpLnNlbGVjdChcImdcIik7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2VsZWN0aW9uLmVtcHR5KCkgJiYgZGF0YSAmJiB4c2NhbGUgJiYgeXNjYWxlICYmIHhncm91cCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGxhYmVscyA9IHNlbGVjdGlvbi5zZWxlY3QoJy5jaGFydC1sYWJlbHMnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbGFiZWxzLmVtcHR5KCkpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVscy5yZW1vdmUoKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJMYWJlbHMoc2VsZWN0aW9uLCBkYXRhLCB4c2NhbGUsIHhncm91cCwgeXNjYWxlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGhpZGU6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBkMy5zZWxlY3QodGhpcy5fZWxlbWVudClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZWxlY3QoJy5jaGFydC1sYWJlbHMnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmludGVycnVwdChcImxhYmVsc1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmludGVycnVwdChcImxhYmVsczpmYWRlXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAudHJhbnNpdGlvbihcImxhYmVsczpmYWRlXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDApXG4gICAgICAgICAgICAgICAgICAgICAgICAub24oXCJlbmRcIiwgKGQsIGksIG5vZGVzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZDMuc2VsZWN0KG5vZGVzW2ldKS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHJlbmRlckxhYmVscyhzZWxlY3Rpb24sIGRhdGEsIHhzY2FsZSwgeGdyb3VwLCB5c2NhbGUsIGFuaW1hdGUpIHtcbiAgICAgICAgYW5pbWF0ZSA9IGFuaW1hdGUgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBhbmltYXRlO1xuICAgICAgICBzZWxlY3Rpb24uc2VsZWN0QWxsKFwiLmNoYXJ0LWxhYmVsc1wiKS5yZW1vdmUoKTtcblxuICAgICAgICBsZXQgbGFiZWxzID0gc2VsZWN0aW9uLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJjaGFydC1sYWJlbHNcIilcbiAgICAgICAgICAgIC8vIC5zZWxlY3RBbGwoXCIuY2hhcnQtbGFiZWxcIilcbiAgICAgICAgICAgIC5zZWxlY3RBbGwoXCIubGFiZWwtZ3JvdXBcIilcbiAgICAgICAgICAgIC5kYXRhKGRhdGEpXG5cbiAgICAgICAgbGV0IG1heFdpZHRoID0gMDsgICAgIC8vIEZvciBjYWxjdWxhdGluZyB0aGUgbWF4IHdpZHRoIG9mIHRleHQuXG4gICAgICAgIGxldCBmb250U2l6ZSA9IDEyOyAgICAvLyBPdXIgaW5pdGlhbCBmb250IHNpemUuXG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IDU7ICAgICAvLyBCdWZmZXIgc3BhY2UgYmV0d2VlbiB3b3JkcyBhbmQgdGhlIHRvcCBvZiBhIGJhci5cbiAgICAgICAgY29uc3QgY2FsY0R5ID0gKHlwb3MpID0+IHlwb3MgPCAxMCA/IGZvbnRTaXplICsgYnVmZmVyIDogLWJ1ZmZlcjtcblxuICAgICAgICAvLyBXYW50IHRvIGZpZ3VyZSBvdXQgaWYgdGhlIGxhYmVsIGlzIHRvbyBkYXJrIC8gbGlnaHQgZm9yIHRoZVxuICAgICAgICAvLyBiYXIuXG4gICAgICAgIGNvbnN0IGdldEludmVydGVkQ29sb3IgPSAoaSkgPT4ge1xuICAgICAgICAgICAgbGV0IGludmVydGVkQ29sb3IgPSBkMy5oY2wodGhpcy5nZXRTZXJpZXNDb2xvdXIoaSkpO1xuICAgICAgICAgICAgaW52ZXJ0ZWRDb2xvci5sICs9IE1hdGgubWluKGludmVydGVkQ29sb3IubCArIDUwLCAxMDApO1xuICAgICAgICAgICAgcmV0dXJuIGludmVydGVkQ29sb3I7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHNob3VsZEludmVydCA9IChpKSA9PiBkMy5oY2wodGhpcy5nZXRTZXJpZXNDb2xvdXIoaSkpLmwgPCA2MDtcblxuICAgICAgICBsYWJlbHMuZW50ZXIoKS5lYWNoKChzZXJpZXMsIHNfaSwgc19ub2RlcykgPT4ge1xuICAgICAgICAgICAgbGV0IGdyb3VwID0gZDMuc2VsZWN0KHNfbm9kZXNbc19pXSlcbiAgICAgICAgICAgICAgICAuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJsYWJlbC1ncm91cFwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIGQgPT4gXCJ0cmFuc2xhdGUoXCIgKyB4c2NhbGUoZC5rZXkpICsgXCIsMClcIilcbiAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKFwiLmNoYXJ0LWxhYmVsXCIpXG4gICAgICAgICAgICAgICAgLmRhdGEoc2VyaWVzLmRhdGEpXG4gICAgICAgICAgICAgICAgLmVudGVyKClcbiAgICAgICAgICAgICAgICAuZWFjaCgoZCwgaSwgbm9kZXMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHlwb3MgPSB5c2NhbGUoZC5feSk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkeSA9IGNhbGNEeSh5cG9zKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRleHQgPSBkMy5zZWxlY3Qobm9kZXNbaV0pXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRleHQodGhpcy5fbGFiZWxGb3JtYXQoZC5feSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwiY2hhcnQtbGFiZWxcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwieVwiLCB5cG9zKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJkeFwiLCBhbmltYXRlID8gLTE1IDogMClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiZHlcIiwgZHkpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDApXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJwb2ludGVyLWV2ZW50c1wiLCBcIm5vbmVcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIC5zdHlsZShcImZvbnQtZmFtaWx5XCIsIFwiT3BlbiBTYW5zLCBzYW5zLXNlcmlmXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAuc3R5bGUoXCJmb250LXdlaWdodFwiLCBcIm5vcm1hbFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gLnN0eWxlKFwiZm9udC1zaXplXCIsIGZvbnRTaXplICsgXCJweFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBkeSA+IDAgJiYgc2hvdWxkSW52ZXJ0KGkpPyBnZXRJbnZlcnRlZENvbG9yKGkpLnRvU3RyaW5nKCkgOiBjb2xvdXJzLmVpZ2h0ZWVuLmRhcmtHcmV5KTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBTZXQgdGhlIHggcG9zaXRpb24sIHdoaWNoIGlzIGJhc2VkIG9uIHdpZHRoLlxuICAgICAgICAgICAgICAgICAgICBjb25zdCB3aWR0aCA9IHRleHQubm9kZSgpLmdldEJCb3goKS53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgbWF4V2lkdGggPSBNYXRoLm1heCh3aWR0aCwgbWF4V2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICB0ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcInhcIiwgeGdyb3VwKGQuX2tleSkgKyB4Z3JvdXAuYmFuZHdpZHRoKCkgLyAyIC0gd2lkdGggLyAyKTtcblxuICAgICAgICAgICAgICAgICAgICB0ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICAudHJhbnNpdGlvbihcImxhYmVsc1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmRlbGF5KCgpID0+IGFuaW1hdGUgPyB0aGlzLmNhbGNCYXJHcm93dGgoc19pLCBzX25vZGVzLmxlbmd0aCkgOiAwKSAvLyBEZWxheSBpbiBsb2Nrc3RlcCB3aXRoIGJhciBncm93dGguXG4gICAgICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24odGhpcy5fZHVyYXRpb24pXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcImR4XCIsIDApXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDEpXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgfSlcblxuXG4gICAgICAgIC8vIEZpZ3VyZSBvdXQgaWYgd2UgZG9uJ3QgaGF2ZSBlbm91Z2ggc3BhY2UgdG8gc2hvdyBvdXIgbGFiZWxzLlxuICAgICAgICAvLyBXZSB0aGVuIHdhbnQgdG8gcmVzaXplLCBpZiBwb3NzaWJsZS5cbiAgICAgICAgaWYgKHhncm91cC5iYW5kd2lkdGgoKSA8IG1heFdpZHRoICogMS4wNSkge1xuICAgICAgICAgICAgbGV0IHNjYWxlID0gbWF4V2lkdGggLyB4Z3JvdXAuYmFuZHdpZHRoKCkgKiAxLjA1O1xuICAgICAgICAgICAgZm9udFNpemUgPSBNYXRoLmZsb29yKGZvbnRTaXplIC8gc2NhbGUpO1xuXG4gICAgICAgICAgICBpZiAoZm9udFNpemUgPCA4KSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGxhYmVscyBhcmUgdG9vIHNtYWxsLlxuICAgICAgICAgICAgICAgIGxhYmVscy5lbnRlcigpLnNlbGVjdEFsbChcInRleHRcIikucmVtb3ZlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxhYmVscy5lbnRlcigpXG4gICAgICAgICAgICAgICAgICAgIC5tZXJnZShsYWJlbHMpXG4gICAgICAgICAgICAgICAgICAgIC5zZWxlY3RBbGwoXCJ0ZXh0XCIpXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZShcImZvbnQtc2l6ZVwiLCBmb250U2l6ZSArIFwicHhcIilcbiAgICAgICAgICAgICAgICAgICAgLmVhY2goKGQsIGksIG5vZGVzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXh0ID0gZDMuc2VsZWN0KG5vZGVzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gdGV4dC5ub2RlKCkuZ2V0QkJveCgpLndpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZHkgPSBjYWxjRHkoZC5feSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcInhcIiwgeGdyb3VwKGQuX2tleSkgKyB4Z3JvdXAuYmFuZHdpZHRoKCkgLyAyIC0gd2lkdGggLyAyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcImZpbGxcIiwgZHkgPiAwICYmIHNob3VsZEludmVydChpKSA/IGdldEludmVydGVkQ29sb3IoaSkudG9TdHJpbmcoKSA6IGNvbG91cnMuZWlnaHRlZW4uZGFya0dyZXkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJkeVwiLCBkeSk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgcmVuZGVyRGF0YUF4aXNMYWJlbChoZWlnaHQsIG1hcmdpbnMpIHtcbiAgICAgICAgbGV0IHN2ZyA9IGQzLnNlbGVjdCh0aGlzLl9lbGVtZW50KS5zZWxlY3QoJ3N2ZycpO1xuICAgICAgICBzdmcuc2VsZWN0QWxsKFwiLmRhdGEtbGFiZWxzXCIpLnJlbW92ZSgpO1xuXG4gICAgICAgIGlmICghdGhpcy5fZGF0YUF4aXNMYWJlbCkgcmV0dXJuO1xuICAgICAgICBsZXQgdGV4dCA9IHRoaXMuX2RhdGFBeGlzTGFiZWw7XG4gICAgICAgIGlmICh0ZXh0LmxvbmcpIHRleHQgPSB0ZXh0Lmxvbmc7XG5cbiAgICAgICAgbGV0IHggPSAtKG1hcmdpbnMudG9wICsgaGVpZ2h0IC8gMik7XG5cbiAgICAgICAgbGV0IGxhYmVsID0gc3ZnLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJkYXRhLWxhYmVsc1wiKVxuICAgICAgICAgICAgLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgICAgIC50ZXh0KHRleHQpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInJvdGF0ZSgtOTAgMCwwKSB0cmFuc2xhdGUoXCIgKyB4ICsgXCIsIDIwKVwiKVxuICAgICAgICAgICAgLy8gLnN0eWxlKFwiZm9udC1mYW1pbHlcIiwgXCJPcGVuIFNhbnMsIHNhbnMtc2VyaWZcIilcbiAgICAgICAgICAgIC8vIC5zdHlsZShcImZvbnQtc2l6ZVwiLCBcIjEycHhcIilcbiAgICAgICAgICAgIC8vIC5zdHlsZShcImZvbnQtc3R5bGVcIiwgXCJpdGFsaWNcIilcbiAgICAgICAgICAgIC5zdHlsZShcImZpbGxcIiwgY29sb3Vycy5laWdodGVlbi5kYXJrR3JleSk7XG5cbiAgICAgICAgbGV0IHdpZHRoID0gbGFiZWwubm9kZSgpLmdldEJCb3goKS53aWR0aDtcbiAgICAgICAgaWYgKHdpZHRoID49IGhlaWdodCAmJiB0aGlzLl9kYXRhQXhpc0xhYmVsLnNob3J0KSB7XG4gICAgICAgICAgICBsYWJlbC50ZXh0KHRoaXMuX2RhdGFBeGlzTGFiZWwuc2hvcnQpO1xuICAgICAgICAgICAgd2lkdGggPSBsYWJlbC5ub2RlKCkuZ2V0QkJveCgpLndpZHRoO1xuICAgICAgICB9XG5cbiAgICAgICAgbGFiZWwuYXR0cihcImR4XCIsIC13aWR0aCAvIDIpO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBncmlkKHNlbGVjdGlvbiwgd2lkdGgsIGF4aXMpIHtcbiAgICAgICAgc2VsZWN0aW9uLnNlbGVjdChcIi5ncmlkXCIpLnJlbW92ZSgpO1xuXG4gICAgICAgIGxldCBncmlkID0gc2VsZWN0aW9uLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJncmlkXCIpXG4gICAgICAgICAgICAuY2FsbChheGlzXG4gICAgICAgICAgICAgICAgLnRpY2tTaXplKC13aWR0aClcbiAgICAgICAgICAgICAgICAudGlja0Zvcm1hdChcIlwiKVxuICAgICAgICAgICAgKTtcblxuICAgICAgICBncmlkLnNlbGVjdEFsbChcImxpbmVcIilcbiAgICAgICAgICAgIC5zdHlsZShcInN0cm9rZVwiLCBjb2xvdXJzLmVpZ2h0ZWVuLmxpZ2h0R3JleSk7XG4gICAgICAgIGdyaWQuc2VsZWN0QWxsKFwiLmRvbWFpblwiKS5yZW1vdmUoKTtcblxuICAgICAgICBncmlkXG4gICAgICAgICAgICAubG93ZXIoKSAvLyBBbHdheXMgZW5zdXJlIHRoYXQgdGhpcyBpcyBlYXJsaWVyIGluIHRoZSBkb20uIFRoaW5ncyBtdXN0IGJlIGRyYXduIG9uIHRvcCBvZiBpdC5cbiAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMClcbiAgICAgICAgICAgIC50cmFuc2l0aW9uKClcbiAgICAgICAgICAgIC5kZWxheSg1MDApXG4gICAgICAgICAgICAuZHVyYXRpb24oNTAwKVxuICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAxKTtcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgeGF4aXMoc2VsZWN0aW9uLCBoZWlnaHQsIHdpZHRoLCB4YXhpcykge1xuICAgICAgICBzZWxlY3Rpb24uc2VsZWN0KFwiLngtYXhpc1wiKS5yZW1vdmUoKTtcbiAgICAgICAgbGV0IGF4aXMgPSBzZWxlY3Rpb24uYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcIngtYXhpc1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoMCxcIiArIGhlaWdodCArIFwiKVwiKVxuICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAwKVxuICAgICAgICAgICAgLmNhbGwoeGF4aXMpO1xuXG4gICAgICAgIGF4aXMuc2VsZWN0KFwiLmRvbWFpblwiKS5yZW1vdmUoKTtcblxuICAgICAgICBsZXQgbWF4ID0gMDtcbiAgICAgICAgY29uc3QgZm9udFNpemUgPSAxMjtcbiAgICAgICAgYXhpcy5zZWxlY3RBbGwoXCJ0ZXh0XCIpXG4gICAgICAgICAgICAvLyAuc3R5bGUoXCJmb250LWZhbWlseVwiLCBcIk9wZW4gU2Fucywgc2Fucy1zZXJpZlwiKVxuICAgICAgICAgICAgLy8gLnN0eWxlKFwiZm9udC1zaXplXCIsIGZvbnRTaXplICsgXCJweFwiKVxuICAgICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBjb2xvdXJzLmVpZ2h0ZWVuLmRhcmtHcmV5KVxuICAgICAgICAgICAgLm5vZGVzKClcbiAgICAgICAgICAgIC5mb3JFYWNoKHRleHQgPT4gbWF4ID0gTWF0aC5tYXgobWF4LCB0ZXh0LmdldEJCb3goKS53aWR0aCkpO1xuXG4gICAgICAgIGlmIChtYXggPj0gd2lkdGggLSAxMCkge1xuICAgICAgICAgICAgY29uc3QgYmFkID0gbWF4ID49IHdpZHRoICogMjtcbiAgICAgICAgICAgIGNvbnN0IGFuZ2xlID0gYmFkID8gLTkwIDogLTMwO1xuICAgICAgICAgICAgY29uc3QgZm9udFNpemUgPSB3aWR0aCA8PSAxMyA/IDggOiAxMjtcbiAgICAgICAgICAgIGNvbnN0IHggPSBiYWQgPyAtZm9udFNpemUgOiAwO1xuICAgICAgICAgICAgY29uc3QgeSA9IGJhZCA/IDUgOiAyO1xuXG4gICAgICAgICAgICBheGlzLnNlbGVjdEFsbChcInRleHRcIilcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ3RleHQtYW5jaG9yJywgJ2VuZCcpXG4gICAgICAgICAgICAgICAgLnN0eWxlKFwiZm9udC1zaXplXCIsIGZvbnRTaXplICsgXCJweFwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsICgpID0+IFwidHJhbnNsYXRlKFwiICsgeCArIFwiLFwiICsgeSArIFwiKSByb3RhdGUoXCIgKyBhbmdsZSArIFwiIDAsMClcIilcbiAgICAgICAgfVxuXG4gICAgICAgIGF4aXNcbiAgICAgICAgICAgIC50cmFuc2l0aW9uKClcbiAgICAgICAgICAgIC5kdXJhdGlvbigxMDAwKVxuICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAxKTtcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgeWF4aXMoc2VsZWN0aW9uLCBheGlzKSB7XG4gICAgICAgIHNlbGVjdGlvbi5zZWxlY3QoXCIueS1heGlzXCIpLnJlbW92ZSgpO1xuICAgICAgICBsZXQgeCA9IHNlbGVjdGlvbi5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwieS1heGlzXCIpXG4gICAgICAgICAgICAuY2FsbChheGlzLnRpY2tTaXplKDApLnRpY2tQYWRkaW5nKDEwKSlcbiAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMClcbiAgICAgICAgICAgIC50cmFuc2l0aW9uKClcbiAgICAgICAgICAgIC5kdXJhdGlvbigxMDAwKVxuICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAxKTtcblxuICAgICAgICB4LnNlbGVjdEFsbChcInRleHRcIilcbiAgICAgICAgICAgIC8vIC5zdHlsZShcImZvbnQtZmFtaWx5XCIsIFwiT3BlbiBTYW5zLCBzYW5zLXNlcmlmXCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIGNvbG91cnMuZWlnaHRlZW4uZGFya0dyZXkpXG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGNhbGNCYXJHcm93dGgoaSwgbWF4KSB7XG4gICAgICAgIGlmIChtYXggPCAxMCkgcmV0dXJuIGkgKiB0aGlzLl9CQVJfR1JPV1RIIC8gMjtcbiAgICAgICAgaWYgKG1heCA8IDM1KSByZXR1cm4gaSAqIHRoaXMuX0JBUl9HUk9XVEggLyA0O1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICBnZXRTZXJpZXNDb2xvdXIoaSkge1xuICAgICAgICBpZiAoaSA8IDAgfHwgIXRoaXMuX2NvbG91cnMpIHJldHVybiBjb2xvdXJzLmVpZ2h0ZWVuLm1pZEdyZXk7XG5cbiAgICAgICAgaSA9IGkgJSB0aGlzLl9jb2xvdXJzLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbG91cnNbaV07XG4gICAgfVxuXG4gICAgZ2V0U29ydGVkRGF0YSgpIHtcbiAgICAgICAgbGV0IGRhdGEgPSB0aGlzLl9kYXRhO1xuICAgICAgICBpZiAoIWRhdGEgfHwgIWRhdGEubGVuZ3RoKSByZXR1cm4gW107XG5cbiAgICAgICAgZGF0YSA9IHRoaXMuX2RhdGEuc29ydCgobGhzLCByaHMpID0+IHtcbiAgICAgICAgICAgIGxocyA9IGxocy5rZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIHJocyA9IHJocy5rZXkudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICAgICAgaWYgKGxocyA9PT0gcmhzKSByZXR1cm4gMDtcbiAgICAgICAgICAgIGlmIChsaHMgPCByaHMpIHJldHVybiAtMTtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICBnZXRUcmFuc2Zvcm1lZERhdGEoKSB7XG4gICAgICAgIGxldCBkYXRhID0gdGhpcy5nZXRTb3J0ZWREYXRhKCk7XG4gICAgICAgIGlmICghZGF0YSB8fCAhZGF0YS5sZW5ndGgpIHJldHVybiBbXTtcblxuICAgICAgICBsZXQgcmVzdWx0cyA9IFtdO1xuXG4gICAgICAgIGNvbnN0IGdldFggPSBkID0+IHRoaXMuX3hBeGlzT3ZlcnJpZGUgPyB0aGlzLl94QXhpc092ZXJyaWRlW3RoaXMuX3goZCldIDogdGhpcy5feChkKTtcblxuICAgICAgICBkYXRhLmZvckVhY2goKHNlcmllcywgc19pKSA9PiB7XG4gICAgICAgICAgICBzZXJpZXMudmFsdWVzLmZvckVhY2goKGQsIGRfaSkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBmaWVsZCA9IHJlc3VsdHMuZmluZChidWNrZXQgPT4gYnVja2V0LmtleSA9PT0gZ2V0WChkKSk7XG4gICAgICAgICAgICAgICAgaWYgKCFmaWVsZCkge1xuICAgICAgICAgICAgICAgICAgICBmaWVsZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiBnZXRYKGQpXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChmaWVsZCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZmllbGQuZGF0YS5wdXNoKE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgICAgICAgICBfc2VyaWVzOiBzZXJpZXMsXG4gICAgICAgICAgICAgICAgICAgIF9zX2k6IHNfaSxcbiAgICAgICAgICAgICAgICAgICAgX2tleTogc2VyaWVzLmtleSxcbiAgICAgICAgICAgICAgICAgICAgX3k6IHRoaXMuX3koZClcbiAgICAgICAgICAgICAgICB9LCBkKSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG5cbiAgICBnZXRLZXlzKCkge1xuICAgICAgICBsZXQgZGF0YSA9IHRoaXMuX2RhdGE7XG4gICAgICAgIGlmICghZGF0YSB8fCAhZGF0YS5sZW5ndGgpIHJldHVybiBbXTtcblxuICAgICAgICByZXR1cm4gWy4uLm5ldyBTZXQoZGF0YS5tYXAoZCA9PiBkLmtleSkpXVxuICAgIH1cbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/ColumnChart.js\n')},"./src/FantasticChart.js":
/*!*******************************!*\
  !*** ./src/FantasticChart.js ***!
  \*******************************/
/*! exports provided: chart */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "chart", function() { return chart; });\n/* harmony import */ var _Colours__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Colours */ "./src/Colours.js");\n/* harmony import */ var _Scales__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Scales */ "./src/Scales.js");\n/* harmony import */ var _Axes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Axes */ "./src/Axes.js");\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./helpers */ "./src/helpers.js");\n// Copyright (C) 2013-2014, 2018 BrandsEye (PTY) LTD\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this\n// software and associated documentation files (the "Software"), to deal in the Software\n// without restriction, including without limitation the rights to use, copy, modify,\n//     merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following\n// conditions:\n//\n//     The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n//     INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n// CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n\n\n\n\nclass FantasticChart {\n\n    constructor() {\n        this._geometries = [];\n        this._x_getter = d => d.x;\n        this._y_getter = d => d.y;\n        this._data = [];\n        this._element = null;\n        this._width = 900;\n        this._height = 512;\n        this._colour = () => _Colours__WEBPACK_IMPORTED_MODULE_0__["colours"].eighteen.midGrey;\n        this._size = () => 1;\n        this._scale_x = Object(_Scales__WEBPACK_IMPORTED_MODULE_1__["scaleIdentity"])();\n        this._scale_y = Object(_Scales__WEBPACK_IMPORTED_MODULE_1__["scaleIdentity"])();\n        this._colour = () => 1;\n        this._facet_x = null;\n        this._colour_scale = d3.schemeAccent;\n        this._x_formatter = d => "" + d;\n    }\n\n    /*\n     * A DOM element that we want to render to.\n     * See, for instance, document.getElementById(id), to get\n     * such a dom element.\n     */\n    element(el) {\n        if (arguments.length === 0) return this._element;\n        this._element = el;\n        return this;\n    }\n\n    width(width) {\n        if (arguments.length === 0) return this._width;\n        if (typeof width !== "number" && width > 0) throw new Error("width must be a positive number");\n        this._width = width;\n        return this;\n    }\n\n    height(height) {\n        if (arguments.length === 0) return this._height;\n        if (typeof height !== "number" && height > 0) throw new Error("height must be a positive number");\n        this._height = height;\n        return this;\n    }\n\n    x(getter) {\n        if (arguments.length === 0) return this._x_getter;\n        if (typeof getter !== \'function\') throw new Error("x getter must be a function");\n        this._x_getter = getter;\n        return this;\n    }\n\n    y(getter) {\n        if (arguments.length === 0) return this._y_getter;\n        if (typeof getter !== \'function\') throw new Error("y getter must be a function");\n        this._y_getter = getter;\n        return this;\n    }\n\n    scaleX(scale) {\n        if (arguments.length === 0) return this._scale_x;\n        this._scale_x = scale;\n        return this;\n    }\n\n    scaleY(scale) {\n        if (arguments.length === 0) return this._scale_y;\n        this._scale_y = scale;\n        return this;\n    }\n\n    /*\n     * Add geometry to render. Multiple geometries can be added.\n     */\n    geometry(geom) {\n        if (arguments.length === 0) return this._geometries.slice(0);\n        this._geometries.push(geom);\n        return this;\n    }\n\n    size() {\n        console.log("=> size: not implemented")\n    }\n\n    formatX(formatter) {\n        if (arguments.length === 0) return this._x_formatter;\n        if (typeof formatter !== \'function\') throw new Error("formatter must be a function");\n        this._x_formatter = formatter;\n        return this;\n    }\n\n    /**\n     * Defines how to separate data visually using colours. It\n     * does not define what colour to use.\n     * @param colour\n     * @returns {*}\n     */\n    colour(colour) {\n        if (arguments.length === 0) return this._colour;\n        if (typeof colour !== \'function\') throw new Error("colour must be a function");\n        this._colour = colour;\n        return this;\n    }\n\n    /**\n     * Defines colours to use.\n     * @param colours\n     */\n    colourScale(colours) {\n        if (arguments.length === 0) return this._colour_scale;\n        if (typeof colours !== \'object\' || !colours.length) throw new Error("colour must be an Array");\n        this._colour_scale = colours;\n        return this;\n    }\n\n    facetX(selector) {\n        if (arguments.length === 0) return this._facet_x;\n        if (selector != null && typeof selector !== \'function\') throw new Error("The facet selector must be a function");\n        this._facet_x = selector;\n        return this;\n    }\n\n    data(data) {\n        if (arguments.length === 0) return this._data.slice();\n        this._data = data;\n        return this;\n    }\n\n    render() {\n        console.log("-------- Rendering ---------");\n\n        //-----------------------------------------------\n        // Create initial svg element\n        let svg = d3.select(this._element).select("svg");\n        if (svg.empty()) svg = d3.select(this._element).append("svg");\n\n        //-----------------------------------------------\n        // Calculate the space that various elements will want to take up\n\n        const geometries = this.sortGeometries();\n        geometries.forEach(geom => this.setupGeom(geom));\n        const axisWidth = geometries.length ? Object(_helpers__WEBPACK_IMPORTED_MODULE_3__["maxBounding"])(svg, geometries[0].yValues()).width + 10 : 0;\n\n        console.log("Axis width is:", axisWidth);\n\n        //-----------------------------------------------\n        // Calculate margins without knowing the final height.\n        // We can only calculate the final height once we can accurately\n        // determine how to lay out the x-axis.\n\n        const margin = {top: 10, right: 10, bottom: 10, left: 10 + axisWidth};\n        const width  = this._width - margin.left - margin.right;\n\n        //-----------------------------------------------\n        // Determine initial facet / small multiple information\n\n        const facets = getFacets(this._data, this._facet_x);\n        const singleFacet = facets.length === 1;\n\n        const facetBand = d3.scaleBand()\n                            .rangeRound([0, width])\n                            .padding(singleFacet ? 0 : 0.1) // take up full space if the only facet.\n                            .domain(facets);\n\n        //-----------------------------------------------\n        // Determine x-axis height\n        // We do this by rendering the various x-axes offscreen.\n\n        geometries.forEach(geom => geom.width(facetBand.bandwidth()));\n        const axisSizeArea = svg.append("g")\n            .attr("transform", "translate(-1000, -1000)");\n\n        let axisHeight = 0;\n        facets.forEach(facet => {\n            const xScale = geometries[0]\n                .width(facetBand.bandwidth())\n                .facet(singleFacet ? null : (d => this._facet_x(d) === facet))\n                .getD3XScale();\n\n            let height = Object(_Axes__WEBPACK_IMPORTED_MODULE_2__["xaxis"])(axisSizeArea, this._height,\n                xScale.bandwidth ? xScale.bandwidth() : facetBand.bandwidth() / xScale.domain().length,\n                d3.axisBottom(xScale).tickSize(0).tickPadding(5).tickFormat(geometries[0].formatX()));\n\n            axisHeight = Math.max(height, axisHeight);\n        });\n\n        axisSizeArea.remove();\n\n        //-----------------------------------------------\n        // Update margins and calculate height\n\n        margin.bottom += axisHeight;\n        const height = this._height - margin.top - margin.bottom;\n\n        //-----------------------------------------------\n        // Setup the svg\n\n        svg\n            .style("width", this._width + "px")\n            .style("height", this._height + "px");\n\n        //-----------------------------------------------\n        // An area for us to render the geometries in to.\n\n        let drawingArea = svg.select(\'.drawing-area\');\n\n        if (drawingArea.empty()) {\n            drawingArea = svg\n                .append("g")\n                .attr("class", "drawing-area")\n        }\n\n        drawingArea.attr("transform", "translate(" + margin.left + "," + margin.top + ")");\n\n\n        //-----------------------------------------------\n        // Set up small multiples / facets\n\n        let facetAreas = drawingArea.selectAll(\'.facet\').data(facets);\n        facetAreas.exit().remove();\n\n        //-----------------------------------------------\n        // Setup axes.\n\n        let xAxisArea = svg.select(".x-axis-area");\n\n        xAxisArea.remove();\n        xAxisArea = svg\n            .append("g")\n            .attr("class", "x-axis-area");\n\n        xAxisArea.attr("transform", "translate(" + margin.left + ",0)");\n\n\n        let yAxisArea = svg.select(".y-axis-area");\n\n        yAxisArea.remove();\n        yAxisArea = svg\n            .append("g")\n            .attr("class", "y-axis-area");\n\n\n        if (geometries.length) {\n            // Draw a little x-axis for every facet.\n            facets.forEach(facet => {\n                const xScale = geometries[0]\n                    .width(facetBand.bandwidth())\n                    .height(height)\n                    .facet(singleFacet ? null : (d => this._facet_x(d) === facet))\n                    .getD3XScale();\n\n                const area = xAxisArea\n                    .append("g")\n                    .attr("transform", "translate(" + (facetBand(facet)) + ",0)")// + (this._height - axisHeight) +")")\n                    .attr("width", facetBand.bandwidth());\n\n\n                Object(_Axes__WEBPACK_IMPORTED_MODULE_2__["xaxis"])(area, this._height,\n                    xScale.bandwidth ? xScale.bandwidth() : facetBand.bandwidth() / xScale.domain().length,\n                    d3.axisBottom(xScale).tickSize(0).tickPadding(5).tickFormat(geometries[0].formatX()))\n            });\n\n            const yscale = geometries[0]\n                .height(height)\n                .getD3YScale();\n\n            Object(_Axes__WEBPACK_IMPORTED_MODULE_2__["yaxis"])(yAxisArea, d3.axisLeft(yscale).ticks(5)); //;.tickFormat(this._tickFormat));\n        }\n\n\n        //-----------------------------------------------\n        // Draw individual geometries.\n\n        facetAreas\n            .enter()\n            .append("g")\n            .attr("class", "facet")\n            .merge(facetAreas)\n            .attr("width", facetBand.bandwidth())\n            .attr("transform", facetId => {\n                if (singleFacet) return "translate(0,0)";\n                return "translate(" + facetBand(facetId) + ",0)";\n            })\n            .each((facet, facet_i, facetNodes) => {\n                console.log("------------ facet ", facet || "single-facet");\n                const area = d3.select(facetNodes[facet_i]);\n                let geoms = area.selectAll(".geometry").data(geometries);\n\n                geoms.exit().remove();\n\n                geoms.enter()\n                          .each((geom, i, nodes) => {\n                              const geom_width  = facetBand.bandwidth(),\n                                    geom_height = height;\n\n                              const geom_top  = 0,\n                                    geom_left = 0;\n\n\n                              let node = d3.select(nodes[i]);\n                              node.append("g")\n                                  .attr("class", "geometry")\n                                  .attr("transform", "translate(" + geom_left + "," + geom_top + ")")\n                                  .each((d, i, nodes) => {\n                                      console.log("Setting height for", geom.name(), "to", height - axisHeight);\n                                      geom.element(d3.select(nodes[i]))\n                                          .facet(singleFacet ? null : (d => this._facet_x(d) === facet))\n                                          .height(geom_height)\n                                          .width(geom_width)\n                                          .render();\n                                  })\n                          });\n\n                // Ensure this is rendered on top of other things.\n                area.select(".x-axis").raise();\n            })\n\n\n    }\n\n\n    /*\n     * Ensures that each geom has the settings that it needs.\n     */\n    setupGeom(geom) {\n        geom.setupX(this._x_getter)\n            .setupY(this._y_getter)\n            .setupColour(this._colour)\n            .setupSize(this._size)\n            .setupScaleX(this._scale_x)\n            .setupScaleY(this._scale_y)\n            .setupFormatX(this._x_formatter)\n            .setupColourScale(this._colour_scale);\n        geom.data(this._data);\n    }\n\n\n    /**\n     * We want to ensure that geometries have a particular order to them.\n     * This is important for rendering: lines should be rendered on top of\n     * large histogram rectangles, for instance, otherwise they will be hidden.\n     */\n    sortGeometries() {\n        if (!this._geometries || !this._geometries.length) return [];\n\n        let geometries = this._geometries.slice(0);\n        geometries.sort((lhs, rhs) => {\n            return lhs.priority() - rhs.priority();\n        });\n\n        return geometries;\n    }\n\n}\n\n\n/*\n * Returns the unique facet choices from the data, given a facet selector.\n */\nfunction getFacets(data, selector) {\n    if (!selector || !data || !data.length) return [1];\n\n    const keys = new Set(data.map(selector));\n    return [...keys];\n}\n\n\n\n\nfunction chart() {\n    return new FantasticChart();\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvRmFudGFzdGljQ2hhcnQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9iM2pzLy4vc3JjL0ZhbnRhc3RpY0NoYXJ0LmpzPzAzMTkiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChDKSAyMDEzLTIwMTQsIDIwMTggQnJhbmRzRXllIChQVFkpIExURFxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpc1xuLy8gc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlXG4vLyB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksXG4vLyAgICAgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0b1xuLy8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcbi8vIGNvbmRpdGlvbnM6XG4vL1xuLy8gICAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuLy8gY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyAgICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUiBJTVBMSUVELFxuLy8gICAgIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBXG4vLyBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUXG4vLyBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0Zcbi8vIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRVxuLy8gT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCB7IGNvbG91cnMgfSBmcm9tICcuL0NvbG91cnMnO1xuaW1wb3J0IHsgc2NhbGVJZGVudGl0eSB9IGZyb20gXCIuL1NjYWxlc1wiO1xuaW1wb3J0IHsgeGF4aXMsIHlheGlzIH0gZnJvbSBcIi4vQXhlc1wiO1xuaW1wb3J0IHttYXhCb3VuZGluZ30gZnJvbSBcIi4vaGVscGVyc1wiO1xuXG5cbmNsYXNzIEZhbnRhc3RpY0NoYXJ0IHtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9nZW9tZXRyaWVzID0gW107XG4gICAgICAgIHRoaXMuX3hfZ2V0dGVyID0gZCA9PiBkLng7XG4gICAgICAgIHRoaXMuX3lfZ2V0dGVyID0gZCA9PiBkLnk7XG4gICAgICAgIHRoaXMuX2RhdGEgPSBbXTtcbiAgICAgICAgdGhpcy5fZWxlbWVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3dpZHRoID0gOTAwO1xuICAgICAgICB0aGlzLl9oZWlnaHQgPSA1MTI7XG4gICAgICAgIHRoaXMuX2NvbG91ciA9ICgpID0+IGNvbG91cnMuZWlnaHRlZW4ubWlkR3JleTtcbiAgICAgICAgdGhpcy5fc2l6ZSA9ICgpID0+IDE7XG4gICAgICAgIHRoaXMuX3NjYWxlX3ggPSBzY2FsZUlkZW50aXR5KCk7XG4gICAgICAgIHRoaXMuX3NjYWxlX3kgPSBzY2FsZUlkZW50aXR5KCk7XG4gICAgICAgIHRoaXMuX2NvbG91ciA9ICgpID0+IDE7XG4gICAgICAgIHRoaXMuX2ZhY2V0X3ggPSBudWxsO1xuICAgICAgICB0aGlzLl9jb2xvdXJfc2NhbGUgPSBkMy5zY2hlbWVBY2NlbnQ7XG4gICAgICAgIHRoaXMuX3hfZm9ybWF0dGVyID0gZCA9PiBcIlwiICsgZDtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIEEgRE9NIGVsZW1lbnQgdGhhdCB3ZSB3YW50IHRvIHJlbmRlciB0by5cbiAgICAgKiBTZWUsIGZvciBpbnN0YW5jZSwgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpLCB0byBnZXRcbiAgICAgKiBzdWNoIGEgZG9tIGVsZW1lbnQuXG4gICAgICovXG4gICAgZWxlbWVudChlbCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX2VsZW1lbnQ7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQgPSBlbDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgd2lkdGgod2lkdGgpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl93aWR0aDtcbiAgICAgICAgaWYgKHR5cGVvZiB3aWR0aCAhPT0gXCJudW1iZXJcIiAmJiB3aWR0aCA+IDApIHRocm93IG5ldyBFcnJvcihcIndpZHRoIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXJcIik7XG4gICAgICAgIHRoaXMuX3dpZHRoID0gd2lkdGg7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGhlaWdodChoZWlnaHQpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl9oZWlnaHQ7XG4gICAgICAgIGlmICh0eXBlb2YgaGVpZ2h0ICE9PSBcIm51bWJlclwiICYmIGhlaWdodCA+IDApIHRocm93IG5ldyBFcnJvcihcImhlaWdodCBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyXCIpO1xuICAgICAgICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHgoZ2V0dGVyKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5feF9nZXR0ZXI7XG4gICAgICAgIGlmICh0eXBlb2YgZ2V0dGVyICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgRXJyb3IoXCJ4IGdldHRlciBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG4gICAgICAgIHRoaXMuX3hfZ2V0dGVyID0gZ2V0dGVyO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB5KGdldHRlcikge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX3lfZ2V0dGVyO1xuICAgICAgICBpZiAodHlwZW9mIGdldHRlciAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IEVycm9yKFwieSBnZXR0ZXIgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICB0aGlzLl95X2dldHRlciA9IGdldHRlcjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgc2NhbGVYKHNjYWxlKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5fc2NhbGVfeDtcbiAgICAgICAgdGhpcy5fc2NhbGVfeCA9IHNjYWxlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzY2FsZVkoc2NhbGUpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl9zY2FsZV95O1xuICAgICAgICB0aGlzLl9zY2FsZV95ID0gc2NhbGU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qXG4gICAgICogQWRkIGdlb21ldHJ5IHRvIHJlbmRlci4gTXVsdGlwbGUgZ2VvbWV0cmllcyBjYW4gYmUgYWRkZWQuXG4gICAgICovXG4gICAgZ2VvbWV0cnkoZ2VvbSkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX2dlb21ldHJpZXMuc2xpY2UoMCk7XG4gICAgICAgIHRoaXMuX2dlb21ldHJpZXMucHVzaChnZW9tKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgc2l6ZSgpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCI9PiBzaXplOiBub3QgaW1wbGVtZW50ZWRcIilcbiAgICB9XG5cbiAgICBmb3JtYXRYKGZvcm1hdHRlcikge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX3hfZm9ybWF0dGVyO1xuICAgICAgICBpZiAodHlwZW9mIGZvcm1hdHRlciAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IEVycm9yKFwiZm9ybWF0dGVyIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgdGhpcy5feF9mb3JtYXR0ZXIgPSBmb3JtYXR0ZXI7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlZmluZXMgaG93IHRvIHNlcGFyYXRlIGRhdGEgdmlzdWFsbHkgdXNpbmcgY29sb3Vycy4gSXRcbiAgICAgKiBkb2VzIG5vdCBkZWZpbmUgd2hhdCBjb2xvdXIgdG8gdXNlLlxuICAgICAqIEBwYXJhbSBjb2xvdXJcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBjb2xvdXIoY29sb3VyKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5fY29sb3VyO1xuICAgICAgICBpZiAodHlwZW9mIGNvbG91ciAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IEVycm9yKFwiY29sb3VyIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgdGhpcy5fY29sb3VyID0gY29sb3VyO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIGNvbG91cnMgdG8gdXNlLlxuICAgICAqIEBwYXJhbSBjb2xvdXJzXG4gICAgICovXG4gICAgY29sb3VyU2NhbGUoY29sb3Vycykge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX2NvbG91cl9zY2FsZTtcbiAgICAgICAgaWYgKHR5cGVvZiBjb2xvdXJzICE9PSAnb2JqZWN0JyB8fCAhY29sb3Vycy5sZW5ndGgpIHRocm93IG5ldyBFcnJvcihcImNvbG91ciBtdXN0IGJlIGFuIEFycmF5XCIpO1xuICAgICAgICB0aGlzLl9jb2xvdXJfc2NhbGUgPSBjb2xvdXJzO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmYWNldFgoc2VsZWN0b3IpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl9mYWNldF94O1xuICAgICAgICBpZiAoc2VsZWN0b3IgIT0gbnVsbCAmJiB0eXBlb2Ygc2VsZWN0b3IgIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBFcnJvcihcIlRoZSBmYWNldCBzZWxlY3RvciBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG4gICAgICAgIHRoaXMuX2ZhY2V0X3ggPSBzZWxlY3RvcjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZGF0YShkYXRhKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5fZGF0YS5zbGljZSgpO1xuICAgICAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIi0tLS0tLS0tIFJlbmRlcmluZyAtLS0tLS0tLS1cIik7XG5cbiAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBDcmVhdGUgaW5pdGlhbCBzdmcgZWxlbWVudFxuICAgICAgICBsZXQgc3ZnID0gZDMuc2VsZWN0KHRoaXMuX2VsZW1lbnQpLnNlbGVjdChcInN2Z1wiKTtcbiAgICAgICAgaWYgKHN2Zy5lbXB0eSgpKSBzdmcgPSBkMy5zZWxlY3QodGhpcy5fZWxlbWVudCkuYXBwZW5kKFwic3ZnXCIpO1xuXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBzcGFjZSB0aGF0IHZhcmlvdXMgZWxlbWVudHMgd2lsbCB3YW50IHRvIHRha2UgdXBcblxuICAgICAgICBjb25zdCBnZW9tZXRyaWVzID0gdGhpcy5zb3J0R2VvbWV0cmllcygpO1xuICAgICAgICBnZW9tZXRyaWVzLmZvckVhY2goZ2VvbSA9PiB0aGlzLnNldHVwR2VvbShnZW9tKSk7XG4gICAgICAgIGNvbnN0IGF4aXNXaWR0aCA9IGdlb21ldHJpZXMubGVuZ3RoID8gbWF4Qm91bmRpbmcoc3ZnLCBnZW9tZXRyaWVzWzBdLnlWYWx1ZXMoKSkud2lkdGggKyAxMCA6IDA7XG5cbiAgICAgICAgY29uc29sZS5sb2coXCJBeGlzIHdpZHRoIGlzOlwiLCBheGlzV2lkdGgpO1xuXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gQ2FsY3VsYXRlIG1hcmdpbnMgd2l0aG91dCBrbm93aW5nIHRoZSBmaW5hbCBoZWlnaHQuXG4gICAgICAgIC8vIFdlIGNhbiBvbmx5IGNhbGN1bGF0ZSB0aGUgZmluYWwgaGVpZ2h0IG9uY2Ugd2UgY2FuIGFjY3VyYXRlbHlcbiAgICAgICAgLy8gZGV0ZXJtaW5lIGhvdyB0byBsYXkgb3V0IHRoZSB4LWF4aXMuXG5cbiAgICAgICAgY29uc3QgbWFyZ2luID0ge3RvcDogMTAsIHJpZ2h0OiAxMCwgYm90dG9tOiAxMCwgbGVmdDogMTAgKyBheGlzV2lkdGh9O1xuICAgICAgICBjb25zdCB3aWR0aCAgPSB0aGlzLl93aWR0aCAtIG1hcmdpbi5sZWZ0IC0gbWFyZ2luLnJpZ2h0O1xuXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gRGV0ZXJtaW5lIGluaXRpYWwgZmFjZXQgLyBzbWFsbCBtdWx0aXBsZSBpbmZvcm1hdGlvblxuXG4gICAgICAgIGNvbnN0IGZhY2V0cyA9IGdldEZhY2V0cyh0aGlzLl9kYXRhLCB0aGlzLl9mYWNldF94KTtcbiAgICAgICAgY29uc3Qgc2luZ2xlRmFjZXQgPSBmYWNldHMubGVuZ3RoID09PSAxO1xuXG4gICAgICAgIGNvbnN0IGZhY2V0QmFuZCA9IGQzLnNjYWxlQmFuZCgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJhbmdlUm91bmQoWzAsIHdpZHRoXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAucGFkZGluZyhzaW5nbGVGYWNldCA/IDAgOiAwLjEpIC8vIHRha2UgdXAgZnVsbCBzcGFjZSBpZiB0aGUgb25seSBmYWNldC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZG9tYWluKGZhY2V0cyk7XG5cbiAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBEZXRlcm1pbmUgeC1heGlzIGhlaWdodFxuICAgICAgICAvLyBXZSBkbyB0aGlzIGJ5IHJlbmRlcmluZyB0aGUgdmFyaW91cyB4LWF4ZXMgb2Zmc2NyZWVuLlxuXG4gICAgICAgIGdlb21ldHJpZXMuZm9yRWFjaChnZW9tID0+IGdlb20ud2lkdGgoZmFjZXRCYW5kLmJhbmR3aWR0aCgpKSk7XG4gICAgICAgIGNvbnN0IGF4aXNTaXplQXJlYSA9IHN2Zy5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZSgtMTAwMCwgLTEwMDApXCIpO1xuXG4gICAgICAgIGxldCBheGlzSGVpZ2h0ID0gMDtcbiAgICAgICAgZmFjZXRzLmZvckVhY2goZmFjZXQgPT4ge1xuICAgICAgICAgICAgY29uc3QgeFNjYWxlID0gZ2VvbWV0cmllc1swXVxuICAgICAgICAgICAgICAgIC53aWR0aChmYWNldEJhbmQuYmFuZHdpZHRoKCkpXG4gICAgICAgICAgICAgICAgLmZhY2V0KHNpbmdsZUZhY2V0ID8gbnVsbCA6IChkID0+IHRoaXMuX2ZhY2V0X3goZCkgPT09IGZhY2V0KSlcbiAgICAgICAgICAgICAgICAuZ2V0RDNYU2NhbGUoKTtcblxuICAgICAgICAgICAgbGV0IGhlaWdodCA9IHhheGlzKGF4aXNTaXplQXJlYSwgdGhpcy5faGVpZ2h0LFxuICAgICAgICAgICAgICAgIHhTY2FsZS5iYW5kd2lkdGggPyB4U2NhbGUuYmFuZHdpZHRoKCkgOiBmYWNldEJhbmQuYmFuZHdpZHRoKCkgLyB4U2NhbGUuZG9tYWluKCkubGVuZ3RoLFxuICAgICAgICAgICAgICAgIGQzLmF4aXNCb3R0b20oeFNjYWxlKS50aWNrU2l6ZSgwKS50aWNrUGFkZGluZyg1KS50aWNrRm9ybWF0KGdlb21ldHJpZXNbMF0uZm9ybWF0WCgpKSk7XG5cbiAgICAgICAgICAgIGF4aXNIZWlnaHQgPSBNYXRoLm1heChoZWlnaHQsIGF4aXNIZWlnaHQpO1xuICAgICAgICB9KTtcblxuICAgICAgICBheGlzU2l6ZUFyZWEucmVtb3ZlKCk7XG5cbiAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBVcGRhdGUgbWFyZ2lucyBhbmQgY2FsY3VsYXRlIGhlaWdodFxuXG4gICAgICAgIG1hcmdpbi5ib3R0b20gKz0gYXhpc0hlaWdodDtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gdGhpcy5faGVpZ2h0IC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b207XG5cbiAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBTZXR1cCB0aGUgc3ZnXG5cbiAgICAgICAgc3ZnXG4gICAgICAgICAgICAuc3R5bGUoXCJ3aWR0aFwiLCB0aGlzLl93aWR0aCArIFwicHhcIilcbiAgICAgICAgICAgIC5zdHlsZShcImhlaWdodFwiLCB0aGlzLl9oZWlnaHQgKyBcInB4XCIpO1xuXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gQW4gYXJlYSBmb3IgdXMgdG8gcmVuZGVyIHRoZSBnZW9tZXRyaWVzIGluIHRvLlxuXG4gICAgICAgIGxldCBkcmF3aW5nQXJlYSA9IHN2Zy5zZWxlY3QoJy5kcmF3aW5nLWFyZWEnKTtcblxuICAgICAgICBpZiAoZHJhd2luZ0FyZWEuZW1wdHkoKSkge1xuICAgICAgICAgICAgZHJhd2luZ0FyZWEgPSBzdmdcbiAgICAgICAgICAgICAgICAuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJkcmF3aW5nLWFyZWFcIilcbiAgICAgICAgfVxuXG4gICAgICAgIGRyYXdpbmdBcmVhLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyBtYXJnaW4ubGVmdCArIFwiLFwiICsgbWFyZ2luLnRvcCArIFwiKVwiKTtcblxuXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gU2V0IHVwIHNtYWxsIG11bHRpcGxlcyAvIGZhY2V0c1xuXG4gICAgICAgIGxldCBmYWNldEFyZWFzID0gZHJhd2luZ0FyZWEuc2VsZWN0QWxsKCcuZmFjZXQnKS5kYXRhKGZhY2V0cyk7XG4gICAgICAgIGZhY2V0QXJlYXMuZXhpdCgpLnJlbW92ZSgpO1xuXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gU2V0dXAgYXhlcy5cblxuICAgICAgICBsZXQgeEF4aXNBcmVhID0gc3ZnLnNlbGVjdChcIi54LWF4aXMtYXJlYVwiKTtcblxuICAgICAgICB4QXhpc0FyZWEucmVtb3ZlKCk7XG4gICAgICAgIHhBeGlzQXJlYSA9IHN2Z1xuICAgICAgICAgICAgLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJ4LWF4aXMtYXJlYVwiKTtcblxuICAgICAgICB4QXhpc0FyZWEuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIG1hcmdpbi5sZWZ0ICsgXCIsMClcIik7XG5cblxuICAgICAgICBsZXQgeUF4aXNBcmVhID0gc3ZnLnNlbGVjdChcIi55LWF4aXMtYXJlYVwiKTtcblxuICAgICAgICB5QXhpc0FyZWEucmVtb3ZlKCk7XG4gICAgICAgIHlBeGlzQXJlYSA9IHN2Z1xuICAgICAgICAgICAgLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJ5LWF4aXMtYXJlYVwiKTtcblxuXG4gICAgICAgIGlmIChnZW9tZXRyaWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gRHJhdyBhIGxpdHRsZSB4LWF4aXMgZm9yIGV2ZXJ5IGZhY2V0LlxuICAgICAgICAgICAgZmFjZXRzLmZvckVhY2goZmFjZXQgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHhTY2FsZSA9IGdlb21ldHJpZXNbMF1cbiAgICAgICAgICAgICAgICAgICAgLndpZHRoKGZhY2V0QmFuZC5iYW5kd2lkdGgoKSlcbiAgICAgICAgICAgICAgICAgICAgLmhlaWdodChoZWlnaHQpXG4gICAgICAgICAgICAgICAgICAgIC5mYWNldChzaW5nbGVGYWNldCA/IG51bGwgOiAoZCA9PiB0aGlzLl9mYWNldF94KGQpID09PSBmYWNldCkpXG4gICAgICAgICAgICAgICAgICAgIC5nZXREM1hTY2FsZSgpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgYXJlYSA9IHhBeGlzQXJlYVxuICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIChmYWNldEJhbmQoZmFjZXQpKSArIFwiLDApXCIpLy8gKyAodGhpcy5faGVpZ2h0IC0gYXhpc0hlaWdodCkgK1wiKVwiKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcIndpZHRoXCIsIGZhY2V0QmFuZC5iYW5kd2lkdGgoKSk7XG5cblxuICAgICAgICAgICAgICAgIHhheGlzKGFyZWEsIHRoaXMuX2hlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgeFNjYWxlLmJhbmR3aWR0aCA/IHhTY2FsZS5iYW5kd2lkdGgoKSA6IGZhY2V0QmFuZC5iYW5kd2lkdGgoKSAvIHhTY2FsZS5kb21haW4oKS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgIGQzLmF4aXNCb3R0b20oeFNjYWxlKS50aWNrU2l6ZSgwKS50aWNrUGFkZGluZyg1KS50aWNrRm9ybWF0KGdlb21ldHJpZXNbMF0uZm9ybWF0WCgpKSlcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjb25zdCB5c2NhbGUgPSBnZW9tZXRyaWVzWzBdXG4gICAgICAgICAgICAgICAgLmhlaWdodChoZWlnaHQpXG4gICAgICAgICAgICAgICAgLmdldEQzWVNjYWxlKCk7XG5cbiAgICAgICAgICAgIHlheGlzKHlBeGlzQXJlYSwgZDMuYXhpc0xlZnQoeXNjYWxlKS50aWNrcyg1KSk7IC8vOy50aWNrRm9ybWF0KHRoaXMuX3RpY2tGb3JtYXQpKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBEcmF3IGluZGl2aWR1YWwgZ2VvbWV0cmllcy5cblxuICAgICAgICBmYWNldEFyZWFzXG4gICAgICAgICAgICAuZW50ZXIoKVxuICAgICAgICAgICAgLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJmYWNldFwiKVxuICAgICAgICAgICAgLm1lcmdlKGZhY2V0QXJlYXMpXG4gICAgICAgICAgICAuYXR0cihcIndpZHRoXCIsIGZhY2V0QmFuZC5iYW5kd2lkdGgoKSlcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIGZhY2V0SWQgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChzaW5nbGVGYWNldCkgcmV0dXJuIFwidHJhbnNsYXRlKDAsMClcIjtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJ0cmFuc2xhdGUoXCIgKyBmYWNldEJhbmQoZmFjZXRJZCkgKyBcIiwwKVwiO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5lYWNoKChmYWNldCwgZmFjZXRfaSwgZmFjZXROb2RlcykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiLS0tLS0tLS0tLS0tIGZhY2V0IFwiLCBmYWNldCB8fCBcInNpbmdsZS1mYWNldFwiKTtcbiAgICAgICAgICAgICAgICBjb25zdCBhcmVhID0gZDMuc2VsZWN0KGZhY2V0Tm9kZXNbZmFjZXRfaV0pO1xuICAgICAgICAgICAgICAgIGxldCBnZW9tcyA9IGFyZWEuc2VsZWN0QWxsKFwiLmdlb21ldHJ5XCIpLmRhdGEoZ2VvbWV0cmllcyk7XG5cbiAgICAgICAgICAgICAgICBnZW9tcy5leGl0KCkucmVtb3ZlKCk7XG5cbiAgICAgICAgICAgICAgICBnZW9tcy5lbnRlcigpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC5lYWNoKChnZW9tLCBpLCBub2RlcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZ2VvbV93aWR0aCAgPSBmYWNldEJhbmQuYmFuZHdpZHRoKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW9tX2hlaWdodCA9IGhlaWdodDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZ2VvbV90b3AgID0gMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlb21fbGVmdCA9IDA7XG5cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5vZGUgPSBkMy5zZWxlY3Qobm9kZXNbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImdlb21ldHJ5XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyBnZW9tX2xlZnQgKyBcIixcIiArIGdlb21fdG9wICsgXCIpXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmVhY2goKGQsIGksIG5vZGVzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiU2V0dGluZyBoZWlnaHQgZm9yXCIsIGdlb20ubmFtZSgpLCBcInRvXCIsIGhlaWdodCAtIGF4aXNIZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW9tLmVsZW1lbnQoZDMuc2VsZWN0KG5vZGVzW2ldKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5mYWNldChzaW5nbGVGYWNldCA/IG51bGwgOiAoZCA9PiB0aGlzLl9mYWNldF94KGQpID09PSBmYWNldCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuaGVpZ2h0KGdlb21faGVpZ2h0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLndpZHRoKGdlb21fd2lkdGgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVuZGVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBFbnN1cmUgdGhpcyBpcyByZW5kZXJlZCBvbiB0b3Agb2Ygb3RoZXIgdGhpbmdzLlxuICAgICAgICAgICAgICAgIGFyZWEuc2VsZWN0KFwiLngtYXhpc1wiKS5yYWlzZSgpO1xuICAgICAgICAgICAgfSlcblxuXG4gICAgfVxuXG5cbiAgICAvKlxuICAgICAqIEVuc3VyZXMgdGhhdCBlYWNoIGdlb20gaGFzIHRoZSBzZXR0aW5ncyB0aGF0IGl0IG5lZWRzLlxuICAgICAqL1xuICAgIHNldHVwR2VvbShnZW9tKSB7XG4gICAgICAgIGdlb20uc2V0dXBYKHRoaXMuX3hfZ2V0dGVyKVxuICAgICAgICAgICAgLnNldHVwWSh0aGlzLl95X2dldHRlcilcbiAgICAgICAgICAgIC5zZXR1cENvbG91cih0aGlzLl9jb2xvdXIpXG4gICAgICAgICAgICAuc2V0dXBTaXplKHRoaXMuX3NpemUpXG4gICAgICAgICAgICAuc2V0dXBTY2FsZVgodGhpcy5fc2NhbGVfeClcbiAgICAgICAgICAgIC5zZXR1cFNjYWxlWSh0aGlzLl9zY2FsZV95KVxuICAgICAgICAgICAgLnNldHVwRm9ybWF0WCh0aGlzLl94X2Zvcm1hdHRlcilcbiAgICAgICAgICAgIC5zZXR1cENvbG91clNjYWxlKHRoaXMuX2NvbG91cl9zY2FsZSk7XG4gICAgICAgIGdlb20uZGF0YSh0aGlzLl9kYXRhKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFdlIHdhbnQgdG8gZW5zdXJlIHRoYXQgZ2VvbWV0cmllcyBoYXZlIGEgcGFydGljdWxhciBvcmRlciB0byB0aGVtLlxuICAgICAqIFRoaXMgaXMgaW1wb3J0YW50IGZvciByZW5kZXJpbmc6IGxpbmVzIHNob3VsZCBiZSByZW5kZXJlZCBvbiB0b3Agb2ZcbiAgICAgKiBsYXJnZSBoaXN0b2dyYW0gcmVjdGFuZ2xlcywgZm9yIGluc3RhbmNlLCBvdGhlcndpc2UgdGhleSB3aWxsIGJlIGhpZGRlbi5cbiAgICAgKi9cbiAgICBzb3J0R2VvbWV0cmllcygpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9nZW9tZXRyaWVzIHx8ICF0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aCkgcmV0dXJuIFtdO1xuXG4gICAgICAgIGxldCBnZW9tZXRyaWVzID0gdGhpcy5fZ2VvbWV0cmllcy5zbGljZSgwKTtcbiAgICAgICAgZ2VvbWV0cmllcy5zb3J0KChsaHMsIHJocykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGxocy5wcmlvcml0eSgpIC0gcmhzLnByaW9yaXR5KCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBnZW9tZXRyaWVzO1xuICAgIH1cblxufVxuXG5cbi8qXG4gKiBSZXR1cm5zIHRoZSB1bmlxdWUgZmFjZXQgY2hvaWNlcyBmcm9tIHRoZSBkYXRhLCBnaXZlbiBhIGZhY2V0IHNlbGVjdG9yLlxuICovXG5mdW5jdGlvbiBnZXRGYWNldHMoZGF0YSwgc2VsZWN0b3IpIHtcbiAgICBpZiAoIXNlbGVjdG9yIHx8ICFkYXRhIHx8ICFkYXRhLmxlbmd0aCkgcmV0dXJuIFsxXTtcblxuICAgIGNvbnN0IGtleXMgPSBuZXcgU2V0KGRhdGEubWFwKHNlbGVjdG9yKSk7XG4gICAgcmV0dXJuIFsuLi5rZXlzXTtcbn1cblxuXG5cblxuZXhwb3J0IGZ1bmN0aW9uIGNoYXJ0KCkge1xuICAgIHJldHVybiBuZXcgRmFudGFzdGljQ2hhcnQoKTtcbn0iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/FantasticChart.js\n')},"./src/Geometry.js":
/*!*************************!*\
  !*** ./src/Geometry.js ***!
  \*************************/
/*! exports provided: Geometry */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Geometry", function() { return Geometry; });\n// Copyright (C) 2013-2014, 2018 BrandsEye (PTY) LTD\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this\n// software and associated documentation files (the "Software"), to deal in the Software\n// without restriction, including without limitation the rights to use, copy, modify,\n//     merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following\n// conditions:\n//\n//     The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n//     INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n// CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\nclass Geometry {\n\n    constructor(name, priority) {\n        this._name = name || "[UNNAMED GEOMETRY]";\n        this._chart_x_getter = null;\n        this._chart_y_getter = null;\n        this._x_getter = null;\n        this._y_getter = null;\n        this._colour = null;\n        this._size = null;\n        this._scale_x = null;\n        this._scale_y = null;\n        this._facet_selector = null;\n        this._chart_colour_scale = null;\n        this._x_formatter = null;\n        this._chart_x_formatter = null;\n        this._priority = priority || 1;\n    }\n\n    name() {\n        return this._name;\n    }\n\n    /**\n     * Provides a sort order priority for metrics. Metrics with a higher priority\n     * are drawn on top of lower priority metrics.\n     */\n    priority() {\n        return this._priority;\n    }\n\n    element(el) {\n        if (arguments.length === 0) return this._element;\n        this._element = el;\n        return this;\n    }\n\n    x(getter) {\n        if (arguments.length === 0) return this._x_getter || this._chart_x_getter;\n        if (typeof getter !== \'function\') throw new Error("x getter must be a function");\n        this._x_getter = getter;\n        return this;\n    }\n\n    y(getter) {\n        if (arguments.length === 0) return this._y_getter || this._chart_y_getter;\n        if (typeof getter !== \'function\') throw new Error("y getter must be a function");\n        this._y_getter = getter;\n        return this;\n    }\n\n    setupX(getter) {\n        if (arguments.length === 0) return this._chart_x_getter;\n        if (typeof getter !== \'function\') throw new Error("x getter must be a function");\n        this._chart_x_getter = getter;\n        return this;\n    }\n\n    setupY(getter) {\n        if (arguments.length === 0) return this._chart_y_getter;\n        if (typeof getter !== \'function\') throw new Error("y getter must be a function");\n        this._chart_y_getter = getter;\n        return this;\n    }\n\n    colour(colour) {\n        if (arguments.length === 0) return this._colour || this._chart_colour;\n        this._colour = colour;\n        return this;\n    }\n\n    setupColour(colour) {\n        if (arguments.length === 0) return this._chart_colour;\n        this._chart_colour = colour;\n        return this;\n    }\n\n    colourScale(colours) {\n        if (arguments.length === 0) return this._chart_colour_scale || this._colour_scale;\n        if (typeof colours !== \'object\' || !colours.length) throw new Error("colour must be an Array");\n        this._colour_scale = colours;\n        return this;\n    }\n\n    setupColourScale(colours) {\n        if (arguments.length === 0) return this._chart_colour_scale;\n        if (typeof colours !== \'object\' || !colours.length) throw new Error("colour must be an Array");\n        this._chart_colour_scale = colours;\n        return this;\n    }\n\n    size(size) {\n        if (arguments.length === 0) return this._size || this._chart_size;\n        this._size = size;\n        return this;\n    }\n\n    setupSize(size) {\n        if (arguments.length === 0) return this._chart_size;\n        this._chart_size = size;\n        return this;\n    }\n\n    scaleX(scale) {\n        if (arguments.length === 0) return this._scale_x || this._chart_scale_x;\n        this._scale_x = scale;\n        return this;\n    }\n\n    setupScaleX(scale) {\n        if (arguments.length === 0) return this._chart_scale_x;\n        this._chart_scale_x = scale;\n        return this;\n    }\n\n    scaleY(scale) {\n        if (arguments.length === 0) return this._scale_y || this._chart_scale_y;\n        this._scale_y = scale;\n        return this;\n    }\n\n    setupScaleY(scale) {\n        if (arguments.length === 0) return this._chart_scale_y;\n        this._chart_scale_y = scale;\n        return this;\n    }\n\n    formatX(formatter) {\n        if (arguments.length === 0) return this._x_formatter || this._chart_x_formatter;\n        if (typeof formatter !== \'function\') throw new Error("formatter must be a function");\n        this._x_formatter = formatter;\n        return this;\n    }\n\n    setupFormatX(formatter) {\n        if (arguments.length === 0) return this._chart_x_formatter;\n        if (typeof formatter !== \'function\') throw new Error("formatter must be a function");\n        this._chart_x_formatter = formatter;\n        return this;\n    }\n\n    width(width) {\n        if (arguments.length === 0) return this._width;\n        this._width = width;\n        return this;\n    }\n\n    height(height) {\n        if (arguments.length === 0) return this._height;\n        this._height = height;\n        return this;\n    }\n\n    data(data) {\n        if (arguments.length === 0) return this._data;\n        this._data = data;\n        return this;\n    }\n\n    facet(selector) {\n        if (arguments.length === 0) return this._facet_selector;\n        if (selector != null && typeof selector !== \'function\' && selector !== null) throw new Error("Facet selector must be a function");\n        this._facet_selector = selector;\n        return this;\n    }\n\n\n    /*\n     * This takes our array of data, and determines what elements\n     * are to be mapped to what aesthetic values, such as colour or size.\n     * Data is grouped by these fields.\n\n     */\n    prepareData(data, faceted) {\n        faceted = !!faceted && this.facet();\n        data = data || this._data;\n        if (!data || !data.length) return [];\n\n        const x = this.x(),\n              y = this.y(),\n              scaleX = this.scaleX(),\n              scaleY = this.scaleY();\n\n        let mapped = {};\n\n        data.forEach(d => {\n            if (faceted && !this.facet()(d)) return;\n            const object = Object.assign({\n                _x: scaleX.transform(x(d)),\n                _y: scaleY.transform(y(d)),\n                _colour: this.colour()(d),\n                _size: this.size()(d)\n            }, d);\n\n            const key = getKey(object);\n            object._key = key;\n\n            let series = mapped[key] || getKeyParameters(object);\n            series.data.push(object);\n            mapped[key] = series;\n        });\n\n        return Object.values(mapped);\n    }\n\n    getD3XScale() {\n        throw new Error("getD3XScale not implemented for " + this.name());\n    }\n\n    getD3YScale() {\n        throw new Error("getD3YScale not implemented for " + this.name());\n    }\n\n    /**\n     * Get all the Y values for this geometry, ignoring faceting.\n     */\n    yValues() {\n        return this.data()\n            .map(d => this.y()(d))\n            .map(d => this.scaleY().transform(d));\n    }\n\n    /**\n     * Get all the Y values for this geometry, ignoring faceting.\n     */\n    xValues() {\n        return this.data()\n                   .map(d => this.x()(d))\n                   .map(d => this.scaleX().transform(d));\n    }\n\n\n    /**\n     * Implement your render code here.\n     */\n    render() {\n        throw new Error("RENDER NOT IMPLEMENTED FOR " + this.name());\n    }\n\n\n    /**\n     * Returns the unique values that the colour function\n     * returns.\n     * @param data\n     * @returns {*}\n     */\n    getColourDomain(data) {\n        if (!data || !data.length) return [];\n\n        const colours = new Set();\n\n        // todo calculate buckets\n        data.forEach(series => {\n            series.data.forEach(d => {\n                colours.add(this.colour()(d))\n            });\n        });\n\n        return [...colours]\n    }\n\n}\n\nfunction getKey(d) {\n    return "" + d._size + ":" + d._colour;\n}\n\nfunction getKeyParameters(d) {\n    return {\n        _key: getKey(d),\n        _size: d._size,\n        _colour: d._colour,\n        data: []\n    }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvR2VvbWV0cnkuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9iM2pzLy4vc3JjL0dlb21ldHJ5LmpzPzExM2IiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChDKSAyMDEzLTIwMTQsIDIwMTggQnJhbmRzRXllIChQVFkpIExURFxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpc1xuLy8gc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlXG4vLyB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksXG4vLyAgICAgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0b1xuLy8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcbi8vIGNvbmRpdGlvbnM6XG4vL1xuLy8gICAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuLy8gY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyAgICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUiBJTVBMSUVELFxuLy8gICAgIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBXG4vLyBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUXG4vLyBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0Zcbi8vIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRVxuLy8gT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cblxuZXhwb3J0IGNsYXNzIEdlb21ldHJ5IHtcblxuICAgIGNvbnN0cnVjdG9yKG5hbWUsIHByaW9yaXR5KSB7XG4gICAgICAgIHRoaXMuX25hbWUgPSBuYW1lIHx8IFwiW1VOTkFNRUQgR0VPTUVUUlldXCI7XG4gICAgICAgIHRoaXMuX2NoYXJ0X3hfZ2V0dGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5fY2hhcnRfeV9nZXR0ZXIgPSBudWxsO1xuICAgICAgICB0aGlzLl94X2dldHRlciA9IG51bGw7XG4gICAgICAgIHRoaXMuX3lfZ2V0dGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5fY29sb3VyID0gbnVsbDtcbiAgICAgICAgdGhpcy5fc2l6ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3NjYWxlX3ggPSBudWxsO1xuICAgICAgICB0aGlzLl9zY2FsZV95ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZmFjZXRfc2VsZWN0b3IgPSBudWxsO1xuICAgICAgICB0aGlzLl9jaGFydF9jb2xvdXJfc2NhbGUgPSBudWxsO1xuICAgICAgICB0aGlzLl94X2Zvcm1hdHRlciA9IG51bGw7XG4gICAgICAgIHRoaXMuX2NoYXJ0X3hfZm9ybWF0dGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJpb3JpdHkgPSBwcmlvcml0eSB8fCAxO1xuICAgIH1cblxuICAgIG5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByb3ZpZGVzIGEgc29ydCBvcmRlciBwcmlvcml0eSBmb3IgbWV0cmljcy4gTWV0cmljcyB3aXRoIGEgaGlnaGVyIHByaW9yaXR5XG4gICAgICogYXJlIGRyYXduIG9uIHRvcCBvZiBsb3dlciBwcmlvcml0eSBtZXRyaWNzLlxuICAgICAqL1xuICAgIHByaW9yaXR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpb3JpdHk7XG4gICAgfVxuXG4gICAgZWxlbWVudChlbCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX2VsZW1lbnQ7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQgPSBlbDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgeChnZXR0ZXIpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl94X2dldHRlciB8fCB0aGlzLl9jaGFydF94X2dldHRlcjtcbiAgICAgICAgaWYgKHR5cGVvZiBnZXR0ZXIgIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBFcnJvcihcInggZ2V0dGVyIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgdGhpcy5feF9nZXR0ZXIgPSBnZXR0ZXI7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHkoZ2V0dGVyKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5feV9nZXR0ZXIgfHwgdGhpcy5fY2hhcnRfeV9nZXR0ZXI7XG4gICAgICAgIGlmICh0eXBlb2YgZ2V0dGVyICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgRXJyb3IoXCJ5IGdldHRlciBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG4gICAgICAgIHRoaXMuX3lfZ2V0dGVyID0gZ2V0dGVyO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzZXR1cFgoZ2V0dGVyKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5fY2hhcnRfeF9nZXR0ZXI7XG4gICAgICAgIGlmICh0eXBlb2YgZ2V0dGVyICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgRXJyb3IoXCJ4IGdldHRlciBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG4gICAgICAgIHRoaXMuX2NoYXJ0X3hfZ2V0dGVyID0gZ2V0dGVyO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzZXR1cFkoZ2V0dGVyKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5fY2hhcnRfeV9nZXR0ZXI7XG4gICAgICAgIGlmICh0eXBlb2YgZ2V0dGVyICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgRXJyb3IoXCJ5IGdldHRlciBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG4gICAgICAgIHRoaXMuX2NoYXJ0X3lfZ2V0dGVyID0gZ2V0dGVyO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBjb2xvdXIoY29sb3VyKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5fY29sb3VyIHx8IHRoaXMuX2NoYXJ0X2NvbG91cjtcbiAgICAgICAgdGhpcy5fY29sb3VyID0gY29sb3VyO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzZXR1cENvbG91cihjb2xvdXIpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl9jaGFydF9jb2xvdXI7XG4gICAgICAgIHRoaXMuX2NoYXJ0X2NvbG91ciA9IGNvbG91cjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgY29sb3VyU2NhbGUoY29sb3Vycykge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX2NoYXJ0X2NvbG91cl9zY2FsZSB8fCB0aGlzLl9jb2xvdXJfc2NhbGU7XG4gICAgICAgIGlmICh0eXBlb2YgY29sb3VycyAhPT0gJ29iamVjdCcgfHwgIWNvbG91cnMubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoXCJjb2xvdXIgbXVzdCBiZSBhbiBBcnJheVwiKTtcbiAgICAgICAgdGhpcy5fY29sb3VyX3NjYWxlID0gY29sb3VycztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgc2V0dXBDb2xvdXJTY2FsZShjb2xvdXJzKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5fY2hhcnRfY29sb3VyX3NjYWxlO1xuICAgICAgICBpZiAodHlwZW9mIGNvbG91cnMgIT09ICdvYmplY3QnIHx8ICFjb2xvdXJzLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKFwiY29sb3VyIG11c3QgYmUgYW4gQXJyYXlcIik7XG4gICAgICAgIHRoaXMuX2NoYXJ0X2NvbG91cl9zY2FsZSA9IGNvbG91cnM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHNpemUoc2l6ZSkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX3NpemUgfHwgdGhpcy5fY2hhcnRfc2l6ZTtcbiAgICAgICAgdGhpcy5fc2l6ZSA9IHNpemU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHNldHVwU2l6ZShzaXplKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5fY2hhcnRfc2l6ZTtcbiAgICAgICAgdGhpcy5fY2hhcnRfc2l6ZSA9IHNpemU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHNjYWxlWChzY2FsZSkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX3NjYWxlX3ggfHwgdGhpcy5fY2hhcnRfc2NhbGVfeDtcbiAgICAgICAgdGhpcy5fc2NhbGVfeCA9IHNjYWxlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzZXR1cFNjYWxlWChzY2FsZSkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX2NoYXJ0X3NjYWxlX3g7XG4gICAgICAgIHRoaXMuX2NoYXJ0X3NjYWxlX3ggPSBzY2FsZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgc2NhbGVZKHNjYWxlKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5fc2NhbGVfeSB8fCB0aGlzLl9jaGFydF9zY2FsZV95O1xuICAgICAgICB0aGlzLl9zY2FsZV95ID0gc2NhbGU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHNldHVwU2NhbGVZKHNjYWxlKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5fY2hhcnRfc2NhbGVfeTtcbiAgICAgICAgdGhpcy5fY2hhcnRfc2NhbGVfeSA9IHNjYWxlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmb3JtYXRYKGZvcm1hdHRlcikge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX3hfZm9ybWF0dGVyIHx8IHRoaXMuX2NoYXJ0X3hfZm9ybWF0dGVyO1xuICAgICAgICBpZiAodHlwZW9mIGZvcm1hdHRlciAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IEVycm9yKFwiZm9ybWF0dGVyIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgdGhpcy5feF9mb3JtYXR0ZXIgPSBmb3JtYXR0ZXI7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHNldHVwRm9ybWF0WChmb3JtYXR0ZXIpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl9jaGFydF94X2Zvcm1hdHRlcjtcbiAgICAgICAgaWYgKHR5cGVvZiBmb3JtYXR0ZXIgIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBFcnJvcihcImZvcm1hdHRlciBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG4gICAgICAgIHRoaXMuX2NoYXJ0X3hfZm9ybWF0dGVyID0gZm9ybWF0dGVyO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB3aWR0aCh3aWR0aCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX3dpZHRoO1xuICAgICAgICB0aGlzLl93aWR0aCA9IHdpZHRoO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBoZWlnaHQoaGVpZ2h0KSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5faGVpZ2h0O1xuICAgICAgICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGRhdGEoZGF0YSkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX2RhdGE7XG4gICAgICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmYWNldChzZWxlY3Rvcikge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX2ZhY2V0X3NlbGVjdG9yO1xuICAgICAgICBpZiAoc2VsZWN0b3IgIT0gbnVsbCAmJiB0eXBlb2Ygc2VsZWN0b3IgIT09ICdmdW5jdGlvbicgJiYgc2VsZWN0b3IgIT09IG51bGwpIHRocm93IG5ldyBFcnJvcihcIkZhY2V0IHNlbGVjdG9yIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgdGhpcy5fZmFjZXRfc2VsZWN0b3IgPSBzZWxlY3RvcjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG5cbiAgICAvKlxuICAgICAqIFRoaXMgdGFrZXMgb3VyIGFycmF5IG9mIGRhdGEsIGFuZCBkZXRlcm1pbmVzIHdoYXQgZWxlbWVudHNcbiAgICAgKiBhcmUgdG8gYmUgbWFwcGVkIHRvIHdoYXQgYWVzdGhldGljIHZhbHVlcywgc3VjaCBhcyBjb2xvdXIgb3Igc2l6ZS5cbiAgICAgKiBEYXRhIGlzIGdyb3VwZWQgYnkgdGhlc2UgZmllbGRzLlxuXG4gICAgICovXG4gICAgcHJlcGFyZURhdGEoZGF0YSwgZmFjZXRlZCkge1xuICAgICAgICBmYWNldGVkID0gISFmYWNldGVkICYmIHRoaXMuZmFjZXQoKTtcbiAgICAgICAgZGF0YSA9IGRhdGEgfHwgdGhpcy5fZGF0YTtcbiAgICAgICAgaWYgKCFkYXRhIHx8ICFkYXRhLmxlbmd0aCkgcmV0dXJuIFtdO1xuXG4gICAgICAgIGNvbnN0IHggPSB0aGlzLngoKSxcbiAgICAgICAgICAgICAgeSA9IHRoaXMueSgpLFxuICAgICAgICAgICAgICBzY2FsZVggPSB0aGlzLnNjYWxlWCgpLFxuICAgICAgICAgICAgICBzY2FsZVkgPSB0aGlzLnNjYWxlWSgpO1xuXG4gICAgICAgIGxldCBtYXBwZWQgPSB7fTtcblxuICAgICAgICBkYXRhLmZvckVhY2goZCA9PiB7XG4gICAgICAgICAgICBpZiAoZmFjZXRlZCAmJiAhdGhpcy5mYWNldCgpKGQpKSByZXR1cm47XG4gICAgICAgICAgICBjb25zdCBvYmplY3QgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgICAgICBfeDogc2NhbGVYLnRyYW5zZm9ybSh4KGQpKSxcbiAgICAgICAgICAgICAgICBfeTogc2NhbGVZLnRyYW5zZm9ybSh5KGQpKSxcbiAgICAgICAgICAgICAgICBfY29sb3VyOiB0aGlzLmNvbG91cigpKGQpLFxuICAgICAgICAgICAgICAgIF9zaXplOiB0aGlzLnNpemUoKShkKVxuICAgICAgICAgICAgfSwgZCk7XG5cbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGdldEtleShvYmplY3QpO1xuICAgICAgICAgICAgb2JqZWN0Ll9rZXkgPSBrZXk7XG5cbiAgICAgICAgICAgIGxldCBzZXJpZXMgPSBtYXBwZWRba2V5XSB8fCBnZXRLZXlQYXJhbWV0ZXJzKG9iamVjdCk7XG4gICAgICAgICAgICBzZXJpZXMuZGF0YS5wdXNoKG9iamVjdCk7XG4gICAgICAgICAgICBtYXBwZWRba2V5XSA9IHNlcmllcztcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIE9iamVjdC52YWx1ZXMobWFwcGVkKTtcbiAgICB9XG5cbiAgICBnZXREM1hTY2FsZSgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZ2V0RDNYU2NhbGUgbm90IGltcGxlbWVudGVkIGZvciBcIiArIHRoaXMubmFtZSgpKTtcbiAgICB9XG5cbiAgICBnZXREM1lTY2FsZSgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZ2V0RDNZU2NhbGUgbm90IGltcGxlbWVudGVkIGZvciBcIiArIHRoaXMubmFtZSgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYWxsIHRoZSBZIHZhbHVlcyBmb3IgdGhpcyBnZW9tZXRyeSwgaWdub3JpbmcgZmFjZXRpbmcuXG4gICAgICovXG4gICAgeVZhbHVlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YSgpXG4gICAgICAgICAgICAubWFwKGQgPT4gdGhpcy55KCkoZCkpXG4gICAgICAgICAgICAubWFwKGQgPT4gdGhpcy5zY2FsZVkoKS50cmFuc2Zvcm0oZCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBhbGwgdGhlIFkgdmFsdWVzIGZvciB0aGlzIGdlb21ldHJ5LCBpZ25vcmluZyBmYWNldGluZy5cbiAgICAgKi9cbiAgICB4VmFsdWVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhKClcbiAgICAgICAgICAgICAgICAgICAubWFwKGQgPT4gdGhpcy54KCkoZCkpXG4gICAgICAgICAgICAgICAgICAgLm1hcChkID0+IHRoaXMuc2NhbGVYKCkudHJhbnNmb3JtKGQpKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEltcGxlbWVudCB5b3VyIHJlbmRlciBjb2RlIGhlcmUuXG4gICAgICovXG4gICAgcmVuZGVyKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSRU5ERVIgTk9UIElNUExFTUVOVEVEIEZPUiBcIiArIHRoaXMubmFtZSgpKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHVuaXF1ZSB2YWx1ZXMgdGhhdCB0aGUgY29sb3VyIGZ1bmN0aW9uXG4gICAgICogcmV0dXJucy5cbiAgICAgKiBAcGFyYW0gZGF0YVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGdldENvbG91ckRvbWFpbihkYXRhKSB7XG4gICAgICAgIGlmICghZGF0YSB8fCAhZGF0YS5sZW5ndGgpIHJldHVybiBbXTtcblxuICAgICAgICBjb25zdCBjb2xvdXJzID0gbmV3IFNldCgpO1xuXG4gICAgICAgIC8vIHRvZG8gY2FsY3VsYXRlIGJ1Y2tldHNcbiAgICAgICAgZGF0YS5mb3JFYWNoKHNlcmllcyA9PiB7XG4gICAgICAgICAgICBzZXJpZXMuZGF0YS5mb3JFYWNoKGQgPT4ge1xuICAgICAgICAgICAgICAgIGNvbG91cnMuYWRkKHRoaXMuY29sb3VyKCkoZCkpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIFsuLi5jb2xvdXJzXVxuICAgIH1cblxufVxuXG5mdW5jdGlvbiBnZXRLZXkoZCkge1xuICAgIHJldHVybiBcIlwiICsgZC5fc2l6ZSArIFwiOlwiICsgZC5fY29sb3VyO1xufVxuXG5mdW5jdGlvbiBnZXRLZXlQYXJhbWV0ZXJzKGQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBfa2V5OiBnZXRLZXkoZCksXG4gICAgICAgIF9zaXplOiBkLl9zaXplLFxuICAgICAgICBfY29sb3VyOiBkLl9jb2xvdXIsXG4gICAgICAgIGRhdGE6IFtdXG4gICAgfVxufSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/Geometry.js\n')},"./src/Histogram.js":
/*!**************************!*\
  !*** ./src/Histogram.js ***!
  \**************************/
/*! exports provided: histogram */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "histogram", function() { return histogram; });\n/* harmony import */ var _Geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Geometry */ "./src/Geometry.js");\n// Copyright (C) 2013-2014, 2018 BrandsEye (PTY) LTD\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this\n// software and associated documentation files (the "Software"), to deal in the Software\n// without restriction, including without limitation the rights to use, copy, modify,\n//     merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following\n// conditions:\n//\n//     The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n//     INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n// CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n\nclass Histogram extends _Geometry__WEBPACK_IMPORTED_MODULE_0__["Geometry"] {\n\n    constructor() {\n        super("HISTOGRAM");\n        this._BAR_GROWTH = 100;\n    }\n\n    render() {\n        console.log("\\tRendering HISTOGRAM");\n\n        const element = this._element;\n        const data = this.prepareData(null, true);\n        const allData = this.prepareData(null, false);\n        const width = this._width,\n              height = this._height;\n\n        element.classed("histogram", true);\n\n        const x = this.getD3XScale(data, width);\n\n        const y = this.getD3YScale(allData, height);\n\n        const xGroup = d3.scaleBand()\n                         .padding(0)\n                         .domain(this.getKeys(data))\n                         .rangeRound([0, x.bandwidth()]);\n\n        const colours = d3.scaleOrdinal(this.colourScale())\n                          .domain(this.getColourDomain(allData));\n\n        let groups = element.select(".bars").selectAll(\'.group\');\n\n        if (groups.empty()) {\n            groups = element\n                .append("g")\n                .attr("class", "bars")\n                .selectAll(".group");\n        }\n\n        // Ensure that we\'re always using the correct height.\n        element.select(".bars")\n           .attr("transform", "translate(0, " + height + "), scale(1, -1)")\n\n        groups = groups.data(data);\n\n        groups.exit().remove();\n\n        groups.enter()\n              .append("g")\n                  .attr("class", "group")\n                  .attr("transform", d => "translate(" + x(d._key) + ",0)")\n                  .attr("width", x.bandwidth())\n                  .attr("height", "100%")\n              .merge(groups)\n              .interrupt("groups:move")\n              .transition("groups:move")\n                  .attr("transform", d => "translate(" + x(d._key) + ",0)")\n                  .attr("width", x.bandwidth())\n              .each((s_d, s_i, nodes) => {\n                  let group = d3.select(nodes[s_i]);\n\n                  let bars = group.selectAll(".bar")\n                                  .data(s_d.data);\n\n                  bars.exit().remove();\n\n                  bars.interrupt("bar:move")     // Animate the bars to their new position.\n                      .transition("bar:move")\n                      .attr("width", xGroup.bandwidth())\n                      .attr("x", d => xGroup(d._key))\n                      .attr("y", 0);\n\n                  bars.enter()\n                      .append("rect")\n                          .attr("class", (d, i) => "bar series series-" + i)\n                          .attr("x", d => xGroup(d._key))\n                          .attr("y", 0)\n                          .attr("width", xGroup.bandwidth())\n                          .attr("height", 0)\n                          .style("fill", d => colours(d._colour))//d => d._colour === 1 ? "grey" : "green")\n                          .style("stroke", d => d3.hcl(d._colour).darker())\n                          .style("cursor", "pointer")\n                      .merge(bars)\n                      .interrupt("bar:growth")    // Animate bars growing.\n                      .transition("bar:growth")\n                      .delay(() => this.calcBarGrowth(s_i, nodes.length))\n                          .style("fill", d => d._colour)\n                          .attr("height", d => height - y(d._y));\n\n                  //     .on("mouseover", (d, i, nodes) => { // Darken the bar on mouse over\n                  //         d3.select(nodes[i])\n                  //           .interrupt("hover:colour")\n                  //           .transition("hover:colour")\n                  //           .duration(400)\n                  //           .style("fill", d3.hcl(this.getSeriesColour(i)).darker())\n                  //         this._dispatch.call("tooltipShow", this, {\n                  //             e: d3.event,\n                  //             point: d,\n                  //             series: s_d,\n                  //             seriesIndex: s_i,\n                  //             value: d._y\n                  //         })\n                  //     })\n                  //     .on("mouseout", (d, i, nodes) => { // bar is regular colour on mouse out.\n                  //         d3.select(nodes[i])\n                  //           .interrupt("hover:colour")\n                  //           .transition("hover:colour")\n                  //           .duration(400)\n                  //           .style("fill", this.getSeriesColour(i));\n                  //         this._dispatch.call("tooltipHide", this);\n                  //     })\n                  //     .on("click auxclick", (d, i, nodes) => {\n                  //         this._dispatch.call("elementClick", this, {\n                  //             e: d3.event,\n                  //             point: d,\n                  //             series: d._series,\n                  //             seriesIndex: s_i,\n                  //             value: this._y(d)\n                  //         })\n                  //     })\n\n\n              })\n    }\n\n    calcBarGrowth(i, max) {\n        if (max < 10) return i * this._BAR_GROWTH / 2;\n        if (max < 35) return i * this._BAR_GROWTH / 4;\n        return 1;\n    }\n\n    prepareData(data, faceted) {\n        data = _Geometry__WEBPACK_IMPORTED_MODULE_0__["Geometry"].prototype.prepareData.call(this, data, faceted);\n\n        let results = {};\n\n        // We want to calculate what bucket each bit of data belongs to.\n        const buckets = this.scaleX()\n                            .buckets(Object\n                                .values(data)\n                                .map(d => d.data)\n                                .reduce((acc, cur) => acc.concat(cur))\n                                .map(d => d._x));\n\n        // Sort data in to their appropriate buckets. This may be\n        // specific date buckets, or general buckets for continuous data.\n        Object.keys(data).forEach(key => {\n            let values = data[key].data;\n            values.forEach(d => {\n                d._bucket = buckets.bucket(d._x);\n                let bucket = results[d._bucket] || { _key: d._bucket, data: [] };\n                bucket.data.push(d);\n                results[d._bucket] = bucket;\n            })\n        });\n\n        return buckets.consolidateBuckets(Object.values(results));\n    }\n\n\n    getBuckets(data) {\n        if (!data || !data.length) return [];\n\n        // todo calculate buckets\n        let buckets = new Set(data.map(d => d._key));\n\n\n        return [...buckets]\n    }\n\n    getKeys(data) {\n        if (!data || !data.length) return [];\n\n        let keys = new Set();\n\n        // todo calculate buckets\n        Object.keys(data).forEach(key => {\n            let values = data[key].data;\n            values.forEach(d => keys.add(d._key))\n        });\n\n\n        return [...keys]\n    }\n\n    getD3XScale(data, width) {\n        data = data || this.prepareData(null, true);\n        width = width || this.width();\n\n        return d3.scaleBand()\n                 .rangeRound([0, width])\n                 .padding(data[0].data.length > 1 ? 0.05 : 0)\n                 .domain(data.map(d => d._key));\n    }\n\n    getD3YScale(data, height) {\n        data = data || this.prepareData(null, false);\n        height = height || this.height();\n\n        return d3.scaleLinear()\n                 .rangeRound([height, 0])\n                 .nice()\n                 .domain([0, d3.max(data, d => d3.max(d.data, d => d._y))]);\n    }\n\n}\n\n\nfunction histogram() {\n    return new Histogram();\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvSGlzdG9ncmFtLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYjNqcy8uL3NyYy9IaXN0b2dyYW0uanM/YzZlYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKEMpIDIwMTMtMjAxNCwgMjAxOCBCcmFuZHNFeWUgKFBUWSkgTFREXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZiB0aGlzXG4vLyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmVcbi8vIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSxcbi8vICAgICBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvXG4vLyBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZ1xuLy8gY29uZGl0aW9uczpcbi8vXG4vLyAgICAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4vLyBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vICAgICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SIElNUExJRUQsXG4vLyAgICAgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEFcbi8vIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFRcbi8vIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRlxuLy8gQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFXG4vLyBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IHsgR2VvbWV0cnkgfSBmcm9tICcuL0dlb21ldHJ5JztcblxuXG5jbGFzcyBIaXN0b2dyYW0gZXh0ZW5kcyBHZW9tZXRyeSB7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoXCJISVNUT0dSQU1cIik7XG4gICAgICAgIHRoaXMuX0JBUl9HUk9XVEggPSAxMDA7XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIlxcdFJlbmRlcmluZyBISVNUT0dSQU1cIik7XG5cbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuX2VsZW1lbnQ7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLnByZXBhcmVEYXRhKG51bGwsIHRydWUpO1xuICAgICAgICBjb25zdCBhbGxEYXRhID0gdGhpcy5wcmVwYXJlRGF0YShudWxsLCBmYWxzZSk7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gdGhpcy5fd2lkdGgsXG4gICAgICAgICAgICAgIGhlaWdodCA9IHRoaXMuX2hlaWdodDtcblxuICAgICAgICBlbGVtZW50LmNsYXNzZWQoXCJoaXN0b2dyYW1cIiwgdHJ1ZSk7XG5cbiAgICAgICAgY29uc3QgeCA9IHRoaXMuZ2V0RDNYU2NhbGUoZGF0YSwgd2lkdGgpO1xuXG4gICAgICAgIGNvbnN0IHkgPSB0aGlzLmdldEQzWVNjYWxlKGFsbERhdGEsIGhlaWdodCk7XG5cbiAgICAgICAgY29uc3QgeEdyb3VwID0gZDMuc2NhbGVCYW5kKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAucGFkZGluZygwKVxuICAgICAgICAgICAgICAgICAgICAgICAgIC5kb21haW4odGhpcy5nZXRLZXlzKGRhdGEpKVxuICAgICAgICAgICAgICAgICAgICAgICAgIC5yYW5nZVJvdW5kKFswLCB4LmJhbmR3aWR0aCgpXSk7XG5cbiAgICAgICAgY29uc3QgY29sb3VycyA9IGQzLnNjYWxlT3JkaW5hbCh0aGlzLmNvbG91clNjYWxlKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC5kb21haW4odGhpcy5nZXRDb2xvdXJEb21haW4oYWxsRGF0YSkpO1xuXG4gICAgICAgIGxldCBncm91cHMgPSBlbGVtZW50LnNlbGVjdChcIi5iYXJzXCIpLnNlbGVjdEFsbCgnLmdyb3VwJyk7XG5cbiAgICAgICAgaWYgKGdyb3Vwcy5lbXB0eSgpKSB7XG4gICAgICAgICAgICBncm91cHMgPSBlbGVtZW50XG4gICAgICAgICAgICAgICAgLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwiYmFyc1wiKVxuICAgICAgICAgICAgICAgIC5zZWxlY3RBbGwoXCIuZ3JvdXBcIik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBFbnN1cmUgdGhhdCB3ZSdyZSBhbHdheXMgdXNpbmcgdGhlIGNvcnJlY3QgaGVpZ2h0LlxuICAgICAgICBlbGVtZW50LnNlbGVjdChcIi5iYXJzXCIpXG4gICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKDAsIFwiICsgaGVpZ2h0ICsgXCIpLCBzY2FsZSgxLCAtMSlcIilcblxuICAgICAgICBncm91cHMgPSBncm91cHMuZGF0YShkYXRhKTtcblxuICAgICAgICBncm91cHMuZXhpdCgpLnJlbW92ZSgpO1xuXG4gICAgICAgIGdyb3Vwcy5lbnRlcigpXG4gICAgICAgICAgICAgIC5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwiZ3JvdXBcIilcbiAgICAgICAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIGQgPT4gXCJ0cmFuc2xhdGUoXCIgKyB4KGQuX2tleSkgKyBcIiwwKVwiKVxuICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCB4LmJhbmR3aWR0aCgpKVxuICAgICAgICAgICAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgXCIxMDAlXCIpXG4gICAgICAgICAgICAgIC5tZXJnZShncm91cHMpXG4gICAgICAgICAgICAgIC5pbnRlcnJ1cHQoXCJncm91cHM6bW92ZVwiKVxuICAgICAgICAgICAgICAudHJhbnNpdGlvbihcImdyb3Vwczptb3ZlXCIpXG4gICAgICAgICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBkID0+IFwidHJhbnNsYXRlKFwiICsgeChkLl9rZXkpICsgXCIsMClcIilcbiAgICAgICAgICAgICAgICAgIC5hdHRyKFwid2lkdGhcIiwgeC5iYW5kd2lkdGgoKSlcbiAgICAgICAgICAgICAgLmVhY2goKHNfZCwgc19pLCBub2RlcykgPT4ge1xuICAgICAgICAgICAgICAgICAgbGV0IGdyb3VwID0gZDMuc2VsZWN0KG5vZGVzW3NfaV0pO1xuXG4gICAgICAgICAgICAgICAgICBsZXQgYmFycyA9IGdyb3VwLnNlbGVjdEFsbChcIi5iYXJcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZGF0YShzX2QuZGF0YSk7XG5cbiAgICAgICAgICAgICAgICAgIGJhcnMuZXhpdCgpLnJlbW92ZSgpO1xuXG4gICAgICAgICAgICAgICAgICBiYXJzLmludGVycnVwdChcImJhcjptb3ZlXCIpICAgICAvLyBBbmltYXRlIHRoZSBiYXJzIHRvIHRoZWlyIG5ldyBwb3NpdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgICAudHJhbnNpdGlvbihcImJhcjptb3ZlXCIpXG4gICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCB4R3JvdXAuYmFuZHdpZHRoKCkpXG4gICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIGQgPT4geEdyb3VwKGQuX2tleSkpXG4gICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ5XCIsIDApO1xuXG4gICAgICAgICAgICAgICAgICBiYXJzLmVudGVyKClcbiAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKFwicmVjdFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIChkLCBpKSA9PiBcImJhciBzZXJpZXMgc2VyaWVzLVwiICsgaSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIGQgPT4geEdyb3VwKGQuX2tleSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwieVwiLCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcIndpZHRoXCIsIHhHcm91cC5iYW5kd2lkdGgoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBkID0+IGNvbG91cnMoZC5fY29sb3VyKSkvL2QgPT4gZC5fY29sb3VyID09PSAxID8gXCJncmV5XCIgOiBcImdyZWVuXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcInN0cm9rZVwiLCBkID0+IGQzLmhjbChkLl9jb2xvdXIpLmRhcmtlcigpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJjdXJzb3JcIiwgXCJwb2ludGVyXCIpXG4gICAgICAgICAgICAgICAgICAgICAgLm1lcmdlKGJhcnMpXG4gICAgICAgICAgICAgICAgICAgICAgLmludGVycnVwdChcImJhcjpncm93dGhcIikgICAgLy8gQW5pbWF0ZSBiYXJzIGdyb3dpbmcuXG4gICAgICAgICAgICAgICAgICAgICAgLnRyYW5zaXRpb24oXCJiYXI6Z3Jvd3RoXCIpXG4gICAgICAgICAgICAgICAgICAgICAgLmRlbGF5KCgpID0+IHRoaXMuY2FsY0Jhckdyb3d0aChzX2ksIG5vZGVzLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcImZpbGxcIiwgZCA9PiBkLl9jb2xvdXIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIGQgPT4gaGVpZ2h0IC0geShkLl95KSk7XG5cbiAgICAgICAgICAgICAgICAgIC8vICAgICAub24oXCJtb3VzZW92ZXJcIiwgKGQsIGksIG5vZGVzKSA9PiB7IC8vIERhcmtlbiB0aGUgYmFyIG9uIG1vdXNlIG92ZXJcbiAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgZDMuc2VsZWN0KG5vZGVzW2ldKVxuICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgIC5pbnRlcnJ1cHQoXCJob3Zlcjpjb2xvdXJcIilcbiAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAudHJhbnNpdGlvbihcImhvdmVyOmNvbG91clwiKVxuICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgIC5kdXJhdGlvbig0MDApXG4gICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBkMy5oY2wodGhpcy5nZXRTZXJpZXNDb2xvdXIoaSkpLmRhcmtlcigpKVxuICAgICAgICAgICAgICAgICAgLy8gICAgICAgICB0aGlzLl9kaXNwYXRjaC5jYWxsKFwidG9vbHRpcFNob3dcIiwgdGhpcywge1xuICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgZTogZDMuZXZlbnQsXG4gICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICBwb2ludDogZCxcbiAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgIHNlcmllczogc19kLFxuICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgc2VyaWVzSW5kZXg6IHNfaSxcbiAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgIHZhbHVlOiBkLl95XG4gICAgICAgICAgICAgICAgICAvLyAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAvLyAgICAgfSlcbiAgICAgICAgICAgICAgICAgIC8vICAgICAub24oXCJtb3VzZW91dFwiLCAoZCwgaSwgbm9kZXMpID0+IHsgLy8gYmFyIGlzIHJlZ3VsYXIgY29sb3VyIG9uIG1vdXNlIG91dC5cbiAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgZDMuc2VsZWN0KG5vZGVzW2ldKVxuICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgIC5pbnRlcnJ1cHQoXCJob3Zlcjpjb2xvdXJcIilcbiAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAudHJhbnNpdGlvbihcImhvdmVyOmNvbG91clwiKVxuICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgIC5kdXJhdGlvbig0MDApXG4gICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCB0aGlzLmdldFNlcmllc0NvbG91cihpKSk7XG4gICAgICAgICAgICAgICAgICAvLyAgICAgICAgIHRoaXMuX2Rpc3BhdGNoLmNhbGwoXCJ0b29sdGlwSGlkZVwiLCB0aGlzKTtcbiAgICAgICAgICAgICAgICAgIC8vICAgICB9KVxuICAgICAgICAgICAgICAgICAgLy8gICAgIC5vbihcImNsaWNrIGF1eGNsaWNrXCIsIChkLCBpLCBub2RlcykgPT4ge1xuICAgICAgICAgICAgICAgICAgLy8gICAgICAgICB0aGlzLl9kaXNwYXRjaC5jYWxsKFwiZWxlbWVudENsaWNrXCIsIHRoaXMsIHtcbiAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgIGU6IGQzLmV2ZW50LFxuICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgcG9pbnQ6IGQsXG4gICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICBzZXJpZXM6IGQuX3NlcmllcyxcbiAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgIHNlcmllc0luZGV4OiBzX2ksXG4gICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICB2YWx1ZTogdGhpcy5feShkKVxuICAgICAgICAgICAgICAgICAgLy8gICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgLy8gICAgIH0pXG5cblxuICAgICAgICAgICAgICB9KVxuICAgIH1cblxuICAgIGNhbGNCYXJHcm93dGgoaSwgbWF4KSB7XG4gICAgICAgIGlmIChtYXggPCAxMCkgcmV0dXJuIGkgKiB0aGlzLl9CQVJfR1JPV1RIIC8gMjtcbiAgICAgICAgaWYgKG1heCA8IDM1KSByZXR1cm4gaSAqIHRoaXMuX0JBUl9HUk9XVEggLyA0O1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICBwcmVwYXJlRGF0YShkYXRhLCBmYWNldGVkKSB7XG4gICAgICAgIGRhdGEgPSBHZW9tZXRyeS5wcm90b3R5cGUucHJlcGFyZURhdGEuY2FsbCh0aGlzLCBkYXRhLCBmYWNldGVkKTtcblxuICAgICAgICBsZXQgcmVzdWx0cyA9IHt9O1xuXG4gICAgICAgIC8vIFdlIHdhbnQgdG8gY2FsY3VsYXRlIHdoYXQgYnVja2V0IGVhY2ggYml0IG9mIGRhdGEgYmVsb25ncyB0by5cbiAgICAgICAgY29uc3QgYnVja2V0cyA9IHRoaXMuc2NhbGVYKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYnVja2V0cyhPYmplY3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnZhbHVlcyhkYXRhKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKGQgPT4gZC5kYXRhKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVkdWNlKChhY2MsIGN1cikgPT4gYWNjLmNvbmNhdChjdXIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKGQgPT4gZC5feCkpO1xuXG4gICAgICAgIC8vIFNvcnQgZGF0YSBpbiB0byB0aGVpciBhcHByb3ByaWF0ZSBidWNrZXRzLiBUaGlzIG1heSBiZVxuICAgICAgICAvLyBzcGVjaWZpYyBkYXRlIGJ1Y2tldHMsIG9yIGdlbmVyYWwgYnVja2V0cyBmb3IgY29udGludW91cyBkYXRhLlxuICAgICAgICBPYmplY3Qua2V5cyhkYXRhKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWVzID0gZGF0YVtrZXldLmRhdGE7XG4gICAgICAgICAgICB2YWx1ZXMuZm9yRWFjaChkID0+IHtcbiAgICAgICAgICAgICAgICBkLl9idWNrZXQgPSBidWNrZXRzLmJ1Y2tldChkLl94KTtcbiAgICAgICAgICAgICAgICBsZXQgYnVja2V0ID0gcmVzdWx0c1tkLl9idWNrZXRdIHx8IHsgX2tleTogZC5fYnVja2V0LCBkYXRhOiBbXSB9O1xuICAgICAgICAgICAgICAgIGJ1Y2tldC5kYXRhLnB1c2goZCk7XG4gICAgICAgICAgICAgICAgcmVzdWx0c1tkLl9idWNrZXRdID0gYnVja2V0O1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGJ1Y2tldHMuY29uc29saWRhdGVCdWNrZXRzKE9iamVjdC52YWx1ZXMocmVzdWx0cykpO1xuICAgIH1cblxuXG4gICAgZ2V0QnVja2V0cyhkYXRhKSB7XG4gICAgICAgIGlmICghZGF0YSB8fCAhZGF0YS5sZW5ndGgpIHJldHVybiBbXTtcblxuICAgICAgICAvLyB0b2RvIGNhbGN1bGF0ZSBidWNrZXRzXG4gICAgICAgIGxldCBidWNrZXRzID0gbmV3IFNldChkYXRhLm1hcChkID0+IGQuX2tleSkpO1xuXG5cbiAgICAgICAgcmV0dXJuIFsuLi5idWNrZXRzXVxuICAgIH1cblxuICAgIGdldEtleXMoZGF0YSkge1xuICAgICAgICBpZiAoIWRhdGEgfHwgIWRhdGEubGVuZ3RoKSByZXR1cm4gW107XG5cbiAgICAgICAgbGV0IGtleXMgPSBuZXcgU2V0KCk7XG5cbiAgICAgICAgLy8gdG9kbyBjYWxjdWxhdGUgYnVja2V0c1xuICAgICAgICBPYmplY3Qua2V5cyhkYXRhKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWVzID0gZGF0YVtrZXldLmRhdGE7XG4gICAgICAgICAgICB2YWx1ZXMuZm9yRWFjaChkID0+IGtleXMuYWRkKGQuX2tleSkpXG4gICAgICAgIH0pO1xuXG5cbiAgICAgICAgcmV0dXJuIFsuLi5rZXlzXVxuICAgIH1cblxuICAgIGdldEQzWFNjYWxlKGRhdGEsIHdpZHRoKSB7XG4gICAgICAgIGRhdGEgPSBkYXRhIHx8IHRoaXMucHJlcGFyZURhdGEobnVsbCwgdHJ1ZSk7XG4gICAgICAgIHdpZHRoID0gd2lkdGggfHwgdGhpcy53aWR0aCgpO1xuXG4gICAgICAgIHJldHVybiBkMy5zY2FsZUJhbmQoKVxuICAgICAgICAgICAgICAgICAucmFuZ2VSb3VuZChbMCwgd2lkdGhdKVxuICAgICAgICAgICAgICAgICAucGFkZGluZyhkYXRhWzBdLmRhdGEubGVuZ3RoID4gMSA/IDAuMDUgOiAwKVxuICAgICAgICAgICAgICAgICAuZG9tYWluKGRhdGEubWFwKGQgPT4gZC5fa2V5KSk7XG4gICAgfVxuXG4gICAgZ2V0RDNZU2NhbGUoZGF0YSwgaGVpZ2h0KSB7XG4gICAgICAgIGRhdGEgPSBkYXRhIHx8IHRoaXMucHJlcGFyZURhdGEobnVsbCwgZmFsc2UpO1xuICAgICAgICBoZWlnaHQgPSBoZWlnaHQgfHwgdGhpcy5oZWlnaHQoKTtcblxuICAgICAgICByZXR1cm4gZDMuc2NhbGVMaW5lYXIoKVxuICAgICAgICAgICAgICAgICAucmFuZ2VSb3VuZChbaGVpZ2h0LCAwXSlcbiAgICAgICAgICAgICAgICAgLm5pY2UoKVxuICAgICAgICAgICAgICAgICAuZG9tYWluKFswLCBkMy5tYXgoZGF0YSwgZCA9PiBkMy5tYXgoZC5kYXRhLCBkID0+IGQuX3kpKV0pO1xuICAgIH1cblxufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBoaXN0b2dyYW0oKSB7XG4gICAgcmV0dXJuIG5ldyBIaXN0b2dyYW0oKTtcbn0iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/Histogram.js\n')},"./src/Line.js":
/*!*********************!*\
  !*** ./src/Line.js ***!
  \*********************/
/*! exports provided: line */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "line", function() { return line; });\n/* harmony import */ var _Geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Geometry */ "./src/Geometry.js");\n// Copyright (C) 2013-2014, 2018 BrandsEye (PTY) LTD\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this\n// software and associated documentation files (the "Software"), to deal in the Software\n// without restriction, including without limitation the rights to use, copy, modify,\n//     merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following\n// conditions:\n//\n//     The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n//     INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n// CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n\nclass Line extends _Geometry__WEBPACK_IMPORTED_MODULE_0__["Geometry"] {\n\n    constructor() {\n        super("LINE", 2);\n    }\n\n    render() {\n        console.log("\\t Rendering LINE");\n\n        const element = this._element;\n        const data = this.prepareData();\n        const width = this._width,\n              height = this._height;\n        const allData = data.map(d => d.data).reduce((acc, val) => acc.concat(val));\n\n        element.classed("line-chart", true);\n\n\n        const x = this.getD3XScale(allData, width);\n        const y = this.getD3YScale(allData, height);\n\n        console.log("lines y range", y.range());\n        console.log("lines y domain", y.domain());\n\n        const colours = d3.scaleOrdinal(this.colourScale())\n                          .domain(this.getColourDomain(data));\n\n\n        //---------------------------------\n        // append the lines\n        let lineGroup = element.select(".lines");\n        lineGroup.selectAll("circle").remove();\n\n        let circle = false;\n        let lastMouse = null;\n        let lastMin = null;\n\n        if (lineGroup.empty()) {\n            lineGroup = element\n                .append("g")\n                .attr("class", "lines")\n                .attr("width", this.width())\n                .attr("height", this.height());\n\n            // This is needed to provide area for mouse interactions.\n            lineGroup\n                .append("rect")\n                .style("opacity", "0")\n                .attr("width", "100%")\n                .attr("height", "100%");\n        }\n\n        lineGroup\n            .on("mousemove", (d, i, nodes) => { // Darken the bar on mouse over\n                const mouse = d3.mouse(nodes[i]);\n\n                const xval = x.invert(mouse[0]);\n                const yval = y.invert(mouse[1]);\n                // let min = this.getClosestPoint(xval, yval, this.getTransformedData()[0].data);\n\n                let mins = data.map(d => getClosestPoint(xval, yval, d.data));\n                mins.forEach(d => d._dist =  [x(d._x), y(d._y)]);\n\n                mins = mins.filter(min => {\n                    const minScreenDist = Math.sqrt((mouse[0] - min._dist[0]) ** 2 + (mouse[1] - min._dist[1]) ** 2);\n                    min._min_screen = minScreenDist;\n                    return minScreenDist < 100;\n                });\n\n\n                if (!mins || !mins.length) {\n                    lastMouse = null;\n                    lineGroup.selectAll("circle").remove();\n                    return;\n                }\n\n                mins = mins.sort((lhs, rhs) => lhs._min_screen - rhs._min_screen);\n                let min = mins[0];\n\n                if (circle) {\n                    if (lastMin && min._x.getTime() === lastMin._x.getTime()) return;\n                    lineGroup.selectAll("circle").remove();\n                }\n\n                circle = true;\n                lastMouse = mouse;\n                lastMin = min;\n                lineGroup\n                    .append("circle")\n                    .attr("cx", x(min._x))\n                    .attr("cy", y(min._y))\n                    .attr("r", 10)\n                    .attr("fill", d._colour)\n                    .style("opacity", 0.1)\n                    .on("mouseover", () => {\n                        this._dispatch.call("tooltipShow", this, {\n                            e: d3.event,\n                            point: min,\n                            series: data[min._s_i],\n                            seriesIndex: min._s_i,\n                            value: min._y\n                        })\n                    })\n                    .on("mouseout", (d, i, nodes) => { // bar is regular colour on mouse out.\n                        this._dispatch.call("tooltipHide", this);\n                    })\n                    .transition()\n                    .style("opacity", 0.5)\n\n            });\n\n        let lines = lineGroup.selectAll(\'.line\');\n        lines = lines.data(data);\n\n        lines.exit().remove();\n\n        const line = d3.line()\n                       .x(d => x(d._x))\n                       .y(d => y(d._y));\n\n        lines\n            .enter()\n            .append("path")\n                .attr("class", "line")\n                .attr("fill", "none")\n                .attr("stroke", d => d3.hcl(colours(d._colour)).darker())\n                .attr("stroke-linejoin", "round")\n                .attr("stroke-linecap", "round")\n                .attr("stroke-width", 2)\n                .style("opacity", 0)\n            .transition()\n                .style("opacity", 1)\n                .attr("d", d => line(d.data));\n\n        lines\n            .transition()\n            .attr("d", d => line(d.data));\n    }\n\n\n    getD3XScale(data, width) {\n        width = width || this.width();\n        data = data || this.prepareData()\n                           .map(d => d.data)\n                           .reduce((acc, val) => acc.concat(val));\n\n        return d3.scaleTime()\n                    .range([0, width])\n                 .domain(d3.extent(data, d => d._x));\n    }\n\n    getD3YScale(data, height) {\n        data = data || this.prepareData()\n                           .map(d => d.data)\n                           .reduce((acc, val) => acc.concat(val));\n        height = height || this.height();\n\n        return d3.scaleLinear()\n          .range([height, 0])\n          .nice(5)\n          .domain([Math.min(0, d3.min(data, d => d._y)), d3.max(data, d => d._y)]);\n\n    }\n}\n\n\nfunction getClosestPoint(xval, yval, data) {\n    let calcDist = d => Math.sqrt(Math.abs(d._x - xval) ** 2 + (d._y - yval) ** 2);\n    let min = data[0];\n    let minDist = calcDist(min);\n\n    data.forEach(d => {\n        let dist = calcDist(d);\n        if (dist < minDist) {\n            minDist = dist;\n            min = d;\n        }\n    });\n\n    return min;\n}\n\n\n\nfunction line() {\n    return new Line();\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvTGluZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2IzanMvLi9zcmMvTGluZS5qcz82OTViIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoQykgMjAxMy0yMDE0LCAyMDE4IEJyYW5kc0V5ZSAoUFRZKSBMVERcbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXNcbi8vIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZVxuLy8gd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LFxuLy8gICAgIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG9cbi8vIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nXG4vLyBjb25kaXRpb25zOlxuLy9cbi8vICAgICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbi8vIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gICAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1IgSU1QTElFRCxcbi8vICAgICBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQVxuLy8gUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxuLy8gSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GXG4vLyBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkVcbi8vIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5pbXBvcnQgeyBHZW9tZXRyeSB9IGZyb20gJy4vR2VvbWV0cnknO1xuXG5cbmNsYXNzIExpbmUgZXh0ZW5kcyBHZW9tZXRyeSB7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoXCJMSU5FXCIsIDIpO1xuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJcXHQgUmVuZGVyaW5nIExJTkVcIik7XG5cbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuX2VsZW1lbnQ7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLnByZXBhcmVEYXRhKCk7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gdGhpcy5fd2lkdGgsXG4gICAgICAgICAgICAgIGhlaWdodCA9IHRoaXMuX2hlaWdodDtcbiAgICAgICAgY29uc3QgYWxsRGF0YSA9IGRhdGEubWFwKGQgPT4gZC5kYXRhKS5yZWR1Y2UoKGFjYywgdmFsKSA9PiBhY2MuY29uY2F0KHZhbCkpO1xuXG4gICAgICAgIGVsZW1lbnQuY2xhc3NlZChcImxpbmUtY2hhcnRcIiwgdHJ1ZSk7XG5cblxuICAgICAgICBjb25zdCB4ID0gdGhpcy5nZXREM1hTY2FsZShhbGxEYXRhLCB3aWR0aCk7XG4gICAgICAgIGNvbnN0IHkgPSB0aGlzLmdldEQzWVNjYWxlKGFsbERhdGEsIGhlaWdodCk7XG5cbiAgICAgICAgY29uc29sZS5sb2coXCJsaW5lcyB5IHJhbmdlXCIsIHkucmFuZ2UoKSk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwibGluZXMgeSBkb21haW5cIiwgeS5kb21haW4oKSk7XG5cbiAgICAgICAgY29uc3QgY29sb3VycyA9IGQzLnNjYWxlT3JkaW5hbCh0aGlzLmNvbG91clNjYWxlKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC5kb21haW4odGhpcy5nZXRDb2xvdXJEb21haW4oZGF0YSkpO1xuXG5cbiAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gYXBwZW5kIHRoZSBsaW5lc1xuICAgICAgICBsZXQgbGluZUdyb3VwID0gZWxlbWVudC5zZWxlY3QoXCIubGluZXNcIik7XG4gICAgICAgIGxpbmVHcm91cC5zZWxlY3RBbGwoXCJjaXJjbGVcIikucmVtb3ZlKCk7XG5cbiAgICAgICAgbGV0IGNpcmNsZSA9IGZhbHNlO1xuICAgICAgICBsZXQgbGFzdE1vdXNlID0gbnVsbDtcbiAgICAgICAgbGV0IGxhc3RNaW4gPSBudWxsO1xuXG4gICAgICAgIGlmIChsaW5lR3JvdXAuZW1wdHkoKSkge1xuICAgICAgICAgICAgbGluZUdyb3VwID0gZWxlbWVudFxuICAgICAgICAgICAgICAgIC5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImxpbmVzXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCB0aGlzLndpZHRoKCkpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgdGhpcy5oZWlnaHQoKSk7XG5cbiAgICAgICAgICAgIC8vIFRoaXMgaXMgbmVlZGVkIHRvIHByb3ZpZGUgYXJlYSBmb3IgbW91c2UgaW50ZXJhY3Rpb25zLlxuICAgICAgICAgICAgbGluZUdyb3VwXG4gICAgICAgICAgICAgICAgLmFwcGVuZChcInJlY3RcIilcbiAgICAgICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMFwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwid2lkdGhcIiwgXCIxMDAlXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgXCIxMDAlXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGluZUdyb3VwXG4gICAgICAgICAgICAub24oXCJtb3VzZW1vdmVcIiwgKGQsIGksIG5vZGVzKSA9PiB7IC8vIERhcmtlbiB0aGUgYmFyIG9uIG1vdXNlIG92ZXJcbiAgICAgICAgICAgICAgICBjb25zdCBtb3VzZSA9IGQzLm1vdXNlKG5vZGVzW2ldKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHh2YWwgPSB4LmludmVydChtb3VzZVswXSk7XG4gICAgICAgICAgICAgICAgY29uc3QgeXZhbCA9IHkuaW52ZXJ0KG1vdXNlWzFdKTtcbiAgICAgICAgICAgICAgICAvLyBsZXQgbWluID0gdGhpcy5nZXRDbG9zZXN0UG9pbnQoeHZhbCwgeXZhbCwgdGhpcy5nZXRUcmFuc2Zvcm1lZERhdGEoKVswXS5kYXRhKTtcblxuICAgICAgICAgICAgICAgIGxldCBtaW5zID0gZGF0YS5tYXAoZCA9PiBnZXRDbG9zZXN0UG9pbnQoeHZhbCwgeXZhbCwgZC5kYXRhKSk7XG4gICAgICAgICAgICAgICAgbWlucy5mb3JFYWNoKGQgPT4gZC5fZGlzdCA9ICBbeChkLl94KSwgeShkLl95KV0pO1xuXG4gICAgICAgICAgICAgICAgbWlucyA9IG1pbnMuZmlsdGVyKG1pbiA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1pblNjcmVlbkRpc3QgPSBNYXRoLnNxcnQoKG1vdXNlWzBdIC0gbWluLl9kaXN0WzBdKSAqKiAyICsgKG1vdXNlWzFdIC0gbWluLl9kaXN0WzFdKSAqKiAyKTtcbiAgICAgICAgICAgICAgICAgICAgbWluLl9taW5fc2NyZWVuID0gbWluU2NyZWVuRGlzdDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1pblNjcmVlbkRpc3QgPCAxMDA7XG4gICAgICAgICAgICAgICAgfSk7XG5cblxuICAgICAgICAgICAgICAgIGlmICghbWlucyB8fCAhbWlucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdE1vdXNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgbGluZUdyb3VwLnNlbGVjdEFsbChcImNpcmNsZVwiKS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG1pbnMgPSBtaW5zLnNvcnQoKGxocywgcmhzKSA9PiBsaHMuX21pbl9zY3JlZW4gLSByaHMuX21pbl9zY3JlZW4pO1xuICAgICAgICAgICAgICAgIGxldCBtaW4gPSBtaW5zWzBdO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNpcmNsZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobGFzdE1pbiAmJiBtaW4uX3guZ2V0VGltZSgpID09PSBsYXN0TWluLl94LmdldFRpbWUoKSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICBsaW5lR3JvdXAuc2VsZWN0QWxsKFwiY2lyY2xlXCIpLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNpcmNsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgbGFzdE1vdXNlID0gbW91c2U7XG4gICAgICAgICAgICAgICAgbGFzdE1pbiA9IG1pbjtcbiAgICAgICAgICAgICAgICBsaW5lR3JvdXBcbiAgICAgICAgICAgICAgICAgICAgLmFwcGVuZChcImNpcmNsZVwiKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcImN4XCIsIHgobWluLl94KSlcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJjeVwiLCB5KG1pbi5feSkpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiclwiLCAxMClcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJmaWxsXCIsIGQuX2NvbG91cilcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAwLjEpXG4gICAgICAgICAgICAgICAgICAgIC5vbihcIm1vdXNlb3ZlclwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXNwYXRjaC5jYWxsKFwidG9vbHRpcFNob3dcIiwgdGhpcywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGU6IGQzLmV2ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50OiBtaW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzOiBkYXRhW21pbi5fc19pXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXNJbmRleDogbWluLl9zX2ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG1pbi5feVxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLm9uKFwibW91c2VvdXRcIiwgKGQsIGksIG5vZGVzKSA9PiB7IC8vIGJhciBpcyByZWd1bGFyIGNvbG91ciBvbiBtb3VzZSBvdXQuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXNwYXRjaC5jYWxsKFwidG9vbHRpcEhpZGVcIiwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKClcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAwLjUpXG5cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIGxldCBsaW5lcyA9IGxpbmVHcm91cC5zZWxlY3RBbGwoJy5saW5lJyk7XG4gICAgICAgIGxpbmVzID0gbGluZXMuZGF0YShkYXRhKTtcblxuICAgICAgICBsaW5lcy5leGl0KCkucmVtb3ZlKCk7XG5cbiAgICAgICAgY29uc3QgbGluZSA9IGQzLmxpbmUoKVxuICAgICAgICAgICAgICAgICAgICAgICAueChkID0+IHgoZC5feCkpXG4gICAgICAgICAgICAgICAgICAgICAgIC55KGQgPT4geShkLl95KSk7XG5cbiAgICAgICAgbGluZXNcbiAgICAgICAgICAgIC5lbnRlcigpXG4gICAgICAgICAgICAuYXBwZW5kKFwicGF0aFwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJsaW5lXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJmaWxsXCIsIFwibm9uZVwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwic3Ryb2tlXCIsIGQgPT4gZDMuaGNsKGNvbG91cnMoZC5fY29sb3VyKSkuZGFya2VyKCkpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJzdHJva2UtbGluZWpvaW5cIiwgXCJyb3VuZFwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwic3Ryb2tlLWxpbmVjYXBcIiwgXCJyb3VuZFwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwic3Ryb2tlLXdpZHRoXCIsIDIpXG4gICAgICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAwKVxuICAgICAgICAgICAgLnRyYW5zaXRpb24oKVxuICAgICAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMSlcbiAgICAgICAgICAgICAgICAuYXR0cihcImRcIiwgZCA9PiBsaW5lKGQuZGF0YSkpO1xuXG4gICAgICAgIGxpbmVzXG4gICAgICAgICAgICAudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAuYXR0cihcImRcIiwgZCA9PiBsaW5lKGQuZGF0YSkpO1xuICAgIH1cblxuXG4gICAgZ2V0RDNYU2NhbGUoZGF0YSwgd2lkdGgpIHtcbiAgICAgICAgd2lkdGggPSB3aWR0aCB8fCB0aGlzLndpZHRoKCk7XG4gICAgICAgIGRhdGEgPSBkYXRhIHx8IHRoaXMucHJlcGFyZURhdGEoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChkID0+IGQuZGF0YSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZWR1Y2UoKGFjYywgdmFsKSA9PiBhY2MuY29uY2F0KHZhbCkpO1xuXG4gICAgICAgIHJldHVybiBkMy5zY2FsZVRpbWUoKVxuICAgICAgICAgICAgICAgICAgICAucmFuZ2UoWzAsIHdpZHRoXSlcbiAgICAgICAgICAgICAgICAgLmRvbWFpbihkMy5leHRlbnQoZGF0YSwgZCA9PiBkLl94KSk7XG4gICAgfVxuXG4gICAgZ2V0RDNZU2NhbGUoZGF0YSwgaGVpZ2h0KSB7XG4gICAgICAgIGRhdGEgPSBkYXRhIHx8IHRoaXMucHJlcGFyZURhdGEoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChkID0+IGQuZGF0YSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZWR1Y2UoKGFjYywgdmFsKSA9PiBhY2MuY29uY2F0KHZhbCkpO1xuICAgICAgICBoZWlnaHQgPSBoZWlnaHQgfHwgdGhpcy5oZWlnaHQoKTtcblxuICAgICAgICByZXR1cm4gZDMuc2NhbGVMaW5lYXIoKVxuICAgICAgICAgIC5yYW5nZShbaGVpZ2h0LCAwXSlcbiAgICAgICAgICAubmljZSg1KVxuICAgICAgICAgIC5kb21haW4oW01hdGgubWluKDAsIGQzLm1pbihkYXRhLCBkID0+IGQuX3kpKSwgZDMubWF4KGRhdGEsIGQgPT4gZC5feSldKTtcblxuICAgIH1cbn1cblxuXG5mdW5jdGlvbiBnZXRDbG9zZXN0UG9pbnQoeHZhbCwgeXZhbCwgZGF0YSkge1xuICAgIGxldCBjYWxjRGlzdCA9IGQgPT4gTWF0aC5zcXJ0KE1hdGguYWJzKGQuX3ggLSB4dmFsKSAqKiAyICsgKGQuX3kgLSB5dmFsKSAqKiAyKTtcbiAgICBsZXQgbWluID0gZGF0YVswXTtcbiAgICBsZXQgbWluRGlzdCA9IGNhbGNEaXN0KG1pbik7XG5cbiAgICBkYXRhLmZvckVhY2goZCA9PiB7XG4gICAgICAgIGxldCBkaXN0ID0gY2FsY0Rpc3QoZCk7XG4gICAgICAgIGlmIChkaXN0IDwgbWluRGlzdCkge1xuICAgICAgICAgICAgbWluRGlzdCA9IGRpc3Q7XG4gICAgICAgICAgICBtaW4gPSBkO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gbWluO1xufVxuXG5cblxuZXhwb3J0IGZ1bmN0aW9uIGxpbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBMaW5lKCk7XG59Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/Line.js\n')},"./src/LineChart.js":
/*!**************************!*\
  !*** ./src/LineChart.js ***!
  \**************************/
/*! exports provided: LineChart */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LineChart", function() { return LineChart; });\n/* harmony import */ var _Colours__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Colours */ "./src/Colours.js");\n/* harmony import */ var _Chart__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Chart */ "./src/Chart.js");\n// Copyright (C) 2013-2014, 2018 BrandsEye (PTY) LTD\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this\n// software and associated documentation files (the "Software"), to deal in the Software\n// without restriction, including without limitation the rights to use, copy, modify,\n//     merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following\n// conditions:\n//\n//     The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n//     INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n// CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n\n\nclass LineChart extends _Chart__WEBPACK_IMPORTED_MODULE_1__["Chart"] {\n\n    constructor() {\n        super();\n        this._xAxisTickFormat = d3.timeFormat("%B %d");\n    }\n\n    //------------------------------------------------------\n\n    data(data) {\n        if (!arguments.length) return this._data;\n        if (data && data[0].key === undefined) {\n            data = [\n                {\n                    key: "series 1",\n                    values: data\n                }\n            ];\n        }\n        this._data = data;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    element(element) {\n        if (!arguments.length) return this._element;\n        this._element = element;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    showLabels(show) {\n        if (!arguments.length) return this._show_labels;\n        this._show_labels = show;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    // todo dispatch\n    showLegend(show) {\n        if (!arguments.length) return this._show_legend;\n        this._show_legend = show;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    x(x) {\n        if (!arguments.length) return this._x;\n        this._x = x;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    y(y) {\n        if (!arguments.length) return this._y;\n        this._y = y;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    width(width) {\n        if (!arguments.length) return this._width;\n        this._width = width;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    height(height) {\n        if (!arguments.length) return this._height;\n        this._height = height;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    colours(colours) {\n        if (!arguments.length) return this._colours;\n        this._colours = colours;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    backgroundColour(colour) {\n        if (!arguments.length) return this._backgroundColour;\n        this._backgroundColour = colour || "#FFF"; // never set it to null.\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    tickFormat(format) {\n        if (!arguments.length) return this._tickFormat;\n        this._tickFormat = format;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    xAxisTickFormat(format) {\n        if (!arguments.length) return this._xAxisTickFormat;\n        this._xAxisTickFormat = format || (d => d.toString());\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    labelFormat(format) {\n        if (!arguments.length) return this._labelFormat;\n        this._labelFormat = format || (d => d.toString());\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    // todo missing\n    labelCompression(compression) {\n        if (!arguments.length) return this._compression;\n        this._compression = compression;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    //todo missing\n    dataAxisLabel(label) {\n        if (!arguments.length) return this._dataAxisLabel;\n        this._dataAxisLabel = label;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    tooltip(tooltip) {\n        if (!arguments.length) return this._tooltip;\n        this._tooltip = tooltip;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    forceY(force) {\n        if (!arguments.length) return this._forceY;\n        this._forceY = force;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n// todo missing\n    duration(duration) {\n        if (!arguments.length) return this._duration;\n        this._duration = duration;\n        return this;\n    }\n\n// todo missing\n    coarseness(coarseness) {\n        if (!arguments.length) return this._coarseness;\n        this._coarseness = coarseness;\n        return this;\n    }\n\n    // todo missing\n    padding(padding) {\n        if (!arguments.length) return this._padding;\n        this._padding = padding;\n        return this;\n    }\n\n    // todo missing\n    xAxisTooltips(tooltips) {\n        if (!arguments.length) return this._xAxisTooltips;\n        this._xAxisTooltips = tooltips;\n        return this;\n    }\n\n    xAxisOverride(override) {\n        if (!arguments.length) return this._xAxisOverride;\n        this._xAxisOverride = override;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    dispatch() {\n        return this._dispatch;\n    }\n\n    //------------------------------------------------------\n\n    render() {\n        if (!this._element) throw new Error("No element set for ColumnChart. See #element()");\n        if (!this._data) {\n            console.warn("No data set for ColumnChart. See #data()");\n            return;\n        }\n\n        const data = this.getTransformedData();\n        const keys = this.getKeys();\n\n        //------------------------------------------------\n        // Set up the SVG area\n\n        let topLevel = d3.select(this._element).select("svg");\n        if (topLevel.empty()) {\n            topLevel = d3.select(this._element).append("svg");\n        }\n\n        topLevel\n            .style("width", this._width + "px")\n            .style("height", this._height + "px");\n\n\n        // ---------------------------------\n        // Layout the showLegend.\n        //\n        // We do this now because we need to know how much space the legend\n        // takes up in order to finish calculating the margins.\n\n        const legendHeight = this.renderLegend();\n\n        //----------------------------------\n        // Calculate margins.\n\n        const margin = {top: 20, right: 20, bottom: 40, left: 40};\n        margin.bottom += legendHeight ? legendHeight + 20 : 0;\n\n        if (this._dataAxisLabel) margin.left += 20 + 12;\n        if (data) {\n            let maxLabelLength = 0;\n            data.forEach(d => {\n                d.data.forEach(d => {\n                    let length = this._xAxisTickFormat(this._x(d)).length;\n                    if (length > maxLabelLength) maxLabelLength = length;\n                })\n            });\n            margin.bottom += maxLabelLength * 2 + 10;    // space for axes labels.\n        }\n\n        const width = this._width - margin.left - margin.right,\n            height = this._height - margin.top - margin.bottom;\n\n        //----------------------------------\n        // Calculate scales and so on.\n\n\n        const x = d3.scaleTime()\n            .range([0, width]);\n\n        const y = d3.scaleLinear()\n            .range([height, 0])\n            .nice(5);\n        this._xscale = x;\n        this._yscale = y;\n\n        // Scale the range of the data in the domains\n\n        const allData = data.map(d => d.data).reduce((acc, val) => acc.concat(val));\n        x.domain(d3.extent(allData, d => d._x));\n        y.domain([Math.min(0, d3.min(allData, d => d._y)), d3.max(allData, d => d._y)]);\n\n        //------------------------------\n\n        let svg = topLevel.select(\'.main-group\');\n\n        if (svg.empty()) {\n            svg = topLevel\n                .append("g")\n                .attr("class", "main-group");\n        }\n\n        svg.attr("transform", "translate(" + margin.left + "," + margin.top + ")");\n\n        //---------------------------------\n        // append the lines\n        let lineGroup = svg.select(".lines");\n        lineGroup.selectAll("circle").remove();\n\n        let circle = false;\n        let lastMouse = null;\n        let lastMin = null;\n\n        if (lineGroup.empty()) {\n            lineGroup = svg\n                .append("g")\n                .attr("class", "lines")\n\n            lineGroup\n                .append("rect")\n                .style("opacity", "0")\n                .attr("width", "100%")\n                .attr("height", "100%");\n        }\n\n        lineGroup\n            .on("mousemove", (d, i, nodes) => { // Darken the bar on mouse over\n                const mouse = d3.mouse(nodes[i]);\n\n                const xval = x.invert(mouse[0]);\n                const yval = y.invert(mouse[1]);\n                // let min = this.getClosestPoint(xval, yval, this.getTransformedData()[0].data);\n\n                let mins = data.map(d => this.getClosestPoint(xval, yval, d.data));\n                mins.forEach(d => d._dist =  [x(d._x), y(d._y)])\n\n                mins = mins.filter(min => {\n                    const minScreenDist = Math.sqrt((mouse[0] - min._dist[0]) ** 2 + (mouse[1] - min._dist[1]) ** 2);\n                    min._min_screen = minScreenDist;\n                    return minScreenDist < 100;\n                });\n\n\n                if (!mins || !mins.length) {\n                    lastMouse = null;\n                    lineGroup.selectAll("circle").remove();\n                    return;\n                }\n\n                mins = mins.sort((lhs, rhs) => lhs._min_screen - rhs._min_screen);\n                let min = mins[0];\n\n                if (circle) {\n                    if (lastMin && min._x.getTime() === lastMin._x.getTime()) return;\n                    lineGroup.selectAll("circle").remove();\n                }\n\n                circle = true;\n                lastMouse = mouse;\n                lastMin = min;\n                lineGroup\n                    .append("circle")\n                        .attr("cx", x(min._x))\n                        .attr("cy", y(min._y))\n                        .attr("r", 10)\n                        .attr("fill", this.getSeriesColour(min._s_i))\n                        .style("opacity", 0.1)\n                    .on("mouseover", () => {\n                        this._dispatch.call("tooltipShow", this, {\n                            e: d3.event,\n                            point: min,\n                            series: data[min._s_i],\n                            seriesIndex: min._s_i,\n                            value: min._y\n                        })\n                    })\n                    .on("mouseout", (d, i, nodes) => { // bar is regular colour on mouse out.\n                        this._dispatch.call("tooltipHide", this);\n                    })\n                    .transition()\n                        .style("opacity", 0.5)\n\n            });\n\n        let lines = lineGroup.selectAll(\'.line\');\n        lines = lines.data(data);\n\n        lines.exit().remove();\n\n        const line = d3.line()\n            .x(d => x(d._x))\n            .y(d => y(d._y));\n\n        lines\n            .enter()\n            .append("path")\n                .attr("class", "line")\n                .attr("fill", "none")\n                .attr("stroke", (d, i) => this.getSeriesColour(i))\n                .attr("stroke-linejoin", "round")\n                .attr("stroke-linecap", "round")\n                .attr("stroke-width", 1.5)\n                .style("opacity", 0)\n\n            // .transition()\n            // .duration(this._duration)\n                .style("opacity", 1)\n                .attr("d", d => line(d.data));\n\n        lines\n            // .transition()\n            .attr("d", d => line(d.data));\n\n\n        // Adding new groups, and hence adding new bars to those groups.\n        // groups.enter()\n        //     .append("g")\n        //     .attr("class", "group")\n        //     .attr("transform", d => "translate(" + x(d.key) + ",0)")\n        //     .attr("width", x.bandwidth())\n        //     .attr("height", "100%")\n        //     .merge(groups)\n        //     .interrupt("groups:move")\n        //     .transition("groups:move")\n        //     .attr("transform", d => "translate(" + x(d.key) + ",0)")\n        //     .attr("width", x.bandwidth())\n        //     .each((s_d, s_i, nodes) => {\n        //         let group = d3.select(nodes[s_i])\n        //\n        //         let bars = group.selectAll(".bar")\n        //             .data(s_d.data);\n        //\n        //         bars.exit().remove();\n        //\n        //         bars.interrupt("bar:move")     // Animate the bars to their new position.\n        //             .transition("bar:move")\n        //             .attr("width", xGroup.bandwidth())\n        //             .attr("x", d => xGroup(d._key))\n        //             .attr("y", 0);\n        //\n        //         bars.enter()\n        //             .append("rect")\n        //             .attr("class", (d, i) => "bar series series-" + i)\n        //             .attr("x", d => xGroup(d._key))\n        //             .attr("y", 0)\n        //             .attr("width", xGroup.bandwidth())\n        //             .attr("height", 0)\n        //             .style("fill", (d, i) => this.getSeriesColour(i))\n        //             .style("cursor", "pointer")\n        //             .on("mouseover", (d, i, nodes) => { // Darken the bar on mouse over\n        //                 d3.select(nodes[i])\n        //                     .interrupt("hover:colour")\n        //                     .transition("hover:colour")\n        //                     .duration(400)\n        //                     .style("fill", d3.hcl(this.getSeriesColour(i)).darker())\n        //                 this._dispatch.call("tooltipShow", this, {\n        //                     e: d3.event,\n        //                     point: d,\n        //                     series: s_d,\n        //                     seriesIndex: s_i,\n        //                     value: d._y\n        //                 })\n        //             })\n        //             .on("mouseout", (d, i, nodes) => { // bar is regular colour on mouse out.\n        //                 d3.select(nodes[i])\n        //                     .interrupt("hover:colour")\n        //                     .transition("hover:colour")\n        //                     .duration(400)\n        //                     .style("fill", this.getSeriesColour(i));\n        //                 this._dispatch.call("tooltipHide", this);\n        //             })\n        //             .on("click auxclick", (d, i, nodes) => {\n        //                 this._dispatch.call("elementClick", this, {\n        //                     e: d3.event,\n        //                     point: d,\n        //                     series: d._series,\n        //                     seriesIndex: s_i,\n        //                     value: this._y(d)\n        //                 })\n        //             })\n        //             .merge(bars)\n        //             .interrupt("bar:growth")    // Animate bars growing.\n        //             .transition("bar:growth")\n        //             .delay((d) => {\n        //                 return this.calcBarGrowth(s_i, nodes.length);\n        //             })\n        //             .duration(this._duration)\n        //             .style("fill", (d, i) => this.getSeriesColour(i))\n        //             .attr("height", d => height - y(d._y));\n        //\n        //     })\n\n        // ---------------------------------\n        // Labels loaded after our first bar grows.\n        // if (this._show_labels) {\n        //     svg.transition("bar:growth")\n        //         .on("end", (d, i, nodes) => {\n        //             if (i < nodes.length - 1) return;\n        //             this.renderLabels(svg, data, x, xGroup, y);\n        //         })\n        // }\n\n        // ---------------------------------\n        // Draw the y axis data label.\n\n        if (this._dataAxisLabel) {\n            this.renderDataAxisLabel(height, margin);\n        }\n\n        // ---------------------------------\n        // Set the background colour\n\n        d3.select(this._element).select(".background").remove();\n        if (this._backgroundColour) {\n            d3.select(this._element).select("svg")\n                .append("rect")\n                .attr("class", "background")\n                .attr("width", "100%")\n                .attr("height", "100%")\n                .style("fill", this._backgroundColour)\n                .lower();\n        }\n\n        //---------------------------------\n        // add the Y gridlines\n        svg.call(this.grid, width, d3.axisLeft(y).ticks(5));\n\n        //---------------------------------\n        // axes\n        svg.call(this.xaxis, height, d3.axisBottom(x).tickSize(0).tickPadding(5).tickFormat(this._xAxisTickFormat)); //); //\n        svg.call(this.yaxis, d3.axisLeft(y).ticks(5).tickFormat(this._tickFormat));\n    }\n\n    //------------------------------------------------------\n\n    /*\n     * Returns an object with two functions, #show() and #hide(),\n     * to show and hide the labels.\n     */\n    labels() {\n        return {\n\n            show: () => {\n                if (this._element) {\n                    let selection = this._element,\n                        data = this.getTransformedData(),\n                        xscale = this._xscale,\n                        xgroup = this._xgroupscale,\n                        yscale = this._yscale;\n\n                    if (selection) selection = d3.select(this._element).select("svg").select("g");\n                    if (!selection.empty() && data && xscale && yscale && xgroup) {\n                        let labels = selection.select(\'.chart-labels\');\n                        if (!labels.empty()) return;\n                        labels.remove()\n                        this.renderLabels(selection, data, xscale, xgroup, yscale, false);\n                    }\n                }\n\n            },\n\n            hide: () => {\n                if (this._element) {\n                    d3.select(this._element)\n                        .select(\'.chart-labels\')\n                        .interrupt("labels")\n                        .interrupt("labels:fade")\n                        .transition("labels:fade")\n                        .style("opacity", 0)\n                        .on("end", (d, i, nodes) => {\n                            d3.select(nodes[i]).remove();\n                        })\n                }\n            }\n        }\n    }\n\n    //------------------------------------------------------\n\n    renderLabels(selection, data, xscale, xgroup, yscale, animate) {\n        animate = animate === undefined ? true : animate;\n        selection.selectAll(".chart-labels").remove();\n\n        let labels = selection.append("g")\n            .attr("class", "chart-labels")\n            // .selectAll(".chart-label")\n            .selectAll(".label-group")\n            .data(data)\n\n        let maxWidth = 0;     // For calculating the max width of text.\n        let fontSize = 12;    // Our initial font size.\n        const buffer = 5;     // Buffer space between words and the top of a bar.\n        const calcDy = (ypos) => ypos < 10 ? fontSize + buffer : -buffer;\n\n        labels.enter().each((series, s_i, s_nodes) => {\n            let group = d3.select(s_nodes[s_i])\n                .append("g")\n                .attr("class", "label-group")\n                .attr("transform", d => "translate(" + xscale(d.key) + ",0)")\n                .selectAll(".chart-label")\n                .data(series.data)\n                .enter()\n                .each((d, i, nodes) => {\n\n                    // Want to figure out if the label is too dark / light for the\n                    // bar.\n                    let invertedColor = d3.hcl(this.getSeriesColour(i));\n                    invertedColor.l += Math.min(invertedColor.l + 50, 100);\n                    let invert = d3.hcl(this.getSeriesColour(i)).l < 60;\n\n                    let ypos = yscale(d._y);\n                    let dy = calcDy(ypos);\n                    let text = d3.select(nodes[i])\n                        .append("text")\n                        .text(this._labelFormat(d._y))\n                        .attr("class", "chart-label")\n                        .attr("y", ypos)\n                        .attr("dx", animate ? -15 : 0)\n                        .attr("dy", dy)\n                        .style("opacity", 0)\n                        .style("pointer-events", "none")\n                        // .style("font-family", "Open Sans, sans-serif")\n                        // .style("font-weight", "normal")\n                        // .style("font-size", fontSize + "px")\n                        .style("fill", dy > 0 && invert ? invertedColor.toString() : _Colours__WEBPACK_IMPORTED_MODULE_0__["colours"].eighteen.darkGrey);\n\n                    // Set the x position, which is based on width.\n                    const width = text.node().getBBox().width;\n                    maxWidth = Math.max(width, maxWidth);\n                    text\n                        .attr("x", xgroup(d._key) + xgroup.bandwidth() / 2 - width / 2);\n\n                    text\n                        .transition("labels")\n                        .delay(() => animate ? this.calcBarGrowth(s_i, s_nodes.length) : 0) // Delay in lockstep with bar growth.\n                        .duration(this._duration)\n                        .attr("dx", 0)\n                        .style("opacity", 1)\n                })\n        })\n\n\n        // Figure out if we don\'t have enough space to show our labels.\n        // We then want to resize, if possible.\n        if (xgroup.bandwidth() < maxWidth * 1.05) {\n            let scale = maxWidth / xgroup.bandwidth() * 1.05;\n            fontSize = Math.floor(fontSize / scale);\n\n            if (fontSize < 8) {\n                // The labels are too small.\n                labels.enter().selectAll("text").remove();\n            } else {\n                labels.enter()\n                    .merge(labels)\n                    .selectAll("text")\n                    .style("font-size", fontSize + "px")\n                    .each((d, i, nodes) => {\n                        const text = d3.select(nodes[i]);\n                        const width = text.node().getBBox().width;\n                        text\n                            .attr("x", xgroup(d._key) + xgroup.bandwidth() / 2 - width / 2)\n                            .attr("dy", calcDy(d._y));\n                    })\n            }\n        }\n    }\n\n    //------------------------------------------------------\n\n    renderDataAxisLabel(height, margins) {\n        let svg = d3.select(this._element).select(\'svg\');\n        svg.selectAll(".data-labels").remove();\n\n        if (!this._dataAxisLabel) return;\n        let text = this._dataAxisLabel;\n        if (text.long) text = text.long;\n\n        let x = -(margins.top + height / 2);\n\n        let label = svg.append("g")\n            .attr("class", "data-labels")\n            .append("text")\n            .text(text)\n            .attr("transform", "rotate(-90 0,0) translate(" + x + ", 20)")\n            // .style("font-family", "Open Sans, sans-serif")\n            // .style("font-size", "12px")\n            // .style("font-style", "italic")\n            .style("fill", _Colours__WEBPACK_IMPORTED_MODULE_0__["colours"].eighteen.darkGrey);\n\n        let width = label.node().getBBox().width;\n        if (width >= height && this._dataAxisLabel.short) {\n            label.text(this._dataAxisLabel.short);\n            width = label.node().getBBox().width;\n        }\n\n        label.attr("dx", -width / 2);\n    }\n\n    //------------------------------------------------------\n\n    grid(selection, width, axis) {\n        selection.select(".grid").remove();\n\n        let grid = selection.append("g")\n            .attr("class", "grid")\n            .call(axis\n                .tickSize(-width)\n                .tickFormat("")\n            );\n\n        grid.selectAll("line")\n            .style("stroke", _Colours__WEBPACK_IMPORTED_MODULE_0__["colours"].eighteen.lightGrey);\n        grid.selectAll(".domain").remove();\n\n        grid\n            .lower() // Always ensure that this is earlier in the dom. Things must be drawn on top of it.\n            .style("opacity", 0)\n            .transition()\n            .delay(500)\n            .duration(500)\n            .style("opacity", 1);\n    }\n\n    //------------------------------------------------------\n\n    xaxis(selection, height, xaxis) {\n        selection.select(".x-axis").remove();\n        let axis = selection.append("g")\n            .attr("class", "x-axis")\n            .attr("transform", "translate(0," + height + ")")\n            .style("opacity", 0)\n            .call(xaxis);\n\n        axis.select(".domain").remove();\n\n        axis\n            .selectAll("text")\n            .style(\'text-anchor\', \'end\')\n            .attr(\'transform\', \'rotate(-30, 0,0)\');\n\n        axis\n            .transition()\n            .duration(1000)\n            .style("opacity", 1);\n    }\n\n    //------------------------------------------------------\n\n    yaxis(selection, axis) {\n        selection.select(".y-axis").remove();\n        let x = selection.append("g")\n            .attr("class", "y-axis")\n            .call(axis.tickSize(0).tickPadding(10))\n            .style("opacity", 0)\n            .transition()\n            .duration(1000)\n            .style("opacity", 1);\n\n        x.selectAll("text")\n            // .style("font-family", "Open Sans, sans-serif")\n            .style("fill", _Colours__WEBPACK_IMPORTED_MODULE_0__["colours"].eighteen.darkGrey)\n    }\n\n    //------------------------------------------------------\n\n    calcBarGrowth(i, max) {\n        if (max < 10) return i * this._BAR_GROWTH / 2;\n        if (max < 35) return i * this._BAR_GROWTH / 4;\n        return 1;\n    }\n\n    getSeriesColour(i) {\n        if (i < 0 || !this._colours) return _Colours__WEBPACK_IMPORTED_MODULE_0__["colours"].eighteen.midGrey;\n\n        i = i % this._colours.length;\n        return this._colours[i];\n    }\n\n    getSortedData() {\n        let data = this._data;\n        if (!data || !data.length) return [];\n\n        data = this._data.sort((lhs, rhs) => {\n            lhs = lhs.key.toLowerCase();\n            rhs = rhs.key.toLowerCase();\n\n            if (lhs === rhs) return 0;\n            if (lhs < rhs) return -1;\n            return 1;\n        });\n\n        return data;\n    }\n\n    getTransformedData() {\n        let data = this.getSortedData();\n        if (!data || !data.length) return [];\n\n        let results = [];\n\n        data.forEach((series, s_i) => {\n            let s = Object.assign({}, series);\n            results.push(s);\n\n            let data = [];\n            s.values.forEach((d) => {\n                data.push(Object.assign({\n                    _x: new Date(this._xAxisOverride ? this._xAxisOverride[this._x(d)] : this._x(d)),\n                    _series: series,\n                    _s_i: s_i,\n                    _key: series.key,\n                    _y: this._y(d)\n                }, d));\n            });\n\n            s.data = data;\n            delete s.values;\n        });\n\n        return results;\n    }\n\n    getKeys() {\n        let data = this._data;\n        if (!data || !data.length) return [];\n\n        return [...new Set(data.map(d => d.key))]\n    }\n\n    getClosestPoint(xval, yval, data) {\n        let calcDist = d => Math.sqrt(Math.abs(d._x - xval) ** 2 + (d._y - yval) ** 2);\n        let min = data[0];\n        let minDist = calcDist(min);\n\n        data.forEach(d => {\n            let dist = calcDist(d);\n            if (dist < minDist) {\n                minDist = dist;\n                min = d;\n            }\n        });\n\n        return min;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvTGluZUNoYXJ0LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYjNqcy8uL3NyYy9MaW5lQ2hhcnQuanM/ODk0ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKEMpIDIwMTMtMjAxNCwgMjAxOCBCcmFuZHNFeWUgKFBUWSkgTFREXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZiB0aGlzXG4vLyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmVcbi8vIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSxcbi8vICAgICBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvXG4vLyBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZ1xuLy8gY29uZGl0aW9uczpcbi8vXG4vLyAgICAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4vLyBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vICAgICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SIElNUExJRUQsXG4vLyAgICAgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEFcbi8vIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFRcbi8vIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRlxuLy8gQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFXG4vLyBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IHtjb2xvdXJzfSBmcm9tICcuL0NvbG91cnMnO1xuaW1wb3J0IHtDaGFydH0gZnJvbSAnLi9DaGFydCc7XG5cblxuZXhwb3J0IGNsYXNzIExpbmVDaGFydCBleHRlbmRzIENoYXJ0IHtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl94QXhpc1RpY2tGb3JtYXQgPSBkMy50aW1lRm9ybWF0KFwiJUIgJWRcIik7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGRhdGEoZGF0YSkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9kYXRhO1xuICAgICAgICBpZiAoZGF0YSAmJiBkYXRhWzBdLmtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBkYXRhID0gW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAga2V5OiBcInNlcmllcyAxXCIsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlczogZGF0YVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZGF0YSA9IGRhdGE7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBlbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fZWxlbWVudDtcbiAgICAgICAgdGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBzaG93TGFiZWxzKHNob3cpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fc2hvd19sYWJlbHM7XG4gICAgICAgIHRoaXMuX3Nob3dfbGFiZWxzID0gc2hvdztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8vIHRvZG8gZGlzcGF0Y2hcbiAgICBzaG93TGVnZW5kKHNob3cpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fc2hvd19sZWdlbmQ7XG4gICAgICAgIHRoaXMuX3Nob3dfbGVnZW5kID0gc2hvdztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHgoeCkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl94O1xuICAgICAgICB0aGlzLl94ID0geDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHkoeSkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl95O1xuICAgICAgICB0aGlzLl95ID0geTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHdpZHRoKHdpZHRoKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3dpZHRoO1xuICAgICAgICB0aGlzLl93aWR0aCA9IHdpZHRoO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgaGVpZ2h0KGhlaWdodCkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9oZWlnaHQ7XG4gICAgICAgIHRoaXMuX2hlaWdodCA9IGhlaWdodDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGNvbG91cnMoY29sb3Vycykge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9jb2xvdXJzO1xuICAgICAgICB0aGlzLl9jb2xvdXJzID0gY29sb3VycztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGJhY2tncm91bmRDb2xvdXIoY29sb3VyKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX2JhY2tncm91bmRDb2xvdXI7XG4gICAgICAgIHRoaXMuX2JhY2tncm91bmRDb2xvdXIgPSBjb2xvdXIgfHwgXCIjRkZGXCI7IC8vIG5ldmVyIHNldCBpdCB0byBudWxsLlxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgdGlja0Zvcm1hdChmb3JtYXQpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fdGlja0Zvcm1hdDtcbiAgICAgICAgdGhpcy5fdGlja0Zvcm1hdCA9IGZvcm1hdDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHhBeGlzVGlja0Zvcm1hdChmb3JtYXQpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5feEF4aXNUaWNrRm9ybWF0O1xuICAgICAgICB0aGlzLl94QXhpc1RpY2tGb3JtYXQgPSBmb3JtYXQgfHwgKGQgPT4gZC50b1N0cmluZygpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGxhYmVsRm9ybWF0KGZvcm1hdCkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9sYWJlbEZvcm1hdDtcbiAgICAgICAgdGhpcy5fbGFiZWxGb3JtYXQgPSBmb3JtYXQgfHwgKGQgPT4gZC50b1N0cmluZygpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8vIHRvZG8gbWlzc2luZ1xuICAgIGxhYmVsQ29tcHJlc3Npb24oY29tcHJlc3Npb24pIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fY29tcHJlc3Npb247XG4gICAgICAgIHRoaXMuX2NvbXByZXNzaW9uID0gY29tcHJlc3Npb247XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvL3RvZG8gbWlzc2luZ1xuICAgIGRhdGFBeGlzTGFiZWwobGFiZWwpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fZGF0YUF4aXNMYWJlbDtcbiAgICAgICAgdGhpcy5fZGF0YUF4aXNMYWJlbCA9IGxhYmVsO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgdG9vbHRpcCh0b29sdGlwKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3Rvb2x0aXA7XG4gICAgICAgIHRoaXMuX3Rvb2x0aXAgPSB0b29sdGlwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgZm9yY2VZKGZvcmNlKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX2ZvcmNlWTtcbiAgICAgICAgdGhpcy5fZm9yY2VZID0gZm9yY2U7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8vIHRvZG8gbWlzc2luZ1xuICAgIGR1cmF0aW9uKGR1cmF0aW9uKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX2R1cmF0aW9uO1xuICAgICAgICB0aGlzLl9kdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbi8vIHRvZG8gbWlzc2luZ1xuICAgIGNvYXJzZW5lc3MoY29hcnNlbmVzcykge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9jb2Fyc2VuZXNzO1xuICAgICAgICB0aGlzLl9jb2Fyc2VuZXNzID0gY29hcnNlbmVzcztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gdG9kbyBtaXNzaW5nXG4gICAgcGFkZGluZyhwYWRkaW5nKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3BhZGRpbmc7XG4gICAgICAgIHRoaXMuX3BhZGRpbmcgPSBwYWRkaW5nO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyB0b2RvIG1pc3NpbmdcbiAgICB4QXhpc1Rvb2x0aXBzKHRvb2x0aXBzKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3hBeGlzVG9vbHRpcHM7XG4gICAgICAgIHRoaXMuX3hBeGlzVG9vbHRpcHMgPSB0b29sdGlwcztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgeEF4aXNPdmVycmlkZShvdmVycmlkZSkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl94QXhpc092ZXJyaWRlO1xuICAgICAgICB0aGlzLl94QXhpc092ZXJyaWRlID0gb3ZlcnJpZGU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBkaXNwYXRjaCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc3BhdGNoO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGlmICghdGhpcy5fZWxlbWVudCkgdGhyb3cgbmV3IEVycm9yKFwiTm8gZWxlbWVudCBzZXQgZm9yIENvbHVtbkNoYXJ0LiBTZWUgI2VsZW1lbnQoKVwiKTtcbiAgICAgICAgaWYgKCF0aGlzLl9kYXRhKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJObyBkYXRhIHNldCBmb3IgQ29sdW1uQ2hhcnQuIFNlZSAjZGF0YSgpXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMuZ2V0VHJhbnNmb3JtZWREYXRhKCk7XG4gICAgICAgIGNvbnN0IGtleXMgPSB0aGlzLmdldEtleXMoKTtcblxuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBTZXQgdXAgdGhlIFNWRyBhcmVhXG5cbiAgICAgICAgbGV0IHRvcExldmVsID0gZDMuc2VsZWN0KHRoaXMuX2VsZW1lbnQpLnNlbGVjdChcInN2Z1wiKTtcbiAgICAgICAgaWYgKHRvcExldmVsLmVtcHR5KCkpIHtcbiAgICAgICAgICAgIHRvcExldmVsID0gZDMuc2VsZWN0KHRoaXMuX2VsZW1lbnQpLmFwcGVuZChcInN2Z1wiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRvcExldmVsXG4gICAgICAgICAgICAuc3R5bGUoXCJ3aWR0aFwiLCB0aGlzLl93aWR0aCArIFwicHhcIilcbiAgICAgICAgICAgIC5zdHlsZShcImhlaWdodFwiLCB0aGlzLl9oZWlnaHQgKyBcInB4XCIpO1xuXG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIExheW91dCB0aGUgc2hvd0xlZ2VuZC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gV2UgZG8gdGhpcyBub3cgYmVjYXVzZSB3ZSBuZWVkIHRvIGtub3cgaG93IG11Y2ggc3BhY2UgdGhlIGxlZ2VuZFxuICAgICAgICAvLyB0YWtlcyB1cCBpbiBvcmRlciB0byBmaW5pc2ggY2FsY3VsYXRpbmcgdGhlIG1hcmdpbnMuXG5cbiAgICAgICAgY29uc3QgbGVnZW5kSGVpZ2h0ID0gdGhpcy5yZW5kZXJMZWdlbmQoKTtcblxuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gQ2FsY3VsYXRlIG1hcmdpbnMuXG5cbiAgICAgICAgY29uc3QgbWFyZ2luID0ge3RvcDogMjAsIHJpZ2h0OiAyMCwgYm90dG9tOiA0MCwgbGVmdDogNDB9O1xuICAgICAgICBtYXJnaW4uYm90dG9tICs9IGxlZ2VuZEhlaWdodCA/IGxlZ2VuZEhlaWdodCArIDIwIDogMDtcblxuICAgICAgICBpZiAodGhpcy5fZGF0YUF4aXNMYWJlbCkgbWFyZ2luLmxlZnQgKz0gMjAgKyAxMjtcbiAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgIGxldCBtYXhMYWJlbExlbmd0aCA9IDA7XG4gICAgICAgICAgICBkYXRhLmZvckVhY2goZCA9PiB7XG4gICAgICAgICAgICAgICAgZC5kYXRhLmZvckVhY2goZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBsZW5ndGggPSB0aGlzLl94QXhpc1RpY2tGb3JtYXQodGhpcy5feChkKSkubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGVuZ3RoID4gbWF4TGFiZWxMZW5ndGgpIG1heExhYmVsTGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG1hcmdpbi5ib3R0b20gKz0gbWF4TGFiZWxMZW5ndGggKiAyICsgMTA7ICAgIC8vIHNwYWNlIGZvciBheGVzIGxhYmVscy5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHdpZHRoID0gdGhpcy5fd2lkdGggLSBtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodCxcbiAgICAgICAgICAgIGhlaWdodCA9IHRoaXMuX2hlaWdodCAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tO1xuXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBDYWxjdWxhdGUgc2NhbGVzIGFuZCBzbyBvbi5cblxuXG4gICAgICAgIGNvbnN0IHggPSBkMy5zY2FsZVRpbWUoKVxuICAgICAgICAgICAgLnJhbmdlKFswLCB3aWR0aF0pO1xuXG4gICAgICAgIGNvbnN0IHkgPSBkMy5zY2FsZUxpbmVhcigpXG4gICAgICAgICAgICAucmFuZ2UoW2hlaWdodCwgMF0pXG4gICAgICAgICAgICAubmljZSg1KTtcbiAgICAgICAgdGhpcy5feHNjYWxlID0geDtcbiAgICAgICAgdGhpcy5feXNjYWxlID0geTtcblxuICAgICAgICAvLyBTY2FsZSB0aGUgcmFuZ2Ugb2YgdGhlIGRhdGEgaW4gdGhlIGRvbWFpbnNcblxuICAgICAgICBjb25zdCBhbGxEYXRhID0gZGF0YS5tYXAoZCA9PiBkLmRhdGEpLnJlZHVjZSgoYWNjLCB2YWwpID0+IGFjYy5jb25jYXQodmFsKSk7XG4gICAgICAgIHguZG9tYWluKGQzLmV4dGVudChhbGxEYXRhLCBkID0+IGQuX3gpKTtcbiAgICAgICAgeS5kb21haW4oW01hdGgubWluKDAsIGQzLm1pbihhbGxEYXRhLCBkID0+IGQuX3kpKSwgZDMubWF4KGFsbERhdGEsIGQgPT4gZC5feSldKTtcblxuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgIGxldCBzdmcgPSB0b3BMZXZlbC5zZWxlY3QoJy5tYWluLWdyb3VwJyk7XG5cbiAgICAgICAgaWYgKHN2Zy5lbXB0eSgpKSB7XG4gICAgICAgICAgICBzdmcgPSB0b3BMZXZlbFxuICAgICAgICAgICAgICAgIC5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcIm1haW4tZ3JvdXBcIik7XG4gICAgICAgIH1cblxuICAgICAgICBzdmcuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIG1hcmdpbi5sZWZ0ICsgXCIsXCIgKyBtYXJnaW4udG9wICsgXCIpXCIpO1xuXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIGFwcGVuZCB0aGUgbGluZXNcbiAgICAgICAgbGV0IGxpbmVHcm91cCA9IHN2Zy5zZWxlY3QoXCIubGluZXNcIik7XG4gICAgICAgIGxpbmVHcm91cC5zZWxlY3RBbGwoXCJjaXJjbGVcIikucmVtb3ZlKCk7XG5cbiAgICAgICAgbGV0IGNpcmNsZSA9IGZhbHNlO1xuICAgICAgICBsZXQgbGFzdE1vdXNlID0gbnVsbDtcbiAgICAgICAgbGV0IGxhc3RNaW4gPSBudWxsO1xuXG4gICAgICAgIGlmIChsaW5lR3JvdXAuZW1wdHkoKSkge1xuICAgICAgICAgICAgbGluZUdyb3VwID0gc3ZnXG4gICAgICAgICAgICAgICAgLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwibGluZXNcIilcblxuICAgICAgICAgICAgbGluZUdyb3VwXG4gICAgICAgICAgICAgICAgLmFwcGVuZChcInJlY3RcIilcbiAgICAgICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMFwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwid2lkdGhcIiwgXCIxMDAlXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgXCIxMDAlXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGluZUdyb3VwXG4gICAgICAgICAgICAub24oXCJtb3VzZW1vdmVcIiwgKGQsIGksIG5vZGVzKSA9PiB7IC8vIERhcmtlbiB0aGUgYmFyIG9uIG1vdXNlIG92ZXJcbiAgICAgICAgICAgICAgICBjb25zdCBtb3VzZSA9IGQzLm1vdXNlKG5vZGVzW2ldKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHh2YWwgPSB4LmludmVydChtb3VzZVswXSk7XG4gICAgICAgICAgICAgICAgY29uc3QgeXZhbCA9IHkuaW52ZXJ0KG1vdXNlWzFdKTtcbiAgICAgICAgICAgICAgICAvLyBsZXQgbWluID0gdGhpcy5nZXRDbG9zZXN0UG9pbnQoeHZhbCwgeXZhbCwgdGhpcy5nZXRUcmFuc2Zvcm1lZERhdGEoKVswXS5kYXRhKTtcblxuICAgICAgICAgICAgICAgIGxldCBtaW5zID0gZGF0YS5tYXAoZCA9PiB0aGlzLmdldENsb3Nlc3RQb2ludCh4dmFsLCB5dmFsLCBkLmRhdGEpKTtcbiAgICAgICAgICAgICAgICBtaW5zLmZvckVhY2goZCA9PiBkLl9kaXN0ID0gIFt4KGQuX3gpLCB5KGQuX3kpXSlcblxuICAgICAgICAgICAgICAgIG1pbnMgPSBtaW5zLmZpbHRlcihtaW4gPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtaW5TY3JlZW5EaXN0ID0gTWF0aC5zcXJ0KChtb3VzZVswXSAtIG1pbi5fZGlzdFswXSkgKiogMiArIChtb3VzZVsxXSAtIG1pbi5fZGlzdFsxXSkgKiogMik7XG4gICAgICAgICAgICAgICAgICAgIG1pbi5fbWluX3NjcmVlbiA9IG1pblNjcmVlbkRpc3Q7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtaW5TY3JlZW5EaXN0IDwgMTAwO1xuICAgICAgICAgICAgICAgIH0pO1xuXG5cbiAgICAgICAgICAgICAgICBpZiAoIW1pbnMgfHwgIW1pbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RNb3VzZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVHcm91cC5zZWxlY3RBbGwoXCJjaXJjbGVcIikucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtaW5zID0gbWlucy5zb3J0KChsaHMsIHJocykgPT4gbGhzLl9taW5fc2NyZWVuIC0gcmhzLl9taW5fc2NyZWVuKTtcbiAgICAgICAgICAgICAgICBsZXQgbWluID0gbWluc1swXTtcblxuICAgICAgICAgICAgICAgIGlmIChjaXJjbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3RNaW4gJiYgbWluLl94LmdldFRpbWUoKSA9PT0gbGFzdE1pbi5feC5nZXRUaW1lKCkpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgbGluZUdyb3VwLnNlbGVjdEFsbChcImNpcmNsZVwiKS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjaXJjbGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGxhc3RNb3VzZSA9IG1vdXNlO1xuICAgICAgICAgICAgICAgIGxhc3RNaW4gPSBtaW47XG4gICAgICAgICAgICAgICAgbGluZUdyb3VwXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoXCJjaXJjbGVcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiY3hcIiwgeChtaW4uX3gpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJjeVwiLCB5KG1pbi5feSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcInJcIiwgMTApXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcImZpbGxcIiwgdGhpcy5nZXRTZXJpZXNDb2xvdXIobWluLl9zX2kpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAwLjEpXG4gICAgICAgICAgICAgICAgICAgIC5vbihcIm1vdXNlb3ZlclwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXNwYXRjaC5jYWxsKFwidG9vbHRpcFNob3dcIiwgdGhpcywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGU6IGQzLmV2ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50OiBtaW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzOiBkYXRhW21pbi5fc19pXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXNJbmRleDogbWluLl9zX2ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG1pbi5feVxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLm9uKFwibW91c2VvdXRcIiwgKGQsIGksIG5vZGVzKSA9PiB7IC8vIGJhciBpcyByZWd1bGFyIGNvbG91ciBvbiBtb3VzZSBvdXQuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXNwYXRjaC5jYWxsKFwidG9vbHRpcEhpZGVcIiwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMC41KVxuXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICBsZXQgbGluZXMgPSBsaW5lR3JvdXAuc2VsZWN0QWxsKCcubGluZScpO1xuICAgICAgICBsaW5lcyA9IGxpbmVzLmRhdGEoZGF0YSk7XG5cbiAgICAgICAgbGluZXMuZXhpdCgpLnJlbW92ZSgpO1xuXG4gICAgICAgIGNvbnN0IGxpbmUgPSBkMy5saW5lKClcbiAgICAgICAgICAgIC54KGQgPT4geChkLl94KSlcbiAgICAgICAgICAgIC55KGQgPT4geShkLl95KSk7XG5cbiAgICAgICAgbGluZXNcbiAgICAgICAgICAgIC5lbnRlcigpXG4gICAgICAgICAgICAuYXBwZW5kKFwicGF0aFwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJsaW5lXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJmaWxsXCIsIFwibm9uZVwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwic3Ryb2tlXCIsIChkLCBpKSA9PiB0aGlzLmdldFNlcmllc0NvbG91cihpKSlcbiAgICAgICAgICAgICAgICAuYXR0cihcInN0cm9rZS1saW5lam9pblwiLCBcInJvdW5kXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJzdHJva2UtbGluZWNhcFwiLCBcInJvdW5kXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJzdHJva2Utd2lkdGhcIiwgMS41KVxuICAgICAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMClcblxuICAgICAgICAgICAgLy8gLnRyYW5zaXRpb24oKVxuICAgICAgICAgICAgLy8gLmR1cmF0aW9uKHRoaXMuX2R1cmF0aW9uKVxuICAgICAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMSlcbiAgICAgICAgICAgICAgICAuYXR0cihcImRcIiwgZCA9PiBsaW5lKGQuZGF0YSkpO1xuXG4gICAgICAgIGxpbmVzXG4gICAgICAgICAgICAvLyAudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAuYXR0cihcImRcIiwgZCA9PiBsaW5lKGQuZGF0YSkpO1xuXG5cbiAgICAgICAgLy8gQWRkaW5nIG5ldyBncm91cHMsIGFuZCBoZW5jZSBhZGRpbmcgbmV3IGJhcnMgdG8gdGhvc2UgZ3JvdXBzLlxuICAgICAgICAvLyBncm91cHMuZW50ZXIoKVxuICAgICAgICAvLyAgICAgLmFwcGVuZChcImdcIilcbiAgICAgICAgLy8gICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJncm91cFwiKVxuICAgICAgICAvLyAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgZCA9PiBcInRyYW5zbGF0ZShcIiArIHgoZC5rZXkpICsgXCIsMClcIilcbiAgICAgICAgLy8gICAgIC5hdHRyKFwid2lkdGhcIiwgeC5iYW5kd2lkdGgoKSlcbiAgICAgICAgLy8gICAgIC5hdHRyKFwiaGVpZ2h0XCIsIFwiMTAwJVwiKVxuICAgICAgICAvLyAgICAgLm1lcmdlKGdyb3VwcylcbiAgICAgICAgLy8gICAgIC5pbnRlcnJ1cHQoXCJncm91cHM6bW92ZVwiKVxuICAgICAgICAvLyAgICAgLnRyYW5zaXRpb24oXCJncm91cHM6bW92ZVwiKVxuICAgICAgICAvLyAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgZCA9PiBcInRyYW5zbGF0ZShcIiArIHgoZC5rZXkpICsgXCIsMClcIilcbiAgICAgICAgLy8gICAgIC5hdHRyKFwid2lkdGhcIiwgeC5iYW5kd2lkdGgoKSlcbiAgICAgICAgLy8gICAgIC5lYWNoKChzX2QsIHNfaSwgbm9kZXMpID0+IHtcbiAgICAgICAgLy8gICAgICAgICBsZXQgZ3JvdXAgPSBkMy5zZWxlY3Qobm9kZXNbc19pXSlcbiAgICAgICAgLy9cbiAgICAgICAgLy8gICAgICAgICBsZXQgYmFycyA9IGdyb3VwLnNlbGVjdEFsbChcIi5iYXJcIilcbiAgICAgICAgLy8gICAgICAgICAgICAgLmRhdGEoc19kLmRhdGEpO1xuICAgICAgICAvL1xuICAgICAgICAvLyAgICAgICAgIGJhcnMuZXhpdCgpLnJlbW92ZSgpO1xuICAgICAgICAvL1xuICAgICAgICAvLyAgICAgICAgIGJhcnMuaW50ZXJydXB0KFwiYmFyOm1vdmVcIikgICAgIC8vIEFuaW1hdGUgdGhlIGJhcnMgdG8gdGhlaXIgbmV3IHBvc2l0aW9uLlxuICAgICAgICAvLyAgICAgICAgICAgICAudHJhbnNpdGlvbihcImJhcjptb3ZlXCIpXG4gICAgICAgIC8vICAgICAgICAgICAgIC5hdHRyKFwid2lkdGhcIiwgeEdyb3VwLmJhbmR3aWR0aCgpKVxuICAgICAgICAvLyAgICAgICAgICAgICAuYXR0cihcInhcIiwgZCA9PiB4R3JvdXAoZC5fa2V5KSlcbiAgICAgICAgLy8gICAgICAgICAgICAgLmF0dHIoXCJ5XCIsIDApO1xuICAgICAgICAvL1xuICAgICAgICAvLyAgICAgICAgIGJhcnMuZW50ZXIoKVxuICAgICAgICAvLyAgICAgICAgICAgICAuYXBwZW5kKFwicmVjdFwiKVxuICAgICAgICAvLyAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIChkLCBpKSA9PiBcImJhciBzZXJpZXMgc2VyaWVzLVwiICsgaSlcbiAgICAgICAgLy8gICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIGQgPT4geEdyb3VwKGQuX2tleSkpXG4gICAgICAgIC8vICAgICAgICAgICAgIC5hdHRyKFwieVwiLCAwKVxuICAgICAgICAvLyAgICAgICAgICAgICAuYXR0cihcIndpZHRoXCIsIHhHcm91cC5iYW5kd2lkdGgoKSlcbiAgICAgICAgLy8gICAgICAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgMClcbiAgICAgICAgLy8gICAgICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCAoZCwgaSkgPT4gdGhpcy5nZXRTZXJpZXNDb2xvdXIoaSkpXG4gICAgICAgIC8vICAgICAgICAgICAgIC5zdHlsZShcImN1cnNvclwiLCBcInBvaW50ZXJcIilcbiAgICAgICAgLy8gICAgICAgICAgICAgLm9uKFwibW91c2VvdmVyXCIsIChkLCBpLCBub2RlcykgPT4geyAvLyBEYXJrZW4gdGhlIGJhciBvbiBtb3VzZSBvdmVyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICBkMy5zZWxlY3Qobm9kZXNbaV0pXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgLmludGVycnVwdChcImhvdmVyOmNvbG91clwiKVxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKFwiaG92ZXI6Y29sb3VyXCIpXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKDQwMClcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIGQzLmhjbCh0aGlzLmdldFNlcmllc0NvbG91cihpKSkuZGFya2VyKCkpXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICB0aGlzLl9kaXNwYXRjaC5jYWxsKFwidG9vbHRpcFNob3dcIiwgdGhpcywge1xuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgIGU6IGQzLmV2ZW50LFxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgIHBvaW50OiBkLFxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgIHNlcmllczogc19kLFxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgIHNlcmllc0luZGV4OiBzX2ksXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGQuX3lcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgIH0pXG4gICAgICAgIC8vICAgICAgICAgICAgIH0pXG4gICAgICAgIC8vICAgICAgICAgICAgIC5vbihcIm1vdXNlb3V0XCIsIChkLCBpLCBub2RlcykgPT4geyAvLyBiYXIgaXMgcmVndWxhciBjb2xvdXIgb24gbW91c2Ugb3V0LlxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgZDMuc2VsZWN0KG5vZGVzW2ldKVxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgIC5pbnRlcnJ1cHQoXCJob3Zlcjpjb2xvdXJcIilcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAudHJhbnNpdGlvbihcImhvdmVyOmNvbG91clwiKVxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbig0MDApXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCB0aGlzLmdldFNlcmllc0NvbG91cihpKSk7XG4gICAgICAgIC8vICAgICAgICAgICAgICAgICB0aGlzLl9kaXNwYXRjaC5jYWxsKFwidG9vbHRpcEhpZGVcIiwgdGhpcyk7XG4gICAgICAgIC8vICAgICAgICAgICAgIH0pXG4gICAgICAgIC8vICAgICAgICAgICAgIC5vbihcImNsaWNrIGF1eGNsaWNrXCIsIChkLCBpLCBub2RlcykgPT4ge1xuICAgICAgICAvLyAgICAgICAgICAgICAgICAgdGhpcy5fZGlzcGF0Y2guY2FsbChcImVsZW1lbnRDbGlja1wiLCB0aGlzLCB7XG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgZTogZDMuZXZlbnQsXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgcG9pbnQ6IGQsXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgc2VyaWVzOiBkLl9zZXJpZXMsXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgc2VyaWVzSW5kZXg6IHNfaSxcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy5feShkKVxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgLy8gICAgICAgICAgICAgfSlcbiAgICAgICAgLy8gICAgICAgICAgICAgLm1lcmdlKGJhcnMpXG4gICAgICAgIC8vICAgICAgICAgICAgIC5pbnRlcnJ1cHQoXCJiYXI6Z3Jvd3RoXCIpICAgIC8vIEFuaW1hdGUgYmFycyBncm93aW5nLlxuICAgICAgICAvLyAgICAgICAgICAgICAudHJhbnNpdGlvbihcImJhcjpncm93dGhcIilcbiAgICAgICAgLy8gICAgICAgICAgICAgLmRlbGF5KChkKSA9PiB7XG4gICAgICAgIC8vICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jYWxjQmFyR3Jvd3RoKHNfaSwgbm9kZXMubGVuZ3RoKTtcbiAgICAgICAgLy8gICAgICAgICAgICAgfSlcbiAgICAgICAgLy8gICAgICAgICAgICAgLmR1cmF0aW9uKHRoaXMuX2R1cmF0aW9uKVxuICAgICAgICAvLyAgICAgICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIChkLCBpKSA9PiB0aGlzLmdldFNlcmllc0NvbG91cihpKSlcbiAgICAgICAgLy8gICAgICAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgZCA9PiBoZWlnaHQgLSB5KGQuX3kpKTtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gICAgIH0pXG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIExhYmVscyBsb2FkZWQgYWZ0ZXIgb3VyIGZpcnN0IGJhciBncm93cy5cbiAgICAgICAgLy8gaWYgKHRoaXMuX3Nob3dfbGFiZWxzKSB7XG4gICAgICAgIC8vICAgICBzdmcudHJhbnNpdGlvbihcImJhcjpncm93dGhcIilcbiAgICAgICAgLy8gICAgICAgICAub24oXCJlbmRcIiwgKGQsIGksIG5vZGVzKSA9PiB7XG4gICAgICAgIC8vICAgICAgICAgICAgIGlmIChpIDwgbm9kZXMubGVuZ3RoIC0gMSkgcmV0dXJuO1xuICAgICAgICAvLyAgICAgICAgICAgICB0aGlzLnJlbmRlckxhYmVscyhzdmcsIGRhdGEsIHgsIHhHcm91cCwgeSk7XG4gICAgICAgIC8vICAgICAgICAgfSlcbiAgICAgICAgLy8gfVxuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBEcmF3IHRoZSB5IGF4aXMgZGF0YSBsYWJlbC5cblxuICAgICAgICBpZiAodGhpcy5fZGF0YUF4aXNMYWJlbCkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJEYXRhQXhpc0xhYmVsKGhlaWdodCwgbWFyZ2luKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBTZXQgdGhlIGJhY2tncm91bmQgY29sb3VyXG5cbiAgICAgICAgZDMuc2VsZWN0KHRoaXMuX2VsZW1lbnQpLnNlbGVjdChcIi5iYWNrZ3JvdW5kXCIpLnJlbW92ZSgpO1xuICAgICAgICBpZiAodGhpcy5fYmFja2dyb3VuZENvbG91cikge1xuICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMuX2VsZW1lbnQpLnNlbGVjdChcInN2Z1wiKVxuICAgICAgICAgICAgICAgIC5hcHBlbmQoXCJyZWN0XCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImJhY2tncm91bmRcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcIndpZHRoXCIsIFwiMTAwJVwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIFwiMTAwJVwiKVxuICAgICAgICAgICAgICAgIC5zdHlsZShcImZpbGxcIiwgdGhpcy5fYmFja2dyb3VuZENvbG91cilcbiAgICAgICAgICAgICAgICAubG93ZXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIGFkZCB0aGUgWSBncmlkbGluZXNcbiAgICAgICAgc3ZnLmNhbGwodGhpcy5ncmlkLCB3aWR0aCwgZDMuYXhpc0xlZnQoeSkudGlja3MoNSkpO1xuXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIGF4ZXNcbiAgICAgICAgc3ZnLmNhbGwodGhpcy54YXhpcywgaGVpZ2h0LCBkMy5heGlzQm90dG9tKHgpLnRpY2tTaXplKDApLnRpY2tQYWRkaW5nKDUpLnRpY2tGb3JtYXQodGhpcy5feEF4aXNUaWNrRm9ybWF0KSk7IC8vKTsgLy9cbiAgICAgICAgc3ZnLmNhbGwodGhpcy55YXhpcywgZDMuYXhpc0xlZnQoeSkudGlja3MoNSkudGlja0Zvcm1hdCh0aGlzLl90aWNrRm9ybWF0KSk7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8qXG4gICAgICogUmV0dXJucyBhbiBvYmplY3Qgd2l0aCB0d28gZnVuY3Rpb25zLCAjc2hvdygpIGFuZCAjaGlkZSgpLFxuICAgICAqIHRvIHNob3cgYW5kIGhpZGUgdGhlIGxhYmVscy5cbiAgICAgKi9cbiAgICBsYWJlbHMoKSB7XG4gICAgICAgIHJldHVybiB7XG5cbiAgICAgICAgICAgIHNob3c6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgc2VsZWN0aW9uID0gdGhpcy5fZWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSB0aGlzLmdldFRyYW5zZm9ybWVkRGF0YSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgeHNjYWxlID0gdGhpcy5feHNjYWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgeGdyb3VwID0gdGhpcy5feGdyb3Vwc2NhbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB5c2NhbGUgPSB0aGlzLl95c2NhbGU7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvbikgc2VsZWN0aW9uID0gZDMuc2VsZWN0KHRoaXMuX2VsZW1lbnQpLnNlbGVjdChcInN2Z1wiKS5zZWxlY3QoXCJnXCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNlbGVjdGlvbi5lbXB0eSgpICYmIGRhdGEgJiYgeHNjYWxlICYmIHlzY2FsZSAmJiB4Z3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBsYWJlbHMgPSBzZWxlY3Rpb24uc2VsZWN0KCcuY2hhcnQtbGFiZWxzJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWxhYmVscy5lbXB0eSgpKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbHMucmVtb3ZlKClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyTGFiZWxzKHNlbGVjdGlvbiwgZGF0YSwgeHNjYWxlLCB4Z3JvdXAsIHlzY2FsZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBoaWRlOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2VsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMuX2VsZW1lbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc2VsZWN0KCcuY2hhcnQtbGFiZWxzJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5pbnRlcnJ1cHQoXCJsYWJlbHNcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5pbnRlcnJ1cHQoXCJsYWJlbHM6ZmFkZVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRyYW5zaXRpb24oXCJsYWJlbHM6ZmFkZVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm9uKFwiZW5kXCIsIChkLCBpLCBub2RlcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQzLnNlbGVjdChub2Rlc1tpXSkucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICByZW5kZXJMYWJlbHMoc2VsZWN0aW9uLCBkYXRhLCB4c2NhbGUsIHhncm91cCwgeXNjYWxlLCBhbmltYXRlKSB7XG4gICAgICAgIGFuaW1hdGUgPSBhbmltYXRlID09PSB1bmRlZmluZWQgPyB0cnVlIDogYW5pbWF0ZTtcbiAgICAgICAgc2VsZWN0aW9uLnNlbGVjdEFsbChcIi5jaGFydC1sYWJlbHNcIikucmVtb3ZlKCk7XG5cbiAgICAgICAgbGV0IGxhYmVscyA9IHNlbGVjdGlvbi5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwiY2hhcnQtbGFiZWxzXCIpXG4gICAgICAgICAgICAvLyAuc2VsZWN0QWxsKFwiLmNoYXJ0LWxhYmVsXCIpXG4gICAgICAgICAgICAuc2VsZWN0QWxsKFwiLmxhYmVsLWdyb3VwXCIpXG4gICAgICAgICAgICAuZGF0YShkYXRhKVxuXG4gICAgICAgIGxldCBtYXhXaWR0aCA9IDA7ICAgICAvLyBGb3IgY2FsY3VsYXRpbmcgdGhlIG1heCB3aWR0aCBvZiB0ZXh0LlxuICAgICAgICBsZXQgZm9udFNpemUgPSAxMjsgICAgLy8gT3VyIGluaXRpYWwgZm9udCBzaXplLlxuICAgICAgICBjb25zdCBidWZmZXIgPSA1OyAgICAgLy8gQnVmZmVyIHNwYWNlIGJldHdlZW4gd29yZHMgYW5kIHRoZSB0b3Agb2YgYSBiYXIuXG4gICAgICAgIGNvbnN0IGNhbGNEeSA9ICh5cG9zKSA9PiB5cG9zIDwgMTAgPyBmb250U2l6ZSArIGJ1ZmZlciA6IC1idWZmZXI7XG5cbiAgICAgICAgbGFiZWxzLmVudGVyKCkuZWFjaCgoc2VyaWVzLCBzX2ksIHNfbm9kZXMpID0+IHtcbiAgICAgICAgICAgIGxldCBncm91cCA9IGQzLnNlbGVjdChzX25vZGVzW3NfaV0pXG4gICAgICAgICAgICAgICAgLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwibGFiZWwtZ3JvdXBcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBkID0+IFwidHJhbnNsYXRlKFwiICsgeHNjYWxlKGQua2V5KSArIFwiLDApXCIpXG4gICAgICAgICAgICAgICAgLnNlbGVjdEFsbChcIi5jaGFydC1sYWJlbFwiKVxuICAgICAgICAgICAgICAgIC5kYXRhKHNlcmllcy5kYXRhKVxuICAgICAgICAgICAgICAgIC5lbnRlcigpXG4gICAgICAgICAgICAgICAgLmVhY2goKGQsIGksIG5vZGVzKSA9PiB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gV2FudCB0byBmaWd1cmUgb3V0IGlmIHRoZSBsYWJlbCBpcyB0b28gZGFyayAvIGxpZ2h0IGZvciB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gYmFyLlxuICAgICAgICAgICAgICAgICAgICBsZXQgaW52ZXJ0ZWRDb2xvciA9IGQzLmhjbCh0aGlzLmdldFNlcmllc0NvbG91cihpKSk7XG4gICAgICAgICAgICAgICAgICAgIGludmVydGVkQ29sb3IubCArPSBNYXRoLm1pbihpbnZlcnRlZENvbG9yLmwgKyA1MCwgMTAwKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGludmVydCA9IGQzLmhjbCh0aGlzLmdldFNlcmllc0NvbG91cihpKSkubCA8IDYwO1xuXG4gICAgICAgICAgICAgICAgICAgIGxldCB5cG9zID0geXNjYWxlKGQuX3kpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZHkgPSBjYWxjRHkoeXBvcyk7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0ZXh0ID0gZDMuc2VsZWN0KG5vZGVzW2ldKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC50ZXh0KHRoaXMuX2xhYmVsRm9ybWF0KGQuX3kpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImNoYXJ0LWxhYmVsXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcInlcIiwgeXBvcylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiZHhcIiwgYW5pbWF0ZSA/IC0xNSA6IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcImR5XCIsIGR5KVxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwicG9pbnRlci1ldmVudHNcIiwgXCJub25lXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAuc3R5bGUoXCJmb250LWZhbWlseVwiLCBcIk9wZW4gU2Fucywgc2Fucy1zZXJpZlwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gLnN0eWxlKFwiZm9udC13ZWlnaHRcIiwgXCJub3JtYWxcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIC5zdHlsZShcImZvbnQtc2l6ZVwiLCBmb250U2l6ZSArIFwicHhcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcImZpbGxcIiwgZHkgPiAwICYmIGludmVydCA/IGludmVydGVkQ29sb3IudG9TdHJpbmcoKSA6IGNvbG91cnMuZWlnaHRlZW4uZGFya0dyZXkpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFNldCB0aGUgeCBwb3NpdGlvbiwgd2hpY2ggaXMgYmFzZWQgb24gd2lkdGguXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gdGV4dC5ub2RlKCkuZ2V0QkJveCgpLndpZHRoO1xuICAgICAgICAgICAgICAgICAgICBtYXhXaWR0aCA9IE1hdGgubWF4KHdpZHRoLCBtYXhXaWR0aCk7XG4gICAgICAgICAgICAgICAgICAgIHRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwieFwiLCB4Z3JvdXAoZC5fa2V5KSArIHhncm91cC5iYW5kd2lkdGgoKSAvIDIgLSB3aWR0aCAvIDIpO1xuXG4gICAgICAgICAgICAgICAgICAgIHRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKFwibGFiZWxzXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAuZGVsYXkoKCkgPT4gYW5pbWF0ZSA/IHRoaXMuY2FsY0Jhckdyb3d0aChzX2ksIHNfbm9kZXMubGVuZ3RoKSA6IDApIC8vIERlbGF5IGluIGxvY2tzdGVwIHdpdGggYmFyIGdyb3d0aC5cbiAgICAgICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbih0aGlzLl9kdXJhdGlvbilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiZHhcIiwgMClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMSlcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICB9KVxuXG5cbiAgICAgICAgLy8gRmlndXJlIG91dCBpZiB3ZSBkb24ndCBoYXZlIGVub3VnaCBzcGFjZSB0byBzaG93IG91ciBsYWJlbHMuXG4gICAgICAgIC8vIFdlIHRoZW4gd2FudCB0byByZXNpemUsIGlmIHBvc3NpYmxlLlxuICAgICAgICBpZiAoeGdyb3VwLmJhbmR3aWR0aCgpIDwgbWF4V2lkdGggKiAxLjA1KSB7XG4gICAgICAgICAgICBsZXQgc2NhbGUgPSBtYXhXaWR0aCAvIHhncm91cC5iYW5kd2lkdGgoKSAqIDEuMDU7XG4gICAgICAgICAgICBmb250U2l6ZSA9IE1hdGguZmxvb3IoZm9udFNpemUgLyBzY2FsZSk7XG5cbiAgICAgICAgICAgIGlmIChmb250U2l6ZSA8IDgpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgbGFiZWxzIGFyZSB0b28gc21hbGwuXG4gICAgICAgICAgICAgICAgbGFiZWxzLmVudGVyKCkuc2VsZWN0QWxsKFwidGV4dFwiKS5yZW1vdmUoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGFiZWxzLmVudGVyKClcbiAgICAgICAgICAgICAgICAgICAgLm1lcmdlKGxhYmVscylcbiAgICAgICAgICAgICAgICAgICAgLnNlbGVjdEFsbChcInRleHRcIilcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwiZm9udC1zaXplXCIsIGZvbnRTaXplICsgXCJweFwiKVxuICAgICAgICAgICAgICAgICAgICAuZWFjaCgoZCwgaSwgbm9kZXMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRleHQgPSBkMy5zZWxlY3Qobm9kZXNbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgd2lkdGggPSB0ZXh0Lm5vZGUoKS5nZXRCQm94KCkud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIHhncm91cChkLl9rZXkpICsgeGdyb3VwLmJhbmR3aWR0aCgpIC8gMiAtIHdpZHRoIC8gMilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcImR5XCIsIGNhbGNEeShkLl95KSk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgcmVuZGVyRGF0YUF4aXNMYWJlbChoZWlnaHQsIG1hcmdpbnMpIHtcbiAgICAgICAgbGV0IHN2ZyA9IGQzLnNlbGVjdCh0aGlzLl9lbGVtZW50KS5zZWxlY3QoJ3N2ZycpO1xuICAgICAgICBzdmcuc2VsZWN0QWxsKFwiLmRhdGEtbGFiZWxzXCIpLnJlbW92ZSgpO1xuXG4gICAgICAgIGlmICghdGhpcy5fZGF0YUF4aXNMYWJlbCkgcmV0dXJuO1xuICAgICAgICBsZXQgdGV4dCA9IHRoaXMuX2RhdGFBeGlzTGFiZWw7XG4gICAgICAgIGlmICh0ZXh0LmxvbmcpIHRleHQgPSB0ZXh0Lmxvbmc7XG5cbiAgICAgICAgbGV0IHggPSAtKG1hcmdpbnMudG9wICsgaGVpZ2h0IC8gMik7XG5cbiAgICAgICAgbGV0IGxhYmVsID0gc3ZnLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJkYXRhLWxhYmVsc1wiKVxuICAgICAgICAgICAgLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgICAgIC50ZXh0KHRleHQpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInJvdGF0ZSgtOTAgMCwwKSB0cmFuc2xhdGUoXCIgKyB4ICsgXCIsIDIwKVwiKVxuICAgICAgICAgICAgLy8gLnN0eWxlKFwiZm9udC1mYW1pbHlcIiwgXCJPcGVuIFNhbnMsIHNhbnMtc2VyaWZcIilcbiAgICAgICAgICAgIC8vIC5zdHlsZShcImZvbnQtc2l6ZVwiLCBcIjEycHhcIilcbiAgICAgICAgICAgIC8vIC5zdHlsZShcImZvbnQtc3R5bGVcIiwgXCJpdGFsaWNcIilcbiAgICAgICAgICAgIC5zdHlsZShcImZpbGxcIiwgY29sb3Vycy5laWdodGVlbi5kYXJrR3JleSk7XG5cbiAgICAgICAgbGV0IHdpZHRoID0gbGFiZWwubm9kZSgpLmdldEJCb3goKS53aWR0aDtcbiAgICAgICAgaWYgKHdpZHRoID49IGhlaWdodCAmJiB0aGlzLl9kYXRhQXhpc0xhYmVsLnNob3J0KSB7XG4gICAgICAgICAgICBsYWJlbC50ZXh0KHRoaXMuX2RhdGFBeGlzTGFiZWwuc2hvcnQpO1xuICAgICAgICAgICAgd2lkdGggPSBsYWJlbC5ub2RlKCkuZ2V0QkJveCgpLndpZHRoO1xuICAgICAgICB9XG5cbiAgICAgICAgbGFiZWwuYXR0cihcImR4XCIsIC13aWR0aCAvIDIpO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBncmlkKHNlbGVjdGlvbiwgd2lkdGgsIGF4aXMpIHtcbiAgICAgICAgc2VsZWN0aW9uLnNlbGVjdChcIi5ncmlkXCIpLnJlbW92ZSgpO1xuXG4gICAgICAgIGxldCBncmlkID0gc2VsZWN0aW9uLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJncmlkXCIpXG4gICAgICAgICAgICAuY2FsbChheGlzXG4gICAgICAgICAgICAgICAgLnRpY2tTaXplKC13aWR0aClcbiAgICAgICAgICAgICAgICAudGlja0Zvcm1hdChcIlwiKVxuICAgICAgICAgICAgKTtcblxuICAgICAgICBncmlkLnNlbGVjdEFsbChcImxpbmVcIilcbiAgICAgICAgICAgIC5zdHlsZShcInN0cm9rZVwiLCBjb2xvdXJzLmVpZ2h0ZWVuLmxpZ2h0R3JleSk7XG4gICAgICAgIGdyaWQuc2VsZWN0QWxsKFwiLmRvbWFpblwiKS5yZW1vdmUoKTtcblxuICAgICAgICBncmlkXG4gICAgICAgICAgICAubG93ZXIoKSAvLyBBbHdheXMgZW5zdXJlIHRoYXQgdGhpcyBpcyBlYXJsaWVyIGluIHRoZSBkb20uIFRoaW5ncyBtdXN0IGJlIGRyYXduIG9uIHRvcCBvZiBpdC5cbiAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMClcbiAgICAgICAgICAgIC50cmFuc2l0aW9uKClcbiAgICAgICAgICAgIC5kZWxheSg1MDApXG4gICAgICAgICAgICAuZHVyYXRpb24oNTAwKVxuICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAxKTtcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgeGF4aXMoc2VsZWN0aW9uLCBoZWlnaHQsIHhheGlzKSB7XG4gICAgICAgIHNlbGVjdGlvbi5zZWxlY3QoXCIueC1heGlzXCIpLnJlbW92ZSgpO1xuICAgICAgICBsZXQgYXhpcyA9IHNlbGVjdGlvbi5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwieC1heGlzXCIpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZSgwLFwiICsgaGVpZ2h0ICsgXCIpXCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDApXG4gICAgICAgICAgICAuY2FsbCh4YXhpcyk7XG5cbiAgICAgICAgYXhpcy5zZWxlY3QoXCIuZG9tYWluXCIpLnJlbW92ZSgpO1xuXG4gICAgICAgIGF4aXNcbiAgICAgICAgICAgIC5zZWxlY3RBbGwoXCJ0ZXh0XCIpXG4gICAgICAgICAgICAuc3R5bGUoJ3RleHQtYW5jaG9yJywgJ2VuZCcpXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3JvdGF0ZSgtMzAsIDAsMCknKTtcblxuICAgICAgICBheGlzXG4gICAgICAgICAgICAudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAuZHVyYXRpb24oMTAwMClcbiAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMSk7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHlheGlzKHNlbGVjdGlvbiwgYXhpcykge1xuICAgICAgICBzZWxlY3Rpb24uc2VsZWN0KFwiLnktYXhpc1wiKS5yZW1vdmUoKTtcbiAgICAgICAgbGV0IHggPSBzZWxlY3Rpb24uYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcInktYXhpc1wiKVxuICAgICAgICAgICAgLmNhbGwoYXhpcy50aWNrU2l6ZSgwKS50aWNrUGFkZGluZygxMCkpXG4gICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDApXG4gICAgICAgICAgICAudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAuZHVyYXRpb24oMTAwMClcbiAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMSk7XG5cbiAgICAgICAgeC5zZWxlY3RBbGwoXCJ0ZXh0XCIpXG4gICAgICAgICAgICAvLyAuc3R5bGUoXCJmb250LWZhbWlseVwiLCBcIk9wZW4gU2Fucywgc2Fucy1zZXJpZlwiKVxuICAgICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBjb2xvdXJzLmVpZ2h0ZWVuLmRhcmtHcmV5KVxuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBjYWxjQmFyR3Jvd3RoKGksIG1heCkge1xuICAgICAgICBpZiAobWF4IDwgMTApIHJldHVybiBpICogdGhpcy5fQkFSX0dST1dUSCAvIDI7XG4gICAgICAgIGlmIChtYXggPCAzNSkgcmV0dXJuIGkgKiB0aGlzLl9CQVJfR1JPV1RIIC8gNDtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuXG4gICAgZ2V0U2VyaWVzQ29sb3VyKGkpIHtcbiAgICAgICAgaWYgKGkgPCAwIHx8ICF0aGlzLl9jb2xvdXJzKSByZXR1cm4gY29sb3Vycy5laWdodGVlbi5taWRHcmV5O1xuXG4gICAgICAgIGkgPSBpICUgdGhpcy5fY29sb3Vycy5sZW5ndGg7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb2xvdXJzW2ldO1xuICAgIH1cblxuICAgIGdldFNvcnRlZERhdGEoKSB7XG4gICAgICAgIGxldCBkYXRhID0gdGhpcy5fZGF0YTtcbiAgICAgICAgaWYgKCFkYXRhIHx8ICFkYXRhLmxlbmd0aCkgcmV0dXJuIFtdO1xuXG4gICAgICAgIGRhdGEgPSB0aGlzLl9kYXRhLnNvcnQoKGxocywgcmhzKSA9PiB7XG4gICAgICAgICAgICBsaHMgPSBsaHMua2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICByaHMgPSByaHMua2V5LnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgICAgIGlmIChsaHMgPT09IHJocykgcmV0dXJuIDA7XG4gICAgICAgICAgICBpZiAobGhzIDwgcmhzKSByZXR1cm4gLTE7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgZ2V0VHJhbnNmb3JtZWREYXRhKCkge1xuICAgICAgICBsZXQgZGF0YSA9IHRoaXMuZ2V0U29ydGVkRGF0YSgpO1xuICAgICAgICBpZiAoIWRhdGEgfHwgIWRhdGEubGVuZ3RoKSByZXR1cm4gW107XG5cbiAgICAgICAgbGV0IHJlc3VsdHMgPSBbXTtcblxuICAgICAgICBkYXRhLmZvckVhY2goKHNlcmllcywgc19pKSA9PiB7XG4gICAgICAgICAgICBsZXQgcyA9IE9iamVjdC5hc3NpZ24oe30sIHNlcmllcyk7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2gocyk7XG5cbiAgICAgICAgICAgIGxldCBkYXRhID0gW107XG4gICAgICAgICAgICBzLnZhbHVlcy5mb3JFYWNoKChkKSA9PiB7XG4gICAgICAgICAgICAgICAgZGF0YS5wdXNoKE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgICAgICAgICBfeDogbmV3IERhdGUodGhpcy5feEF4aXNPdmVycmlkZSA/IHRoaXMuX3hBeGlzT3ZlcnJpZGVbdGhpcy5feChkKV0gOiB0aGlzLl94KGQpKSxcbiAgICAgICAgICAgICAgICAgICAgX3Nlcmllczogc2VyaWVzLFxuICAgICAgICAgICAgICAgICAgICBfc19pOiBzX2ksXG4gICAgICAgICAgICAgICAgICAgIF9rZXk6IHNlcmllcy5rZXksXG4gICAgICAgICAgICAgICAgICAgIF95OiB0aGlzLl95KGQpXG4gICAgICAgICAgICAgICAgfSwgZCkpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHMuZGF0YSA9IGRhdGE7XG4gICAgICAgICAgICBkZWxldGUgcy52YWx1ZXM7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cblxuICAgIGdldEtleXMoKSB7XG4gICAgICAgIGxldCBkYXRhID0gdGhpcy5fZGF0YTtcbiAgICAgICAgaWYgKCFkYXRhIHx8ICFkYXRhLmxlbmd0aCkgcmV0dXJuIFtdO1xuXG4gICAgICAgIHJldHVybiBbLi4ubmV3IFNldChkYXRhLm1hcChkID0+IGQua2V5KSldXG4gICAgfVxuXG4gICAgZ2V0Q2xvc2VzdFBvaW50KHh2YWwsIHl2YWwsIGRhdGEpIHtcbiAgICAgICAgbGV0IGNhbGNEaXN0ID0gZCA9PiBNYXRoLnNxcnQoTWF0aC5hYnMoZC5feCAtIHh2YWwpICoqIDIgKyAoZC5feSAtIHl2YWwpICoqIDIpO1xuICAgICAgICBsZXQgbWluID0gZGF0YVswXTtcbiAgICAgICAgbGV0IG1pbkRpc3QgPSBjYWxjRGlzdChtaW4pO1xuXG4gICAgICAgIGRhdGEuZm9yRWFjaChkID0+IHtcbiAgICAgICAgICAgIGxldCBkaXN0ID0gY2FsY0Rpc3QoZCk7XG4gICAgICAgICAgICBpZiAoZGlzdCA8IG1pbkRpc3QpIHtcbiAgICAgICAgICAgICAgICBtaW5EaXN0ID0gZGlzdDtcbiAgICAgICAgICAgICAgICBtaW4gPSBkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gbWluO1xuICAgIH1cbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/LineChart.js\n')},"./src/PieChart.js":
/*!*************************!*\
  !*** ./src/PieChart.js ***!
  \*************************/
/*! exports provided: PieChart */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PieChart", function() { return PieChart; });\n/* harmony import */ var _Colours__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Colours */ "./src/Colours.js");\n/* harmony import */ var _Chart__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Chart */ "./src/Chart.js");\n// Copyright (C) 2013-2014, 2018 BrandsEye (PTY) LTD\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this\n// software and associated documentation files (the "Software"), to deal in the Software\n// without restriction, including without limitation the rights to use, copy, modify,\n//     merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following\n// conditions:\n//\n//     The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n//     INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n// CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n\nclass PieChart extends _Chart__WEBPACK_IMPORTED_MODULE_1__["Chart"] {\n    constructor() {\n        super();\n        this._colours = ["#98abc5", "#8a89a6", "#7b6888", "#6b486b", "#a05d56", "#d0743c", "#ff8c00"];\n    }\n\n    //------------------------------------------------------\n\n    data(data) {\n        if (!arguments.length) return this._data;\n        if (data && data[0].key === undefined) {\n            data = [\n                {\n                    key: "series 1",\n                    values: data\n                }\n            ];\n        }\n        this._data = data;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    element(element) {\n        if (!arguments.length) return this._element;\n        this._element = element;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    showLabels(show) {\n        if (!arguments.length) return this._show_labels;\n        this._show_labels = show;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    // todo dispatch\n    showLegend(show) {\n        if (!arguments.length) return this._show_legend;\n        this._show_legend = show;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    x(x) {\n        if (!arguments.length) return this._x;\n        this._x = x;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    y(y) {\n        if (!arguments.length) return this._y;\n        this._y = y;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    width(width) {\n        if (!arguments.length) return this._width;\n        this._width = width;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    height(height) {\n        if (!arguments.length) return this._height;\n        this._height = height;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    colours(colours) {\n        if (!arguments.length) return this._colours;\n        this._colours = colours;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    backgroundColour(colour) {\n        if (!arguments.length) return this._backgroundColour;\n        this._backgroundColour = colour || "#FFF"; // never set it to null.\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    tickFormat(format) {\n        if (!arguments.length) return this._tickFormat;\n        this._tickFormat = format;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    xAxisTickFormat(format) {\n        if (!arguments.length) return this._xAxisTickFormat;\n        this._xAxisTickFormat = format || (d => d.toString());\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    labelFormat(format) {\n        if (!arguments.length) return this._labelFormat;\n        this._labelFormat = format || (d => d.toString());\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    // todo missing\n    labelCompression(compression) {\n        if (!arguments.length) return this._compression;\n        this._compression = compression;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    //todo missing\n    dataAxisLabel(label) {\n        if (!arguments.length) return this._dataAxisLabel;\n        this._dataAxisLabel = label;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    tooltip(tooltip) {\n        if (!arguments.length) return this._tooltip;\n        this._tooltip = tooltip;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    forceY(force) {\n        if (!arguments.length) return this._forceY;\n        this._forceY = force;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n// todo missing\n    duration(duration) {\n        if (!arguments.length) return this._duration;\n        this._duration = duration;\n        return this;\n    }\n\n// todo missing\n    coarseness(coarseness) {\n        if (!arguments.length) return this._coarseness;\n        this._coarseness = coarseness;\n        return this;\n    }\n\n    // todo missing\n    padding(padding) {\n        if (!arguments.length) return this._padding;\n        this._padding = padding;\n        return this;\n    }\n\n    // todo missing\n    xAxisTooltips(tooltips) {\n        if (!arguments.length) return this._xAxisTooltips;\n        this._xAxisTooltips = tooltips;\n        return this;\n    }\n\n    xAxisOverride(override) {\n        if (!arguments.length) return this._xAxisOverride;\n        this._xAxisOverride = override;\n        return this;\n    }\n\n    //------------------------------------------------------\n\n    dispatch() {\n        return this._dispatch;\n    }\n\n    //------------------------------------------------------\n\n    render() {\n        if (!this._element) throw new Error("No element set for ColumnChart. See #element()");\n        if (!this._data) {\n            console.warn("No data set for ColumnChart. See #data()");\n            return;\n        }\n\n        const data = this.getTransformedData();\n\n        //------------------------------------------------\n        // Set up the SVG area\n\n        let topLevel = d3.select(this._element).select("svg");\n        if (topLevel.empty()) topLevel = d3.select(this._element).append("svg");\n\n        topLevel\n            .style("width", this._width + "px")\n            .style("height", this._height + "px");\n\n        // ---------------------------------\n        // Layout the showLegend.\n        //\n        // We do this now because we need to know how much space the legend\n        // takes up in order to finish calculating the margins.\n\n        const legendHeight = this.renderLegend(topLevel, data, 0, this._width, this._height, d => d._key);\n\n        //----------------------------------\n        // Calculate margins.\n\n        const margin = {top: 20, right: 20, bottom: 40, left: 40};\n        margin.bottom += legendHeight ? legendHeight + 20 : 0;\n\n        // if (this._dataAxisLabel) margin.left += 20 + 12;\n        // if (data) {\n        //     let maxLabelLength = 0;\n        //     data.forEach(d => {\n        //         d.data.forEach(d => {\n        //             let length = this._xAxisTickFormat(this._x(d)).length;\n        //             if (length > maxLabelLength) maxLabelLength = length;\n        //         })\n        //     });\n        //     margin.bottom += maxLabelLength * 2 + 10;    // space for axes labels.\n        // }\n\n        const width = this._width - margin.left - margin.right,\n              height = this._height - margin.top - margin.bottom;\n        const radius = Math.min(width, height) / 2;\n        this._radius = radius;\n\n        //----------------------------------\n        // Calculate scales and so on.\n\n        let colour = d3.scaleOrdinal(["#98abc5", "#8a89a6", "#7b6888", "#6b486b", "#a05d56", "#d0743c", "#ff8c00"]);\n\n        //------------------------------\n\n        let svg = topLevel.select(\'.main-group\');\n\n        if (svg.empty()) {\n            svg = topLevel\n                .append("g")\n                .attr("class", "main-group");\n        }\n\n        svg.attr("transform", "translate(" + (margin.left + width / 2) + "," + (margin.top + height / 2) + ")");\n\n        //---------------------------------\n        // Get rid of current labels.\n        svg.select(".chart-labels")\n            .remove();\n\n        //---------------------------------\n        // append the arcs for the pie chart\n\n        let pie = d3.pie()\n            .sort(null)\n            .value(d => d._y);\n        this._pie = pie;\n\n        let path = d3.arc()\n            .outerRadius(radius - 10)\n            .innerRadius(0);\n\n        let arcs = svg.select(".slices").selectAll(\'.arc\');\n\n        if (arcs.empty()) {\n            arcs = svg\n                .append("g")\n                .attr("class", "slices")\n                .selectAll(".arc");\n        }\n\n        let pieData = pie(data);\n        arcs = arcs.data(pieData);\n        arcs.exit().remove();\n\n        function arcTween(d, i) {\n            this._current = this._current || (i <= 0 ? { startAngle: 0, endAngle: 0} : pieData[i - 1]);\n            let interpolator = d3.interpolate(this._current, d);\n            this._current = interpolator(0);\n\n            return function(t) {\n                return path(interpolator(t))\n            }\n        }\n\n        arcs.enter()\n            .append("path")\n                .attr("class", (d, i) => "arc " + "series series-" + i)\n                .style("cursor", "pointer")\n            .on("mouseover", (d, i, nodes) => { // Darken the pie on mouse over\n                // We want to shift the pie out a bit on mouseover.\n                // So we want to find the direction to move the pie in.\n                // We can just ask the path helper to give us the centroid,\n                // normalise it, and that is the direction to move in.\n                const centre = path.centroid(d);\n                const norm = Math.sqrt(centre[0] ** 2 + centre[1] ** 2);\n                centre[0] = centre[0] / norm;\n                centre[1] = centre[1] / norm;\n\n                d3.select(nodes[i])\n                    .interrupt("hover:colour")\n                    .transition("hover:colour")\n                    .duration(300)\n                        .attr("transform", "translate(" + (centre[0] * 10) + "," + (centre[1] * 10) + "), scale(1.1)")\n                        .style("fill", d3.hcl(this.getSeriesColour(i)).darker());\n                this._dispatch.call("tooltipShow", this, {\n                    e: d3.event,\n                    point: d.data,\n                    series: d.data._series,\n                    seriesIndex: d.data._s_i,\n                    value: d.data._y\n                })\n            })\n            .on("mouseout", (d, i, nodes) => { // pie is regular colour on mouse out.\n                d3.select(nodes[i])\n                    .interrupt("hover:colour")\n                    .transition("hover:colour")\n                    .duration(300)\n                        .attr("transform", "translate(0,0)")\n                        .style("fill", this.getSeriesColour(i));\n                this._dispatch.call("tooltipHide", this);\n            })\n            .on("click auxclick", (d, i, nodes) => {\n                this._dispatch.call("elementClick", this, {\n                    e: d3.event,\n                    point: d.data,\n                    series: d.data._series,\n                    seriesIndex: d.data._s_i,\n                    value: d.data._y\n                })\n            })\n            .merge(arcs)\n            .transition()\n                .attrTween("d", arcTween)\n                .attr("fill", (d, i) => this.getSeriesColour(i) );\n\n        // arcs.append("text")\n        //     .attr("transform", function(d) { return "translate(" + label.centroid(d) + ")"; })\n        //     .attr("dy", "0.35em")\n        //     .text(d => {console.log("d is", d); return d.data._y; });\n\n\n        // ---------------------------------\n        // Labels loaded after our first bar grows.\n        if (this._show_labels) {\n            svg.transition("bar:growth")\n                .on("end", (d, i, nodes) => {\n                    if (i < nodes.length - 1) return;\n                    this.renderLabels(svg, data);\n                })\n        }\n\n        // ---------------------------------\n        // Set the background colour\n\n        d3.select(this._element).select(".background").remove();\n        if (this._backgroundColour) {\n            d3.select(this._element).select("svg")\n                .append("rect")\n                    .attr("class", "background")\n                    .attr("width", "100%")\n                    .attr("height", "100%")\n                    .style("fill", this._backgroundColour)\n                .lower();\n        }\n\n    }\n\n    //------------------------------------------------------\n\n    /*\n     * Returns an object with two functions, #show() and #hide(),\n     * to show and hide the labels.\n     */\n    labels() {\n        return {\n\n            show: () => {\n                if (this._element) {\n                    let selection = this._element,\n                        data = this.getTransformedData();\n\n                    if (selection) selection = d3.select(this._element).select("svg").select(".main-group");\n                    if (!selection.empty() && data) {\n                        let labels = selection.select(\'.chart-labels\');\n                        if (!labels.empty()) return;\n                        labels.remove();\n                        this.renderLabels(selection, data);\n                    }\n                }\n\n            },\n\n            hide: () => {\n                if (this._element) {\n                    d3.select(this._element)\n                        .select(\'.chart-labels\')\n                        .interrupt("labels")\n                        .interrupt("labels:fade")\n                        .transition("labels:fade")\n                        .style("opacity", 0)\n                        .on("end", (d, i, nodes) => {\n                            d3.select(nodes[i]).remove();\n                        })\n                }\n            }\n        }\n    }\n\n    //------------------------------------------------------\n\n    renderLabels(selection, data, animate) {\n        selection.selectAll(".chart-labels").remove();\n\n        const radius = this._radius + 15;\n\n        let arc = d3.arc()\n            .outerRadius(radius)\n            .innerRadius(radius);\n\n        let labels = selection.append("g")\n            .attr("class", "chart-labels")\n            .selectAll(".label-group")\n            .data(this._pie(data));\n\n        labels.enter()\n            .each((d, i, nodes) => {\n                const centroid = arc.centroid(d);\n                const radians = d.endAngle - d.startAngle;\n                const arcLength = radians * radius;\n\n                let label = d3.select(nodes[i])\n                    .append("text")\n                    .text(d => this._labelFormat(d.data._y))\n                        // .style("font-family", "Open Sans, sans-serif")\n                        // .style("font-size", "12px")\n                        .style("fill", _Colours__WEBPACK_IMPORTED_MODULE_0__["colours"].eighteen.darkGrey)\n                        .style("opacity", 0)\n                        .attr("transform", "translate(" + centroid + ")");\n\n                const bounding = label.node().getBBox();\n                if (bounding.width < arcLength) {\n                    // label.attr("dx", (bounding.width / 2) * (direction[0] < 0 ? -1 : 1));\n                    // label.attr("dy", (bounding.height / 2) * (direction[1] < 0 ? -1 : 1));\n                    label.attr("dx", -(bounding.width / 2));\n                    label.attr("dy", (bounding.height / 2));\n\n                    label\n                        .transition()\n                        .duration(this._duration)\n                        .style("opacity", 1)\n                }\n\n            })\n    }\n\n    //------------------------------------------------------\n\n    getSeriesColour(i) {\n        if (i < 0 || !this._colours) return _Colours__WEBPACK_IMPORTED_MODULE_0__["colours"].eighteen.midGrey;\n\n        i = i % this._colours.length;\n        return this._colours[i];\n    }\n\n    getSortedData() {\n        let data = this._data;\n        if (!data || !data.length) return [];\n\n        data = this._data.sort((lhs, rhs) => {\n            lhs = lhs.key.toLowerCase();\n            rhs = rhs.key.toLowerCase();\n\n            if (lhs === rhs) return 0;\n            if (lhs < rhs) return -1;\n            return 1;\n        });\n\n        return data;\n    }\n\n    getTransformedData() {\n        let data = this.getSortedData();\n        if (!data || !data.length) return [];\n\n        let results = [];\n\n        let series = data[0];\n        series.values.forEach((d, d_i) => {\n\n            results.push(Object.assign({\n                _y: this._y(d),\n                _series_key: series.key,\n                _s_i: 0,\n                _series: series,\n                _key: this._xAxisOverride ? this._xAxisOverride[this._x(d)] : this._x(d)\n            }, d));\n        });\n\n        return results;\n    }\n\n    getKeys() {\n        let data = this._data;\n        if (!data || !data.length) return [];\n\n        return [...new Set(data.map(d => d.key))]\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvUGllQ2hhcnQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9iM2pzLy4vc3JjL1BpZUNoYXJ0LmpzPzczZGQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChDKSAyMDEzLTIwMTQsIDIwMTggQnJhbmRzRXllIChQVFkpIExURFxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpc1xuLy8gc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlXG4vLyB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksXG4vLyAgICAgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0b1xuLy8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcbi8vIGNvbmRpdGlvbnM6XG4vL1xuLy8gICAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuLy8gY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyAgICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUiBJTVBMSUVELFxuLy8gICAgIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBXG4vLyBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUXG4vLyBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0Zcbi8vIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRVxuLy8gT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCB7Y29sb3Vyc30gZnJvbSAnLi9Db2xvdXJzJztcbmltcG9ydCB7Q2hhcnR9IGZyb20gJy4vQ2hhcnQnO1xuXG5leHBvcnQgY2xhc3MgUGllQ2hhcnQgZXh0ZW5kcyBDaGFydCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX2NvbG91cnMgPSBbXCIjOThhYmM1XCIsIFwiIzhhODlhNlwiLCBcIiM3YjY4ODhcIiwgXCIjNmI0ODZiXCIsIFwiI2EwNWQ1NlwiLCBcIiNkMDc0M2NcIiwgXCIjZmY4YzAwXCJdO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBkYXRhKGRhdGEpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fZGF0YTtcbiAgICAgICAgaWYgKGRhdGEgJiYgZGF0YVswXS5rZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZGF0YSA9IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGtleTogXCJzZXJpZXMgMVwiLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZXM6IGRhdGFcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgZWxlbWVudChlbGVtZW50KSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX2VsZW1lbnQ7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgc2hvd0xhYmVscyhzaG93KSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3Nob3dfbGFiZWxzO1xuICAgICAgICB0aGlzLl9zaG93X2xhYmVscyA9IHNob3c7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvLyB0b2RvIGRpc3BhdGNoXG4gICAgc2hvd0xlZ2VuZChzaG93KSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3Nob3dfbGVnZW5kO1xuICAgICAgICB0aGlzLl9zaG93X2xlZ2VuZCA9IHNob3c7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB4KHgpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5feDtcbiAgICAgICAgdGhpcy5feCA9IHg7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB5KHkpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5feTtcbiAgICAgICAgdGhpcy5feSA9IHk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB3aWR0aCh3aWR0aCkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl93aWR0aDtcbiAgICAgICAgdGhpcy5fd2lkdGggPSB3aWR0aDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGhlaWdodChoZWlnaHQpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5faGVpZ2h0O1xuICAgICAgICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBjb2xvdXJzKGNvbG91cnMpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fY29sb3VycztcbiAgICAgICAgdGhpcy5fY29sb3VycyA9IGNvbG91cnM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBiYWNrZ3JvdW5kQ29sb3VyKGNvbG91cikge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9iYWNrZ3JvdW5kQ29sb3VyO1xuICAgICAgICB0aGlzLl9iYWNrZ3JvdW5kQ29sb3VyID0gY29sb3VyIHx8IFwiI0ZGRlwiOyAvLyBuZXZlciBzZXQgaXQgdG8gbnVsbC5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHRpY2tGb3JtYXQoZm9ybWF0KSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3RpY2tGb3JtYXQ7XG4gICAgICAgIHRoaXMuX3RpY2tGb3JtYXQgPSBmb3JtYXQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB4QXhpc1RpY2tGb3JtYXQoZm9ybWF0KSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3hBeGlzVGlja0Zvcm1hdDtcbiAgICAgICAgdGhpcy5feEF4aXNUaWNrRm9ybWF0ID0gZm9ybWF0IHx8IChkID0+IGQudG9TdHJpbmcoKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBsYWJlbEZvcm1hdChmb3JtYXQpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fbGFiZWxGb3JtYXQ7XG4gICAgICAgIHRoaXMuX2xhYmVsRm9ybWF0ID0gZm9ybWF0IHx8IChkID0+IGQudG9TdHJpbmcoKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvLyB0b2RvIG1pc3NpbmdcbiAgICBsYWJlbENvbXByZXNzaW9uKGNvbXByZXNzaW9uKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX2NvbXByZXNzaW9uO1xuICAgICAgICB0aGlzLl9jb21wcmVzc2lvbiA9IGNvbXByZXNzaW9uO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLy90b2RvIG1pc3NpbmdcbiAgICBkYXRhQXhpc0xhYmVsKGxhYmVsKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX2RhdGFBeGlzTGFiZWw7XG4gICAgICAgIHRoaXMuX2RhdGFBeGlzTGFiZWwgPSBsYWJlbDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHRvb2x0aXAodG9vbHRpcCkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl90b29sdGlwO1xuICAgICAgICB0aGlzLl90b29sdGlwID0gdG9vbHRpcDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGZvcmNlWShmb3JjZSkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9mb3JjZVk7XG4gICAgICAgIHRoaXMuX2ZvcmNlWSA9IGZvcmNlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vLyB0b2RvIG1pc3NpbmdcbiAgICBkdXJhdGlvbihkdXJhdGlvbikge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9kdXJhdGlvbjtcbiAgICAgICAgdGhpcy5fZHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4vLyB0b2RvIG1pc3NpbmdcbiAgICBjb2Fyc2VuZXNzKGNvYXJzZW5lc3MpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fY29hcnNlbmVzcztcbiAgICAgICAgdGhpcy5fY29hcnNlbmVzcyA9IGNvYXJzZW5lc3M7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIHRvZG8gbWlzc2luZ1xuICAgIHBhZGRpbmcocGFkZGluZykge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9wYWRkaW5nO1xuICAgICAgICB0aGlzLl9wYWRkaW5nID0gcGFkZGluZztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gdG9kbyBtaXNzaW5nXG4gICAgeEF4aXNUb29sdGlwcyh0b29sdGlwcykge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl94QXhpc1Rvb2x0aXBzO1xuICAgICAgICB0aGlzLl94QXhpc1Rvb2x0aXBzID0gdG9vbHRpcHM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHhBeGlzT3ZlcnJpZGUob3ZlcnJpZGUpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5feEF4aXNPdmVycmlkZTtcbiAgICAgICAgdGhpcy5feEF4aXNPdmVycmlkZSA9IG92ZXJyaWRlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgZGlzcGF0Y2goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaXNwYXRjaDtcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2VsZW1lbnQpIHRocm93IG5ldyBFcnJvcihcIk5vIGVsZW1lbnQgc2V0IGZvciBDb2x1bW5DaGFydC4gU2VlICNlbGVtZW50KClcIik7XG4gICAgICAgIGlmICghdGhpcy5fZGF0YSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiTm8gZGF0YSBzZXQgZm9yIENvbHVtbkNoYXJ0LiBTZWUgI2RhdGEoKVwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLmdldFRyYW5zZm9ybWVkRGF0YSgpO1xuXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIFNldCB1cCB0aGUgU1ZHIGFyZWFcblxuICAgICAgICBsZXQgdG9wTGV2ZWwgPSBkMy5zZWxlY3QodGhpcy5fZWxlbWVudCkuc2VsZWN0KFwic3ZnXCIpO1xuICAgICAgICBpZiAodG9wTGV2ZWwuZW1wdHkoKSkgdG9wTGV2ZWwgPSBkMy5zZWxlY3QodGhpcy5fZWxlbWVudCkuYXBwZW5kKFwic3ZnXCIpO1xuXG4gICAgICAgIHRvcExldmVsXG4gICAgICAgICAgICAuc3R5bGUoXCJ3aWR0aFwiLCB0aGlzLl93aWR0aCArIFwicHhcIilcbiAgICAgICAgICAgIC5zdHlsZShcImhlaWdodFwiLCB0aGlzLl9oZWlnaHQgKyBcInB4XCIpO1xuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBMYXlvdXQgdGhlIHNob3dMZWdlbmQuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFdlIGRvIHRoaXMgbm93IGJlY2F1c2Ugd2UgbmVlZCB0byBrbm93IGhvdyBtdWNoIHNwYWNlIHRoZSBsZWdlbmRcbiAgICAgICAgLy8gdGFrZXMgdXAgaW4gb3JkZXIgdG8gZmluaXNoIGNhbGN1bGF0aW5nIHRoZSBtYXJnaW5zLlxuXG4gICAgICAgIGNvbnN0IGxlZ2VuZEhlaWdodCA9IHRoaXMucmVuZGVyTGVnZW5kKHRvcExldmVsLCBkYXRhLCAwLCB0aGlzLl93aWR0aCwgdGhpcy5faGVpZ2h0LCBkID0+IGQuX2tleSk7XG5cbiAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIENhbGN1bGF0ZSBtYXJnaW5zLlxuXG4gICAgICAgIGNvbnN0IG1hcmdpbiA9IHt0b3A6IDIwLCByaWdodDogMjAsIGJvdHRvbTogNDAsIGxlZnQ6IDQwfTtcbiAgICAgICAgbWFyZ2luLmJvdHRvbSArPSBsZWdlbmRIZWlnaHQgPyBsZWdlbmRIZWlnaHQgKyAyMCA6IDA7XG5cbiAgICAgICAgLy8gaWYgKHRoaXMuX2RhdGFBeGlzTGFiZWwpIG1hcmdpbi5sZWZ0ICs9IDIwICsgMTI7XG4gICAgICAgIC8vIGlmIChkYXRhKSB7XG4gICAgICAgIC8vICAgICBsZXQgbWF4TGFiZWxMZW5ndGggPSAwO1xuICAgICAgICAvLyAgICAgZGF0YS5mb3JFYWNoKGQgPT4ge1xuICAgICAgICAvLyAgICAgICAgIGQuZGF0YS5mb3JFYWNoKGQgPT4ge1xuICAgICAgICAvLyAgICAgICAgICAgICBsZXQgbGVuZ3RoID0gdGhpcy5feEF4aXNUaWNrRm9ybWF0KHRoaXMuX3goZCkpLmxlbmd0aDtcbiAgICAgICAgLy8gICAgICAgICAgICAgaWYgKGxlbmd0aCA+IG1heExhYmVsTGVuZ3RoKSBtYXhMYWJlbExlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgLy8gICAgICAgICB9KVxuICAgICAgICAvLyAgICAgfSk7XG4gICAgICAgIC8vICAgICBtYXJnaW4uYm90dG9tICs9IG1heExhYmVsTGVuZ3RoICogMiArIDEwOyAgICAvLyBzcGFjZSBmb3IgYXhlcyBsYWJlbHMuXG4gICAgICAgIC8vIH1cblxuICAgICAgICBjb25zdCB3aWR0aCA9IHRoaXMuX3dpZHRoIC0gbWFyZ2luLmxlZnQgLSBtYXJnaW4ucmlnaHQsXG4gICAgICAgICAgICAgIGhlaWdodCA9IHRoaXMuX2hlaWdodCAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tO1xuICAgICAgICBjb25zdCByYWRpdXMgPSBNYXRoLm1pbih3aWR0aCwgaGVpZ2h0KSAvIDI7XG4gICAgICAgIHRoaXMuX3JhZGl1cyA9IHJhZGl1cztcblxuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHNjYWxlcyBhbmQgc28gb24uXG5cbiAgICAgICAgbGV0IGNvbG91ciA9IGQzLnNjYWxlT3JkaW5hbChbXCIjOThhYmM1XCIsIFwiIzhhODlhNlwiLCBcIiM3YjY4ODhcIiwgXCIjNmI0ODZiXCIsIFwiI2EwNWQ1NlwiLCBcIiNkMDc0M2NcIiwgXCIjZmY4YzAwXCJdKTtcblxuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgIGxldCBzdmcgPSB0b3BMZXZlbC5zZWxlY3QoJy5tYWluLWdyb3VwJyk7XG5cbiAgICAgICAgaWYgKHN2Zy5lbXB0eSgpKSB7XG4gICAgICAgICAgICBzdmcgPSB0b3BMZXZlbFxuICAgICAgICAgICAgICAgIC5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcIm1haW4tZ3JvdXBcIik7XG4gICAgICAgIH1cblxuICAgICAgICBzdmcuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIChtYXJnaW4ubGVmdCArIHdpZHRoIC8gMikgKyBcIixcIiArIChtYXJnaW4udG9wICsgaGVpZ2h0IC8gMikgKyBcIilcIik7XG5cbiAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gR2V0IHJpZCBvZiBjdXJyZW50IGxhYmVscy5cbiAgICAgICAgc3ZnLnNlbGVjdChcIi5jaGFydC1sYWJlbHNcIilcbiAgICAgICAgICAgIC5yZW1vdmUoKTtcblxuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBhcHBlbmQgdGhlIGFyY3MgZm9yIHRoZSBwaWUgY2hhcnRcblxuICAgICAgICBsZXQgcGllID0gZDMucGllKClcbiAgICAgICAgICAgIC5zb3J0KG51bGwpXG4gICAgICAgICAgICAudmFsdWUoZCA9PiBkLl95KTtcbiAgICAgICAgdGhpcy5fcGllID0gcGllO1xuXG4gICAgICAgIGxldCBwYXRoID0gZDMuYXJjKClcbiAgICAgICAgICAgIC5vdXRlclJhZGl1cyhyYWRpdXMgLSAxMClcbiAgICAgICAgICAgIC5pbm5lclJhZGl1cygwKTtcblxuICAgICAgICBsZXQgYXJjcyA9IHN2Zy5zZWxlY3QoXCIuc2xpY2VzXCIpLnNlbGVjdEFsbCgnLmFyYycpO1xuXG4gICAgICAgIGlmIChhcmNzLmVtcHR5KCkpIHtcbiAgICAgICAgICAgIGFyY3MgPSBzdmdcbiAgICAgICAgICAgICAgICAuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJzbGljZXNcIilcbiAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKFwiLmFyY1wiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBwaWVEYXRhID0gcGllKGRhdGEpO1xuICAgICAgICBhcmNzID0gYXJjcy5kYXRhKHBpZURhdGEpO1xuICAgICAgICBhcmNzLmV4aXQoKS5yZW1vdmUoKTtcblxuICAgICAgICBmdW5jdGlvbiBhcmNUd2VlbihkLCBpKSB7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50ID0gdGhpcy5fY3VycmVudCB8fCAoaSA8PSAwID8geyBzdGFydEFuZ2xlOiAwLCBlbmRBbmdsZTogMH0gOiBwaWVEYXRhW2kgLSAxXSk7XG4gICAgICAgICAgICBsZXQgaW50ZXJwb2xhdG9yID0gZDMuaW50ZXJwb2xhdGUodGhpcy5fY3VycmVudCwgZCk7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50ID0gaW50ZXJwb2xhdG9yKDApO1xuXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXRoKGludGVycG9sYXRvcih0KSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGFyY3MuZW50ZXIoKVxuICAgICAgICAgICAgLmFwcGVuZChcInBhdGhcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIChkLCBpKSA9PiBcImFyYyBcIiArIFwic2VyaWVzIHNlcmllcy1cIiArIGkpXG4gICAgICAgICAgICAgICAgLnN0eWxlKFwiY3Vyc29yXCIsIFwicG9pbnRlclwiKVxuICAgICAgICAgICAgLm9uKFwibW91c2VvdmVyXCIsIChkLCBpLCBub2RlcykgPT4geyAvLyBEYXJrZW4gdGhlIHBpZSBvbiBtb3VzZSBvdmVyXG4gICAgICAgICAgICAgICAgLy8gV2Ugd2FudCB0byBzaGlmdCB0aGUgcGllIG91dCBhIGJpdCBvbiBtb3VzZW92ZXIuXG4gICAgICAgICAgICAgICAgLy8gU28gd2Ugd2FudCB0byBmaW5kIHRoZSBkaXJlY3Rpb24gdG8gbW92ZSB0aGUgcGllIGluLlxuICAgICAgICAgICAgICAgIC8vIFdlIGNhbiBqdXN0IGFzayB0aGUgcGF0aCBoZWxwZXIgdG8gZ2l2ZSB1cyB0aGUgY2VudHJvaWQsXG4gICAgICAgICAgICAgICAgLy8gbm9ybWFsaXNlIGl0LCBhbmQgdGhhdCBpcyB0aGUgZGlyZWN0aW9uIHRvIG1vdmUgaW4uXG4gICAgICAgICAgICAgICAgY29uc3QgY2VudHJlID0gcGF0aC5jZW50cm9pZChkKTtcbiAgICAgICAgICAgICAgICBjb25zdCBub3JtID0gTWF0aC5zcXJ0KGNlbnRyZVswXSAqKiAyICsgY2VudHJlWzFdICoqIDIpO1xuICAgICAgICAgICAgICAgIGNlbnRyZVswXSA9IGNlbnRyZVswXSAvIG5vcm07XG4gICAgICAgICAgICAgICAgY2VudHJlWzFdID0gY2VudHJlWzFdIC8gbm9ybTtcblxuICAgICAgICAgICAgICAgIGQzLnNlbGVjdChub2Rlc1tpXSlcbiAgICAgICAgICAgICAgICAgICAgLmludGVycnVwdChcImhvdmVyOmNvbG91clwiKVxuICAgICAgICAgICAgICAgICAgICAudHJhbnNpdGlvbihcImhvdmVyOmNvbG91clwiKVxuICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24oMzAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyAoY2VudHJlWzBdICogMTApICsgXCIsXCIgKyAoY2VudHJlWzFdICogMTApICsgXCIpLCBzY2FsZSgxLjEpXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIGQzLmhjbCh0aGlzLmdldFNlcmllc0NvbG91cihpKSkuZGFya2VyKCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3BhdGNoLmNhbGwoXCJ0b29sdGlwU2hvd1wiLCB0aGlzLCB7XG4gICAgICAgICAgICAgICAgICAgIGU6IGQzLmV2ZW50LFxuICAgICAgICAgICAgICAgICAgICBwb2ludDogZC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICBzZXJpZXM6IGQuZGF0YS5fc2VyaWVzLFxuICAgICAgICAgICAgICAgICAgICBzZXJpZXNJbmRleDogZC5kYXRhLl9zX2ksXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBkLmRhdGEuX3lcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbihcIm1vdXNlb3V0XCIsIChkLCBpLCBub2RlcykgPT4geyAvLyBwaWUgaXMgcmVndWxhciBjb2xvdXIgb24gbW91c2Ugb3V0LlxuICAgICAgICAgICAgICAgIGQzLnNlbGVjdChub2Rlc1tpXSlcbiAgICAgICAgICAgICAgICAgICAgLmludGVycnVwdChcImhvdmVyOmNvbG91clwiKVxuICAgICAgICAgICAgICAgICAgICAudHJhbnNpdGlvbihcImhvdmVyOmNvbG91clwiKVxuICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24oMzAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoMCwwKVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCB0aGlzLmdldFNlcmllc0NvbG91cihpKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGlzcGF0Y2guY2FsbChcInRvb2x0aXBIaWRlXCIsIHRoaXMpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbihcImNsaWNrIGF1eGNsaWNrXCIsIChkLCBpLCBub2RlcykgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3BhdGNoLmNhbGwoXCJlbGVtZW50Q2xpY2tcIiwgdGhpcywge1xuICAgICAgICAgICAgICAgICAgICBlOiBkMy5ldmVudCxcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQ6IGQuZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgc2VyaWVzOiBkLmRhdGEuX3NlcmllcyxcbiAgICAgICAgICAgICAgICAgICAgc2VyaWVzSW5kZXg6IGQuZGF0YS5fc19pLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZC5kYXRhLl95XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAubWVyZ2UoYXJjcylcbiAgICAgICAgICAgIC50cmFuc2l0aW9uKClcbiAgICAgICAgICAgICAgICAuYXR0clR3ZWVuKFwiZFwiLCBhcmNUd2VlbilcbiAgICAgICAgICAgICAgICAuYXR0cihcImZpbGxcIiwgKGQsIGkpID0+IHRoaXMuZ2V0U2VyaWVzQ29sb3VyKGkpICk7XG5cbiAgICAgICAgLy8gYXJjcy5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgICAgIC8vICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBmdW5jdGlvbihkKSB7IHJldHVybiBcInRyYW5zbGF0ZShcIiArIGxhYmVsLmNlbnRyb2lkKGQpICsgXCIpXCI7IH0pXG4gICAgICAgIC8vICAgICAuYXR0cihcImR5XCIsIFwiMC4zNWVtXCIpXG4gICAgICAgIC8vICAgICAudGV4dChkID0+IHtjb25zb2xlLmxvZyhcImQgaXNcIiwgZCk7IHJldHVybiBkLmRhdGEuX3k7IH0pO1xuXG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIExhYmVscyBsb2FkZWQgYWZ0ZXIgb3VyIGZpcnN0IGJhciBncm93cy5cbiAgICAgICAgaWYgKHRoaXMuX3Nob3dfbGFiZWxzKSB7XG4gICAgICAgICAgICBzdmcudHJhbnNpdGlvbihcImJhcjpncm93dGhcIilcbiAgICAgICAgICAgICAgICAub24oXCJlbmRcIiwgKGQsIGksIG5vZGVzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpIDwgbm9kZXMubGVuZ3RoIC0gMSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckxhYmVscyhzdmcsIGRhdGEpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gU2V0IHRoZSBiYWNrZ3JvdW5kIGNvbG91clxuXG4gICAgICAgIGQzLnNlbGVjdCh0aGlzLl9lbGVtZW50KS5zZWxlY3QoXCIuYmFja2dyb3VuZFwiKS5yZW1vdmUoKTtcbiAgICAgICAgaWYgKHRoaXMuX2JhY2tncm91bmRDb2xvdXIpIHtcbiAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzLl9lbGVtZW50KS5zZWxlY3QoXCJzdmdcIilcbiAgICAgICAgICAgICAgICAuYXBwZW5kKFwicmVjdFwiKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwiYmFja2dyb3VuZFwiKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcIndpZHRoXCIsIFwiMTAwJVwiKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcImhlaWdodFwiLCBcIjEwMCVcIilcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCB0aGlzLl9iYWNrZ3JvdW5kQ29sb3VyKVxuICAgICAgICAgICAgICAgIC5sb3dlcigpO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLypcbiAgICAgKiBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIHR3byBmdW5jdGlvbnMsICNzaG93KCkgYW5kICNoaWRlKCksXG4gICAgICogdG8gc2hvdyBhbmQgaGlkZSB0aGUgbGFiZWxzLlxuICAgICAqL1xuICAgIGxhYmVscygpIHtcbiAgICAgICAgcmV0dXJuIHtcblxuICAgICAgICAgICAgc2hvdzogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9lbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzZWxlY3Rpb24gPSB0aGlzLl9lbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHRoaXMuZ2V0VHJhbnNmb3JtZWREYXRhKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvbikgc2VsZWN0aW9uID0gZDMuc2VsZWN0KHRoaXMuX2VsZW1lbnQpLnNlbGVjdChcInN2Z1wiKS5zZWxlY3QoXCIubWFpbi1ncm91cFwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzZWxlY3Rpb24uZW1wdHkoKSAmJiBkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbGFiZWxzID0gc2VsZWN0aW9uLnNlbGVjdCgnLmNoYXJ0LWxhYmVscycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFsYWJlbHMuZW1wdHkoKSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWxzLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJMYWJlbHMoc2VsZWN0aW9uLCBkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgaGlkZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9lbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzLl9lbGVtZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgLnNlbGVjdCgnLmNoYXJ0LWxhYmVscycpXG4gICAgICAgICAgICAgICAgICAgICAgICAuaW50ZXJydXB0KFwibGFiZWxzXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAuaW50ZXJydXB0KFwibGFiZWxzOmZhZGVcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKFwibGFiZWxzOmZhZGVcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5vbihcImVuZFwiLCAoZCwgaSwgbm9kZXMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkMy5zZWxlY3Qobm9kZXNbaV0pLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgcmVuZGVyTGFiZWxzKHNlbGVjdGlvbiwgZGF0YSwgYW5pbWF0ZSkge1xuICAgICAgICBzZWxlY3Rpb24uc2VsZWN0QWxsKFwiLmNoYXJ0LWxhYmVsc1wiKS5yZW1vdmUoKTtcblxuICAgICAgICBjb25zdCByYWRpdXMgPSB0aGlzLl9yYWRpdXMgKyAxNTtcblxuICAgICAgICBsZXQgYXJjID0gZDMuYXJjKClcbiAgICAgICAgICAgIC5vdXRlclJhZGl1cyhyYWRpdXMpXG4gICAgICAgICAgICAuaW5uZXJSYWRpdXMocmFkaXVzKTtcblxuICAgICAgICBsZXQgbGFiZWxzID0gc2VsZWN0aW9uLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJjaGFydC1sYWJlbHNcIilcbiAgICAgICAgICAgIC5zZWxlY3RBbGwoXCIubGFiZWwtZ3JvdXBcIilcbiAgICAgICAgICAgIC5kYXRhKHRoaXMuX3BpZShkYXRhKSk7XG5cbiAgICAgICAgbGFiZWxzLmVudGVyKClcbiAgICAgICAgICAgIC5lYWNoKChkLCBpLCBub2RlcykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNlbnRyb2lkID0gYXJjLmNlbnRyb2lkKGQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJhZGlhbnMgPSBkLmVuZEFuZ2xlIC0gZC5zdGFydEFuZ2xlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFyY0xlbmd0aCA9IHJhZGlhbnMgKiByYWRpdXM7XG5cbiAgICAgICAgICAgICAgICBsZXQgbGFiZWwgPSBkMy5zZWxlY3Qobm9kZXNbaV0pXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgICAgICAgICAgICAgICAgIC50ZXh0KGQgPT4gdGhpcy5fbGFiZWxGb3JtYXQoZC5kYXRhLl95KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIC5zdHlsZShcImZvbnQtZmFtaWx5XCIsIFwiT3BlbiBTYW5zLCBzYW5zLXNlcmlmXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAuc3R5bGUoXCJmb250LXNpemVcIiwgXCIxMnB4XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIGNvbG91cnMuZWlnaHRlZW4uZGFya0dyZXkpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDApXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIGNlbnRyb2lkICsgXCIpXCIpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgYm91bmRpbmcgPSBsYWJlbC5ub2RlKCkuZ2V0QkJveCgpO1xuICAgICAgICAgICAgICAgIGlmIChib3VuZGluZy53aWR0aCA8IGFyY0xlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBsYWJlbC5hdHRyKFwiZHhcIiwgKGJvdW5kaW5nLndpZHRoIC8gMikgKiAoZGlyZWN0aW9uWzBdIDwgMCA/IC0xIDogMSkpO1xuICAgICAgICAgICAgICAgICAgICAvLyBsYWJlbC5hdHRyKFwiZHlcIiwgKGJvdW5kaW5nLmhlaWdodCAvIDIpICogKGRpcmVjdGlvblsxXSA8IDAgPyAtMSA6IDEpKTtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWwuYXR0cihcImR4XCIsIC0oYm91bmRpbmcud2lkdGggLyAyKSk7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsLmF0dHIoXCJkeVwiLCAoYm91bmRpbmcuaGVpZ2h0IC8gMikpO1xuXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsXG4gICAgICAgICAgICAgICAgICAgICAgICAudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24odGhpcy5fZHVyYXRpb24pXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDEpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9KVxuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBnZXRTZXJpZXNDb2xvdXIoaSkge1xuICAgICAgICBpZiAoaSA8IDAgfHwgIXRoaXMuX2NvbG91cnMpIHJldHVybiBjb2xvdXJzLmVpZ2h0ZWVuLm1pZEdyZXk7XG5cbiAgICAgICAgaSA9IGkgJSB0aGlzLl9jb2xvdXJzLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbG91cnNbaV07XG4gICAgfVxuXG4gICAgZ2V0U29ydGVkRGF0YSgpIHtcbiAgICAgICAgbGV0IGRhdGEgPSB0aGlzLl9kYXRhO1xuICAgICAgICBpZiAoIWRhdGEgfHwgIWRhdGEubGVuZ3RoKSByZXR1cm4gW107XG5cbiAgICAgICAgZGF0YSA9IHRoaXMuX2RhdGEuc29ydCgobGhzLCByaHMpID0+IHtcbiAgICAgICAgICAgIGxocyA9IGxocy5rZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIHJocyA9IHJocy5rZXkudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICAgICAgaWYgKGxocyA9PT0gcmhzKSByZXR1cm4gMDtcbiAgICAgICAgICAgIGlmIChsaHMgPCByaHMpIHJldHVybiAtMTtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICBnZXRUcmFuc2Zvcm1lZERhdGEoKSB7XG4gICAgICAgIGxldCBkYXRhID0gdGhpcy5nZXRTb3J0ZWREYXRhKCk7XG4gICAgICAgIGlmICghZGF0YSB8fCAhZGF0YS5sZW5ndGgpIHJldHVybiBbXTtcblxuICAgICAgICBsZXQgcmVzdWx0cyA9IFtdO1xuXG4gICAgICAgIGxldCBzZXJpZXMgPSBkYXRhWzBdO1xuICAgICAgICBzZXJpZXMudmFsdWVzLmZvckVhY2goKGQsIGRfaSkgPT4ge1xuXG4gICAgICAgICAgICByZXN1bHRzLnB1c2goT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICAgICAgX3k6IHRoaXMuX3koZCksXG4gICAgICAgICAgICAgICAgX3Nlcmllc19rZXk6IHNlcmllcy5rZXksXG4gICAgICAgICAgICAgICAgX3NfaTogMCxcbiAgICAgICAgICAgICAgICBfc2VyaWVzOiBzZXJpZXMsXG4gICAgICAgICAgICAgICAgX2tleTogdGhpcy5feEF4aXNPdmVycmlkZSA/IHRoaXMuX3hBeGlzT3ZlcnJpZGVbdGhpcy5feChkKV0gOiB0aGlzLl94KGQpXG4gICAgICAgICAgICB9LCBkKSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cblxuICAgIGdldEtleXMoKSB7XG4gICAgICAgIGxldCBkYXRhID0gdGhpcy5fZGF0YTtcbiAgICAgICAgaWYgKCFkYXRhIHx8ICFkYXRhLmxlbmd0aCkgcmV0dXJuIFtdO1xuXG4gICAgICAgIHJldHVybiBbLi4ubmV3IFNldChkYXRhLm1hcChkID0+IGQua2V5KSldXG4gICAgfVxufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/PieChart.js\n')},"./src/Points.js":
/*!***********************!*\
  !*** ./src/Points.js ***!
  \***********************/
/*! exports provided: points */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "points", function() { return points; });\n/* harmony import */ var _Geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Geometry */ "./src/Geometry.js");\n// Copyright (C) 2013-2014, 2018 BrandsEye (PTY) LTD\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this\n// software and associated documentation files (the "Software"), to deal in the Software\n// without restriction, including without limitation the rights to use, copy, modify,\n//     merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following\n// conditions:\n//\n//     The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n//     INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n// CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n\nclass Point extends _Geometry__WEBPACK_IMPORTED_MODULE_0__["Geometry"] {\n\n    constructor() {\n        super("POINT", 3);\n    }\n\n    render() {\n        console.log("\\tRendering POINTS");\n\n        const element = this._element;\n        const data = this.prepareData();\n        const width = this._width,\n              height = this._height;\n\n        element.classed("points", true);\n\n\n        const x = this.getD3XScale(data, width);\n        const y = this.getD3YScale(data, height);\n\n        const colours = d3.scaleOrdinal(this.colourScale())\n                          .domain(this.getColourDomain(data));\n\n        let groups = element.selectAll(\'.point-groups\');\n        groups = groups.data(data);\n\n        groups.exit().remove();\n\n        groups.enter()\n              .append("g")\n              .attr("class", "point-groups")\n              .merge(groups.selectAll(".point-groups"))\n              .each((d, i, nodes) => {\n                  const group = d3.select(nodes[i]);\n                  const points = group.selectAll(".point")\n                      .data(d.data);\n\n                  points.enter()\n                      .append("circle")\n                          .style("opacity", 0.4)\n                          .attr("cx", d => x(d._x))\n                          .attr("cy", d => y(d._y))\n                          .attr("fill", d => colours(d._colour))\n                          .attr("r", 5);\n              });\n    }\n\n    getD3XScale(data, width) {\n        width = width || this.width();\n        data = data || this.prepareData()\n        return d3.scaleLinear()\n                 .rangeRound([0, width])\n                 .domain([Math.min(0, d3.min(data, d => d3.min(d.data, d => d._x))),\n                     d3.max(data, d => d3.max(d.data, d => d._x))]);\n\n    }\n\n    getD3YScale(data, height) {\n        data = data || this.prepareData();\n        height = height || this.height();\n\n        return d3.scaleLinear()\n                 .rangeRound([height, 0])\n                 .nice()\n                 .domain([Math.min(0, d3.min(data, d => d3.min(d.data, d => d._y))),\n                     d3.max(data, d => d3.max(d.data, d => d._y))]);\n\n    }\n}\n\n\nfunction points() {\n    return new Point();\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvUG9pbnRzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYjNqcy8uL3NyYy9Qb2ludHMuanM/MGJjOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKEMpIDIwMTMtMjAxNCwgMjAxOCBCcmFuZHNFeWUgKFBUWSkgTFREXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZiB0aGlzXG4vLyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmVcbi8vIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSxcbi8vICAgICBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvXG4vLyBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZ1xuLy8gY29uZGl0aW9uczpcbi8vXG4vLyAgICAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4vLyBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vICAgICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SIElNUExJRUQsXG4vLyAgICAgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEFcbi8vIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFRcbi8vIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRlxuLy8gQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFXG4vLyBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IHsgR2VvbWV0cnkgfSBmcm9tICcuL0dlb21ldHJ5JztcblxuXG5jbGFzcyBQb2ludCBleHRlbmRzIEdlb21ldHJ5IHtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihcIlBPSU5UXCIsIDMpO1xuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJcXHRSZW5kZXJpbmcgUE9JTlRTXCIpO1xuXG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLl9lbGVtZW50O1xuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5wcmVwYXJlRGF0YSgpO1xuICAgICAgICBjb25zdCB3aWR0aCA9IHRoaXMuX3dpZHRoLFxuICAgICAgICAgICAgICBoZWlnaHQgPSB0aGlzLl9oZWlnaHQ7XG5cbiAgICAgICAgZWxlbWVudC5jbGFzc2VkKFwicG9pbnRzXCIsIHRydWUpO1xuXG5cbiAgICAgICAgY29uc3QgeCA9IHRoaXMuZ2V0RDNYU2NhbGUoZGF0YSwgd2lkdGgpO1xuICAgICAgICBjb25zdCB5ID0gdGhpcy5nZXREM1lTY2FsZShkYXRhLCBoZWlnaHQpO1xuXG4gICAgICAgIGNvbnN0IGNvbG91cnMgPSBkMy5zY2FsZU9yZGluYWwodGhpcy5jb2xvdXJTY2FsZSgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAuZG9tYWluKHRoaXMuZ2V0Q29sb3VyRG9tYWluKGRhdGEpKTtcblxuICAgICAgICBsZXQgZ3JvdXBzID0gZWxlbWVudC5zZWxlY3RBbGwoJy5wb2ludC1ncm91cHMnKTtcbiAgICAgICAgZ3JvdXBzID0gZ3JvdXBzLmRhdGEoZGF0YSk7XG5cbiAgICAgICAgZ3JvdXBzLmV4aXQoKS5yZW1vdmUoKTtcblxuICAgICAgICBncm91cHMuZW50ZXIoKVxuICAgICAgICAgICAgICAuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwicG9pbnQtZ3JvdXBzXCIpXG4gICAgICAgICAgICAgIC5tZXJnZShncm91cHMuc2VsZWN0QWxsKFwiLnBvaW50LWdyb3Vwc1wiKSlcbiAgICAgICAgICAgICAgLmVhY2goKGQsIGksIG5vZGVzKSA9PiB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBncm91cCA9IGQzLnNlbGVjdChub2Rlc1tpXSk7XG4gICAgICAgICAgICAgICAgICBjb25zdCBwb2ludHMgPSBncm91cC5zZWxlY3RBbGwoXCIucG9pbnRcIilcbiAgICAgICAgICAgICAgICAgICAgICAuZGF0YShkLmRhdGEpO1xuXG4gICAgICAgICAgICAgICAgICBwb2ludHMuZW50ZXIoKVxuICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoXCJjaXJjbGVcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAwLjQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiY3hcIiwgZCA9PiB4KGQuX3gpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcImN5XCIsIGQgPT4geShkLl95KSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJmaWxsXCIsIGQgPT4gY29sb3VycyhkLl9jb2xvdXIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcInJcIiwgNSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgIH1cblxuICAgIGdldEQzWFNjYWxlKGRhdGEsIHdpZHRoKSB7XG4gICAgICAgIHdpZHRoID0gd2lkdGggfHwgdGhpcy53aWR0aCgpO1xuICAgICAgICBkYXRhID0gZGF0YSB8fCB0aGlzLnByZXBhcmVEYXRhKClcbiAgICAgICAgcmV0dXJuIGQzLnNjYWxlTGluZWFyKClcbiAgICAgICAgICAgICAgICAgLnJhbmdlUm91bmQoWzAsIHdpZHRoXSlcbiAgICAgICAgICAgICAgICAgLmRvbWFpbihbTWF0aC5taW4oMCwgZDMubWluKGRhdGEsIGQgPT4gZDMubWluKGQuZGF0YSwgZCA9PiBkLl94KSkpLFxuICAgICAgICAgICAgICAgICAgICAgZDMubWF4KGRhdGEsIGQgPT4gZDMubWF4KGQuZGF0YSwgZCA9PiBkLl94KSldKTtcblxuICAgIH1cblxuICAgIGdldEQzWVNjYWxlKGRhdGEsIGhlaWdodCkge1xuICAgICAgICBkYXRhID0gZGF0YSB8fCB0aGlzLnByZXBhcmVEYXRhKCk7XG4gICAgICAgIGhlaWdodCA9IGhlaWdodCB8fCB0aGlzLmhlaWdodCgpO1xuXG4gICAgICAgIHJldHVybiBkMy5zY2FsZUxpbmVhcigpXG4gICAgICAgICAgICAgICAgIC5yYW5nZVJvdW5kKFtoZWlnaHQsIDBdKVxuICAgICAgICAgICAgICAgICAubmljZSgpXG4gICAgICAgICAgICAgICAgIC5kb21haW4oW01hdGgubWluKDAsIGQzLm1pbihkYXRhLCBkID0+IGQzLm1pbihkLmRhdGEsIGQgPT4gZC5feSkpKSxcbiAgICAgICAgICAgICAgICAgICAgIGQzLm1heChkYXRhLCBkID0+IGQzLm1heChkLmRhdGEsIGQgPT4gZC5feSkpXSk7XG5cbiAgICB9XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIHBvaW50cygpIHtcbiAgICByZXR1cm4gbmV3IFBvaW50KCk7XG59Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/Points.js\n')},"./src/Scales.js":
/*!***********************!*\
  !*** ./src/Scales.js ***!
  \***********************/
/*! exports provided: scaleTime, scaleIdentity */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaleTime", function() { return scaleTime; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaleIdentity", function() { return scaleIdentity; });\n/* harmony import */ var _Bucket__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Bucket */ "./src/Bucket.js");\n// Copyright (C) 2013-2014, 2018 BrandsEye (PTY) LTD\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this\n// software and associated documentation files (the "Software"), to deal in the Software\n// without restriction, including without limitation the rights to use, copy, modify,\n//     merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following\n// conditions:\n//\n//     The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n//     INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n// CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n\nclass ScaleTime {\n    transform(val) {\n        if (val instanceof Date) return val;\n        if (typeof val !== \'string\') throw new Error("Value is not a string and cannot be converted to a date");\n        return new Date(val);\n    }\n\n    buckets(data) {\n        return new _Bucket__WEBPACK_IMPORTED_MODULE_0__["DateBucket"](data);\n    }\n}\n\nclass ScaleIdentity {\n    transform(val) {\n        return val;\n    }\n\n    buckets(data) {\n        return new _Bucket__WEBPACK_IMPORTED_MODULE_0__["ContinuousBucket"](data);\n    }\n}\n\n\nfunction scaleTime() {\n    return new ScaleTime();\n}\n\nfunction scaleIdentity() {\n    return new ScaleIdentity();\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvU2NhbGVzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYjNqcy8uL3NyYy9TY2FsZXMuanM/ZmRlOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKEMpIDIwMTMtMjAxNCwgMjAxOCBCcmFuZHNFeWUgKFBUWSkgTFREXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZiB0aGlzXG4vLyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmVcbi8vIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSxcbi8vICAgICBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvXG4vLyBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZ1xuLy8gY29uZGl0aW9uczpcbi8vXG4vLyAgICAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4vLyBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vICAgICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SIElNUExJRUQsXG4vLyAgICAgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEFcbi8vIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFRcbi8vIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRlxuLy8gQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFXG4vLyBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IHtEYXRlQnVja2V0LCBDb250aW51b3VzQnVja2V0fSBmcm9tIFwiLi9CdWNrZXRcIjtcblxuXG5jbGFzcyBTY2FsZVRpbWUge1xuICAgIHRyYW5zZm9ybSh2YWwpIHtcbiAgICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIERhdGUpIHJldHVybiB2YWw7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsICE9PSAnc3RyaW5nJykgdGhyb3cgbmV3IEVycm9yKFwiVmFsdWUgaXMgbm90IGEgc3RyaW5nIGFuZCBjYW5ub3QgYmUgY29udmVydGVkIHRvIGEgZGF0ZVwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHZhbCk7XG4gICAgfVxuXG4gICAgYnVja2V0cyhkYXRhKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZUJ1Y2tldChkYXRhKTtcbiAgICB9XG59XG5cbmNsYXNzIFNjYWxlSWRlbnRpdHkge1xuICAgIHRyYW5zZm9ybSh2YWwpIHtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG5cbiAgICBidWNrZXRzKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb250aW51b3VzQnVja2V0KGRhdGEpO1xuICAgIH1cbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gc2NhbGVUaW1lKCkge1xuICAgIHJldHVybiBuZXcgU2NhbGVUaW1lKCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzY2FsZUlkZW50aXR5KCkge1xuICAgIHJldHVybiBuZXcgU2NhbGVJZGVudGl0eSgpO1xufSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/Scales.js\n')},"./src/Statistics.js":
/*!***************************!*\
  !*** ./src/Statistics.js ***!
  \***************************/
/*! exports provided: freedmanDiaconis */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "freedmanDiaconis", function() { return freedmanDiaconis; });\n/* harmony import */ var compute_iqr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! compute-iqr */ "./node_modules/compute-iqr/lib/index.js");\n/* harmony import */ var compute_iqr__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(compute_iqr__WEBPACK_IMPORTED_MODULE_0__);\n// Copyright (C) 2013-2014, 2018 BrandsEye (PTY) LTD\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this\n// software and associated documentation files (the "Software"), to deal in the Software\n// without restriction, including without limitation the rights to use, copy, modify,\n//     merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following\n// conditions:\n//\n//     The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n//     INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n// CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n\n/**\n * Calculates the number of buckets to split a real value domain\n * in to when calculating a histogram.\n *\n * https://en.wikipedia.org/wiki/Histogram\n *\n * @return {number}\n */\nfunction freedmanDiaconis(data) {\n    return 2 * compute_iqr__WEBPACK_IMPORTED_MODULE_0___default()(data) / Math.pow(data.length, 1/3);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvU3RhdGlzdGljcy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2IzanMvLi9zcmMvU3RhdGlzdGljcy5qcz9kNThlIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoQykgMjAxMy0yMDE0LCAyMDE4IEJyYW5kc0V5ZSAoUFRZKSBMVERcbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXNcbi8vIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZVxuLy8gd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LFxuLy8gICAgIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG9cbi8vIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nXG4vLyBjb25kaXRpb25zOlxuLy9cbi8vICAgICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbi8vIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gICAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1IgSU1QTElFRCxcbi8vICAgICBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQVxuLy8gUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxuLy8gSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GXG4vLyBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkVcbi8vIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5pbXBvcnQgaXFyIGZyb20gJ2NvbXB1dGUtaXFyJztcblxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIG51bWJlciBvZiBidWNrZXRzIHRvIHNwbGl0IGEgcmVhbCB2YWx1ZSBkb21haW5cbiAqIGluIHRvIHdoZW4gY2FsY3VsYXRpbmcgYSBoaXN0b2dyYW0uXG4gKlxuICogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSGlzdG9ncmFtXG4gKlxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJlZWRtYW5EaWFjb25pcyhkYXRhKSB7XG4gICAgcmV0dXJuIDIgKiBpcXIoZGF0YSkgLyBNYXRoLnBvdyhkYXRhLmxlbmd0aCwgMS8zKTtcbn0iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/Statistics.js\n')},"./src/helpers.js":
/*!************************!*\
  !*** ./src/helpers.js ***!
  \************************/
/*! exports provided: maxBounding */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "maxBounding", function() { return maxBounding; });\n// Copyright (C) 2013-2014, 2018 BrandsEye (PTY) LTD\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this\n// software and associated documentation files (the "Software"), to deal in the Software\n// without restriction, including without limitation the rights to use, copy, modify,\n//     merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following\n// conditions:\n//\n//     The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n//     INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n// CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n/**\n * Given an array of text, this places things in the DOM to figure out how\n * much pixel space the text takes up.\n */\nfunction maxBounding(selection, text, font, fontSize) {\n    // font = font || "Open Sans, sans-serif";\n    // fontSize = fontSize || "12";\n\n    let width = 0;\n    let height = 0;\n    selection.append("g")\n            .attr("class", "text-size")\n            .style("opacity", 0)\n            .attr("transform", "translate(-100, -100)")\n        .selectAll(".text-measurement")\n        .data(text)\n        .enter()\n        .append("text")\n        .text(d => d)\n        .each((d, i, nodes) => {\n            let node = nodes[i];\n            let bb = node.getBBox();\n            width = Math.max(width, bb.width);\n            height = Math.max(height, bb.height)\n        });\n\n    selection.select(".text-size").remove();\n    return {\n        width: width,\n        height: height\n    }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaGVscGVycy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2IzanMvLi9zcmMvaGVscGVycy5qcz9kN2MyIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoQykgMjAxMy0yMDE0LCAyMDE4IEJyYW5kc0V5ZSAoUFRZKSBMVERcbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXNcbi8vIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZVxuLy8gd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LFxuLy8gICAgIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG9cbi8vIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nXG4vLyBjb25kaXRpb25zOlxuLy9cbi8vICAgICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbi8vIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gICAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1IgSU1QTElFRCxcbi8vICAgICBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQVxuLy8gUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxuLy8gSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GXG4vLyBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkVcbi8vIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5cbi8qKlxuICogR2l2ZW4gYW4gYXJyYXkgb2YgdGV4dCwgdGhpcyBwbGFjZXMgdGhpbmdzIGluIHRoZSBET00gdG8gZmlndXJlIG91dCBob3dcbiAqIG11Y2ggcGl4ZWwgc3BhY2UgdGhlIHRleHQgdGFrZXMgdXAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXhCb3VuZGluZyhzZWxlY3Rpb24sIHRleHQsIGZvbnQsIGZvbnRTaXplKSB7XG4gICAgLy8gZm9udCA9IGZvbnQgfHwgXCJPcGVuIFNhbnMsIHNhbnMtc2VyaWZcIjtcbiAgICAvLyBmb250U2l6ZSA9IGZvbnRTaXplIHx8IFwiMTJcIjtcblxuICAgIGxldCB3aWR0aCA9IDA7XG4gICAgbGV0IGhlaWdodCA9IDA7XG4gICAgc2VsZWN0aW9uLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJ0ZXh0LXNpemVcIilcbiAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMClcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKC0xMDAsIC0xMDApXCIpXG4gICAgICAgIC5zZWxlY3RBbGwoXCIudGV4dC1tZWFzdXJlbWVudFwiKVxuICAgICAgICAuZGF0YSh0ZXh0KVxuICAgICAgICAuZW50ZXIoKVxuICAgICAgICAuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgICAudGV4dChkID0+IGQpXG4gICAgICAgIC5lYWNoKChkLCBpLCBub2RlcykgPT4ge1xuICAgICAgICAgICAgbGV0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgICAgIGxldCBiYiA9IG5vZGUuZ2V0QkJveCgpO1xuICAgICAgICAgICAgd2lkdGggPSBNYXRoLm1heCh3aWR0aCwgYmIud2lkdGgpO1xuICAgICAgICAgICAgaGVpZ2h0ID0gTWF0aC5tYXgoaGVpZ2h0LCBiYi5oZWlnaHQpXG4gICAgICAgIH0pO1xuXG4gICAgc2VsZWN0aW9uLnNlbGVjdChcIi50ZXh0LXNpemVcIikucmVtb3ZlKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgIH1cbn1cblxuXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/helpers.js\n')},"./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! exports provided: ColumnChart, BarChart, PieChart, LineChart, colours, chart, histogram, line, points, scaleTime */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _ColumnChart__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ColumnChart */ "./src/ColumnChart.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ColumnChart", function() { return _ColumnChart__WEBPACK_IMPORTED_MODULE_0__["ColumnChart"]; });\n\n/* harmony import */ var _BarChart__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BarChart */ "./src/BarChart.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BarChart", function() { return _BarChart__WEBPACK_IMPORTED_MODULE_1__["BarChart"]; });\n\n/* harmony import */ var _PieChart__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./PieChart */ "./src/PieChart.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PieChart", function() { return _PieChart__WEBPACK_IMPORTED_MODULE_2__["PieChart"]; });\n\n/* harmony import */ var _LineChart__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./LineChart */ "./src/LineChart.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LineChart", function() { return _LineChart__WEBPACK_IMPORTED_MODULE_3__["LineChart"]; });\n\n/* harmony import */ var _Colours__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Colours */ "./src/Colours.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "colours", function() { return _Colours__WEBPACK_IMPORTED_MODULE_4__["colours"]; });\n\n/* harmony import */ var _FantasticChart__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./FantasticChart */ "./src/FantasticChart.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "chart", function() { return _FantasticChart__WEBPACK_IMPORTED_MODULE_5__["chart"]; });\n\n/* harmony import */ var _Histogram__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Histogram */ "./src/Histogram.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "histogram", function() { return _Histogram__WEBPACK_IMPORTED_MODULE_6__["histogram"]; });\n\n/* harmony import */ var _Line__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Line */ "./src/Line.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "line", function() { return _Line__WEBPACK_IMPORTED_MODULE_7__["line"]; });\n\n/* harmony import */ var _Points__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Points */ "./src/Points.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "points", function() { return _Points__WEBPACK_IMPORTED_MODULE_8__["points"]; });\n\n/* harmony import */ var _Scales__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Scales */ "./src/Scales.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scaleTime", function() { return _Scales__WEBPACK_IMPORTED_MODULE_9__["scaleTime"]; });\n\n// Copyright (C) 2013-2014, 2018 BrandsEye (PTY) LTD\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this\n// software and associated documentation files (the "Software"), to deal in the Software\n// without restriction, including without limitation the rights to use, copy, modify,\n//     merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following\n// conditions:\n//\n//     The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n//     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n//     INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n// CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n\n\n\n\n// For the Fantastic Chart\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9iM2pzLy4vc3JjL2luZGV4LmpzP2I2MzUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChDKSAyMDEzLTIwMTQsIDIwMTggQnJhbmRzRXllIChQVFkpIExURFxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpc1xuLy8gc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlXG4vLyB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksXG4vLyAgICAgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0b1xuLy8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcbi8vIGNvbmRpdGlvbnM6XG4vL1xuLy8gICAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuLy8gY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyAgICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUiBJTVBMSUVELFxuLy8gICAgIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBXG4vLyBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUXG4vLyBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0Zcbi8vIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRVxuLy8gT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbmV4cG9ydCB7IENvbHVtbkNoYXJ0IGFzIENvbHVtbkNoYXJ0IH0gZnJvbSAnLi9Db2x1bW5DaGFydCc7XG5leHBvcnQgeyBCYXJDaGFydCBhcyBCYXJDaGFydCB9IGZyb20gJy4vQmFyQ2hhcnQnO1xuZXhwb3J0IHsgUGllQ2hhcnQgYXMgUGllQ2hhcnQgfSBmcm9tICcuL1BpZUNoYXJ0JztcbmV4cG9ydCB7IExpbmVDaGFydCBhcyBMaW5lQ2hhcnQgfSBmcm9tICcuL0xpbmVDaGFydCc7XG5leHBvcnQgeyBjb2xvdXJzIH0gZnJvbSAnLi9Db2xvdXJzJztcblxuLy8gRm9yIHRoZSBGYW50YXN0aWMgQ2hhcnRcbmV4cG9ydCB7IGNoYXJ0IH0gZnJvbSAnLi9GYW50YXN0aWNDaGFydCc7XG5leHBvcnQgeyBoaXN0b2dyYW0gfSBmcm9tICcuL0hpc3RvZ3JhbSc7XG5leHBvcnQgeyBsaW5lIH0gZnJvbSAnLi9MaW5lJztcbmV4cG9ydCB7IHBvaW50cyB9IGZyb20gJy4vUG9pbnRzJztcbmV4cG9ydCB7IHNjYWxlVGltZSB9IGZyb20gJy4vU2NhbGVzJzsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/index.js\n')}});